This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    tm/
      add-dependency/
        add-dependency.md
      add-subtask/
        add-subtask.md
        convert-task-to-subtask.md
      add-task/
        add-task.md
      analyze-complexity/
        analyze-complexity.md
      clear-subtasks/
        clear-all-subtasks.md
        clear-subtasks.md
      complexity-report/
        complexity-report.md
      expand/
        expand-all-tasks.md
        expand-task.md
      fix-dependencies/
        fix-dependencies.md
      generate/
        generate-tasks.md
      init/
        init-project-quick.md
        init-project.md
      list/
        list-tasks-by-status.md
        list-tasks-with-subtasks.md
        list-tasks.md
      models/
        setup-models.md
        view-models.md
      next/
        next-task.md
      parse-prd/
        parse-prd-with-research.md
        parse-prd.md
      remove-dependency/
        remove-dependency.md
      remove-subtask/
        remove-subtask.md
      remove-task/
        remove-task.md
      set-status/
        to-cancelled.md
        to-deferred.md
        to-done.md
        to-in-progress.md
        to-pending.md
        to-review.md
      setup/
        install-taskmaster.md
        quick-install-taskmaster.md
      show/
        show-task.md
      status/
        project-status.md
      sync-readme/
        sync-readme.md
      update/
        update-single-task.md
        update-task.md
        update-tasks-from-id.md
      utils/
        analyze-project.md
      validate-dependencies/
        validate-dependencies.md
      workflows/
        auto-implement-tasks.md
        command-pipeline.md
        smart-workflow.md
      help.md
      learn.md
      tm-main.md
  settings.json
  settings.local.json
  TM_COMMANDS_GUIDE.md
.github/
  workflows/
    backend-ci.yml
    frontend-ci.yml
    monorepo-ci.yml
.taskmaster/
  docs/
    home-task-management-prd.md
    PRD.txt
  reports/
    task-complexity-report.json
  tasks/
    tasks.json
  templates/
    example_prd.txt
  CLAUDE.md
  config.json
  state.json
backend/
  src/
    config/
      auth.config.ts
      database.config.ts
    database/
      entities/
        audit-log.entity.ts
        file.entity.ts
        project-member.entity.ts
        project.entity.ts
        task-comment.entity.ts
        task-dependency.entity.ts
        task-label.entity.ts
        task.entity.ts
        time-entry.entity.ts
        user.entity.ts
      migrations/
        1706000000000-initial-schema.ts
    modules/
      admin/
        controllers/
          admin.controller.ts
          audit-logs.controller.ts
          projects-admin.controller.ts
          settings-admin.controller.ts
          users-admin.controller.ts
        decorators/
          audit-log.decorator.ts
          permissions.decorator.ts
        guards/
          admin.guard.ts
          permissions.guard.ts
        interceptors/
          audit-log.interceptor.ts
        services/
          admin.service.ts
          audit.service.ts
        admin.module.ts
      auth/
        decorators/
          current-user.decorator.ts
          public.decorator.ts
          roles.decorator.ts
        dto/
          auth.dto.ts
        guards/
          auth.guard.ts
          google-auth.guard.ts
          jwt-auth.guard.ts
          roles.guard.ts
          throttle.guard.ts
        middleware/
          audit.middleware.ts
          auth.middleware.ts
        strategies/
          google.strategy.ts
          jwt.strategy.ts
        auth.controller.ts
        auth.module.ts
        auth.service.ts
      projects/
        dto/
          project.dto.ts
        projects.controller.ts
        projects.module.ts
        projects.service.ts
      tasks/
        dto/
          task.dto.ts
        tasks.controller.ts
        tasks.module.ts
        tasks.service.ts
      users/
        dto/
          update-user.dto.ts
        users.controller.ts
        users.module.ts
        users.service.ts
      websocket/
        websocket.gateway.ts
        websocket.module.ts
    scripts/
      grant-admin-simple.ts
      grant-admin.ts
    types/
      admin.types.ts
    app.module.ts
    main.ts
  test/
    jest-e2e.json
    setup-e2e.ts
    setup.ts
  .eslintrc.js
  Dockerfile
  jest.config.js
  package.json
  tsconfig.json
docs/
  admin-api-design.md
  admin-components-design.md
  admin-implementation-guide.md
  admin-panel-design.md
  admin-rbac-design.md
  PROJECT_STRUCTURE.md
frontend/
  src/
    app/
      admin/
        audit-logs/
          page.tsx
        projects/
          page.tsx
        settings/
          page.tsx
        users/
          page.tsx
        layout.tsx
        page.tsx
      auth/
        callback/
          page.tsx
        login/
          page.tsx
        layout.tsx
      board/
        page.tsx
      goals/
        page.tsx
      inbox/
        page.tsx
      privacy/
        page.tsx
      profile/
        page.tsx
      projects/
        [id]/
          page.tsx
        page.tsx
      search/
        page.tsx
      settings/
        page.tsx
      tasks/
        page.tsx
      terms/
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      admin/
        AdminButton.tsx
        AdminNavItem.tsx
        index.ts
        PermissionGuard.tsx
      auth/
        GoogleLoginButton.tsx
        LoginForm.tsx
        SocialLogin.tsx
      board/
        KnowledgeWiki.tsx
        MissionBoard.tsx
        ProjectShowcase.tsx
      home/
        HomeTaskDashboard.tsx
      inbox/
        CPERModal.tsx
        InboxModal.tsx
      layout/
        ConditionalLayout.tsx
        Header.tsx
        MainContainer.tsx
      navigation/
        LeftNavigation.tsx
        MobileNavigation.tsx
      projects/
        ProjectChatChannel.tsx
        ProjectObjectiveManager.tsx
        SlashCommandInput.tsx
      tasks/
        CollapsibleCalendar.tsx
        ResponsiveTaskCard.tsx
        TaskCard.tsx
        TaskCreationWizard.tsx
        TaskDetailModal.tsx
        TaskFilters.tsx
        TaskList.tsx
        TaskPriorityBadge.tsx
        TaskStatusBadge.tsx
        TaskStatusSelector.tsx
      ui/
        AdvancedFilterPanel.tsx
        Button.tsx
        CalendarToggleFAB.tsx
        Card.tsx
        FilterChips.tsx
        FilterManager.tsx
        Input.tsx
        LoginBanner.tsx
        MobileFilterTabs.tsx
        MobileTabs.tsx
        QuickAddInput.tsx
        SearchBar.tsx
        Select.tsx
        SimpleFilterChips.tsx
        Textarea.tsx
        TriageWizardModal.tsx
        UnifiedFilter.tsx
        WorklyFloatingActionButton.tsx
        WorklyMDXEditor.tsx
      workflow/
        ExecuteWorkflowDashboard.tsx
        PlanWorkflowModal.tsx
        ReviewWorkflowDashboard.tsx
    hooks/
      useDeviceType.ts
      useScrollVisibility.ts
    lib/
      api/
        admin-api.ts
        tasks.ts
        workly-api.ts
      hooks/
        useAdminApi.ts
      stores/
        authStore.ts
        calendarFilterStore.ts
      api.ts
      auth.ts
      utils.ts
    styles/
      scrollbar-system.md
    types/
      api.types.ts
      project.types.ts
      task.types.ts
  .eslintrc.js
  .eslintrc.json
  .gitignore
  Dockerfile
  jest.config.js
  jest.setup.js
  next-env.d.ts
  next.config.js
  package.json
  postcss.config.js
  tailwind.config.ts
  tsconfig.json
  vercel.json
instructions/
  20250725-01.md
  20250725-02.md
  20250726-repomix.md
  20250727-01.md
  20250727-02.md
  20250727-03.md
  20250728-01.md
  20250728-02.md
  20250728-03.md
  20250728-04.md
  20250801-01.md
  20250801-02.md
  20250801-03.md
  20250801-04.md
  20250801-05.md
  20250801-06.md
references/
  SuperClaude Guide.md
  superclaude_commands_guide_workly.md
  Task-master-ai Guide.md
  threads-ui-analysis.md
  WORKLY_PLAN_1.0.md
  WORKLY_PRD.md
scripts/
  deploy-production.sh
  deploy.sh
  migrate.sh
  setup.sh
shared/
  constants/
    api-endpoints.ts
    socket-events.ts
  src/
    index.ts
  types/
    admin.types.ts
    api.types.ts
    goal.types.ts
    inbox.types.ts
    index.ts
    navigation.types.ts
    socket.types.ts
    workly-core.types.ts
  utils/
    hierarchy.utils.ts
  package.json
  tsconfig.json
.env.example
.eslintrc.js
.gitignore
.prettierignore
.prettierrc
CLAUDE.md
docker-compose.yml
GEMINI.md
package.json
README.md
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(npx create-next-app:*)",
      "Bash(rm:*)",
      "Bash(true)",
      "Bash(mv:*)",
      "Bash(mkdir:*)",
      "Bash(git init:*)",
      "Bash(git add:*)",
      "Bash(npm install)",
      "mcp__task-master-ai__get_tasks",
      "Bash(ls:*)",
      "Bash(task-master parse-prd:*)",
      "Bash(task-master:*)",
      "mcp__task-master-ai__parse_prd",
      "mcp__task-master-ai__analyze_project_complexity",
      "mcp__task-master-ai__expand_task",
      "Bash(git commit:*)",
      "mcp__task-master-ai__set_task_status",
      "mcp__task-master-ai__get_task",
      "Bash(npm run start:dev:*)",
      "Bash(npm run:*)",
      "Bash(docker:*)",
      "Bash(grep:*)",
      "Bash(code:*)",
      "Bash(claude doctor)",
      "mcp__task-master-ai__add_task",
      "mcp__task-master-ai__next_task",
      "mcp__task-master-ai__update_subtask"
    ],
    "deny": []
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "task-master-ai"
  ]
}
</file>

<file path=".claude/commands/tm/add-dependency/add-dependency.md">
Add a dependency between tasks.

Arguments: $ARGUMENTS

Parse the task IDs to establish dependency relationship.

## Adding Dependencies

Creates a dependency where one task must be completed before another can start.

## Argument Parsing

Parse natural language or IDs:
- "make 5 depend on 3" → task 5 depends on task 3
- "5 needs 3" → task 5 depends on task 3
- "5 3" → task 5 depends on task 3
- "5 after 3" → task 5 depends on task 3

## Execution

```bash
task-master add-dependency --id=<task-id> --depends-on=<dependency-id>
```

## Validation

Before adding:
1. **Verify both tasks exist**
2. **Check for circular dependencies**
3. **Ensure dependency makes logical sense**
4. **Warn if creating complex chains**

## Smart Features

- Detect if dependency already exists
- Suggest related dependencies
- Show impact on task flow
- Update task priorities if needed

## Post-Addition

After adding dependency:
1. Show updated dependency graph
2. Identify any newly blocked tasks
3. Suggest task order changes
4. Update project timeline

## Example Flows

```
/project:tm/add-dependency 5 needs 3
→ Task #5 now depends on Task #3
→ Task #5 is now blocked until #3 completes
→ Suggested: Also consider if #5 needs #4
```
</file>

<file path=".claude/commands/tm/add-subtask/add-subtask.md">
Add a subtask to a parent task.

Arguments: $ARGUMENTS

Parse arguments to create a new subtask or convert existing task.

## Adding Subtasks

Creates subtasks to break down complex parent tasks into manageable pieces.

## Argument Parsing

Flexible natural language:
- "add subtask to 5: implement login form"
- "break down 5 with: setup, implement, test"
- "subtask for 5: handle edge cases"
- "5: validate user input" → adds subtask to task 5

## Execution Modes

### 1. Create New Subtask
```bash
task-master add-subtask --parent=<id> --title="<title>" --description="<desc>"
```

### 2. Convert Existing Task
```bash
task-master add-subtask --parent=<id> --task-id=<existing-id>
```

## Smart Features

1. **Automatic Subtask Generation**
   - If title contains "and" or commas, create multiple
   - Suggest common subtask patterns
   - Inherit parent's context

2. **Intelligent Defaults**
   - Priority based on parent
   - Appropriate time estimates
   - Logical dependencies between subtasks

3. **Validation**
   - Check parent task complexity
   - Warn if too many subtasks
   - Ensure subtask makes sense

## Creation Process

1. Parse parent task context
2. Generate subtask with ID like "5.1"
3. Set appropriate defaults
4. Link to parent task
5. Update parent's time estimate

## Example Flows

```
/project:tm/add-subtask to 5: implement user authentication
→ Created subtask #5.1: "implement user authentication"
→ Parent task #5 now has 1 subtask
→ Suggested next subtasks: tests, documentation

/project:tm/add-subtask 5: setup, implement, test
→ Created 3 subtasks:
  #5.1: setup
  #5.2: implement  
  #5.3: test
```

## Post-Creation

- Show updated task hierarchy
- Suggest logical next subtasks
- Update complexity estimates
- Recommend subtask order
</file>

<file path=".claude/commands/tm/add-subtask/convert-task-to-subtask.md">
Convert an existing task into a subtask.

Arguments: $ARGUMENTS

Parse parent ID and task ID to convert.

## Task Conversion

Converts an existing standalone task into a subtask of another task.

## Argument Parsing

- "move task 8 under 5"
- "make 8 a subtask of 5"
- "nest 8 in 5"
- "5 8" → make task 8 a subtask of task 5

## Execution

```bash
task-master add-subtask --parent=<parent-id> --task-id=<task-to-convert>
```

## Pre-Conversion Checks

1. **Validation**
   - Both tasks exist and are valid
   - No circular parent relationships
   - Task isn't already a subtask
   - Logical hierarchy makes sense

2. **Impact Analysis**
   - Dependencies that will be affected
   - Tasks that depend on converting task
   - Priority alignment needed
   - Status compatibility

## Conversion Process

1. Change task ID from "8" to "5.1" (next available)
2. Update all dependency references
3. Inherit parent's context where appropriate
4. Adjust priorities if needed
5. Update time estimates

## Smart Features

- Preserve task history
- Maintain dependencies
- Update all references
- Create conversion log

## Example

```
/project:tm/add-subtask/from-task 5 8
→ Converting: Task #8 becomes subtask #5.1
→ Updated: 3 dependency references
→ Parent task #5 now has 1 subtask
→ Note: Subtask inherits parent's priority

Before: #8 "Implement validation" (standalone)
After:  #5.1 "Implement validation" (subtask of #5)
```

## Post-Conversion

- Show new task hierarchy
- List updated dependencies
- Verify project integrity
- Suggest related conversions
</file>

<file path=".claude/commands/tm/add-task/add-task.md">
Add new tasks with intelligent parsing and context awareness.

Arguments: $ARGUMENTS

## Smart Task Addition

Parse natural language to create well-structured tasks.

### 1. **Input Understanding**

I'll intelligently parse your request:
- Natural language → Structured task
- Detect priority from keywords (urgent, ASAP, important)
- Infer dependencies from context
- Suggest complexity based on description
- Determine task type (feature, bug, refactor, test, docs)

### 2. **Smart Parsing Examples**

**"Add urgent task to fix login bug"**
→ Title: Fix login bug
→ Priority: high
→ Type: bug
→ Suggested complexity: medium

**"Create task for API documentation after task 23 is done"**
→ Title: API documentation
→ Dependencies: [23]
→ Type: documentation
→ Priority: medium

**"Need to refactor auth module - depends on 12 and 15, high complexity"**
→ Title: Refactor auth module
→ Dependencies: [12, 15]
→ Complexity: high
→ Type: refactor

### 3. **Context Enhancement**

Based on current project state:
- Suggest related existing tasks
- Warn about potential conflicts
- Recommend dependencies
- Propose subtasks if complex

### 4. **Interactive Refinement**

```yaml
Task Preview:
─────────────
Title: [Extracted title]
Priority: [Inferred priority]
Dependencies: [Detected dependencies]
Complexity: [Estimated complexity]

Suggestions:
- Similar task #34 exists, consider as dependency?
- This seems complex, break into subtasks?
- Tasks #45-47 work on same module
```

### 5. **Validation & Creation**

Before creating:
- Validate dependencies exist
- Check for duplicates
- Ensure logical ordering
- Verify task completeness

### 6. **Smart Defaults**

Intelligent defaults based on:
- Task type patterns
- Team conventions
- Historical data
- Current sprint/phase

Result: High-quality tasks from minimal input.
</file>

<file path=".claude/commands/tm/analyze-complexity/analyze-complexity.md">
Analyze task complexity and generate expansion recommendations.

Arguments: $ARGUMENTS

Perform deep analysis of task complexity across the project.

## Complexity Analysis

Uses AI to analyze tasks and recommend which ones need breakdown.

## Execution Options

```bash
task-master analyze-complexity [--research] [--threshold=5]
```

## Analysis Parameters

- `--research` → Use research AI for deeper analysis
- `--threshold=5` → Only flag tasks above complexity 5
- Default: Analyze all pending tasks

## Analysis Process

### 1. **Task Evaluation**
For each task, AI evaluates:
- Technical complexity
- Time requirements
- Dependency complexity
- Risk factors
- Knowledge requirements

### 2. **Complexity Scoring**
Assigns score 1-10 based on:
- Implementation difficulty
- Integration challenges
- Testing requirements
- Unknown factors
- Technical debt risk

### 3. **Recommendations**
For complex tasks:
- Suggest expansion approach
- Recommend subtask breakdown
- Identify risk areas
- Propose mitigation strategies

## Smart Analysis Features

1. **Pattern Recognition**
   - Similar task comparisons
   - Historical complexity accuracy
   - Team velocity consideration
   - Technology stack factors

2. **Contextual Factors**
   - Team expertise
   - Available resources
   - Timeline constraints
   - Business criticality

3. **Risk Assessment**
   - Technical risks
   - Timeline risks
   - Dependency risks
   - Knowledge gaps

## Output Format

```
Task Complexity Analysis Report
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

High Complexity Tasks (>7):
📍 #5 "Implement real-time sync" - Score: 9/10
   Factors: WebSocket complexity, state management, conflict resolution
   Recommendation: Expand into 5-7 subtasks
   Risks: Performance, data consistency

📍 #12 "Migrate database schema" - Score: 8/10
   Factors: Data migration, zero downtime, rollback strategy
   Recommendation: Expand into 4-5 subtasks
   Risks: Data loss, downtime

Medium Complexity Tasks (5-7):
📍 #23 "Add export functionality" - Score: 6/10
   Consider expansion if timeline tight

Low Complexity Tasks (<5):
✅ 15 tasks - No expansion needed

Summary:
- Expand immediately: 2 tasks
- Consider expanding: 5 tasks
- Keep as-is: 15 tasks
```

## Actionable Output

For each high-complexity task:
1. Complexity score with reasoning
2. Specific expansion suggestions
3. Risk mitigation approaches
4. Recommended subtask structure

## Integration

Results are:
- Saved to `.taskmaster/reports/complexity-analysis.md`
- Used by expand command
- Inform sprint planning
- Guide resource allocation

## Next Steps

After analysis:
```
/project:tm/expand 5    # Expand specific task
/project:tm/expand/all  # Expand all recommended
/project:tm/complexity-report  # View detailed report
```
</file>

<file path=".claude/commands/tm/clear-subtasks/clear-all-subtasks.md">
Clear all subtasks from all tasks globally.

## Global Subtask Clearing

Remove all subtasks across the entire project. Use with extreme caution.

## Execution

```bash
task-master clear-subtasks --all
```

## Pre-Clear Analysis

1. **Project-Wide Summary**
   ```
   Global Subtask Summary
   ━━━━━━━━━━━━━━━━━━━━
   Total parent tasks: 12
   Total subtasks: 47
   - Completed: 15
   - In-progress: 8
   - Pending: 24
   
   Work at risk: ~120 hours
   ```

2. **Critical Warnings**
   - In-progress subtasks that will lose work
   - Completed subtasks with valuable history
   - Complex dependency chains
   - Integration test results

## Double Confirmation

```
⚠️  DESTRUCTIVE OPERATION WARNING ⚠️
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
This will remove ALL 47 subtasks from your project
Including 8 in-progress and 15 completed subtasks

This action CANNOT be undone

Type 'CLEAR ALL SUBTASKS' to confirm:
```

## Smart Safeguards

- Require explicit confirmation phrase
- Create automatic backup
- Log all removed data
- Option to export first

## Use Cases

Valid reasons for global clear:
- Project restructuring
- Major pivot in approach
- Starting fresh breakdown
- Switching to different task organization

## Process

1. Full project analysis
2. Create backup file
3. Show detailed impact
4. Require confirmation
5. Execute removal
6. Generate summary report

## Alternative Suggestions

Before clearing all:
- Export subtasks to file
- Clear only pending subtasks
- Clear by task category
- Archive instead of delete

## Post-Clear Report

```
Global Subtask Clear Complete
━━━━━━━━━━━━━━━━━━━━━━━━━━━
Removed: 47 subtasks from 12 tasks
Backup saved: .taskmaster/backup/subtasks-20240115.json
Parent tasks updated: 12
Time estimates adjusted: Yes

Next steps:
- Review updated task list
- Re-expand complex tasks as needed
- Check project timeline
```
</file>

<file path=".claude/commands/tm/clear-subtasks/clear-subtasks.md">
Clear all subtasks from a specific task.

Arguments: $ARGUMENTS (task ID)

Remove all subtasks from a parent task at once.

## Clearing Subtasks

Bulk removal of all subtasks from a parent task.

## Execution

```bash
task-master clear-subtasks --id=<task-id>
```

## Pre-Clear Analysis

1. **Subtask Summary**
   - Number of subtasks
   - Completion status of each
   - Work already done
   - Dependencies affected

2. **Impact Assessment**
   - Data that will be lost
   - Dependencies to be removed
   - Effect on project timeline
   - Parent task implications

## Confirmation Required

```
Clear Subtasks Confirmation
━━━━━━━━━━━━━━━━━━━━━━━━━
Parent Task: #5 "Implement user authentication"
Subtasks to remove: 4
- #5.1 "Setup auth framework" (done)
- #5.2 "Create login form" (in-progress)
- #5.3 "Add validation" (pending)
- #5.4 "Write tests" (pending)

⚠️  This will permanently delete all subtask data
Continue? (y/n)
```

## Smart Features

- Option to convert to standalone tasks
- Backup task data before clearing
- Preserve completed work history
- Update parent task appropriately

## Process

1. List all subtasks for confirmation
2. Check for in-progress work
3. Remove all subtasks
4. Update parent task
5. Clean up dependencies

## Alternative Options

Suggest alternatives:
- Convert important subtasks to tasks
- Keep completed subtasks
- Archive instead of delete
- Export subtask data first

## Post-Clear

- Show updated parent task
- Recalculate time estimates
- Update task complexity
- Suggest next steps

## Example

```
/project:tm/clear-subtasks 5
→ Found 4 subtasks to remove
→ Warning: Subtask #5.2 is in-progress
→ Cleared all subtasks from task #5
→ Updated parent task estimates
→ Suggestion: Consider re-expanding with better breakdown
```
</file>

<file path=".claude/commands/tm/complexity-report/complexity-report.md">
Display the task complexity analysis report.

Arguments: $ARGUMENTS

View the detailed complexity analysis generated by analyze-complexity command.

## Viewing Complexity Report

Shows comprehensive task complexity analysis with actionable insights.

## Execution

```bash
task-master complexity-report [--file=<path>]
```

## Report Location

Default: `.taskmaster/reports/complexity-analysis.md`
Custom: Specify with --file parameter

## Report Contents

### 1. **Executive Summary**
```
Complexity Analysis Summary
━━━━━━━━━━━━━━━━━━━━━━━━
Analysis Date: 2024-01-15
Tasks Analyzed: 32
High Complexity: 5 (16%)
Medium Complexity: 12 (37%)
Low Complexity: 15 (47%)

Critical Findings:
- 5 tasks need immediate expansion
- 3 tasks have high technical risk
- 2 tasks block critical path
```

### 2. **Detailed Task Analysis**
For each complex task:
- Complexity score breakdown
- Contributing factors
- Specific risks identified
- Expansion recommendations
- Similar completed tasks

### 3. **Risk Matrix**
Visual representation:
```
Risk vs Complexity Matrix
━━━━━━━━━━━━━━━━━━━━━━━
High Risk  | #5(9) #12(8) | #23(6)
Med Risk   | #34(7)       | #45(5) #67(5)
Low Risk   | #78(8)       | [15 tasks]
           | High Complex  | Med Complex
```

### 4. **Recommendations**

**Immediate Actions:**
1. Expand task #5 - Critical path + high complexity
2. Expand task #12 - High risk + dependencies
3. Review task #34 - Consider splitting

**Sprint Planning:**
- Don't schedule multiple high-complexity tasks together
- Ensure expertise available for complex tasks
- Build in buffer time for unknowns

## Interactive Features

When viewing report:
1. **Quick Actions**
   - Press 'e' to expand a task
   - Press 'd' for task details
   - Press 'r' to refresh analysis

2. **Filtering**
   - View by complexity level
   - Filter by risk factors
   - Show only actionable items

3. **Export Options**
   - Markdown format
   - CSV for spreadsheets
   - JSON for tools

## Report Intelligence

- Compares with historical data
- Shows complexity trends
- Identifies patterns
- Suggests process improvements

## Integration

Use report for:
- Sprint planning sessions
- Resource allocation
- Risk assessment
- Team discussions
- Client updates

## Example Usage

```
/project:tm/complexity-report
→ Opens latest analysis

/project:tm/complexity-report --file=archived/2024-01-01.md
→ View historical analysis

After viewing:
/project:tm/expand 5
→ Expand high-complexity task
```
</file>

<file path=".claude/commands/tm/expand/expand-all-tasks.md">
Expand all pending tasks that need subtasks.

## Bulk Task Expansion

Intelligently expands all tasks that would benefit from breakdown.

## Execution

```bash
task-master expand --all
```

## Smart Selection

Only expands tasks that:
- Are marked as pending
- Have high complexity (>5)
- Lack existing subtasks
- Would benefit from breakdown

## Expansion Process

1. **Analysis Phase**
   - Identify expansion candidates
   - Group related tasks
   - Plan expansion strategy

2. **Batch Processing**
   - Expand tasks in logical order
   - Maintain consistency
   - Preserve relationships
   - Optimize for parallelism

3. **Quality Control**
   - Ensure subtask quality
   - Avoid over-decomposition
   - Maintain task coherence
   - Update dependencies

## Options

- Add `force` to expand all regardless of complexity
- Add `research` for enhanced AI analysis

## Results

After bulk expansion:
- Summary of tasks expanded
- New subtask count
- Updated complexity metrics
- Suggested task order
</file>

<file path=".claude/commands/tm/expand/expand-task.md">
Break down a complex task into subtasks.

Arguments: $ARGUMENTS (task ID)

## Intelligent Task Expansion

Analyzes a task and creates detailed subtasks for better manageability.

## Execution

```bash
task-master expand --id=$ARGUMENTS
```

## Expansion Process

1. **Task Analysis**
   - Review task complexity
   - Identify components
   - Detect technical challenges
   - Estimate time requirements

2. **Subtask Generation**
   - Create 3-7 subtasks typically
   - Each subtask 1-4 hours
   - Logical implementation order
   - Clear acceptance criteria

3. **Smart Breakdown**
   - Setup/configuration tasks
   - Core implementation
   - Testing components
   - Integration steps
   - Documentation updates

## Enhanced Features

Based on task type:
- **Feature**: Setup → Implement → Test → Integrate
- **Bug Fix**: Reproduce → Diagnose → Fix → Verify
- **Refactor**: Analyze → Plan → Refactor → Validate

## Post-Expansion

After expansion:
1. Show subtask hierarchy
2. Update time estimates
3. Suggest implementation order
4. Highlight critical path
</file>

<file path=".claude/commands/tm/fix-dependencies/fix-dependencies.md">
Automatically fix dependency issues found during validation.

## Automatic Dependency Repair

Intelligently fixes common dependency problems while preserving project logic.

## Execution

```bash
task-master fix-dependencies
```

## What Gets Fixed

### 1. **Auto-Fixable Issues**
- Remove references to deleted tasks
- Break simple circular dependencies
- Remove self-dependencies
- Clean up duplicate dependencies

### 2. **Smart Resolutions**
- Reorder dependencies to maintain logic
- Suggest task merging for over-dependent tasks
- Flatten unnecessary dependency chains
- Remove redundant transitive dependencies

### 3. **Manual Review Required**
- Complex circular dependencies
- Critical path modifications
- Business logic dependencies
- High-impact changes

## Fix Process

1. **Analysis Phase**
   - Run validation check
   - Categorize issues by type
   - Determine fix strategy

2. **Execution Phase**
   - Apply automatic fixes
   - Log all changes made
   - Preserve task relationships

3. **Verification Phase**
   - Re-validate after fixes
   - Show before/after comparison
   - Highlight manual fixes needed

## Smart Features

- Preserves intended task flow
- Minimal disruption approach
- Creates fix history/log
- Suggests manual interventions

## Output Example

```
Dependency Auto-Fix Report
━━━━━━━━━━━━━━━━━━━━━━━━
Fixed Automatically:
✅ Removed 2 references to deleted tasks
✅ Resolved 1 self-dependency
✅ Cleaned 3 redundant dependencies

Manual Review Needed:
⚠️ Complex circular dependency: #12 → #15 → #18 → #12
  Suggestion: Make #15 not depend on #12
⚠️ Task #45 has 8 dependencies
  Suggestion: Break into subtasks

Run '/project:tm/validate-dependencies' to verify fixes
```

## Safety

- Preview mode available
- Rollback capability
- Change logging
- No data loss
</file>

<file path=".claude/commands/tm/generate/generate-tasks.md">
Generate individual task files from tasks.json.

## Task File Generation

Creates separate markdown files for each task, perfect for AI agents or documentation.

## Execution

```bash
task-master generate
```

## What It Creates

For each task, generates a file like `task_001.txt`:

```
Task ID: 1
Title: Implement user authentication
Status: pending
Priority: high
Dependencies: []
Created: 2024-01-15
Complexity: 7

## Description
Create a secure user authentication system with login, logout, and session management.

## Details
- Use JWT tokens for session management
- Implement secure password hashing
- Add remember me functionality
- Include password reset flow

## Test Strategy
- Unit tests for auth functions
- Integration tests for login flow
- Security testing for vulnerabilities
- Performance tests for concurrent logins

## Subtasks
1.1 Setup authentication framework (pending)
1.2 Create login endpoints (pending)
1.3 Implement session management (pending)
1.4 Add password reset (pending)
```

## File Organization

Creates structure:
```
.taskmaster/
└── tasks/
    ├── task_001.txt
    ├── task_002.txt
    ├── task_003.txt
    └── ...
```

## Smart Features

1. **Consistent Formatting**
   - Standardized structure
   - Clear sections
   - AI-readable format
   - Markdown compatible

2. **Contextual Information**
   - Full task details
   - Related task references
   - Progress indicators
   - Implementation notes

3. **Incremental Updates**
   - Only regenerate changed tasks
   - Preserve custom additions
   - Track generation timestamp
   - Version control friendly

## Use Cases

- **AI Context**: Provide task context to AI assistants
- **Documentation**: Standalone task documentation
- **Archival**: Task history preservation
- **Sharing**: Send specific tasks to team members
- **Review**: Easier task review process

## Generation Options

Based on arguments:
- Filter by status
- Include/exclude completed
- Custom templates
- Different formats

## Post-Generation

```
Task File Generation Complete
━━━━━━━━━━━━━━━━━━━━━━━━━━
Generated: 45 task files
Location: .taskmaster/tasks/
Total size: 156 KB

New files: 5
Updated files: 12
Unchanged: 28

Ready for:
- AI agent consumption
- Version control
- Team distribution
```

## Integration Benefits

- Git-trackable task history
- Easy task sharing
- AI tool compatibility
- Offline task access
- Backup redundancy
</file>

<file path=".claude/commands/tm/init/init-project-quick.md">
Quick initialization with auto-confirmation.

Arguments: $ARGUMENTS

Initialize a Task Master project without prompts, accepting all defaults.

## Quick Setup

```bash
task-master init -y
```

## What It Does

1. Creates `.taskmaster/` directory structure
2. Initializes empty `tasks.json`
3. Sets up default configuration
4. Uses directory name as project name
5. Skips all confirmation prompts

## Smart Defaults

- Project name: Current directory name
- Description: "Task Master Project"
- Model config: Existing environment vars
- Task structure: Standard format

## Next Steps

After quick init:
1. Configure AI models if needed:
   ```
   /project:tm/models/setup
   ```

2. Parse PRD if available:
   ```
   /project:tm/parse-prd <file>
   ```

3. Or create first task:
   ```
   /project:tm/add-task create initial setup
   ```

Perfect for rapid project setup!
</file>

<file path=".claude/commands/tm/init/init-project.md">
Initialize a new Task Master project.

Arguments: $ARGUMENTS

Parse arguments to determine initialization preferences.

## Initialization Process

1. **Parse Arguments**
   - PRD file path (if provided)
   - Project name
   - Auto-confirm flag (-y)

2. **Project Setup**
   ```bash
   task-master init
   ```

3. **Smart Initialization**
   - Detect existing project files
   - Suggest project name from directory
   - Check for git repository
   - Verify AI provider configuration

## Configuration Options

Based on arguments:
- `quick` / `-y` → Skip confirmations
- `<file.md>` → Use as PRD after init
- `--name=<name>` → Set project name
- `--description=<desc>` → Set description

## Post-Initialization

After successful init:
1. Show project structure created
2. Verify AI models configured
3. Suggest next steps:
   - Parse PRD if available
   - Configure AI providers
   - Set up git hooks
   - Create first tasks

## Integration

If PRD file provided:
```
/project:tm/init my-prd.md
→ Automatically runs parse-prd after init
```
</file>

<file path=".claude/commands/tm/list/list-tasks-by-status.md">
List tasks filtered by a specific status.

Arguments: $ARGUMENTS

Parse the status from arguments and list only tasks matching that status.

## Status Options
- `pending` - Not yet started
- `in-progress` - Currently being worked on
- `done` - Completed
- `review` - Awaiting review
- `deferred` - Postponed
- `cancelled` - Cancelled

## Execution

Based on $ARGUMENTS, run:
```bash
task-master list --status=$ARGUMENTS
```

## Enhanced Display

For the filtered results:
- Group by priority within the status
- Show time in current status
- Highlight tasks approaching deadlines
- Display blockers and dependencies
- Suggest next actions for each status group

## Intelligent Insights

Based on the status filter:
- **Pending**: Show recommended start order
- **In-Progress**: Display idle time warnings
- **Done**: Show newly unblocked tasks
- **Review**: Indicate review duration
- **Deferred**: Show reactivation criteria
- **Cancelled**: Display impact analysis
</file>

<file path=".claude/commands/tm/list/list-tasks-with-subtasks.md">
List all tasks including their subtasks in a hierarchical view.

This command shows all tasks with their nested subtasks, providing a complete project overview.

## Execution

Run the Task Master list command with subtasks flag:
```bash
task-master list --with-subtasks
```

## Enhanced Display

I'll organize the output to show:
- Parent tasks with clear indicators
- Nested subtasks with proper indentation
- Status badges for quick scanning
- Dependencies and blockers highlighted
- Progress indicators for tasks with subtasks

## Smart Filtering

Based on the task hierarchy:
- Show completion percentage for parent tasks
- Highlight blocked subtask chains
- Group by functional areas
- Indicate critical path items

This gives you a complete tree view of your project structure.
</file>

<file path=".claude/commands/tm/list/list-tasks.md">
List tasks with intelligent argument parsing.

Parse arguments to determine filters and display options:
- Status: pending, in-progress, done, review, deferred, cancelled
- Priority: high, medium, low (or priority:high)
- Special: subtasks, tree, dependencies, blocked
- IDs: Direct numbers (e.g., "1,3,5" or "1-5")
- Complex: "pending high" = pending AND high priority

Arguments: $ARGUMENTS

Let me parse your request intelligently:

1. **Detect Filter Intent**
   - If arguments contain status keywords → filter by status
   - If arguments contain priority → filter by priority
   - If arguments contain "subtasks" → include subtasks
   - If arguments contain "tree" → hierarchical view
   - If arguments contain numbers → show specific tasks
   - If arguments contain "blocked" → show blocked tasks only

2. **Smart Combinations**
   Examples of what I understand:
   - "pending high" → pending tasks with high priority
   - "done today" → tasks completed today
   - "blocked" → tasks with unmet dependencies
   - "1-5" → tasks 1 through 5
   - "subtasks tree" → hierarchical view with subtasks

3. **Execute Appropriate Query**
   Based on parsed intent, run the most specific task-master command

4. **Enhanced Display**
   - Group by relevant criteria
   - Show most important information first
   - Use visual indicators for quick scanning
   - Include relevant metrics

5. **Intelligent Suggestions**
   Based on what you're viewing, suggest next actions:
   - Many pending? → Suggest priority order
   - Many blocked? → Show dependency resolution
   - Looking at specific tasks? → Show related tasks
</file>

<file path=".claude/commands/tm/models/setup-models.md">
Run interactive setup to configure AI models.

## Interactive Model Configuration

Guides you through setting up AI providers for Task Master.

## Execution

```bash
task-master models --setup
```

## Setup Process

1. **Environment Check**
   - Detect existing API keys
   - Show current configuration
   - Identify missing providers

2. **Provider Selection**
   - Choose main provider (required)
   - Select research provider (recommended)
   - Configure fallback (optional)

3. **API Key Configuration**
   - Prompt for missing keys
   - Validate key format
   - Test connectivity
   - Save configuration

## Smart Recommendations

Based on your needs:
- **For best results**: Claude + Perplexity
- **Budget conscious**: GPT-3.5 + Perplexity
- **Maximum capability**: GPT-4 + Perplexity + Claude fallback

## Configuration Storage

Keys can be stored in:
1. Environment variables (recommended)
2. `.env` file in project
3. Global `.taskmaster/config`

## Post-Setup

After configuration:
- Test each provider
- Show usage examples
- Suggest next steps
- Verify parse-prd works
</file>

<file path=".claude/commands/tm/models/view-models.md">
View current AI model configuration.

## Model Configuration Display

Shows the currently configured AI providers and models for Task Master.

## Execution

```bash
task-master models
```

## Information Displayed

1. **Main Provider**
   - Model ID and name
   - API key status (configured/missing)
   - Usage: Primary task generation

2. **Research Provider**
   - Model ID and name  
   - API key status
   - Usage: Enhanced research mode

3. **Fallback Provider**
   - Model ID and name
   - API key status
   - Usage: Backup when main fails

## Visual Status

```
Task Master AI Model Configuration
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Main:     ✅ claude-3-5-sonnet (configured)
Research: ✅ perplexity-sonar (configured)  
Fallback: ⚠️  Not configured (optional)

Available Models:
- claude-3-5-sonnet
- gpt-4-turbo
- gpt-3.5-turbo
- perplexity-sonar
```

## Next Actions

Based on configuration:
- If missing API keys → Suggest setup
- If no research model → Explain benefits
- If all configured → Show usage tips
</file>

<file path=".claude/commands/tm/next/next-task.md">
Intelligently determine and prepare the next action based on comprehensive context.

This enhanced version of 'next' considers:
- Current task states
- Recent activity
- Time constraints
- Dependencies
- Your working patterns

Arguments: $ARGUMENTS

## Intelligent Next Action

### 1. **Context Gathering**
Let me analyze the current situation:
- Active tasks (in-progress)
- Recently completed tasks
- Blocked tasks
- Time since last activity
- Arguments provided: $ARGUMENTS

### 2. **Smart Decision Tree**

**If you have an in-progress task:**
- Has it been idle > 2 hours? → Suggest resuming or switching
- Near completion? → Show remaining steps
- Blocked? → Find alternative task

**If no in-progress tasks:**
- Unblocked high-priority tasks? → Start highest
- Complex tasks need breakdown? → Suggest expansion
- All tasks blocked? → Show dependency resolution

**Special arguments handling:**
- "quick" → Find task < 2 hours
- "easy" → Find low complexity task
- "important" → Find high priority regardless of complexity
- "continue" → Resume last worked task

### 3. **Preparation Workflow**

Based on selected task:
1. Show full context and history
2. Set up development environment
3. Run relevant tests
4. Open related files
5. Show similar completed tasks
6. Estimate completion time

### 4. **Alternative Suggestions**

Always provide options:
- Primary recommendation
- Quick alternative (< 1 hour)
- Strategic option (unblocks most tasks)
- Learning option (new technology/skill)

### 5. **Workflow Integration**

Seamlessly connect to:
- `/project:task-master:start [selected]` 
- `/project:workflows:auto-implement`
- `/project:task-master:expand` (if complex)
- `/project:utils:complexity-report` (if unsure)

The goal: Zero friction from decision to implementation.
</file>

<file path=".claude/commands/tm/parse-prd/parse-prd-with-research.md">
Parse PRD with enhanced research mode for better task generation.

Arguments: $ARGUMENTS (PRD file path)

## Research-Enhanced Parsing

Uses the research AI provider (typically Perplexity) for more comprehensive task generation with current best practices.

## Execution

```bash
task-master parse-prd --input=$ARGUMENTS --research
```

## Research Benefits

1. **Current Best Practices**
   - Latest framework patterns
   - Security considerations
   - Performance optimizations
   - Accessibility requirements

2. **Technical Deep Dive**
   - Implementation approaches
   - Library recommendations
   - Architecture patterns
   - Testing strategies

3. **Comprehensive Coverage**
   - Edge cases consideration
   - Error handling tasks
   - Monitoring setup
   - Deployment tasks

## Enhanced Output

Research mode typically:
- Generates more detailed tasks
- Includes industry standards
- Adds compliance considerations
- Suggests modern tooling

## When to Use

- New technology domains
- Complex requirements
- Regulatory compliance needed
- Best practices crucial
</file>

<file path=".claude/commands/tm/parse-prd/parse-prd.md">
Parse a PRD document to generate tasks.

Arguments: $ARGUMENTS (PRD file path)

## Intelligent PRD Parsing

Analyzes your requirements document and generates a complete task breakdown.

## Execution

```bash
task-master parse-prd --input=$ARGUMENTS
```

## Parsing Process

1. **Document Analysis**
   - Extract key requirements
   - Identify technical components
   - Detect dependencies
   - Estimate complexity

2. **Task Generation**
   - Create 10-15 tasks by default
   - Include implementation tasks
   - Add testing tasks
   - Include documentation tasks
   - Set logical dependencies

3. **Smart Enhancements**
   - Group related functionality
   - Set appropriate priorities
   - Add acceptance criteria
   - Include test strategies

## Options

Parse arguments for modifiers:
- Number after filename → `--num-tasks`
- `research` → Use research mode
- `comprehensive` → Generate more tasks

## Post-Generation

After parsing:
1. Display task summary
2. Show dependency graph
3. Suggest task expansion for complex items
4. Recommend sprint planning
</file>

<file path=".claude/commands/tm/remove-dependency/remove-dependency.md">
Remove a dependency between tasks.

Arguments: $ARGUMENTS

Parse the task IDs to remove dependency relationship.

## Removing Dependencies

Removes a dependency relationship, potentially unblocking tasks.

## Argument Parsing

Parse natural language or IDs:
- "remove dependency between 5 and 3"
- "5 no longer needs 3"
- "unblock 5 from 3"
- "5 3" → remove dependency of 5 on 3

## Execution

```bash
task-master remove-dependency --id=<task-id> --depends-on=<dependency-id>
```

## Pre-Removal Checks

1. **Verify dependency exists**
2. **Check impact on task flow**
3. **Warn if it breaks logical sequence**
4. **Show what will be unblocked**

## Smart Analysis

Before removing:
- Show why dependency might have existed
- Check if removal makes tasks executable
- Verify no critical path disruption
- Suggest alternative dependencies

## Post-Removal

After removing:
1. Show updated task status
2. List newly unblocked tasks
3. Update project timeline
4. Suggest next actions

## Safety Features

- Confirm if removing critical dependency
- Show tasks that become immediately actionable
- Warn about potential issues
- Keep removal history

## Example

```
/project:tm/remove-dependency 5 from 3
→ Removed: Task #5 no longer depends on #3
→ Task #5 is now UNBLOCKED and ready to start
→ Warning: Consider if #5 still needs #2 completed first
```
</file>

<file path=".claude/commands/tm/remove-subtask/remove-subtask.md">
Remove a subtask from its parent task.

Arguments: $ARGUMENTS

Parse subtask ID to remove, with option to convert to standalone task.

## Removing Subtasks

Remove a subtask and optionally convert it back to a standalone task.

## Argument Parsing

- "remove subtask 5.1"
- "delete 5.1"
- "convert 5.1 to task" → remove and convert
- "5.1 standalone" → convert to standalone

## Execution Options

### 1. Delete Subtask
```bash
task-master remove-subtask --id=<parentId.subtaskId>
```

### 2. Convert to Standalone
```bash
task-master remove-subtask --id=<parentId.subtaskId> --convert
```

## Pre-Removal Checks

1. **Validate Subtask**
   - Verify subtask exists
   - Check completion status
   - Review dependencies

2. **Impact Analysis**
   - Other subtasks that depend on it
   - Parent task implications
   - Data that will be lost

## Removal Process

### For Deletion:
1. Confirm if subtask has work done
2. Update parent task estimates
3. Remove subtask and its data
4. Clean up dependencies

### For Conversion:
1. Assign new standalone task ID
2. Preserve all task data
3. Update dependency references
4. Maintain task history

## Smart Features

- Warn if subtask is in-progress
- Show impact on parent task
- Preserve important data
- Update related estimates

## Example Flows

```
/project:tm/remove-subtask 5.1
→ Warning: Subtask #5.1 is in-progress
→ This will delete all subtask data
→ Parent task #5 will be updated
Confirm deletion? (y/n)

/project:tm/remove-subtask 5.1 convert
→ Converting subtask #5.1 to standalone task #89
→ Preserved: All task data and history
→ Updated: 2 dependency references
→ New task #89 is now independent
```

## Post-Removal

- Update parent task status
- Recalculate estimates
- Show updated hierarchy
- Suggest next actions
</file>

<file path=".claude/commands/tm/remove-task/remove-task.md">
Remove a task permanently from the project.

Arguments: $ARGUMENTS (task ID)

Delete a task and handle all its relationships properly.

## Task Removal

Permanently removes a task while maintaining project integrity.

## Argument Parsing

- "remove task 5"
- "delete 5"
- "5" → remove task 5
- Can include "-y" for auto-confirm

## Execution

```bash
task-master remove-task --id=<id> [-y]
```

## Pre-Removal Analysis

1. **Task Details**
   - Current status
   - Work completed
   - Time invested
   - Associated data

2. **Relationship Check**
   - Tasks that depend on this
   - Dependencies this task has
   - Subtasks that will be removed
   - Blocking implications

3. **Impact Assessment**
   ```
   Task Removal Impact
   ━━━━━━━━━━━━━━━━━━
   Task: #5 "Implement authentication" (in-progress)
   Status: 60% complete (~8 hours work)
   
   Will affect:
   - 3 tasks depend on this (will be blocked)
   - Has 4 subtasks (will be deleted)
   - Part of critical path
   
   ⚠️  This action cannot be undone
   ```

## Smart Warnings

- Warn if task is in-progress
- Show dependent tasks that will be blocked
- Highlight if part of critical path
- Note any completed work being lost

## Removal Process

1. Show comprehensive impact
2. Require confirmation (unless -y)
3. Update dependent task references
4. Remove task and subtasks
5. Clean up orphaned dependencies
6. Log removal with timestamp

## Alternative Actions

Suggest before deletion:
- Mark as cancelled instead
- Convert to documentation
- Archive task data
- Transfer work to another task

## Post-Removal

- List affected tasks
- Show broken dependencies
- Update project statistics
- Suggest dependency fixes
- Recalculate timeline

## Example Flows

```
/project:tm/remove-task 5
→ Task #5 is in-progress with 8 hours logged
→ 3 other tasks depend on this
→ Suggestion: Mark as cancelled instead?
Remove anyway? (y/n)

/project:tm/remove-task 5 -y
→ Removed: Task #5 and 4 subtasks
→ Updated: 3 task dependencies
→ Warning: Tasks #7, #8, #9 now have missing dependency
→ Run /project:tm/fix-dependencies to resolve
```

## Safety Features

- Confirmation required
- Impact preview
- Removal logging
- Suggest alternatives
- No cascade delete of dependents
</file>

<file path=".claude/commands/tm/set-status/to-cancelled.md">
Cancel a task permanently.

Arguments: $ARGUMENTS (task ID)

## Cancelling a Task

This status indicates a task is no longer needed and won't be completed.

## Valid Reasons for Cancellation

- Requirements changed
- Feature deprecated
- Duplicate of another task
- Strategic pivot
- Technical approach invalidated

## Pre-Cancellation Checks

1. Confirm no critical dependencies
2. Check for partial implementation
3. Verify cancellation rationale
4. Document lessons learned

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=cancelled
```

## Cancellation Impact

When cancelling:
1. **Dependency Updates**
   - Notify dependent tasks
   - Update project scope
   - Recalculate timelines

2. **Clean-up Actions**
   - Remove related branches
   - Archive any work done
   - Update documentation
   - Close related issues

3. **Learning Capture**
   - Document why cancelled
   - Note what was learned
   - Update estimation models
   - Prevent future duplicates

## Historical Preservation

- Keep for reference
- Tag with cancellation reason
- Link to replacement if any
- Maintain audit trail
</file>

<file path=".claude/commands/tm/set-status/to-deferred.md">
Defer a task for later consideration.

Arguments: $ARGUMENTS (task ID)

## Deferring a Task

This status indicates a task is valid but not currently actionable or prioritized.

## Valid Reasons for Deferral

- Waiting for external dependencies
- Reprioritized for future sprint
- Blocked by technical limitations
- Resource constraints
- Strategic timing considerations

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=deferred
```

## Deferral Management

When deferring:
1. **Document Reason**
   - Capture why it's being deferred
   - Set reactivation criteria
   - Note any partial work completed

2. **Impact Analysis**
   - Check dependent tasks
   - Update project timeline
   - Notify affected stakeholders

3. **Future Planning**
   - Set review reminders
   - Tag for specific milestone
   - Preserve context for reactivation
   - Link to blocking issues

## Smart Tracking

- Monitor deferral duration
- Alert when criteria met
- Prevent scope creep
- Regular review cycles
</file>

<file path=".claude/commands/tm/set-status/to-done.md">
Mark a task as completed.

Arguments: $ARGUMENTS (task ID)

## Completing a Task

This command validates task completion and updates project state intelligently.

## Pre-Completion Checks

1. Verify test strategy was followed
2. Check if all subtasks are complete
3. Validate acceptance criteria met
4. Ensure code is committed

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=done
```

## Post-Completion Actions

1. **Update Dependencies**
   - Identify newly unblocked tasks
   - Update sprint progress
   - Recalculate project timeline

2. **Documentation**
   - Generate completion summary
   - Update CLAUDE.md with learnings
   - Log implementation approach

3. **Next Steps**
   - Show newly available tasks
   - Suggest logical next task
   - Update velocity metrics

## Celebration & Learning

- Show impact of completion
- Display unblocked work
- Recognize achievement
- Capture lessons learned
</file>

<file path=".claude/commands/tm/set-status/to-in-progress.md">
Start working on a task by setting its status to in-progress.

Arguments: $ARGUMENTS (task ID)

## Starting Work on Task

This command does more than just change status - it prepares your environment for productive work.

## Pre-Start Checks

1. Verify dependencies are met
2. Check if another task is already in-progress
3. Ensure task details are complete
4. Validate test strategy exists

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=in-progress
```

## Environment Setup

After setting to in-progress:
1. Create/checkout appropriate git branch
2. Open relevant documentation
3. Set up test watchers if applicable
4. Display task details and acceptance criteria
5. Show similar completed tasks for reference

## Smart Suggestions

- Estimated completion time based on complexity
- Related files from similar tasks
- Potential blockers to watch for
- Recommended first steps
</file>

<file path=".claude/commands/tm/set-status/to-pending.md">
Set a task's status to pending.

Arguments: $ARGUMENTS (task ID)

## Setting Task to Pending

This moves a task back to the pending state, useful for:
- Resetting erroneously started tasks
- Deferring work that was prematurely begun
- Reorganizing sprint priorities

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=pending
```

## Validation

Before setting to pending:
- Warn if task is currently in-progress
- Check if this will block other tasks
- Suggest documenting why it's being reset
- Preserve any work already done

## Smart Actions

After setting to pending:
- Update sprint planning if needed
- Notify about freed resources
- Suggest priority reassessment
- Log the status change with context
</file>

<file path=".claude/commands/tm/set-status/to-review.md">
Set a task's status to review.

Arguments: $ARGUMENTS (task ID)

## Marking Task for Review

This status indicates work is complete but needs verification before final approval.

## When to Use Review Status

- Code complete but needs peer review
- Implementation done but needs testing
- Documentation written but needs proofreading
- Design complete but needs stakeholder approval

## Execution

```bash
task-master set-status --id=$ARGUMENTS --status=review
```

## Review Preparation

When setting to review:
1. **Generate Review Checklist**
   - Link to PR/MR if applicable
   - Highlight key changes
   - Note areas needing attention
   - Include test results

2. **Documentation**
   - Update task with review notes
   - Link relevant artifacts
   - Specify reviewers if known

3. **Smart Actions**
   - Create review reminders
   - Track review duration
   - Suggest reviewers based on expertise
   - Prepare rollback plan if needed
</file>

<file path=".claude/commands/tm/setup/install-taskmaster.md">
Check if Task Master is installed and install it if needed.

This command helps you get Task Master set up globally on your system.

## Detection and Installation Process

1. **Check Current Installation**
   ```bash
   # Check if task-master command exists
   which task-master || echo "Task Master not found"
   
   # Check npm global packages
   npm list -g task-master-ai
   ```

2. **System Requirements Check**
   ```bash
   # Verify Node.js is installed
   node --version
   
   # Verify npm is installed  
   npm --version
   
   # Check Node version (need 16+)
   ```

3. **Install Task Master Globally**
   If not installed, run:
   ```bash
   npm install -g task-master-ai
   ```

4. **Verify Installation**
   ```bash
   # Check version
   task-master --version
   
   # Verify command is available
   which task-master
   ```

5. **Initial Setup**
   ```bash
   # Initialize in current directory
   task-master init
   ```

6. **Configure AI Provider**
   Ensure you have at least one AI provider API key set:
   ```bash
   # Check current configuration
   task-master models --status
   
   # If no API keys found, guide setup
   echo "You'll need at least one API key:"
   echo "- ANTHROPIC_API_KEY for Claude"
   echo "- OPENAI_API_KEY for GPT models"
   echo "- PERPLEXITY_API_KEY for research"
   echo ""
   echo "Set them in your shell profile or .env file"
   ```

7. **Quick Test**
   ```bash
   # Create a test PRD
   echo "Build a simple hello world API" > test-prd.txt
   
   # Try parsing it
   task-master parse-prd test-prd.txt -n 3
   ```

## Troubleshooting

If installation fails:

**Permission Errors:**
```bash
# Try with sudo (macOS/Linux)
sudo npm install -g task-master-ai

# Or fix npm permissions
npm config set prefix ~/.npm-global
export PATH=~/.npm-global/bin:$PATH
```

**Network Issues:**
```bash
# Use different registry
npm install -g task-master-ai --registry https://registry.npmjs.org/
```

**Node Version Issues:**
```bash
# Install Node 18+ via nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18
```

## Success Confirmation

Once installed, you should see:
```
✅ Task Master v0.16.2 (or higher) installed
✅ Command 'task-master' available globally
✅ AI provider configured
✅ Ready to use slash commands!

Try: /project:task-master:init your-prd.md
```

## Next Steps

After installation:
1. Run `/project:utils:check-health` to verify setup
2. Configure AI providers with `/project:task-master:models`
3. Start using Task Master commands!
</file>

<file path=".claude/commands/tm/setup/quick-install-taskmaster.md">
Quick install Task Master globally if not already installed.

Execute this streamlined installation:

```bash
# Check and install in one command
task-master --version 2>/dev/null || npm install -g task-master-ai

# Verify installation
task-master --version

# Quick setup check
task-master models --status || echo "Note: You'll need to set up an AI provider API key"
```

If you see "command not found" after installation, you may need to:
1. Restart your terminal
2. Or add npm global bin to PATH: `export PATH=$(npm bin -g):$PATH`

Once installed, you can use all the Task Master commands!

Quick test: Run `/project:help` to see all available commands.
</file>

<file path=".claude/commands/tm/show/show-task.md">
Show detailed task information with rich context and insights.

Arguments: $ARGUMENTS

## Enhanced Task Display

Parse arguments to determine what to show and how.

### 1. **Smart Task Selection**

Based on $ARGUMENTS:
- Number → Show specific task with full context
- "current" → Show active in-progress task(s)
- "next" → Show recommended next task
- "blocked" → Show all blocked tasks with reasons
- "critical" → Show critical path tasks
- Multiple IDs → Comparative view

### 2. **Contextual Information**

For each task, intelligently include:

**Core Details**
- Full task information (id, title, description, details)
- Current status with history
- Test strategy and acceptance criteria
- Priority and complexity analysis

**Relationships**
- Dependencies (what it needs)
- Dependents (what needs it)
- Parent/subtask hierarchy
- Related tasks (similar work)

**Time Intelligence**
- Created/updated timestamps
- Time in current status
- Estimated vs actual time
- Historical completion patterns

### 3. **Visual Enhancements**

```
📋 Task #45: Implement User Authentication
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Status: 🟡 in-progress (2 hours)
Priority: 🔴 High | Complexity: 73/100

Dependencies: ✅ #41, ✅ #42, ⏳ #43 (blocked)
Blocks: #46, #47, #52

Progress: ████████░░ 80% complete

Recent Activity:
- 2h ago: Status changed to in-progress
- 4h ago: Dependency #42 completed
- Yesterday: Task expanded with 3 subtasks
```

### 4. **Intelligent Insights**

Based on task analysis:
- **Risk Assessment**: Complexity vs time remaining
- **Bottleneck Analysis**: Is this blocking critical work?
- **Recommendation**: Suggested approach or concerns
- **Similar Tasks**: How others completed similar work

### 5. **Action Suggestions**

Context-aware next steps:
- If blocked → Show how to unblock
- If complex → Suggest expansion
- If in-progress → Show completion checklist
- If done → Show dependent tasks ready to start

### 6. **Multi-Task View**

When showing multiple tasks:
- Common dependencies
- Optimal completion order
- Parallel work opportunities
- Combined complexity analysis
</file>

<file path=".claude/commands/tm/status/project-status.md">
Enhanced status command with comprehensive project insights.

Arguments: $ARGUMENTS

## Intelligent Status Overview

### 1. **Executive Summary**
Quick dashboard view:
- 🏃 Active work (in-progress tasks)
- 📊 Progress metrics (% complete, velocity)
- 🚧 Blockers and risks
- ⏱️ Time analysis (estimated vs actual)
- 🎯 Sprint/milestone progress

### 2. **Contextual Analysis**

Based on $ARGUMENTS, focus on:
- "sprint" → Current sprint progress and burndown
- "blocked" → Dependency chains and resolution paths
- "team" → Task distribution and workload
- "timeline" → Schedule adherence and projections
- "risk" → High complexity or overdue items

### 3. **Smart Insights**

**Workflow Health:**
- Idle tasks (in-progress > 24h without updates)
- Bottlenecks (multiple tasks waiting on same dependency)
- Quick wins (low complexity, high impact)

**Predictive Analytics:**
- Completion projections based on velocity
- Risk of missing deadlines
- Recommended task order for optimal flow

### 4. **Visual Intelligence**

Dynamic visualization based on data:
```
Sprint Progress: ████████░░ 80% (16/20 tasks)
Velocity Trend: ↗️ +15% this week
Blocked Tasks:  🔴 3 critical path items

Priority Distribution:
High:   ████████ 8 tasks (2 blocked)
Medium: ████░░░░ 4 tasks
Low:    ██░░░░░░ 2 tasks
```

### 5. **Actionable Recommendations**

Based on analysis:
1. **Immediate actions** (unblock critical path)
2. **Today's focus** (optimal task sequence)
3. **Process improvements** (recurring patterns)
4. **Resource needs** (skills, time, dependencies)

### 6. **Historical Context**

Compare to previous periods:
- Velocity changes
- Pattern recognition
- Improvement areas
- Success patterns to repeat
</file>

<file path=".claude/commands/tm/sync-readme/sync-readme.md">
Export tasks to README.md with professional formatting.

Arguments: $ARGUMENTS

Generate a well-formatted README with current task information.

## README Synchronization

Creates or updates README.md with beautifully formatted task information.

## Argument Parsing

Optional filters:
- "pending" → Only pending tasks
- "with-subtasks" → Include subtask details
- "by-priority" → Group by priority
- "sprint" → Current sprint only

## Execution

```bash
task-master sync-readme [--with-subtasks] [--status=<status>]
```

## README Generation

### 1. **Project Header**
```markdown
# Project Name

## 📋 Task Progress

Last Updated: 2024-01-15 10:30 AM

### Summary
- Total Tasks: 45
- Completed: 15 (33%)
- In Progress: 5 (11%)
- Pending: 25 (56%)
```

### 2. **Task Sections**
Organized by status or priority:
- Progress indicators
- Task descriptions
- Dependencies noted
- Time estimates

### 3. **Visual Elements**
- Progress bars
- Status badges
- Priority indicators
- Completion checkmarks

## Smart Features

1. **Intelligent Grouping**
   - By feature area
   - By sprint/milestone
   - By assigned developer
   - By priority

2. **Progress Tracking**
   - Overall completion
   - Sprint velocity
   - Burndown indication
   - Time tracking

3. **Formatting Options**
   - GitHub-flavored markdown
   - Task checkboxes
   - Collapsible sections
   - Table format available

## Example Output

```markdown
## 🚀 Current Sprint

### In Progress
- [ ] 🔄 #5 **Implement user authentication** (60% complete)
  - Dependencies: API design (#3 ✅)
  - Subtasks: 4 (2 completed)
  - Est: 8h / Spent: 5h

### Pending (High Priority)
- [ ] ⚡ #8 **Create dashboard UI**
  - Blocked by: #5
  - Complexity: High
  - Est: 12h
```

## Customization

Based on arguments:
- Include/exclude sections
- Detail level control
- Custom grouping
- Filter by criteria

## Post-Sync

After generation:
1. Show diff preview
2. Backup existing README
3. Write new content
4. Commit reminder
5. Update timestamp

## Integration

Works well with:
- Git workflows
- CI/CD pipelines
- Project documentation
- Team updates
- Client reports
</file>

<file path=".claude/commands/tm/update/update-single-task.md">
Update a single specific task with new information.

Arguments: $ARGUMENTS

Parse task ID and update details.

## Single Task Update

Precisely update one task with AI assistance to maintain consistency.

## Argument Parsing

Natural language updates:
- "5: add caching requirement"
- "update 5 to include error handling"
- "task 5 needs rate limiting"
- "5 change priority to high"

## Execution

```bash
task-master update-task --id=<id> --prompt="<context>"
```

## Update Types

### 1. **Content Updates**
- Enhance description
- Add requirements
- Clarify details
- Update acceptance criteria

### 2. **Metadata Updates**
- Change priority
- Adjust time estimates
- Update complexity
- Modify dependencies

### 3. **Strategic Updates**
- Revise approach
- Change test strategy
- Update implementation notes
- Adjust subtask needs

## AI-Powered Updates

The AI:
1. **Understands Context**
   - Reads current task state
   - Identifies update intent
   - Maintains consistency
   - Preserves important info

2. **Applies Changes**
   - Updates relevant fields
   - Keeps style consistent
   - Adds without removing
   - Enhances clarity

3. **Validates Results**
   - Checks coherence
   - Verifies completeness
   - Maintains relationships
   - Suggests related updates

## Example Updates

```
/project:tm/update/single 5: add rate limiting
→ Updating Task #5: "Implement API endpoints"

Current: Basic CRUD endpoints
Adding: Rate limiting requirements

Updated sections:
✓ Description: Added rate limiting mention
✓ Details: Added specific limits (100/min)
✓ Test Strategy: Added rate limit tests
✓ Complexity: Increased from 5 to 6
✓ Time Estimate: Increased by 2 hours

Suggestion: Also update task #6 (API Gateway) for consistency?
```

## Smart Features

1. **Incremental Updates**
   - Adds without overwriting
   - Preserves work history
   - Tracks what changed
   - Shows diff view

2. **Consistency Checks**
   - Related task alignment
   - Subtask compatibility
   - Dependency validity
   - Timeline impact

3. **Update History**
   - Timestamp changes
   - Track who/what updated
   - Reason for update
   - Previous versions

## Field-Specific Updates

Quick syntax for specific fields:
- "5 priority:high" → Update priority only
- "5 add-time:4h" → Add to time estimate
- "5 status:review" → Change status
- "5 depends:3,4" → Add dependencies

## Post-Update

- Show updated task
- Highlight changes
- Check related tasks
- Update suggestions
- Timeline adjustments
</file>

<file path=".claude/commands/tm/update/update-task.md">
Update tasks with intelligent field detection and bulk operations.

Arguments: $ARGUMENTS

## Intelligent Task Updates

Parse arguments to determine update intent and execute smartly.

### 1. **Natural Language Processing**

Understand update requests like:
- "mark 23 as done" → Update status to done
- "increase priority of 45" → Set priority to high
- "add dependency on 12 to task 34" → Add dependency
- "tasks 20-25 need review" → Bulk status update
- "all API tasks high priority" → Pattern-based update

### 2. **Smart Field Detection**

Automatically detect what to update:
- Status keywords: done, complete, start, pause, review
- Priority changes: urgent, high, low, deprioritize
- Dependency updates: depends on, blocks, after
- Assignment: assign to, owner, responsible
- Time: estimate, spent, deadline

### 3. **Bulk Operations**

Support for multiple task updates:
```
Examples:
- "complete tasks 12, 15, 18"
- "all pending auth tasks to in-progress"
- "increase priority for tasks blocking 45"
- "defer all documentation tasks"
```

### 4. **Contextual Validation**

Before updating, check:
- Status transitions are valid
- Dependencies don't create cycles
- Priority changes make sense
- Bulk updates won't break project flow

Show preview:
```
Update Preview:
─────────────────
Tasks to update: #23, #24, #25
Change: status → in-progress
Impact: Will unblock tasks #30, #31
Warning: Task #24 has unmet dependencies
```

### 5. **Smart Suggestions**

Based on update:
- Completing task? → Show newly unblocked tasks
- Changing priority? → Show impact on sprint
- Adding dependency? → Check for conflicts
- Bulk update? → Show summary of changes

### 6. **Workflow Integration**

After updates:
- Auto-update dependent task states
- Trigger status recalculation
- Update sprint/milestone progress
- Log changes with context

Result: Flexible, intelligent task updates with safety checks.
</file>

<file path=".claude/commands/tm/update/update-tasks-from-id.md">
Update multiple tasks starting from a specific ID.

Arguments: $ARGUMENTS

Parse starting task ID and update context.

## Bulk Task Updates

Update multiple related tasks based on new requirements or context changes.

## Argument Parsing

- "from 5: add security requirements"
- "5 onwards: update API endpoints"
- "starting at 5: change to use new framework"

## Execution

```bash
task-master update --from=<id> --prompt="<context>"
```

## Update Process

### 1. **Task Selection**
Starting from specified ID:
- Include the task itself
- Include all dependent tasks
- Include related subtasks
- Smart boundary detection

### 2. **Context Application**
AI analyzes the update context and:
- Identifies what needs changing
- Maintains consistency
- Preserves completed work
- Updates related information

### 3. **Intelligent Updates**
- Modify descriptions appropriately
- Update test strategies
- Adjust time estimates
- Revise dependencies if needed

## Smart Features

1. **Scope Detection**
   - Find natural task groupings
   - Identify related features
   - Stop at logical boundaries
   - Avoid over-updating

2. **Consistency Maintenance**
   - Keep naming conventions
   - Preserve relationships
   - Update cross-references
   - Maintain task flow

3. **Change Preview**
   ```
   Bulk Update Preview
   ━━━━━━━━━━━━━━━━━━
   Starting from: Task #5
   Tasks to update: 8 tasks + 12 subtasks
   
   Context: "add security requirements"
   
   Changes will include:
   - Add security sections to descriptions
   - Update test strategies for security
   - Add security-related subtasks where needed
   - Adjust time estimates (+20% average)
   
   Continue? (y/n)
   ```

## Example Updates

```
/project:tm/update/from-id 5: change database to PostgreSQL
→ Analyzing impact starting from task #5
→ Found 6 related tasks to update
→ Updates will maintain consistency
→ Preview changes? (y/n)

Applied updates:
✓ Task #5: Updated connection logic references
✓ Task #6: Changed migration approach
✓ Task #7: Updated query syntax notes
✓ Task #8: Revised testing strategy
✓ Task #9: Updated deployment steps
✓ Task #12: Changed backup procedures
```

## Safety Features

- Preview all changes
- Selective confirmation
- Rollback capability
- Change logging
- Validation checks

## Post-Update

- Summary of changes
- Consistency verification
- Suggest review tasks
- Update timeline if needed
</file>

<file path=".claude/commands/tm/utils/analyze-project.md">
Advanced project analysis with actionable insights and recommendations.

Arguments: $ARGUMENTS

## Comprehensive Project Analysis

Multi-dimensional analysis based on requested focus area.

### 1. **Analysis Modes**

Based on $ARGUMENTS:
- "velocity" → Sprint velocity and trends
- "quality" → Code quality metrics
- "risk" → Risk assessment and mitigation
- "dependencies" → Dependency graph analysis
- "team" → Workload and skill distribution
- "architecture" → System design coherence
- Default → Full spectrum analysis

### 2. **Velocity Analytics**

```
📊 Velocity Analysis
━━━━━━━━━━━━━━━━━━━
Current Sprint: 24 points/week ↗️ +20%
Rolling Average: 20 points/week
Efficiency: 85% (17/20 tasks on time)

Bottlenecks Detected:
- Code review delays (avg 4h wait)
- Test environment availability
- Dependency on external team

Recommendations:
1. Implement parallel review process
2. Add staging environment
3. Mock external dependencies
```

### 3. **Risk Assessment**

**Technical Risks**
- High complexity tasks without backup assignee
- Single points of failure in architecture
- Insufficient test coverage in critical paths
- Technical debt accumulation rate

**Project Risks**
- Critical path dependencies
- Resource availability gaps
- Deadline feasibility analysis
- Scope creep indicators

### 4. **Dependency Intelligence**

Visual dependency analysis:
```
Critical Path: 
#12 → #15 → #23 → #45 → #50 (20 days)
         ↘ #24 → #46 ↗

Optimization: Parallelize #15 and #24
Time Saved: 3 days
```

### 5. **Quality Metrics**

**Code Quality**
- Test coverage trends
- Complexity scores
- Technical debt ratio
- Review feedback patterns

**Process Quality**
- Rework frequency
- Bug introduction rate
- Time to resolution
- Knowledge distribution

### 6. **Predictive Insights**

Based on patterns:
- Completion probability by deadline
- Resource needs projection
- Risk materialization likelihood
- Suggested interventions

### 7. **Executive Dashboard**

High-level summary with:
- Health score (0-100)
- Top 3 risks
- Top 3 opportunities
- Recommended actions
- Success probability

Result: Data-driven decisions with clear action paths.
</file>

<file path=".claude/commands/tm/validate-dependencies/validate-dependencies.md">
Validate all task dependencies for issues.

## Dependency Validation

Comprehensive check for dependency problems across the entire project.

## Execution

```bash
task-master validate-dependencies
```

## Validation Checks

1. **Circular Dependencies**
   - A depends on B, B depends on A
   - Complex circular chains
   - Self-dependencies

2. **Missing Dependencies**
   - References to non-existent tasks
   - Deleted task references
   - Invalid task IDs

3. **Logical Issues**
   - Completed tasks depending on pending
   - Cancelled tasks in dependency chains
   - Impossible sequences

4. **Complexity Warnings**
   - Over-complex dependency chains
   - Too many dependencies per task
   - Bottleneck tasks

## Smart Analysis

The validation provides:
- Visual dependency graph
- Critical path analysis
- Bottleneck identification
- Suggested optimizations

## Report Format

```
Dependency Validation Report
━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ No circular dependencies found
⚠️  2 warnings found:
   - Task #23 has 7 dependencies (consider breaking down)
   - Task #45 blocks 5 other tasks (potential bottleneck)
❌ 1 error found:
   - Task #67 depends on deleted task #66

Critical Path: #1 → #5 → #23 → #45 → #50 (15 days)
```

## Actionable Output

For each issue found:
- Clear description
- Impact assessment
- Suggested fix
- Command to resolve

## Next Steps

After validation:
- Run `/project:tm/fix-dependencies` to auto-fix
- Manually adjust problematic dependencies
- Rerun to verify fixes
</file>

<file path=".claude/commands/tm/workflows/auto-implement-tasks.md">
Enhanced auto-implementation with intelligent code generation and testing.

Arguments: $ARGUMENTS

## Intelligent Auto-Implementation

Advanced implementation with context awareness and quality checks.

### 1. **Pre-Implementation Analysis**

Before starting:
- Analyze task complexity and requirements
- Check codebase patterns and conventions
- Identify similar completed tasks
- Assess test coverage needs
- Detect potential risks

### 2. **Smart Implementation Strategy**

Based on task type and context:

**Feature Tasks**
1. Research existing patterns
2. Design component architecture
3. Implement with tests
4. Integrate with system
5. Update documentation

**Bug Fix Tasks**
1. Reproduce issue
2. Identify root cause
3. Implement minimal fix
4. Add regression tests
5. Verify side effects

**Refactoring Tasks**
1. Analyze current structure
2. Plan incremental changes
3. Maintain test coverage
4. Refactor step-by-step
5. Verify behavior unchanged

### 3. **Code Intelligence**

**Pattern Recognition**
- Learn from existing code
- Follow team conventions
- Use preferred libraries
- Match style guidelines

**Test-Driven Approach**
- Write tests first when possible
- Ensure comprehensive coverage
- Include edge cases
- Performance considerations

### 4. **Progressive Implementation**

Step-by-step with validation:
```
Step 1/5: Setting up component structure ✓
Step 2/5: Implementing core logic ✓
Step 3/5: Adding error handling ⚡ (in progress)
Step 4/5: Writing tests ⏳
Step 5/5: Integration testing ⏳

Current: Adding try-catch blocks and validation...
```

### 5. **Quality Assurance**

Automated checks:
- Linting and formatting
- Test execution
- Type checking
- Dependency validation
- Performance analysis

### 6. **Smart Recovery**

If issues arise:
- Diagnostic analysis
- Suggestion generation
- Fallback strategies
- Manual intervention points
- Learning from failures

### 7. **Post-Implementation**

After completion:
- Generate PR description
- Update documentation
- Log lessons learned
- Suggest follow-up tasks
- Update task relationships

Result: High-quality, production-ready implementations.
</file>

<file path=".claude/commands/tm/workflows/command-pipeline.md">
Execute a pipeline of commands based on a specification.

Arguments: $ARGUMENTS

## Command Pipeline Execution

Parse pipeline specification from arguments. Supported formats:

### Simple Pipeline
`init → expand-all → sprint-plan`

### Conditional Pipeline  
`status → if:pending>10 → sprint-plan → else → next`

### Iterative Pipeline
`for:pending-tasks → expand → complexity-check`

### Smart Pipeline Patterns

**1. Project Setup Pipeline**
```
init [prd] → 
expand-all → 
complexity-report → 
sprint-plan → 
show first-sprint
```

**2. Daily Work Pipeline**
```
standup →
if:in-progress → continue →
else → next → start
```

**3. Task Completion Pipeline**
```
complete [id] →
git-commit →
if:blocked-tasks-freed → show-freed →
next
```

**4. Quality Check Pipeline**
```
list in-progress →
for:each → check-idle-time →
if:idle>1day → prompt-update
```

### Pipeline Features

**Variables**
- Store results: `status → $count=pending-count`
- Use in conditions: `if:$count>10`
- Pass between commands: `expand $high-priority-tasks`

**Error Handling**
- On failure: `try:complete → catch:show-blockers`
- Skip on error: `optional:test-run`
- Retry logic: `retry:3:commit`

**Parallel Execution**
- Parallel branches: `[analyze | test | lint]`
- Join results: `parallel → join:report`

### Execution Flow

1. Parse pipeline specification
2. Validate command sequence
3. Execute with state passing
4. Handle conditions and loops
5. Aggregate results
6. Show summary

This enables complex workflows like:
`parse-prd → expand-all → filter:complex>70 → assign:senior → sprint-plan:weighted`
</file>

<file path=".claude/commands/tm/workflows/smart-workflow.md">
Execute an intelligent workflow based on current project state and recent commands.

This command analyzes:
1. Recent commands you've run
2. Current project state
3. Time of day / day of week
4. Your working patterns

Arguments: $ARGUMENTS

## Intelligent Workflow Selection

Based on context, I'll determine the best workflow:

### Context Analysis
- Previous command executed
- Current task states
- Unfinished work from last session
- Your typical patterns

### Smart Execution

If last command was:
- `status` → Likely starting work → Run daily standup
- `complete` → Task finished → Find next task
- `list pending` → Planning → Suggest sprint planning
- `expand` → Breaking down work → Show complexity analysis
- `init` → New project → Show onboarding workflow

If no recent commands:
- Morning? → Daily standup workflow
- Many pending tasks? → Sprint planning
- Tasks blocked? → Dependency resolution
- Friday? → Weekly review

### Workflow Composition

I'll chain appropriate commands:
1. Analyze current state
2. Execute primary workflow
3. Suggest follow-up actions
4. Prepare environment for coding

### Learning Mode

This command learns from your patterns:
- Track command sequences
- Note time preferences
- Remember common workflows
- Adapt to your style

Example flows detected:
- Morning: standup → next → start
- After lunch: status → continue task
- End of day: complete → commit → status
</file>

<file path=".claude/commands/tm/help.md">
Show help for Task Master commands.

Arguments: $ARGUMENTS

Display help for Task Master commands. If arguments provided, show specific command help.

## Task Master Command Help

### Quick Navigation

Type `/project:tm/` and use tab completion to explore all commands.

### Command Categories

#### 🚀 Setup & Installation
- `/project:tm/setup/install` - Comprehensive installation guide
- `/project:tm/setup/quick-install` - One-line global install

#### 📋 Project Setup
- `/project:tm/init` - Initialize new project
- `/project:tm/init/quick` - Quick setup with auto-confirm
- `/project:tm/models` - View AI configuration
- `/project:tm/models/setup` - Configure AI providers

#### 🎯 Task Generation
- `/project:tm/parse-prd` - Generate tasks from PRD
- `/project:tm/parse-prd/with-research` - Enhanced parsing
- `/project:tm/generate` - Create task files

#### 📝 Task Management
- `/project:tm/list` - List tasks (natural language filters)
- `/project:tm/show <id>` - Display task details
- `/project:tm/add-task` - Create new task
- `/project:tm/update` - Update tasks naturally
- `/project:tm/next` - Get next task recommendation

#### 🔄 Status Management
- `/project:tm/set-status/to-pending <id>`
- `/project:tm/set-status/to-in-progress <id>`
- `/project:tm/set-status/to-done <id>`
- `/project:tm/set-status/to-review <id>`
- `/project:tm/set-status/to-deferred <id>`
- `/project:tm/set-status/to-cancelled <id>`

#### 🔍 Analysis & Breakdown
- `/project:tm/analyze-complexity` - Analyze task complexity
- `/project:tm/expand <id>` - Break down complex task
- `/project:tm/expand/all` - Expand all eligible tasks

#### 🔗 Dependencies
- `/project:tm/add-dependency` - Add task dependency
- `/project:tm/remove-dependency` - Remove dependency
- `/project:tm/validate-dependencies` - Check for issues

#### 🤖 Workflows
- `/project:tm/workflows/smart-flow` - Intelligent workflows
- `/project:tm/workflows/pipeline` - Command chaining
- `/project:tm/workflows/auto-implement` - Auto-implementation

#### 📊 Utilities
- `/project:tm/utils/analyze` - Project analysis
- `/project:tm/status` - Project dashboard
- `/project:tm/learn` - Interactive learning

### Natural Language Examples

```
/project:tm/list pending high priority
/project:tm/update mark all API tasks as done
/project:tm/add-task create login system with OAuth
/project:tm/show current
```

### Getting Started

1. Install: `/project:tm/setup/quick-install`
2. Initialize: `/project:tm/init/quick`
3. Learn: `/project:tm/learn start`
4. Work: `/project:tm/workflows/smart-flow`

For detailed command info: `/project:tm/help <command-name>`
</file>

<file path=".claude/commands/tm/learn.md">
Learn about Task Master capabilities through interactive exploration.

Arguments: $ARGUMENTS

## Interactive Task Master Learning

Based on your input, I'll help you discover capabilities:

### 1. **What are you trying to do?**

If $ARGUMENTS contains:
- "start" / "begin" → Show project initialization workflows
- "manage" / "organize" → Show task management commands  
- "automate" / "auto" → Show automation workflows
- "analyze" / "report" → Show analysis tools
- "fix" / "problem" → Show troubleshooting commands
- "fast" / "quick" → Show efficiency shortcuts

### 2. **Intelligent Suggestions**

Based on your project state:

**No tasks yet?**
```
You'll want to start with:
1. /project:task-master:init <prd-file>
   → Creates tasks from requirements
   
2. /project:task-master:parse-prd <file>
   → Alternative task generation

Try: /project:task-master:init demo-prd.md
```

**Have tasks?**
Let me analyze what you might need...
- Many pending tasks? → Learn sprint planning
- Complex tasks? → Learn task expansion
- Daily work? → Learn workflow automation

### 3. **Command Discovery**

**By Category:**
- 📋 Task Management: list, show, add, update, complete
- 🔄 Workflows: auto-implement, sprint-plan, daily-standup
- 🛠️ Utilities: check-health, complexity-report, sync-memory
- 🔍 Analysis: validate-deps, show dependencies

**By Scenario:**
- "I want to see what to work on" → `/project:task-master:next`
- "I need to break this down" → `/project:task-master:expand <id>`
- "Show me everything" → `/project:task-master:status`
- "Just do it for me" → `/project:workflows:auto-implement`

### 4. **Power User Patterns**

**Command Chaining:**
```
/project:task-master:next
/project:task-master:start <id>
/project:workflows:auto-implement
```

**Smart Filters:**
```
/project:task-master:list pending high
/project:task-master:list blocked
/project:task-master:list 1-5 tree
```

**Automation:**
```
/project:workflows:pipeline init → expand-all → sprint-plan
```

### 5. **Learning Path**

Based on your experience level:

**Beginner Path:**
1. init → Create project
2. status → Understand state
3. next → Find work
4. complete → Finish task

**Intermediate Path:**
1. expand → Break down complex tasks
2. sprint-plan → Organize work
3. complexity-report → Understand difficulty
4. validate-deps → Ensure consistency

**Advanced Path:**
1. pipeline → Chain operations
2. smart-flow → Context-aware automation
3. Custom commands → Extend the system

### 6. **Try This Now**

Based on what you asked about, try:
[Specific command suggestion based on $ARGUMENTS]

Want to learn more about a specific command?
Type: /project:help <command-name>
</file>

<file path=".claude/commands/tm/tm-main.md">
# Task Master Command Reference

Comprehensive command structure for Task Master integration with Claude Code.

## Command Organization

Commands are organized hierarchically to match Task Master's CLI structure while providing enhanced Claude Code integration.

## Project Setup & Configuration

### `/project:tm/init`
- `init-project` - Initialize new project (handles PRD files intelligently)
- `init-project-quick` - Quick setup with auto-confirmation (-y flag)

### `/project:tm/models`
- `view-models` - View current AI model configuration
- `setup-models` - Interactive model configuration
- `set-main` - Set primary generation model
- `set-research` - Set research model
- `set-fallback` - Set fallback model

## Task Generation

### `/project:tm/parse-prd`
- `parse-prd` - Generate tasks from PRD document
- `parse-prd-with-research` - Enhanced parsing with research mode

### `/project:tm/generate`
- `generate-tasks` - Create individual task files from tasks.json

## Task Management

### `/project:tm/list`
- `list-tasks` - Smart listing with natural language filters
- `list-tasks-with-subtasks` - Include subtasks in hierarchical view
- `list-tasks-by-status` - Filter by specific status

### `/project:tm/set-status`
- `to-pending` - Reset task to pending
- `to-in-progress` - Start working on task
- `to-done` - Mark task complete
- `to-review` - Submit for review
- `to-deferred` - Defer task
- `to-cancelled` - Cancel task

### `/project:tm/sync-readme`
- `sync-readme` - Export tasks to README.md with formatting

### `/project:tm/update`
- `update-task` - Update tasks with natural language
- `update-tasks-from-id` - Update multiple tasks from a starting point
- `update-single-task` - Update specific task

### `/project:tm/add-task`
- `add-task` - Add new task with AI assistance

### `/project:tm/remove-task`
- `remove-task` - Remove task with confirmation

## Subtask Management

### `/project:tm/add-subtask`
- `add-subtask` - Add new subtask to parent
- `convert-task-to-subtask` - Convert existing task to subtask

### `/project:tm/remove-subtask`
- `remove-subtask` - Remove subtask (with optional conversion)

### `/project:tm/clear-subtasks`
- `clear-subtasks` - Clear subtasks from specific task
- `clear-all-subtasks` - Clear all subtasks globally

## Task Analysis & Breakdown

### `/project:tm/analyze-complexity`
- `analyze-complexity` - Analyze and generate expansion recommendations

### `/project:tm/complexity-report`
- `complexity-report` - Display complexity analysis report

### `/project:tm/expand`
- `expand-task` - Break down specific task
- `expand-all-tasks` - Expand all eligible tasks
- `with-research` - Enhanced expansion

## Task Navigation

### `/project:tm/next`
- `next-task` - Intelligent next task recommendation

### `/project:tm/show`
- `show-task` - Display detailed task information

### `/project:tm/status`
- `project-status` - Comprehensive project dashboard

## Dependency Management

### `/project:tm/add-dependency`
- `add-dependency` - Add task dependency

### `/project:tm/remove-dependency`
- `remove-dependency` - Remove task dependency

### `/project:tm/validate-dependencies`
- `validate-dependencies` - Check for dependency issues

### `/project:tm/fix-dependencies`
- `fix-dependencies` - Automatically fix dependency problems

## Workflows & Automation

### `/project:tm/workflows`
- `smart-workflow` - Context-aware intelligent workflow execution
- `command-pipeline` - Chain multiple commands together
- `auto-implement-tasks` - Advanced auto-implementation with code generation

## Utilities

### `/project:tm/utils`
- `analyze-project` - Deep project analysis and insights

### `/project:tm/setup`
- `install-taskmaster` - Comprehensive installation guide
- `quick-install-taskmaster` - One-line global installation

## Usage Patterns

### Natural Language
Most commands accept natural language arguments:
```
/project:tm/add-task create user authentication system
/project:tm/update mark all API tasks as high priority
/project:tm/list show blocked tasks
```

### ID-Based Commands
Commands requiring IDs intelligently parse from $ARGUMENTS:
```
/project:tm/show 45
/project:tm/expand 23
/project:tm/set-status/to-done 67
```

### Smart Defaults
Commands provide intelligent defaults and suggestions based on context.
</file>

<file path=".claude/settings.json">
{
  "permissions": {
    "allow": [
      "Bash",
      "Read",
      "Write", 
      "Edit",
      "MultiEdit",
      "Glob",
      "Grep",
      "LS",
      "TodoWrite",
      "Task",
      "WebFetch",
      "WebSearch",
      "mcp__task-master-ai__*"
    ],
    "deny": []
  },
  "enableAllProjectMcpServers": true,
  "mcpServers": {
    "task-master-ai": {
      "enabled": true
    }
  }
}
</file>

<file path=".claude/TM_COMMANDS_GUIDE.md">
# Task Master Commands for Claude Code

Complete guide to using Task Master through Claude Code's slash commands.

## Overview

All Task Master functionality is available through the `/project:tm/` namespace with natural language support and intelligent features.

## Quick Start

```bash
# Install Task Master
/project:tm/setup/quick-install

# Initialize project
/project:tm/init/quick

# Parse requirements
/project:tm/parse-prd requirements.md

# Start working
/project:tm/next
```

## Command Structure

Commands are organized hierarchically to match Task Master's CLI:
- Main commands at `/project:tm/[command]`
- Subcommands for specific operations `/project:tm/[command]/[subcommand]`
- Natural language arguments accepted throughout

## Complete Command Reference

### Setup & Configuration
- `/project:tm/setup/install` - Full installation guide
- `/project:tm/setup/quick-install` - One-line install
- `/project:tm/init` - Initialize project
- `/project:tm/init/quick` - Quick init with -y
- `/project:tm/models` - View AI config
- `/project:tm/models/setup` - Configure AI

### Task Generation
- `/project:tm/parse-prd` - Generate from PRD
- `/project:tm/parse-prd/with-research` - Enhanced parsing
- `/project:tm/generate` - Create task files

### Task Management
- `/project:tm/list` - List with natural language filters
- `/project:tm/list/with-subtasks` - Hierarchical view
- `/project:tm/list/by-status <status>` - Filter by status
- `/project:tm/show <id>` - Task details
- `/project:tm/add-task` - Create task
- `/project:tm/update` - Update tasks
- `/project:tm/remove-task` - Delete task

### Status Management
- `/project:tm/set-status/to-pending <id>`
- `/project:tm/set-status/to-in-progress <id>`
- `/project:tm/set-status/to-done <id>`
- `/project:tm/set-status/to-review <id>`
- `/project:tm/set-status/to-deferred <id>`
- `/project:tm/set-status/to-cancelled <id>`

### Task Analysis
- `/project:tm/analyze-complexity` - AI analysis
- `/project:tm/complexity-report` - View report
- `/project:tm/expand <id>` - Break down task
- `/project:tm/expand/all` - Expand all complex

### Dependencies
- `/project:tm/add-dependency` - Add dependency
- `/project:tm/remove-dependency` - Remove dependency
- `/project:tm/validate-dependencies` - Check issues
- `/project:tm/fix-dependencies` - Auto-fix

### Workflows
- `/project:tm/workflows/smart-flow` - Adaptive workflows
- `/project:tm/workflows/pipeline` - Chain commands
- `/project:tm/workflows/auto-implement` - AI implementation

### Utilities
- `/project:tm/status` - Project dashboard
- `/project:tm/next` - Next task recommendation
- `/project:tm/utils/analyze` - Project analysis
- `/project:tm/learn` - Interactive help

## Key Features

### Natural Language Support
All commands understand natural language:
```
/project:tm/list pending high priority
/project:tm/update mark 23 as done
/project:tm/add-task implement OAuth login
```

### Smart Context
Commands analyze project state and provide intelligent suggestions based on:
- Current task status
- Dependencies
- Team patterns
- Project phase

### Visual Enhancements
- Progress bars and indicators
- Status badges
- Organized displays
- Clear hierarchies

## Common Workflows

### Daily Development
```
/project:tm/workflows/smart-flow morning
/project:tm/next
/project:tm/set-status/to-in-progress <id>
/project:tm/set-status/to-done <id>
```

### Task Breakdown
```
/project:tm/show <id>
/project:tm/expand <id>
/project:tm/list/with-subtasks
```

### Sprint Planning
```
/project:tm/analyze-complexity
/project:tm/workflows/pipeline init → expand/all → status
```

## Migration from Old Commands

| Old | New |
|-----|-----|
| `/project:task-master:list` | `/project:tm/list` |
| `/project:task-master:complete` | `/project:tm/set-status/to-done` |
| `/project:workflows:auto-implement` | `/project:tm/workflows/auto-implement` |

## Tips

1. Use `/project:tm/` + Tab for command discovery
2. Natural language is supported everywhere
3. Commands provide smart defaults
4. Chain commands for automation
5. Check `/project:tm/learn` for interactive help
</file>

<file path=".github/workflows/backend-ci.yml">
name: Backend CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - 'shared/**'
      - '.github/workflows/backend-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'shared/**'

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: workly_test
          POSTGRES_USER: test_user
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm run build:shared

    - name: Lint
      run: npm run lint:backend

    - name: Test
      run: npm run test:backend
      env:
        DATABASE_HOST: localhost
        DATABASE_PORT: 5432
        DATABASE_NAME: workly_test
        DATABASE_USERNAME: test_user
        DATABASE_PASSWORD: test_password
        JWT_SECRET: test-jwt-secret

    - name: E2E Test
      run: npm run test:e2e --workspace=backend
      env:
        DATABASE_HOST: localhost
        DATABASE_PORT: 5432
        DATABASE_NAME: workly_test
        DATABASE_USERNAME: test_user
        DATABASE_PASSWORD: test_password
        JWT_SECRET: test-jwt-secret

    - name: Build
      run: npm run build:backend

  security:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run security audit
      run: npm audit --workspace=backend

    - name: Run Snyk to check for vulnerabilities
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --file=backend/package.json

  build-and-deploy:
    needs: [test, security]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm run build:shared

    - name: Build
      run: npm run build:backend

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Build Docker image
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        docker build -t workly-backend ./backend
        docker tag workly-backend:latest ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/workly-backend:latest

    - name: Login to Amazon ECR
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Push to ECR
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/workly-backend:latest

    - name: Deploy to ECS
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        aws ecs update-service --cluster workly-cluster --service workly-backend --force-new-deployment
</file>

<file path=".github/workflows/frontend-ci.yml">
name: Frontend CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - 'shared/**'
      - '.github/workflows/frontend-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'shared/**'

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm run build:shared

    - name: Type check
      run: npm run type-check --workspace=frontend

    - name: Lint
      run: npm run lint:frontend

    - name: Test
      run: npm run test:frontend

    - name: Build
      run: npm run build:frontend

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm run build:shared

    - name: Build
      run: npm run build:frontend
      env:
        NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}

    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        working-directory: ./frontend
        vercel-args: '--prod'

  storybook:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm run build:shared

    - name: Build Storybook
      run: npm run build-storybook --workspace=frontend

    - name: Deploy Storybook to Chromatic
      uses: chromaui/action@v1
      if: github.event_name == 'pull_request'
      with:
        projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
        workingDir: frontend
</file>

<file path=".github/workflows/monorepo-ci.yml">
name: Monorepo CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      backend: ${{ steps.changes.outputs.backend }}
      shared: ${{ steps.changes.outputs.shared }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Check for changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          frontend:
            - 'frontend/**'
          backend:
            - 'backend/**'
          shared:
            - 'shared/**'

  shared:
    needs: changes
    if: ${{ needs.changes.outputs.shared == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Type check shared
      run: npm run type-check --workspace=shared

    - name: Build shared
      run: npm run build:shared

  dependency-check:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Check for dependency vulnerabilities
      run: npm audit

    - name: Check for outdated dependencies
      run: npm outdated || true

  code-quality:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: javascript

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  notify:
    needs: [shared, dependency-check, code-quality]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Notify on failure
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#dev-notifications'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
</file>

<file path=".taskmaster/docs/home-task-management-prd.md">
# 홈 및 업무 관리 시스템 PRD (Product Requirements Document)

## 개요

기획서 섹션 2를 기반으로 한 홈 및 업무 관리 시스템 개발을 위한 상세 요구사항 정의서입니다. GTD(Getting Things Done) 방법론을 기반으로 한 지능형 업무 관리와 미니멀한 UI/UX를 구현합니다.

## 핵심 기능 요구사항

### 1. 홈 대시보드 - 지능형 '오늘' 보기

#### 1.1 업무 카드 피드
- **디자인**: Threads 스타일의 깔끔한 스크롤 가능한 피드
- **카드 구성 요소**:
  - 업무 제목 (대제목, 명확한 타이포그래피)
  - 관련 프로젝트 (색상 코딩된 태그)
  - 마감일 (날짜/시간 표시)
  - 우선순위 표시 (시각적 인디케이터)
  - 진행 상태 (체크박스, 진행률)

#### 1.2 모멘텀 점수 알고리즘
- **RICE 모델 기반 점수 계산**:
  - Reach (프로젝트 중요도): 의존성 있는 업무/마일스톤 수
  - Impact (긴급성/중요성): 마감일 + 아이젠하워 매트릭스
  - Confidence (명확성): 업무 정의 완성도
  - Effort (예상 소요 시간): 소요 시간 역가중치
- **동적 정렬**: 실시간 점수 계산 및 재정렬

#### 1.3 보기 및 필터
- **탭 기반 필터링**:
  - '오늘' (모멘텀 점수 정렬)
  - '완료됨' (완료된 업무 목록)
  - '전체' (모든 업무)
  - '나중에 할 일' (마감일 없는 업무)
- **검색 기능**: 전체 프로젝트 통합 검색

### 2. GTD 기반 업무 생성 플로우

#### 2.1 FAB (Floating Action Button) 트리거
- **위치**: 화면 오른쪽 하단, 인체공학적 접근 가능
- **상호작용**: 스피드 다이얼 메뉴
  - '업무 추가'
  - '프로젝트 추가'
  - '게시글 추가'
- **상황 인식**: 홈, 프로젝트, 게시판에만 표시

#### 2.2 단계별 업무 생성 프로세스

##### 1단계: 수집
- **UI**: "무엇이 마음에 걸리나요?" 프롬프트
- **입력**: 단순 텍스트 필드
- **목표**: 마찰 없는 브레인 덤프

##### 2단계: 명료화
- **실행 가능성 판단**:
  - "실행 가능한 일인가요?" (Y/N)
  - 아니오 → 참고 자료/언젠가 목록 분류
- **2분 규칙 적용**:
  - "2분 안에 끝낼 수 있나요?"
  - 예 → 즉시 처리 권장
- **프로젝트 연결**:
  - "더 큰 목표의 일부인가요?"
  - 기존 프로젝트 할당 또는 신규 생성

##### 3단계: 정리
- **세부 정보 입력**:
  - 마감일 설정
  - 우선순위 (아이젠하워 매트릭스 UI)
  - 담당자 지정 (공유 프로젝트)
  - 예상 소요 시간

##### 4단계: 실행 준비
- **최종 검토**: 입력된 정보 확인
- **홈 등록**: '오늘' 보기에 즉시 반영

### 3. 프로젝트 진행률 통합

#### 3.1 시각적 연결
- **업무 카드 내 진행률 표시줄**: 관련 프로젝트 진행률 미묘하게 표시
- **완료 애니메이션**: 업무 완료 시 진행률 바 채우기 효과
- **실시간 업데이트**: 프로젝트 전체 진행률 즉시 반영

## UI/UX 디자인 원칙

### 1. Threads 정신의 미니멀리즘
- **단순성**: 화면당 하나의 주요 목적
- **명확성**: 충분한 여백, 가독성 높은 타이포그래피
- **일관성**: 통일된 시각적 언어 (아이콘, 버튼, 간격)
- **시각적 계층**: 크기, 색상, 대비를 통한 우선순위 표현

### 2. 마이크로인터랙션
- **즉각적 피드백**: 모든 사용자 행동에 시각적 반응
- **만족스러운 애니메이션**: 업무 완료 체크, 카드 이동
- **도허티 임계값**: 100ms 이내 응답 시간

### 3. 접근성 고려사항
- **충분한 색상 대비**: WCAG 가이드라인 준수
- **스크린 리더 지원**: 의미있는 라벨링
- **키보드 내비게이션**: 모든 기능 키보드 접근 가능

## 기술적 구현 요구사항

### 1. 프론트엔드 컴포넌트
- **HomeTaskDashboard**: 메인 대시보드 컴포넌트
- **TaskCard**: 개별 업무 카드 컴포넌트
- **TaskCreationWizard**: 단계별 업무 생성 마법사
- **FloatingActionButton**: FAB 및 스피드 다이얼
- **TaskFilters**: 필터 및 정렬 컴포넌트
- **MomentumScoreIndicator**: 점수 시각화 컴포넌트

### 2. 상태 관리
- **TaskStore**: Zustand 기반 업무 상태 관리
- **ProjectStore**: 프로젝트 연계 상태
- **UIStore**: 필터, 정렬, 모달 상태

### 3. API 인터페이스
- **GET /tasks**: 사용자 업무 목록 조회
- **POST /tasks**: 새 업무 생성
- **PUT /tasks/:id**: 업무 수정
- **DELETE /tasks/:id**: 업무 삭제
- **GET /tasks/momentum-score**: 모멘텀 점수 계산

### 4. 데이터 모델
```typescript
interface Task {
  id: string;
  title: string;
  description?: string;
  projectId?: string;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate?: Date;
  estimatedHours?: number;
  assigneeId?: string;
  momentumScore: number;
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

interface MomentumScore {
  reach: number;      // 0-10
  impact: number;     // 0-10  
  confidence: number; // 0-10
  effort: number;     // 0-10
  total: number;      // 계산된 총점
}
```

## 성능 요구사항

### 1. 응답 시간
- **초기 로딩**: 2초 이내
- **업무 생성**: 1초 이내
- **필터링/정렬**: 500ms 이내
- **모멘텀 점수 계산**: 300ms 이내

### 2. 사용성
- **모바일 최적화**: 터치 친화적 인터페이스
- **오프라인 지원**: 기본 CRUD 작업 캐싱
- **실시간 동기화**: 다중 디바이스 상태 동기화

## 검증 및 테스트

### 1. 사용자 테스트
- **온보딩 플로우**: 첫 업무 생성까지 5분 이내
- **아하 모멘트**: 첫 업무가 홈 화면 상단 표시
- **학습 곡선**: 핵심 기능 10분 이내 숙달

### 2. A/B 테스트 영역
- **모멘텀 점수 가중치**: 사용자별 최적화
- **업무 생성 단계**: 단계 수 최적화
- **카드 레이아웃**: 정보 표시 우선순위

## 성공 지표 (KPI)

### 1. 참여도
- **일일 활성 사용자 (DAU)**: 신규 가입 후 7일 내 50% 이상
- **업무 완료율**: 생성된 업무의 80% 이상 완료
- **세션 시간**: 평균 15분 이상

### 2. 효율성
- **업무 생성 시간**: 평균 2분 이내
- **완료까지 소요 시간**: 예상 시간 대비 120% 이내
- **재방문율**: 주간 75% 이상

## 출시 단계

### Phase 1: 기본 구현 (2주)
- 홈 대시보드 기본 UI
- 업무 CRUD 기능
- 단순 우선순위 정렬

### Phase 2: GTD 플로우 (2주)
- 단계별 업무 생성 마법사
- FAB 스피드 다이얼
- 프로젝트 연계

### Phase 3: 지능형 기능 (2주)
- 모멘텀 점수 알고리즘
- 동적 정렬 및 필터링
- 프로젝트 진행률 통합

### Phase 4: 최적화 (1주)
- 성능 최적화
- 마이크로인터랙션 완성
- 접근성 향상

---

이 PRD는 기획서 섹션 2의 비전을 구체적이고 실행 가능한 개발 계획으로 변환한 것입니다. 각 단계별로 측정 가능한 목표와 명확한 구현 방향을 제시하여 효율적인 개발을 지원합니다.
</file>

<file path=".taskmaster/docs/PRD.txt">
<context>
# Overview  
워클리(Workly)는 게이미피케이션 기반 생산성 생태계로서, 개인의 업무 관리, 팀 협업, 전문적 성장을 하나의 통합된 플랫폼에서 제공합니다. Threads 스타일의 미니멀한 UI/UX를 기반으로 하여, GTD(Getting Things Done) 방법론과 깊이 있는 게이미피케이션을 결합해 사용자의 지속적인 참여와 성장을 유도합니다.

이 제품은 기존 생산성 도구들의 기능적 접근을 넘어서, 사용자가 자신의 전문적 여정을 '플레이'하며 성취를 통해 성장할 수 있는 새로운 패러다임을 제시합니다. 

# Core Features  
## 1. 지능형 업무 관리 (홈)
- **GTD 기반 업무 생성**: 5단계 순차적 프로세스로 브레인 덤프에서 실행까지
- **모멘텀 점수 알고리즘**: RICE 모델 기반 우선순위 자동 정렬
- **스마트 필터링**: '오늘', '완료됨', '전체', '나중에 할 일' 보기
- **직관적 검색**: 전체 프로젝트 통합 검색

## 2. 채팅 우선 프로젝트 관리
- **실시간 협업**: Slack 스타일 영구 채팅 채널
- **슬래시 명령어**: /add-task, /delegate, /set-milestone 등 생산성 명령
- **OKR 기반 목표 설정**: 목표-핵심결과 구조로 명확한 성과 측정
- **팀 구성 시스템**: Upwork 스타일 모집 및 기술 매칭

## 3. 포괄적 게이미피케이션
- **XP & 레벨 시스템**: 모든 긍정적 행동에 대한 보상
- **스킬 트리**: 전문 분야별 역량 시각화 및 성장 추적
- **업적 & 배지**: 특정 마일스톤 달성 보상
- **평판 시스템**: Stack Overflow 스타일 커뮤니티 신뢰도
- **시즌제**: 분기별 테마와 독점 보상이 있는 참여 주기

## 4. 생태계 허브 (게시판)
- **지식 위키**: 사용자 생성 튜토리얼 및 모범 사례 가이드
- **프로젝트 쇼케이스**: Behance 스타일 포트폴리오 공유 공간
- **임무 마켓플레이스**: 유료 프리랜스 업무 플랫폼 (향후 구현)

## 5. 워크스페이스 (B2B)
- **팀 관리**: 중앙집중식 멤버 관리 및 권한 설정
- **비공개 프로젝트**: 조직 내부 전용 협업 공간
- **팀 분석**: 생산성 및 성과 대시보드
- **엔터프라이즈 보안**: SSO, 감사 로그, 규정 준수

# User Experience  
## 핵심 사용자 페르소나
1. **개인 생산성 추구자**: 업무 관리와 개인 성장을 원하는 전문가
2. **스타트업 팀**: 민첩한 협업과 동기부여가 필요한 소규모 팀
3. **프리랜서/크리에이터**: 포트폴리오 구축과 수익 창출 기회를 찾는 개인
4. **엔터프라이즈**: 게이미피케이션으로 팀 참여도를 높이려는 조직

## 핵심 사용자 여정
### 온보딩 (첫 5분)
1. **Google 로그인**: 단일 '구글로 시작하기' 버튼
2. **환영 화면**: 핵심 가치 제안 간결 소개  
3. **첫 업무 생성**: 가이드된 GTD 프로세스 체험
4. **아하! 모멘트**: 우선순위 정렬된 홈 화면에서 즉시 가치 확인

### 일일 워크플로우
1. **홈 화면 확인**: 모멘텀 점수 기반 우선순위 업무 검토
2. **업무 실행**: 체크 완료 시 XP 획득 및 진행률 피드백
3. **프로젝트 협업**: 채팅을 통한 자연스러운 팀 커뮤니케이션
4. **성장 추적**: 스킬 트리 레벨업 및 업적 달성 확인

### UI/UX 핵심 원칙
- **점진적 공개**: 핵심 행동은 단순하게, 고급 기능은 직관적으로 접근 가능
- **일관성**: 플랫폼 관례 준수 및 통일된 시각적 언어
- **즉각적 피드백**: 모든 사용자 행동에 대한 마이크로인터랙션
- **모바일 우선**: 전체 화면 활용 및 터치 최적화
</context>

<PRD>
# Technical Architecture  
## 시스템 컴포넌트
### Frontend
- **Framework**: Next.js 14+ (App Router)
- **언어**: TypeScript (타입 안전성)
- **스타일링**: Tailwind CSS (유틸리티 우선)
- **상태 관리**: Zustand (경량 상태 관리)
- **UI 컴포넌트**: Headless UI + 커스텀 컴포넌트

### Backend  
- **Framework**: NestJS (확장 가능한 Node.js)
- **데이터베이스**: PostgreSQL (관계형 데이터)
- **ORM**: TypeORM (TypeScript 통합)
- **실시간**: Socket.io (채팅 및 실시간 업데이트)
- **인증**: JWT + Google OAuth 2.0

### 인프라
- **배포**: Docker + Docker Compose (개발/프로덕션)
- **파일 저장**: AWS S3 (이미지, 문서)
- **CDN**: CloudFront (글로벌 콘텐츠 배포)
- **모니터링**: Sentry (오류 추적)

## 데이터 모델
### 핵심 엔티티
```typescript
// 사용자
User {
  id, email, profile, xp, level, skills[], reputation, 
  workspaceId?, role, preferences, createdAt
}

// 업무
Task {
  id, title, description, status, priority, momentum_score,
  project_id, assignee_id, due_date, xp_reward, tags[]
}

// 프로젝트  
Project {
  id, title, objectives[], key_results[], 
  members[], chat_messages[], privacy, workspace_id?
}

// 게이미피케이션
Achievement {
  id, name, description, xp_reward, badge_icon, 
  unlock_criteria, rarity
}

SkillTree {
  user_id, skill_name, level, progress_xp, 
  total_xp_required, unlock_achievements[]
}
```

## API 설계
### RESTful Endpoints
```
# 인증
POST /auth/google - Google OAuth 로그인
GET /auth/me - 현재 사용자 정보

# 업무 관리
GET /tasks - 사용자 업무 목록 (필터링 지원)
POST /tasks - 새 업무 생성 (GTD 단계별)
PUT /tasks/:id - 업무 상태/내용 업데이트
DELETE /tasks/:id - 업무 삭제

# 프로젝트
GET /projects - 사용자 참여 프로젝트
POST /projects - 새 프로젝트 생성
PUT /projects/:id - 프로젝트 업데이트
GET /projects/:id/chat - 채팅 메시지 조회

# 게이미피케이션
GET /users/:id/profile - 사용자 프로필 (XP, 스킬 등)
POST /achievements/unlock - 업적 달성 처리
GET /leaderboards - 리더보드 조회
```

### WebSocket Events
```
# 실시간 채팅
project:message - 프로젝트 채팅 메시지
project:join - 프로젝트 채널 참여
project:leave - 프로젝트 채널 퇴장

# 실시간 업데이트
task:updated - 업무 상태 변경
xp:gained - XP 획득 알림
achievement:unlocked - 업적 달성 알림
```

## 통합 요구사항
- **Google Calendar API**: 마감일 동기화
- **Slack API**: 알림 및 업무 생성 (향후)
- **GitHub API**: 커밋-업무 연결 (향후)
- **결제 시스템**: Stripe (B2B 구독, 임무 마켓플레이스)

# Development Roadmap  
## Phase 1: MVP Core (3개월)
### 필수 기능 (Must-have)
1. **사용자 인증**: Google OAuth 통합
2. **홈 - 업무 관리**: 
   - GTD 기반 업무 생성 플로우
   - 기본 우선순위 정렬 (모멘텀 점수 v1)
   - 완료/미완료 필터링
3. **프로젝트 - 기본 협업**:
   - 프로젝트 생성/관리
   - 실시간 채팅 시스템
   - 기본 슬래시 명령어 (/add-task)
4. **프로필 - 기본 게이미피케이션**:
   - XP/레벨 시스템
   - 기본 대시보드
5. **설정**: 다크모드, 언어 설정, 알림 제어

### 기술적 목표
- 완전한 풀스택 아키텍처 구축
- 모바일 우선 반응형 디자인 완성
- 기본 실시간 기능 구현
- CI/CD 파이프라인 설정

## Phase 2: 게이미피케이션 확장 (2개월)
### 추가 기능 (Should-have)
1. **고급 게이미피케이션**:
   - 업적/배지 시스템
   - 스킬 트리 v1 (핵심 기술 5개)
   - 기본 평판 시스템
2. **지식 위키**:
   - 마크다운 기반 문서 작성
   - 태그 및 검색 시스템
   - 기본 큐레이션 기능
3. **외부 통합**:
   - Google Calendar 동기화
   - 기본 알림 시스템

### 기술적 목표
- 복합 쿼리 성능 최적화
- 파일 업로드 시스템 구축
- 검색 엔진 통합 (Elasticsearch)

## Phase 3: 커뮤니티 & 확장 (3개월)
### 향후 기능 (Could-have)
1. **프로젝트 쇼케이스**: 
   - 포트폴리오 갤러리
   - 추천/평가 시스템
2. **팀 기능 확장**:
   - 고급 프로젝트 템플릿
   - 팀 분석 대시보드
3. **모바일 앱**: React Native 또는 Flutter
4. **고급 통합**: Slack, GitHub, Notion

## Phase 4: B2B & 수익화 (4개월)
### 엔터프라이즈 기능 (Won't-have 단기)
1. **워크스페이스 시스템**: 
   - 팀 관리 콘솔
   - 역할 기반 권한
   - 팀 전체 분석
2. **임무 마켓플레이스**: 
   - 프리랜스 업무 플랫폼
   - 결제 시스템 통합
   - 분쟁 해결 시스템
3. **시즌제 시스템**: 
   - 분기별 테마
   - 시즌 패스
   - 리더보드

# Logical Dependency Chain
## 개발 순서 및 종속성

### Foundation Layer (Week 1-4)
**필수 선행 작업 - 모든 후속 기능의 기반**
1. **인증 시스템**: Google OAuth + JWT (모든 기능의 전제조건)
2. **기본 데이터 모델**: User, Task, Project 엔티티 설계
3. **UI 기초**: 헤더, 네비게이션, 기본 레이아웃 컴포넌트
4. **실시간 인프라**: Socket.io 기본 설정

### Core Loop (Week 5-8)
**즉시 사용 가능한 가치 제공**
1. **업무 관리 (홈)**: 
   - 단순 CRUD → GTD 플로우 → 기본 정렬
   - 의존성: 인증, User/Task 모델
2. **기본 프로젝트**: 
   - 프로젝트 생성 → 멤버 초대 → 간단한 업무 할당
   - 의존성: 업무 관리, Project 모델

### Engagement Layer (Week 9-12)  
**사용자 유지를 위한 동기부여 시스템**
1. **기본 게이미피케이션**:
   - XP 적립 → 레벨 시스템 → 프로필 대시보드
   - 의존성: 업무 완료 이벤트, 사용자 프로필
2. **실시간 채팅**:
   - 프로젝트 채팅 → 슬래시 명령어 → 알림
   - 의존성: 프로젝트 시스템, 실시간 인프라

### 이후 단계별 확장
각 단계는 이전 단계의 안정성 확보 후 진행:
- **Week 13-16**: 고급 게이미피케이션 (업적, 스킬)
- **Week 17-20**: 커뮤니티 기능 (위키, 쇼케이스) 
- **Week 21+**: B2B 기능 (워크스페이스, 마켓플레이스)

## 점진적 가치 전달 전략
1. **Week 4**: 기본 업무 관리 앱으로 사용 가능
2. **Week 8**: 팀 협업 기능으로 소규모 그룹 유치
3. **Week 12**: 게이미피케이션으로 장기 사용자 확보
4. **Week 16+**: 커뮤니티 기능으로 네트워크 효과 창출

# Risks and Mitigations  
## 기술적 위험
### 1. 실시간 성능 문제
**위험**: Socket.io 동시 접속자 확장 한계
**완화**: 
- Redis 기반 메시지 브로커 도입
- 수평 확장 가능한 서버 아키텍처 설계
- 채팅 메시지 페이지네이션 및 캐싱

### 2. 데이터베이스 복잡성
**위험**: 게이미피케이션 로직으로 인한 복합 쿼리 성능 저하
**완화**:
- 읽기 전용 복제본으로 조회 성능 분산
- 레디스 캐싱으로 빈번한 계산 결과 저장
- 배치 작업으로 무거운 계산 비동기 처리

### 3. 모바일 성능
**위험**: 복잡한 게이미피케이션 UI로 인한 모바일 성능 저하
**완화**:
- Progressive Web App (PWA) 우선 개발
- 코드 분할 및 지연 로딩
- 네이티브 앱은 Phase 3 이후 검증된 기능만 포팅

## 제품/시장 위험
### 1. MVP 범위 과대 설정
**위험**: 모든 기능을 한번에 구현하려다 출시 지연
**완화**:
- 엄격한 MoSCoW 우선순위 준수  
- 2주 스프린트로 작은 단위 검증
- 사용자 피드백 기반 우선순위 재조정

### 2. 게이미피케이션 균형
**위험**: 보상 시스템 불균형으로 인한 사용자 이탈
**완화**:
- A/B 테스트로 XP/레벨 밸런스 조정
- 사용자 행동 분석으로 참여 패턴 모니터링
- 단계적 보상 시스템으로 점진적 조정 가능

### 3. 커뮤니티 활성화 실패
**위험**: 위키/쇼케이스 등 UGC 기능 사용률 저조
**완화**:
- 초기 고품질 시드 콘텐츠 플랫폼 직접 제공
- 얼리 어답터 대상 콘텐츠 기여 인센티브
- 큐레이션을 통한 품질 관리 및 발견 가능성 증대

## 비즈니스 위험
### 1. 경쟁사 대응
**위험**: 기존 대형 플랫폼의 게이미피케이션 기능 추가
**완화**:
- 핵심 차별점 (GTD + 게이미피케이션 통합)에 집중
- 커뮤니티 기반 방어막 구축
- 빠른 혁신 주기로 기능 우위 유지

### 2. 수익화 시점
**위험**: B2B 전환 시점 오판으로 인한 현금 흐름 문제
**완화**:
- 개인 사용자 MAU 10K+ 달성 후 B2B 진입
- 프리미엄 개인 요금제로 조기 수익화 테스트
- 시드 투자로 충분한 개발 버퍼 확보

# Appendix  
## 게이미피케이션 밸런스 설정
### XP 획득 기준표
- 일일 업무 완료: 10 XP
- 프로젝트 마일스톤: 100 XP  
- 프로젝트 완료: 250 XP
- 위키 문서 작성: 20 XP
- 쇼케이스 게시: 50 XP

### 레벨업 요구 XP (지수적 증가)
```
Level 1→2: 100 XP (누적 100)
Level 2→3: 150 XP (누적 250)  
Level 3→4: 225 XP (누적 475)
...
Level 10: 약 2,500 XP (일일 활성 사용자 기준 3-4개월)
```

## 기술 스택 상세
### 패키지 의존성
```json
{
  "frontend": {
    "next": "14.x",
    "typescript": "5.x", 
    "tailwindcss": "3.x",
    "zustand": "4.x",
    "@headlessui/react": "1.x"
  },
  "backend": {
    "@nestjs/core": "10.x",
    "typeorm": "0.3.x",
    "socket.io": "4.x",
    "@nestjs/jwt": "10.x",
    "passport-google-oauth20": "2.x"
  }
}
```

### 환경 설정
```env
# 개발 환경
DATABASE_URL=postgresql://localhost:5432/workly_dev
GOOGLE_CLIENT_ID=xxx
GOOGLE_CLIENT_SECRET=xxx
JWT_SECRET=xxx
REDIS_URL=redis://localhost:6379

# 프로덕션 추가
AWS_ACCESS_KEY_ID=xxx
AWS_SECRET_ACCESS_KEY=xxx  
SENTRY_DSN=xxx
```

## 사용자 연구 결과 (참고)
### 핵심 사용자 니즈
1. **명확한 우선순위**: "무엇을 먼저 해야 할지 모르겠어요"
2. **성취감**: "완료해도 허무해요, 성장이 보이지 않아요"  
3. **팀 소통**: "업무와 대화가 따로 놀아요"
4. **동기 부여**: "계속 사용할 이유가 부족해요"

### 경쟁 분석
- **Todoist**: 개인 중심, 게이미피케이션 부족
- **Asana**: 팀 중심, 개인 성장 지원 부족  
- **Habitica**: 게이미피케이션 강하나 협업 약함
- **Notion**: 유연하나 러닝 커브 높음

→ **워클리의 포지션**: "개인 성장과 팀 협업을 게이미피케이션으로 연결하는 유일한 플랫폼"
</PRD>
</file>

<file path=".taskmaster/reports/task-complexity-report.json">
{
	"meta": {
		"generatedAt": "2025-07-25T13:38:34.837Z",
		"tasksAnalyzed": 12,
		"totalTasks": 12,
		"analysisCount": 12,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "Initialize Monorepo & CI/CD Pipeline",
			"complexityScore": 8,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Break down the monorepo setup, Dockerization for both applications (dev/prod), and the CI/CD pipeline configuration for automated build, test, and deployment using GitHub Actions.",
			"reasoning": "This task is highly complex due to its foundational nature, involving multiple distinct technologies (monorepo tools, Docker, CI/CD) and environments (dev, prod) for two different applications. Each component requires careful configuration and integration, making it prone to environmental issues and requiring significant setup time. The recommended subtasks reflect these distinct areas."
		},
		{
			"taskId": 2,
			"taskTitle": "Implement Google OAuth & JWT Authentication",
			"complexityScore": 7,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Detail the steps for implementing Google OAuth 2.0 on the NestJS backend, including JWT generation and secure storage, and integrating the login flow and protected routes on the Next.js frontend.",
			"reasoning": "Authentication is a critical and security-sensitive area. Implementing Google OAuth involves external API interaction, callback handling, and secure token management. JWT implementation requires careful consideration of generation, validation, and secure storage (e.g., HttpOnly cookies vs. local storage). The task also includes user registration/login logic and protecting API routes, which adds to the complexity."
		},
		{
			"taskId": 3,
			"taskTitle": "Design & Implement Core Data Models (PostgreSQL, TypeORM)",
			"complexityScore": 6,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Outline the process for setting up PostgreSQL and TypeORM, defining the User, Task, and Project entities with their relationships, and creating initial database migrations.",
			"reasoning": "This task is foundational for the application's data layer. It involves setting up the database, configuring the ORM, and carefully designing the core data models and their relationships. While individual CRUD operations might be straightforward, ensuring correct relationships, data integrity, and a robust migration strategy adds significant complexity."
		},
		{
			"taskId": 4,
			"taskTitle": "Configure Socket.io for Real-time Updates",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Detail the steps for configuring Socket.io on the NestJS backend and integrating it with the Next.js frontend, including initial event handling and client-side connection management.",
			"reasoning": "Implementing real-time communication with Socket.io involves setting up a persistent connection layer on both the backend and frontend. This requires understanding WebSocket protocols, managing connections, and handling event-driven communication, which is more complex than typical REST API interactions."
		},
		{
			"taskId": 5,
			"taskTitle": "Develop Core UI/UX & Mobile-First Layout",
			"complexityScore": 6,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Break down the development of the core UI/UX, including Tailwind CSS setup, responsive layout implementation, and the creation of foundational navigation and UI components for a mobile-first design.",
			"reasoning": "This task is foundational for the entire frontend. It involves not just styling but establishing a robust, responsive, and maintainable UI architecture. Considerations like mobile-first design, component reusability, and adherence to design principles add to its complexity beyond simple styling."
		},
		{
			"taskId": 6,
			"taskTitle": "Implement User Profile & XP/Level System",
			"complexityScore": 5,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Detail the implementation of the user profile page, including backend logic for XP acquisition and level progression, and frontend display of XP and level.",
			"reasoning": "This task combines backend data model updates and logic with frontend UI development. The gamification logic (XP calculation, level progression) requires careful implementation and testing to ensure correctness and prevent exploits."
		},
		{
			"taskId": 7,
			"taskTitle": "Develop GTD-based Task Management System",
			"complexityScore": 7,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Break down the development of the GTD-based task management system, including the 5-step task creation flow, full CRUD operations, and smart filtering capabilities for 'Today', 'Completed', and 'All' tasks.",
			"reasoning": "This is a central feature of the application. The 'GTD 5-step sequential process' implies a more complex task creation flow than a simple form. Implementing robust CRUD operations, along with 'smart filtering' (which often involves date calculations and status management), requires significant backend logic and corresponding frontend UI."
		},
		{
			"taskId": 8,
			"taskTitle": "Implement Project Creation & Basic Collaboration",
			"complexityScore": 6,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Detail the implementation of project creation and basic collaboration features, including backend CRUD operations for projects and member management, and corresponding frontend UI for creation, listing, and detail views.",
			"reasoning": "This task involves standard CRUD operations for projects. However, the 'invite/manage members' aspect introduces additional complexity related to user relationships, potential roles, and ensuring proper access control, which goes beyond simple data persistence."
		},
		{
			"taskId": 9,
			"taskTitle": "Develop Real-time Project Chat with Slash Commands",
			"complexityScore": 7,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Break down the development of the real-time project chat, including Socket.io integration for message exchange, backend logic for parsing and executing slash commands like /add-task, and the frontend chat UI with message history.",
			"reasoning": "This task builds upon existing Socket.io infrastructure but adds significant complexity. Real-time chat requires robust message handling, history management, and efficient UI updates. The addition of slash commands introduces parsing logic and cross-feature integration (e.g., with the task service), making it a multi-faceted and challenging feature."
		},
		{
			"taskId": 10,
			"taskTitle": "Implement Momentum Score & Advanced Task Filtering",
			"complexityScore": 6,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Detail the implementation of the momentum score using the RICE model, including backend calculation and integration, and the development of advanced task filtering ('Later') and global search functionalities.",
			"reasoning": "This task involves implementing a specific algorithm (RICE model) for task prioritization, which requires careful calculation and integration into task updates. Additionally, advanced filtering and global search capabilities necessitate efficient database queries and robust frontend UI to handle dynamic data display."
		},
		{
			"taskId": 11,
			"taskTitle": "Integrate Google Calendar for Due Date Sync",
			"complexityScore": 7,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down the integration with Google Calendar API for due date synchronization, including backend setup for event creation/update and frontend UI for connecting the calendar and managing sync.",
			"reasoning": "Integrating with an external API like Google Calendar is inherently complex. It involves managing OAuth 2.0 for specific scopes, handling API rate limits, implementing robust error handling, and ensuring reliable one-way synchronization of events based on task due dates."
		},
		{
			"taskId": 12,
			"taskTitle": "Establish Comprehensive Testing & Monitoring",
			"complexityScore": 7,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Detail the establishment of a comprehensive testing suite, including unit, integration, and end-to-end tests, and the setup of Sentry for error tracking and basic application performance monitoring.",
			"reasoning": "This task is crucial for application quality and stability. It involves setting up and configuring multiple testing frameworks (unit, integration, E2E) for both frontend and backend, which requires distinct configurations and test writing strategies. Additionally, integrating a monitoring solution like Sentry adds another layer of complexity for error tracking and observability."
		}
	]
}
</file>

<file path=".taskmaster/templates/example_prd.txt">
<context>
# Overview  
[Provide a high-level overview of your product here. Explain what problem it solves, who it's for, and why it's valuable.]

# Core Features  
[List and describe the main features of your product. For each feature, include:
- What it does
- Why it's important
- How it works at a high level]

# User Experience  
[Describe the user journey and experience. Include:
- User personas
- Key user flows
- UI/UX considerations]
</context>
<PRD>
# Technical Architecture  
[Outline the technical implementation details:
- System components
- Data models
- APIs and integrations
- Infrastructure requirements]

# Development Roadmap  
[Break down the development process into phases:
- MVP requirements
- Future enhancements
- Do not think about timelines whatsoever -- all that matters is scope and detailing exactly what needs to be build in each phase so it can later be cut up into tasks]

# Logical Dependency Chain
[Define the logical order of development:
- Which features need to be built first (foundation)
- Getting as quickly as possible to something usable/visible front end that works
- Properly pacing and scoping each feature so it is atomic but can also be built upon and improved as development approaches]

# Risks and Mitigations  
[Identify potential risks and how they'll be addressed:
- Technical challenges
- Figuring out the MVP that we can build upon
- Resource constraints]

# Appendix  
[Include any additional information:
- Research findings
- Technical specifications]
</PRD>
</file>

<file path=".taskmaster/CLAUDE.md">
# Task Master AI - Agent Integration Guide

## Essential Commands

### Core Workflow Commands

```bash
# Project Setup
task-master init                                    # Initialize Task Master in current project
task-master parse-prd .taskmaster/docs/prd.txt      # Generate tasks from PRD document
task-master models --setup                        # Configure AI models interactively

# Daily Development Workflow
task-master list                                   # Show all tasks with status
task-master next                                   # Get next available task to work on
task-master show <id>                             # View detailed task information (e.g., task-master show 1.2)
task-master set-status --id=<id> --status=done    # Mark task complete

# Task Management
task-master add-task --prompt="description" --research        # Add new task with AI assistance
task-master expand --id=<id> --research --force              # Break task into subtasks
task-master update-task --id=<id> --prompt="changes"         # Update specific task
task-master update --from=<id> --prompt="changes"            # Update multiple tasks from ID onwards
task-master update-subtask --id=<id> --prompt="notes"        # Add implementation notes to subtask

# Analysis & Planning
task-master analyze-complexity --research          # Analyze task complexity
task-master complexity-report                      # View complexity analysis
task-master expand --all --research               # Expand all eligible tasks

# Dependencies & Organization
task-master add-dependency --id=<id> --depends-on=<id>       # Add task dependency
task-master move --from=<id> --to=<id>                       # Reorganize task hierarchy
task-master validate-dependencies                            # Check for dependency issues
task-master generate                                         # Update task markdown files (usually auto-called)
```

## Key Files & Project Structure

### Core Files

- `.taskmaster/tasks/tasks.json` - Main task data file (auto-managed)
- `.taskmaster/config.json` - AI model configuration (use `task-master models` to modify)
- `.taskmaster/docs/prd.txt` - Product Requirements Document for parsing
- `.taskmaster/tasks/*.txt` - Individual task files (auto-generated from tasks.json)
- `.env` - API keys for CLI usage

### Claude Code Integration Files

- `CLAUDE.md` - Auto-loaded context for Claude Code (this file)
- `.claude/settings.json` - Claude Code tool allowlist and preferences
- `.claude/commands/` - Custom slash commands for repeated workflows
- `.mcp.json` - MCP server configuration (project-specific)

### Directory Structure

```
project/
├── .taskmaster/
│   ├── tasks/              # Task files directory
│   │   ├── tasks.json      # Main task database
│   │   ├── task-1.md      # Individual task files
│   │   └── task-2.md
│   ├── docs/              # Documentation directory
│   │   ├── prd.txt        # Product requirements
│   ├── reports/           # Analysis reports directory
│   │   └── task-complexity-report.json
│   ├── templates/         # Template files
│   │   └── example_prd.txt  # Example PRD template
│   └── config.json        # AI models & settings
├── .claude/
│   ├── settings.json      # Claude Code configuration
│   └── commands/         # Custom slash commands
├── .env                  # API keys
├── .mcp.json            # MCP configuration
└── CLAUDE.md            # This file - auto-loaded by Claude Code
```

## MCP Integration

Task Master provides an MCP server that Claude Code can connect to. Configure in `.mcp.json`:

```json
{
  "mcpServers": {
    "task-master-ai": {
      "command": "npx",
      "args": ["-y", "--package=task-master-ai", "task-master-ai"],
      "env": {
        "ANTHROPIC_API_KEY": "your_key_here",
        "PERPLEXITY_API_KEY": "your_key_here",
        "OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
        "GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
        "XAI_API_KEY": "XAI_API_KEY_HERE",
        "OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
        "MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
        "AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
        "OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
      }
    }
  }
}
```

### Essential MCP Tools

```javascript
help; // = shows available taskmaster commands
// Project setup
initialize_project; // = task-master init
parse_prd; // = task-master parse-prd

// Daily workflow
get_tasks; // = task-master list
next_task; // = task-master next
get_task; // = task-master show <id>
set_task_status; // = task-master set-status

// Task management
add_task; // = task-master add-task
expand_task; // = task-master expand
update_task; // = task-master update-task
update_subtask; // = task-master update-subtask
update; // = task-master update

// Analysis
analyze_project_complexity; // = task-master analyze-complexity
complexity_report; // = task-master complexity-report
```

## Claude Code Workflow Integration

### Standard Development Workflow

#### 1. Project Initialization

```bash
# Initialize Task Master
task-master init

# Create or obtain PRD, then parse it
task-master parse-prd .taskmaster/docs/prd.txt

# Analyze complexity and expand tasks
task-master analyze-complexity --research
task-master expand --all --research
```

If tasks already exist, another PRD can be parsed (with new information only!) using parse-prd with --append flag. This will add the generated tasks to the existing list of tasks..

#### 2. Daily Development Loop

```bash
# Start each session
task-master next                           # Find next available task
task-master show <id>                     # Review task details

# During implementation, check in code context into the tasks and subtasks
task-master update-subtask --id=<id> --prompt="implementation notes..."

# Complete tasks
task-master set-status --id=<id> --status=done
```

#### 3. Multi-Claude Workflows

For complex projects, use multiple Claude Code sessions:

```bash
# Terminal 1: Main implementation
cd project && claude

# Terminal 2: Testing and validation
cd project-test-worktree && claude

# Terminal 3: Documentation updates
cd project-docs-worktree && claude
```

### Custom Slash Commands

Create `.claude/commands/taskmaster-next.md`:

```markdown
Find the next available Task Master task and show its details.

Steps:

1. Run `task-master next` to get the next task
2. If a task is available, run `task-master show <id>` for full details
3. Provide a summary of what needs to be implemented
4. Suggest the first implementation step
```

Create `.claude/commands/taskmaster-complete.md`:

```markdown
Complete a Task Master task: $ARGUMENTS

Steps:

1. Review the current task with `task-master show $ARGUMENTS`
2. Verify all implementation is complete
3. Run any tests related to this task
4. Mark as complete: `task-master set-status --id=$ARGUMENTS --status=done`
5. Show the next available task with `task-master next`
```

## Tool Allowlist Recommendations

Add to `.claude/settings.json`:

```json
{
  "allowedTools": [
    "Edit",
    "Bash(task-master *)",
    "Bash(git commit:*)",
    "Bash(git add:*)",
    "Bash(npm run *)",
    "mcp__task_master_ai__*"
  ]
}
```

## Configuration & Setup

### API Keys Required

At least **one** of these API keys must be configured:

- `ANTHROPIC_API_KEY` (Claude models) - **Recommended**
- `PERPLEXITY_API_KEY` (Research features) - **Highly recommended**
- `OPENAI_API_KEY` (GPT models)
- `GOOGLE_API_KEY` (Gemini models)
- `MISTRAL_API_KEY` (Mistral models)
- `OPENROUTER_API_KEY` (Multiple models)
- `XAI_API_KEY` (Grok models)

An API key is required for any provider used across any of the 3 roles defined in the `models` command.

### Model Configuration

```bash
# Interactive setup (recommended)
task-master models --setup

# Set specific models
task-master models --set-main claude-3-5-sonnet-20241022
task-master models --set-research perplexity-llama-3.1-sonar-large-128k-online
task-master models --set-fallback gpt-4o-mini
```

## Task Structure & IDs

### Task ID Format

- Main tasks: `1`, `2`, `3`, etc.
- Subtasks: `1.1`, `1.2`, `2.1`, etc.
- Sub-subtasks: `1.1.1`, `1.1.2`, etc.

### Task Status Values

- `pending` - Ready to work on
- `in-progress` - Currently being worked on
- `done` - Completed and verified
- `deferred` - Postponed
- `cancelled` - No longer needed
- `blocked` - Waiting on external factors

### Task Fields

```json
{
  "id": "1.2",
  "title": "Implement user authentication",
  "description": "Set up JWT-based auth system",
  "status": "pending",
  "priority": "high",
  "dependencies": ["1.1"],
  "details": "Use bcrypt for hashing, JWT for tokens...",
  "testStrategy": "Unit tests for auth functions, integration tests for login flow",
  "subtasks": []
}
```

## Claude Code Best Practices with Task Master

### Context Management

- Use `/clear` between different tasks to maintain focus
- This CLAUDE.md file is automatically loaded for context
- Use `task-master show <id>` to pull specific task context when needed

### Iterative Implementation

1. `task-master show <subtask-id>` - Understand requirements
2. Explore codebase and plan implementation
3. `task-master update-subtask --id=<id> --prompt="detailed plan"` - Log plan
4. `task-master set-status --id=<id> --status=in-progress` - Start work
5. Implement code following logged plan
6. `task-master update-subtask --id=<id> --prompt="what worked/didn't work"` - Log progress
7. `task-master set-status --id=<id> --status=done` - Complete task

### Complex Workflows with Checklists

For large migrations or multi-step processes:

1. Create a markdown PRD file describing the new changes: `touch task-migration-checklist.md` (prds can be .txt or .md)
2. Use Taskmaster to parse the new prd with `task-master parse-prd --append` (also available in MCP)
3. Use Taskmaster to expand the newly generated tasks into subtasks. Consdier using `analyze-complexity` with the correct --to and --from IDs (the new ids) to identify the ideal subtask amounts for each task. Then expand them.
4. Work through items systematically, checking them off as completed
5. Use `task-master update-subtask` to log progress on each task/subtask and/or updating/researching them before/during implementation if getting stuck

### Git Integration

Task Master works well with `gh` CLI:

```bash
# Create PR for completed task
gh pr create --title "Complete task 1.2: User authentication" --body "Implements JWT auth system as specified in task 1.2"

# Reference task in commits
git commit -m "feat: implement JWT auth (task 1.2)"
```

### Parallel Development with Git Worktrees

```bash
# Create worktrees for parallel task development
git worktree add ../project-auth feature/auth-system
git worktree add ../project-api feature/api-refactor

# Run Claude Code in each worktree
cd ../project-auth && claude    # Terminal 1: Auth work
cd ../project-api && claude     # Terminal 2: API work
```

## Troubleshooting

### AI Commands Failing

```bash
# Check API keys are configured
cat .env                           # For CLI usage

# Verify model configuration
task-master models

# Test with different model
task-master models --set-fallback gpt-4o-mini
```

### MCP Connection Issues

- Check `.mcp.json` configuration
- Verify Node.js installation
- Use `--mcp-debug` flag when starting Claude Code
- Use CLI as fallback if MCP unavailable

### Task File Sync Issues

```bash
# Regenerate task files from tasks.json
task-master generate

# Fix dependency issues
task-master fix-dependencies
```

DO NOT RE-INITIALIZE. That will not do anything beyond re-adding the same Taskmaster core files.

## Important Notes

### AI-Powered Operations

These commands make AI calls and may take up to a minute:

- `parse_prd` / `task-master parse-prd`
- `analyze_project_complexity` / `task-master analyze-complexity`
- `expand_task` / `task-master expand`
- `expand_all` / `task-master expand --all`
- `add_task` / `task-master add-task`
- `update` / `task-master update`
- `update_task` / `task-master update-task`
- `update_subtask` / `task-master update-subtask`

### File Management

- Never manually edit `tasks.json` - use commands instead
- Never manually edit `.taskmaster/config.json` - use `task-master models`
- Task markdown files in `tasks/` are auto-generated
- Run `task-master generate` after manual changes to tasks.json

### Claude Code Session Management

- Use `/clear` frequently to maintain focused context
- Create custom slash commands for repeated Task Master workflows
- Configure tool allowlist to streamline permissions
- Use headless mode for automation: `claude -p "task-master next"`

### Multi-Task Updates

- Use `update --from=<id>` to update multiple future tasks
- Use `update-task --id=<id>` for single task updates
- Use `update-subtask --id=<id>` for implementation logging

### Research Mode

- Add `--research` flag for research-based AI enhancement
- Requires a research model API key like Perplexity (`PERPLEXITY_API_KEY`) in environment
- Provides more informed task creation and updates
- Recommended for complex technical tasks

---

_This guide ensures Claude Code has immediate access to Task Master's essential functionality for agentic development workflows._
</file>

<file path=".taskmaster/config.json">
{
  "models": {
    "main": {
      "provider": "gemini-cli",
      "modelId": "gemini-2.5-pro",
      "maxTokens": 65536,
      "temperature": 0.2
    },
    "research": {
      "provider": "gemini-cli",
      "modelId": "gemini-2.5-flash",
      "maxTokens": 65536,
      "temperature": 0.1
    },
    "fallback": {
      "provider": "gemini-cli",
      "modelId": "gemini-2.5-pro",
      "maxTokens": 65536,
      "temperature": 0.2
    }
  },
  "global": {
    "logLevel": "info",
    "debug": false,
    "defaultNumTasks": 10,
    "defaultSubtasks": 5,
    "defaultPriority": "medium",
    "projectName": "Taskmaster",
    "ollamaBaseURL": "http://localhost:11434/api",
    "bedrockBaseURL": "https://bedrock.us-east-1.amazonaws.com",
    "responseLanguage": "한국어",
    "defaultTag": "master",
    "azureOpenaiBaseURL": "https://your-endpoint.openai.azure.com/",
    "userId": "1234567890"
  },
  "claudeCode": {}
}
</file>

<file path=".taskmaster/state.json">
{
  "currentTag": "master",
  "lastSwitched": "2025-07-25T13:17:16.956Z",
  "branchTagMapping": {},
  "migrationNoticeShown": false
}
</file>

<file path="backend/src/database/entities/audit-log.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Index,
} from 'typeorm';

@Entity('audit_logs')
@Index(['adminId'])
@Index(['action'])
@Index(['targetType'])
@Index(['timestamp'])
export class AuditLog {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('uuid')
  adminId: string;

  @Column()
  adminName: string;

  @Column()
  action: string;

  @Column()
  targetType: string;

  @Column({ nullable: true })
  targetId?: string;

  @Column({ nullable: true })
  targetName?: string;

  @Column('jsonb', { nullable: true })
  changes?: {
    before?: Record<string, any>;
    after?: Record<string, any>;
  };

  @Column()
  ipAddress: string;

  @Column()
  userAgent: string;

  @CreateDateColumn()
  timestamp: Date;

  @Column({ default: true })
  success: boolean;

  @Column({ nullable: true })
  errorMessage?: string;
}
</file>

<file path="backend/src/database/entities/task-comment.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  OneToMany,
  Index,
} from 'typeorm';
import { Task } from './task.entity';
import { User } from './user.entity';

@Entity('task_comments')
@Index(['taskId'])
@Index(['authorId'])
@Index(['parentId'])
@Index(['createdAt'])
@Index(['isInternal'])
export class TaskComment {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text')
  content: string;

  @Column()
  taskId: string;

  @Column()
  authorId: string;

  @Column({ nullable: true })
  parentId?: string;

  @Column({ default: false })
  isInternal: boolean;

  @Column({ default: false })
  isEdited: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => Task, task => task.comments, {
    onDelete: 'CASCADE'
  })
  task: Task;

  @ManyToOne(() => User, { eager: true })
  author: User;

  @ManyToOne(() => TaskComment, comment => comment.replies, {
    onDelete: 'CASCADE'
  })
  parent?: TaskComment;

  @OneToMany(() => TaskComment, comment => comment.parent)
  replies: TaskComment[];

  // 답글인지 확인
  isReply(): boolean {
    return this.parentId !== null;
  }

  // 답글이 있는지 확인
  hasReplies(): boolean {
    return this.replies && this.replies.length > 0;
  }

  // 내용 업데이트
  updateContent(content: string): void {
    this.content = content;
    this.isEdited = true;
  }

  // 내부 댓글로 설정
  markAsInternal(): void {
    this.isInternal = true;
  }

  // 공개 댓글로 설정
  markAsPublic(): void {
    this.isInternal = false;
  }

  // 작성자 확인
  isAuthoredBy(userId: string): boolean {
    return this.authorId === userId;
  }

  // 편집 가능한지 확인
  canEdit(userId: string): boolean {
    return this.isAuthoredBy(userId);
  }

  // 삭제 가능한지 확인
  canDelete(userId: string): boolean {
    return this.isAuthoredBy(userId);
  }
}
</file>

<file path="backend/src/database/entities/task-label.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  ManyToMany,
  Index,
} from 'typeorm';
import { Task } from './task.entity';
import { Project } from './project.entity';

@Entity('task_labels')
@Index(['name'])
@Index(['projectId'])
export class TaskLabel {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ length: 7 })
  color: string;

  @Column('text', { nullable: true })
  description?: string;

  @Column({ nullable: true })
  projectId?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => Project, {
    onDelete: 'CASCADE'
  })
  project?: Project;

  @ManyToMany(() => Task, task => task.labels)
  tasks: Task[];

  // 전역 라벨인지 확인
  isGlobal(): boolean {
    return this.projectId === null;
  }

  // 프로젝트별 라벨인지 확인
  isProjectSpecific(): boolean {
    return this.projectId !== null;
  }
}
</file>

<file path="backend/src/database/migrations/1706000000000-initial-schema.ts">
import { MigrationInterface, QueryRunner } from 'typeorm';

export class InitialSchema1706000000000 implements MigrationInterface {
  name = 'InitialSchema1706000000000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Users 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "users" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "email" character varying NOT NULL,
        "password" character varying NOT NULL,
        "name" character varying NOT NULL,
        "avatar" character varying,
        "role" "public"."users_role_enum" NOT NULL DEFAULT 'member',
        "status" "public"."users_status_enum" NOT NULL DEFAULT 'pending_verification',
        "profile" jsonb NOT NULL,
        "preferences" jsonb NOT NULL,
        "lastLoginAt" TIMESTAMP,
        "emailVerifiedAt" TIMESTAMP,
        "googleId" character varying,
        "resetPasswordToken" character varying,
        "resetPasswordExpiresAt" TIMESTAMP,
        "emailVerificationToken" character varying,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "UQ_users_email" UNIQUE ("email"),
        CONSTRAINT "PK_users_id" PRIMARY KEY ("id")
      )
    `);

    // Users 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_users_email" ON "users" ("email")`);
    await queryRunner.query(`CREATE INDEX "IDX_users_googleId" ON "users" ("googleId")`);
    await queryRunner.query(`CREATE INDEX "IDX_users_status" ON "users" ("status")`);
    await queryRunner.query(`CREATE INDEX "IDX_users_role" ON "users" ("role")`);
    await queryRunner.query(`CREATE INDEX "IDX_users_createdAt" ON "users" ("createdAt")`);
    await queryRunner.query(`CREATE INDEX "IDX_users_lastLoginAt" ON "users" ("lastLoginAt")`);

    // Projects 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "projects" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "title" character varying NOT NULL,
        "description" text,
        "status" "public"."projects_status_enum" NOT NULL DEFAULT 'planning',
        "priority" "public"."projects_priority_enum" NOT NULL DEFAULT 'medium',
        "startDate" date,
        "endDate" date,
        "progress" integer NOT NULL DEFAULT 0,
        "budget" numeric(12,2),
        "currency" character varying(3),
        "tags" text array NOT NULL DEFAULT '{}',
        "isArchived" boolean NOT NULL DEFAULT false,
        "isTemplate" boolean NOT NULL DEFAULT false,
        "templateId" character varying,
        "color" character varying(7),
        "icon" character varying,
        "visibility" "public"."projects_visibility_enum" NOT NULL DEFAULT 'private',
        "settings" jsonb NOT NULL,
        "ownerId" uuid NOT NULL,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_projects_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_projects_ownerId" FOREIGN KEY ("ownerId") REFERENCES "users"("id") ON DELETE CASCADE
      )
    `);

    // Projects 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_projects_title" ON "projects" ("title")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_status" ON "projects" ("status")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_priority" ON "projects" ("priority")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_ownerId" ON "projects" ("ownerId")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_createdAt" ON "projects" ("createdAt")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_startDate" ON "projects" ("startDate")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_endDate" ON "projects" ("endDate")`);
    await queryRunner.query(`CREATE INDEX "IDX_projects_isArchived" ON "projects" ("isArchived")`);

    // Project Members 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "project_members" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "projectId" uuid NOT NULL,
        "userId" uuid NOT NULL,
        "role" "public"."project_members_role_enum" NOT NULL DEFAULT 'member',
        "permissions" text array NOT NULL,
        "joinedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "UQ_project_members_projectId_userId" UNIQUE ("projectId", "userId"),
        CONSTRAINT "PK_project_members_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_project_members_projectId" FOREIGN KEY ("projectId") REFERENCES "projects"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_project_members_userId" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE
      )
    `);

    // Project Members 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_project_members_projectId" ON "project_members" ("projectId")`);
    await queryRunner.query(`CREATE INDEX "IDX_project_members_userId" ON "project_members" ("userId")`);
    await queryRunner.query(`CREATE INDEX "IDX_project_members_role" ON "project_members" ("role")`);

    // Task Labels 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "task_labels" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "name" character varying NOT NULL,
        "color" character varying(7) NOT NULL,
        "description" text,
        "projectId" uuid,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_task_labels_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_task_labels_projectId" FOREIGN KEY ("projectId") REFERENCES "projects"("id") ON DELETE CASCADE
      )
    `);

    // Task Labels 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_task_labels_name" ON "task_labels" ("name")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_labels_projectId" ON "task_labels" ("projectId")`);

    // Tasks 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "tasks" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "title" character varying NOT NULL,
        "description" text,
        "status" "public"."tasks_status_enum" NOT NULL DEFAULT 'todo',
        "priority" "public"."tasks_priority_enum" NOT NULL DEFAULT 'medium',
        "type" "public"."tasks_type_enum" NOT NULL DEFAULT 'task',
        "dueDate" TIMESTAMP,
        "startDate" TIMESTAMP,
        "completedAt" TIMESTAMP,
        "projectId" uuid,
        "assigneeId" uuid,
        "reporterId" uuid NOT NULL,
        "parentTaskId" uuid,
        "estimatedHours" numeric(8,2),
        "actualHours" numeric(8,2) NOT NULL DEFAULT 0,
        "progress" integer NOT NULL DEFAULT 0,
        "workflowStageId" character varying,
        "tags" text array NOT NULL DEFAULT '{}',
        "customFields" jsonb NOT NULL DEFAULT '{}',
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_tasks_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_tasks_projectId" FOREIGN KEY ("projectId") REFERENCES "projects"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_tasks_assigneeId" FOREIGN KEY ("assigneeId") REFERENCES "users"("id") ON DELETE SET NULL,
        CONSTRAINT "FK_tasks_reporterId" FOREIGN KEY ("reporterId") REFERENCES "users"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_tasks_parentTaskId" FOREIGN KEY ("parentTaskId") REFERENCES "tasks"("id") ON DELETE CASCADE
      )
    `);

    // Tasks 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_tasks_title" ON "tasks" ("title")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_status" ON "tasks" ("status")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_priority" ON "tasks" ("priority")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_type" ON "tasks" ("type")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_projectId" ON "tasks" ("projectId")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_assigneeId" ON "tasks" ("assigneeId")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_reporterId" ON "tasks" ("reporterId")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_parentTaskId" ON "tasks" ("parentTaskId")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_dueDate" ON "tasks" ("dueDate")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_createdAt" ON "tasks" ("createdAt")`);
    await queryRunner.query(`CREATE INDEX "IDX_tasks_workflowStageId" ON "tasks" ("workflowStageId")`);

    // Task Labels Mapping 테이블 생성 (다대다 관계)
    await queryRunner.query(`
      CREATE TABLE "task_labels_mapping" (
        "taskId" uuid NOT NULL,
        "labelId" uuid NOT NULL,
        CONSTRAINT "PK_task_labels_mapping" PRIMARY KEY ("taskId", "labelId"),
        CONSTRAINT "FK_task_labels_mapping_taskId" FOREIGN KEY ("taskId") REFERENCES "tasks"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_task_labels_mapping_labelId" FOREIGN KEY ("labelId") REFERENCES "task_labels"("id") ON DELETE CASCADE
      )
    `);

    // Task Watchers 테이블 생성 (다대다 관계)
    await queryRunner.query(`
      CREATE TABLE "task_watchers" (
        "taskId" uuid NOT NULL,
        "userId" uuid NOT NULL,
        CONSTRAINT "PK_task_watchers" PRIMARY KEY ("taskId", "userId"),
        CONSTRAINT "FK_task_watchers_taskId" FOREIGN KEY ("taskId") REFERENCES "tasks"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_task_watchers_userId" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE
      )
    `);

    // Task Comments 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "task_comments" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "content" text NOT NULL,
        "taskId" uuid NOT NULL,
        "authorId" uuid NOT NULL,
        "parentId" uuid,
        "isInternal" boolean NOT NULL DEFAULT false,
        "isEdited" boolean NOT NULL DEFAULT false,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_task_comments_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_task_comments_taskId" FOREIGN KEY ("taskId") REFERENCES "tasks"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_task_comments_authorId" FOREIGN KEY ("authorId") REFERENCES "users"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_task_comments_parentId" FOREIGN KEY ("parentId") REFERENCES "task_comments"("id") ON DELETE CASCADE
      )
    `);

    // Task Comments 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_task_comments_taskId" ON "task_comments" ("taskId")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_comments_authorId" ON "task_comments" ("authorId")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_comments_parentId" ON "task_comments" ("parentId")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_comments_createdAt" ON "task_comments" ("createdAt")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_comments_isInternal" ON "task_comments" ("isInternal")`);

    // Task Dependencies 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "task_dependencies" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "dependentTaskId" uuid NOT NULL,
        "dependsOnTaskId" uuid NOT NULL,
        "type" "public"."task_dependencies_type_enum" NOT NULL DEFAULT 'blocks',
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "UQ_task_dependencies_dependentTaskId_dependsOnTaskId" UNIQUE ("dependentTaskId", "dependsOnTaskId"),
        CONSTRAINT "PK_task_dependencies_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_task_dependencies_dependentTaskId" FOREIGN KEY ("dependentTaskId") REFERENCES "tasks"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_task_dependencies_dependsOnTaskId" FOREIGN KEY ("dependsOnTaskId") REFERENCES "tasks"("id") ON DELETE CASCADE
      )
    `);

    // Task Dependencies 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_task_dependencies_dependentTaskId" ON "task_dependencies" ("dependentTaskId")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_dependencies_dependsOnTaskId" ON "task_dependencies" ("dependsOnTaskId")`);
    await queryRunner.query(`CREATE INDEX "IDX_task_dependencies_type" ON "task_dependencies" ("type")`);

    // Time Entries 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "time_entries" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "description" text,
        "duration" integer NOT NULL,
        "startTime" TIMESTAMP NOT NULL,
        "endTime" TIMESTAMP,
        "taskId" uuid NOT NULL,
        "userId" uuid NOT NULL,
        "billable" boolean NOT NULL DEFAULT false,
        "approved" boolean NOT NULL DEFAULT false,
        "approvedBy" uuid,
        "approvedAt" TIMESTAMP,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_time_entries_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_time_entries_taskId" FOREIGN KEY ("taskId") REFERENCES "tasks"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_time_entries_userId" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE,
        CONSTRAINT "FK_time_entries_approvedBy" FOREIGN KEY ("approvedBy") REFERENCES "users"("id") ON DELETE SET NULL
      )
    `);

    // Time Entries 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_taskId" ON "time_entries" ("taskId")`);
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_userId" ON "time_entries" ("userId")`);
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_startTime" ON "time_entries" ("startTime")`);
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_billable" ON "time_entries" ("billable")`);
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_approved" ON "time_entries" ("approved")`);
    await queryRunner.query(`CREATE INDEX "IDX_time_entries_createdAt" ON "time_entries" ("createdAt")`);

    // Files 테이블 생성
    await queryRunner.query(`
      CREATE TABLE "files" (
        "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
        "filename" character varying NOT NULL,
        "originalName" character varying NOT NULL,
        "mimetype" character varying NOT NULL,
        "size" bigint NOT NULL,
        "path" character varying NOT NULL,
        "url" character varying NOT NULL,
        "thumbnailUrl" character varying,
        "uploaderId" uuid NOT NULL,
        "entityType" character varying,
        "entityId" character varying,
        "isPublic" boolean NOT NULL DEFAULT false,
        "isProcessed" boolean NOT NULL DEFAULT false,
        "tags" text array NOT NULL DEFAULT '{}',
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_files_id" PRIMARY KEY ("id"),
        CONSTRAINT "FK_files_uploaderId" FOREIGN KEY ("uploaderId") REFERENCES "users"("id") ON DELETE CASCADE
      )
    `);

    // Files 인덱스 생성
    await queryRunner.query(`CREATE INDEX "IDX_files_filename" ON "files" ("filename")`);
    await queryRunner.query(`CREATE INDEX "IDX_files_mimetype" ON "files" ("mimetype")`);
    await queryRunner.query(`CREATE INDEX "IDX_files_uploaderId" ON "files" ("uploaderId")`);
    await queryRunner.query(`CREATE INDEX "IDX_files_createdAt" ON "files" ("createdAt")`);
    await queryRunner.query(`CREATE INDEX "IDX_files_entityType_entityId" ON "files" ("entityType", "entityId")`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // 테이블 삭제 (외래키 종속성 순서대로)
    await queryRunner.query(`DROP TABLE IF EXISTS "files"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "time_entries"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "task_dependencies"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "task_comments"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "task_watchers"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "task_labels_mapping"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "tasks"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "task_labels"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "project_members"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "projects"`);
    await queryRunner.query(`DROP TABLE IF EXISTS "users"`);
  }
}
</file>

<file path="backend/src/modules/admin/controllers/admin.controller.ts">
import { 
  Controller, 
  Get, 
  UseGuards, 
  UseInterceptors,
  Req,
} from '@nestjs/common';
import { AdminGuard } from '../guards/admin.guard';
import { PermissionsGuard } from '../guards/permissions.guard';
import { RequirePermissions } from '../decorators/permissions.decorator';
import { AuditLog } from '../decorators/audit-log.decorator';
import { AuditLogInterceptor } from '../interceptors/audit-log.interceptor';
import { AdminService } from '../services/admin.service';

@Controller('api/admin')
@UseGuards(AdminGuard, PermissionsGuard)
@UseInterceptors(AuditLogInterceptor)
export class AdminController {
  constructor(private adminService: AdminService) {}

  @Get('dashboard')
  @RequirePermissions('admin:dashboard:read')
  @AuditLog('대시보드 조회')
  async getDashboard(@Req() req: any) {
    const stats = await this.adminService.getDashboardStats();
    
    return {
      success: true,
      data: {
        stats,
        adminInfo: {
          id: req.user.id,
          name: req.user.name,
          role: req.user.adminRole,
          permissions: req.user.adminPermissions,
          lastAdminLogin: req.user.lastAdminLogin,
        },
      },
    };
  }

  @Get('profile')
  @RequirePermissions('admin:profile:read')
  async getAdminProfile(@Req() req: any) {
    return {
      success: true,
      data: {
        id: req.user.id,
        name: req.user.name,
        email: req.user.email,
        role: req.user.adminRole,
        permissions: req.user.adminPermissions,
        lastAdminLogin: req.user.lastAdminLogin,
        twoFactorEnabled: req.user.twoFactorEnabled,
        allowedIPs: req.user.allowedIPs,
      },
    };
  }
}
</file>

<file path="backend/src/modules/admin/controllers/audit-logs.controller.ts">
import { 
  Controller, 
  Get,
  Query,
  UseGuards, 
  UseInterceptors,
} from '@nestjs/common';
import { AdminGuard } from '../guards/admin.guard';
import { PermissionsGuard } from '../guards/permissions.guard';
import { RequirePermissions } from '../decorators/permissions.decorator';
import { AuditLog } from '../decorators/audit-log.decorator';
import { AuditLogInterceptor } from '../interceptors/audit-log.interceptor';
import { AuditService } from '../services/audit.service';

@Controller('api/admin/audit-logs')
@UseGuards(AdminGuard, PermissionsGuard)
@UseInterceptors(AuditLogInterceptor)
export class AuditLogsController {
  constructor(private auditService: AuditService) {}

  @Get()
  @RequirePermissions('admin:audit:read')
  @AuditLog('감사 로그 조회')
  async getAuditLogs(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('adminId') adminId?: string,
    @Query('action') action?: string,
    @Query('targetType') targetType?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('success') success?: string,
  ) {
    const dateRange = startDate && endDate ? {
      start: new Date(startDate),
      end: new Date(endDate),
    } : undefined;

    const result = await this.auditService.getAuditLogs({
      page: page ? Number(page) : 1,
      limit: limit ? Number(limit) : 50,
      adminId,
      action,
      targetType,
      dateRange,
      success: success ? success === 'true' : undefined,
    });

    return {
      success: true,
      data: result.data,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        totalPages: Math.ceil(result.total / result.limit),
      },
    };
  }

  @Get('recent')
  @RequirePermissions('admin:audit:read')
  async getRecentAuditLogs(
    @Query('adminId') adminId?: string,
    @Query('hours') hours?: number,
  ) {
    const logs = await this.auditService.getRecentActions(
      adminId || '',
      hours ? Number(hours) : 24,
    );

    return {
      success: true,
      data: logs,
    };
  }
}
</file>

<file path="backend/src/modules/admin/controllers/projects-admin.controller.ts">
import { 
  Controller, 
  Get, 
  Delete,
  Param,
  Query,
  UseGuards, 
  UseInterceptors,
  ParseUUIDPipe,
} from '@nestjs/common';
import { AdminGuard } from '../guards/admin.guard';
import { PermissionsGuard } from '../guards/permissions.guard';
import { RequirePermissions } from '../decorators/permissions.decorator';
import { AuditLog } from '../decorators/audit-log.decorator';
import { AuditLogInterceptor } from '../interceptors/audit-log.interceptor';
import { AdminService } from '../services/admin.service';

@Controller('api/admin/projects')
@UseGuards(AdminGuard, PermissionsGuard)
@UseInterceptors(AuditLogInterceptor)
export class ProjectsAdminController {
  constructor(private adminService: AdminService) {}

  @Get()
  @RequirePermissions('admin:projects:read')
  @AuditLog('프로젝트 목록 조회')
  async getAllProjects(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('search') search?: string,
    @Query('status') status?: string,
  ) {
    const result = await this.adminService.getAllProjects({
      page: page ? Number(page) : 1,
      limit: limit ? Number(limit) : 20,
      search,
      status,
    });

    return {
      success: true,
      data: result.data,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        totalPages: result.totalPages,
      },
    };
  }

  @Get(':id')
  @RequirePermissions('admin:projects:read')
  @AuditLog('프로젝트 상세 조회')
  async getProjectById(@Param('id', ParseUUIDPipe) id: string) {
    const project = await this.adminService.getProjectById(id);

    return {
      success: true,
      data: project,
    };
  }

  @Delete(':id')
  @RequirePermissions('admin:projects:delete')
  @AuditLog('프로젝트 삭제')
  async deleteProject(@Param('id', ParseUUIDPipe) id: string) {
    await this.adminService.deleteProject(id);

    return {
      success: true,
      message: '프로젝트가 성공적으로 삭제되었습니다',
    };
  }
}
</file>

<file path="backend/src/modules/admin/controllers/settings-admin.controller.ts">
import { 
  Controller, 
  Get, 
  Put,
  Body,
  UseGuards, 
  UseInterceptors,
} from '@nestjs/common';
import { AdminGuard } from '../guards/admin.guard';
import { PermissionsGuard } from '../guards/permissions.guard';
import { RequirePermissions } from '../decorators/permissions.decorator';
import { AuditLog } from '../decorators/audit-log.decorator';
import { AuditLogInterceptor } from '../interceptors/audit-log.interceptor';
import { AdminService } from '../services/admin.service';

class UpdateSystemSettingsDto {
  maintenanceMode?: boolean;
  registrationEnabled?: boolean;
  maxUsersPerProject?: number;
  maxProjectsPerUser?: number;
  emailNotifications?: boolean;
}

@Controller('api/admin/settings')
@UseGuards(AdminGuard, PermissionsGuard)
@UseInterceptors(AuditLogInterceptor)
export class SettingsAdminController {
  constructor(private adminService: AdminService) {}

  @Get()
  @RequirePermissions('admin:settings:read')
  @AuditLog('시스템 설정 조회')
  async getSystemSettings() {
    const settings = await this.adminService.getSystemSettings();

    return {
      success: true,
      data: settings,
    };
  }

  @Put()
  @RequirePermissions('admin:settings:update')
  @AuditLog('시스템 설정 변경')
  async updateSystemSettings(@Body() updateSettingsDto: UpdateSystemSettingsDto) {
    const settings = await this.adminService.updateSystemSettings(updateSettingsDto);

    return {
      success: true,
      data: settings,
      message: '시스템 설정이 성공적으로 변경되었습니다',
    };
  }
}
</file>

<file path="backend/src/modules/admin/decorators/audit-log.decorator.ts">
import { SetMetadata } from '@nestjs/common';

export const AuditLog = (action: string) =>
  SetMetadata('auditAction', action);

export const AUDIT_ACTION_KEY = 'auditAction';
</file>

<file path="backend/src/modules/admin/decorators/permissions.decorator.ts">
import { SetMetadata } from '@nestjs/common';

export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions);

export const PERMISSIONS_KEY = 'permissions';
</file>

<file path="backend/src/modules/admin/interceptors/audit-log.interceptor.ts">
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { AuditService } from '../services/audit.service';
import { AUDIT_ACTION_KEY } from '../decorators/audit-log.decorator';

@Injectable()
export class AuditLogInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private auditService: AuditService,
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const action = this.reflector.get<string>(AUDIT_ACTION_KEY, context.getHandler());
    
    if (!action) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    if (!user || !user.isAdminUser()) {
      return next.handle();
    }

    const targetType = this.extractTargetType(context);
    const targetId = this.extractTargetId(request);
    const beforeData = this.extractBeforeData(request);

    return next.handle().pipe(
      tap((result) => {
        this.auditService.log({
          adminId: user.id,
          adminName: user.name,
          action,
          targetType,
          targetId,
          targetName: this.extractTargetName(result),
          changes: {
            before: beforeData,
            after: this.extractAfterData(result),
          },
          ipAddress: this.getClientIp(request),
          userAgent: request.get('User-Agent') || '',
          success: true,
        }).catch(error => {
          console.error('감사 로그 저장 실패:', error);
        });
      }),
      catchError((error) => {
        this.auditService.log({
          adminId: user.id,
          adminName: user.name,
          action,
          targetType,
          targetId,
          ipAddress: this.getClientIp(request),
          userAgent: request.get('User-Agent') || '',
          success: false,
          errorMessage: error.message,
        }).catch(logError => {
          console.error('감사 로그 저장 실패:', logError);
        });
        throw error;
      })
    );
  }

  private extractTargetType(context: ExecutionContext): string {
    const controllerName = context.getClass().name;
    
    if (controllerName.includes('Users')) return 'user';
    if (controllerName.includes('Projects')) return 'project';
    if (controllerName.includes('Tasks')) return 'task';
    if (controllerName.includes('Settings')) return 'settings';
    
    return 'system';
  }

  private extractTargetId(request: any): string | undefined {
    return request.params?.id;
  }

  private extractTargetName(result: any): string | undefined {
    if (result?.data?.name) return result.data.name;
    if (result?.data?.title) return result.data.title;
    if (result?.data?.email) return result.data.email;
    return undefined;
  }

  private extractBeforeData(request: any): Record<string, any> | undefined {
    // 업데이트 요청인 경우, 기존 데이터를 가져와야 하지만 
    // 여기서는 간단히 요청 바디를 반환
    return request.body;
  }

  private extractAfterData(result: any): Record<string, any> | undefined {
    return result?.data;
  }

  private getClientIp(request: any): string {
    return (
      request.headers['x-forwarded-for'] ||
      request.connection.remoteAddress ||
      request.socket.remoteAddress ||
      request.ip ||
      'unknown'
    );
  }
}
</file>

<file path="backend/src/modules/admin/services/audit.service.ts">
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { AuditLog } from '../../../database/entities/audit-log.entity';

export interface AuditLogData {
  adminId: string;
  adminName: string;
  action: string;
  targetType: string;
  targetId?: string;
  targetName?: string;
  changes?: {
    before?: Record<string, any>;
    after?: Record<string, any>;
  };
  ipAddress: string;
  userAgent: string;
  success: boolean;
  errorMessage?: string;
}

@Injectable()
export class AuditService {
  constructor(
    @InjectRepository(AuditLog)
    private auditLogRepository: Repository<AuditLog>,
  ) {}

  async log(data: AuditLogData): Promise<AuditLog> {
    const auditLog = this.auditLogRepository.create({
      ...data,
      timestamp: new Date(),
    });

    return this.auditLogRepository.save(auditLog);
  }

  async getRecentActions(adminId: string, hours: number): Promise<AuditLog[]> {
    const since = new Date();
    since.setHours(since.getHours() - hours);

    return this.auditLogRepository.find({
      where: {
        adminId,
        timestamp: since as any, // TypeORM MoreThanOrEqual 사용 시
      },
      order: {
        timestamp: 'DESC',
      },
    });
  }

  async getAuditLogs(options: {
    page?: number;
    limit?: number;
    adminId?: string;
    action?: string;
    targetType?: string;
    dateRange?: { start: Date; end: Date };
    success?: boolean;
  }): Promise<{
    data: AuditLog[];
    total: number;
    page: number;
    limit: number;
  }> {
    const { page = 1, limit = 20 } = options;
    const skip = (page - 1) * limit;

    const queryBuilder = this.auditLogRepository.createQueryBuilder('audit');

    if (options.adminId) {
      queryBuilder.andWhere('audit.adminId = :adminId', { adminId: options.adminId });
    }

    if (options.action) {
      queryBuilder.andWhere('audit.action LIKE :action', { action: `%${options.action}%` });
    }

    if (options.targetType) {
      queryBuilder.andWhere('audit.targetType = :targetType', { targetType: options.targetType });
    }

    if (options.dateRange) {
      queryBuilder.andWhere('audit.timestamp >= :start AND audit.timestamp <= :end', {
        start: options.dateRange.start,
        end: options.dateRange.end,
      });
    }

    if (options.success !== undefined) {
      queryBuilder.andWhere('audit.success = :success', { success: options.success });
    }

    queryBuilder
      .orderBy('audit.timestamp', 'DESC')
      .skip(skip)
      .take(limit);

    const [data, total] = await queryBuilder.getManyAndCount();

    return {
      data,
      total,
      page,
      limit,
    };
  }
}
</file>

<file path="backend/src/modules/admin/admin.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AdminController } from './controllers/admin.controller';
import { AdminService } from './services/admin.service';
import { AuditService } from './services/audit.service';
import { UsersAdminController } from './controllers/users-admin.controller';
import { ProjectsAdminController } from './controllers/projects-admin.controller';
import { SettingsAdminController } from './controllers/settings-admin.controller';
import { AuditLogsController } from './controllers/audit-logs.controller';
import { User } from '../../database/entities/user.entity';
import { Project } from '../../database/entities/project.entity';
import { Task } from '../../database/entities/task.entity';
import { AuditLog } from '../../database/entities/audit-log.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      User,
      Project, 
      Task,
      AuditLog,
    ]),
  ],
  controllers: [
    AdminController,
    UsersAdminController,
    ProjectsAdminController,
    SettingsAdminController,
    AuditLogsController,
  ],
  providers: [
    AdminService,
    AuditService,
  ],
  exports: [AdminService, AuditService],
})
export class AdminModule {}
</file>

<file path="backend/src/modules/auth/decorators/current-user.decorator.ts">
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '../../../database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: keyof User | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    return data ? user?.[data] : user;
  },
);
</file>

<file path="backend/src/modules/auth/decorators/public.decorator.ts">
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
</file>

<file path="backend/src/modules/auth/dto/auth.dto.ts">
import {
  IsEmail,
  IsString,
  MinLength,
  MaxLength,
  IsBoolean,
  IsOptional,
  Matches,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
  @ApiProperty({
    description: '사용자 이메일',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: '올바른 이메일 형식이 아닙니다.' })
  email: string;

  @ApiProperty({
    description: '사용자 비밀번호',
    example: 'password123',
    minLength: 8,
  })
  @IsString()
  @MinLength(8, { message: '비밀번호는 최소 8자 이상이어야 합니다.' })
  password: string;

  @ApiProperty({
    description: '로그인 유지 여부',
    example: false,
    required: false,
  })
  @IsBoolean()
  @IsOptional()
  rememberMe?: boolean;
}

export class RegisterDto {
  @ApiProperty({
    description: '사용자 이메일',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: '올바른 이메일 형식이 아닙니다.' })
  email: string;

  @ApiProperty({
    description: '사용자 비밀번호',
    example: 'password123',
    minLength: 8,
  })
  @IsString()
  @MinLength(8, { message: '비밀번호는 최소 8자 이상이어야 합니다.' })
  @Matches(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    {
      message: '비밀번호는 대소문자, 숫자, 특수문자를 포함해야 합니다.',
    }
  )
  password: string;

  @ApiProperty({
    description: '사용자 이름 (성)',
    example: '홍',
  })
  @IsString()
  @MinLength(1, { message: '성은 필수입니다.' })
  @MaxLength(50, { message: '성은 50자를 초과할 수 없습니다.' })
  firstName: string;

  @ApiProperty({
    description: '사용자 이름 (이름)',
    example: '길동',
  })
  @IsString()
  @MinLength(1, { message: '이름은 필수입니다.' })
  @MaxLength(50, { message: '이름은 50자를 초과할 수 없습니다.' })
  lastName: string;

  @ApiProperty({
    description: '서비스 이용약관 동의',
    example: true,
  })
  @IsBoolean()
  agreeToTerms: boolean;

  @ApiProperty({
    description: '개인정보 처리방침 동의',
    example: true,
  })
  @IsBoolean()
  agreeToPrivacy: boolean;
}

export class GoogleAuthDto {
  @ApiProperty({
    description: 'Google OAuth 인증 코드',
    example: 'google_auth_code_here',
  })
  @IsString()
  code: string;

  @ApiProperty({
    description: 'OAuth 리다이렉트 URI',
    example: 'http://localhost:3000/auth/google/callback',
  })
  @IsString()
  redirectUri: string;
}

export class RefreshTokenDto {
  @ApiProperty({
    description: '리프레시 토큰',
    example: 'refresh_token_here',
  })
  @IsString()
  refreshToken: string;
}

export class ChangePasswordDto {
  @ApiProperty({
    description: '현재 비밀번호',
    example: 'current_password',
  })
  @IsString()
  currentPassword: string;

  @ApiProperty({
    description: '새 비밀번호',
    example: 'new_password123',
    minLength: 8,
  })
  @IsString()
  @MinLength(8, { message: '비밀번호는 최소 8자 이상이어야 합니다.' })
  @Matches(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    {
      message: '비밀번호는 대소문자, 숫자, 특수문자를 포함해야 합니다.',
    }
  )
  newPassword: string;

  @ApiProperty({
    description: '새 비밀번호 확인',
    example: 'new_password123',
  })
  @IsString()
  confirmPassword: string;
}

export class ForgotPasswordDto {
  @ApiProperty({
    description: '사용자 이메일',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: '올바른 이메일 형식이 아닙니다.' })
  email: string;
}

export class ResetPasswordDto {
  @ApiProperty({
    description: '비밀번호 재설정 토큰',
    example: 'reset_token_here',
  })
  @IsString()
  token: string;

  @ApiProperty({
    description: '새 비밀번호',
    example: 'new_password123',
    minLength: 8,
  })
  @IsString()
  @MinLength(8, { message: '비밀번호는 최소 8자 이상이어야 합니다.' })
  @Matches(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    {
      message: '비밀번호는 대소문자, 숫자, 특수문자를 포함해야 합니다.',
    }
  )
  newPassword: string;

  @ApiProperty({
    description: '새 비밀번호 확인',
    example: 'new_password123',
  })
  @IsString()
  confirmPassword: string;
}

export class VerifyEmailDto {
  @ApiProperty({
    description: '이메일 인증 토큰',
    example: 'verification_token_here',
  })
  @IsString()
  token: string;
}

export class ResendVerificationDto {
  @ApiProperty({
    description: '사용자 이메일',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: '올바른 이메일 형식이 아닙니다.' })
  email: string;
}
</file>

<file path="backend/src/modules/auth/guards/auth.guard.ts">
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';
import { getAuthConfig } from '../../../config/auth.config';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
    private reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // Public 데코레이터가 있는 경우 인증 건너뛰기
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('Access token is required');
    }

    try {
      const authConfig = getAuthConfig(this.configService);
      const payload = await this.jwtService.verifyAsync(token, {
        secret: authConfig.jwt.secret,
      });

      // 요청에 사용자 정보 첨부
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException('Invalid or expired token');
    }

    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
</file>

<file path="backend/src/modules/auth/guards/google-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GoogleAuthGuard extends AuthGuard('google') {}
</file>

<file path="backend/src/modules/auth/guards/jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
</file>

<file path="backend/src/modules/auth/middleware/auth.middleware.ts">
import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { getAuthConfig } from '../../../config/auth.config';

@Injectable()
export class AuthMiddleware implements NestMiddleware {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async use(req: Request, res: Response, next: NextFunction) {
    try {
      const token = this.extractTokenFromHeader(req);
      
      if (token) {
        const authConfig = getAuthConfig(this.configService);
        const payload = await this.jwtService.verifyAsync(token, {
          secret: authConfig.jwt.secret,
        });
        
        // 요청에 사용자 정보 첨부
        req['user'] = payload;
      }
    } catch (error) {
      // 토큰이 유효하지 않은 경우, 사용자 정보를 첨부하지 않고 계속 진행
      // 실제 인증이 필요한 경우는 가드에서 처리
    }

    next();
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
</file>

<file path="backend/src/modules/auth/strategies/google.strategy.ts">
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, VerifyCallback } from 'passport-google-oauth20';
import { AuthService } from '../auth.service';
import { getAuthConfig } from '../../../config/auth.config';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(
    private configService: ConfigService,
    private authService: AuthService,
  ) {
    const authConfig = getAuthConfig(configService);
    
    super({
      clientID: authConfig.google.clientId,
      clientSecret: authConfig.google.clientSecret,
      callbackURL: authConfig.google.callbackUrl,
      scope: ['email', 'profile'],
    });
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: VerifyCallback,
  ): Promise<any> {
    try {
      const { id, name, emails, photos } = profile;
      
      // Google 프로필에서 사용자 정보 추출
      const googleUser = {
        googleId: id,
        email: emails[0].value,
        firstName: name.givenName,
        lastName: name.familyName,
        avatar: photos[0]?.value || null,
        emailVerified: emails[0].verified,
      };

      // 기존 사용자 찾거나 새로 생성
      const user = await this.authService.validateGoogleUser(googleUser);
      
      done(null, user);
    } catch (error) {
      done(error, false);
    }
  }
}
</file>

<file path="backend/src/modules/projects/projects.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProjectsService } from './projects.service';
import { ProjectsController } from './projects.controller';
import { Project } from '../../database/entities/project.entity';
import { ProjectMember } from '../../database/entities/project-member.entity';
import { User } from '../../database/entities/user.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      Project,
      ProjectMember,
      User,
    ])
  ],
  controllers: [ProjectsController],
  providers: [ProjectsService],
  exports: [ProjectsService],
})
export class ProjectsModule {}
</file>

<file path="backend/src/modules/tasks/tasks.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TasksService } from './tasks.service';
import { TasksController } from './tasks.controller';
import { Task } from '../../database/entities/task.entity';
import { TaskLabel } from '../../database/entities/task-label.entity';
import { TaskComment } from '../../database/entities/task-comment.entity';
import { TaskDependency } from '../../database/entities/task-dependency.entity';
import { TimeEntry } from '../../database/entities/time-entry.entity';
import { Project } from '../../database/entities/project.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      Task,
      TaskLabel,
      TaskComment,
      TaskDependency,
      TimeEntry,
      Project,
    ])
  ],
  controllers: [TasksController],
  providers: [TasksService],
  exports: [TasksService],
})
export class TasksModule {}
</file>

<file path="backend/src/modules/users/users.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User } from '../../database/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
</file>

<file path="backend/src/modules/users/users.service.ts">
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../../database/entities/user.entity';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async findAll(): Promise<User[]> {
    return this.usersRepository.find();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.usersRepository.findOne({
      where: { id },
    });

    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다.');
    }

    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.usersRepository.findOne({
      where: { email },
    });
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    const user = await this.findOne(id);

    Object.assign(user, updateUserDto);
    return this.usersRepository.save(user);
  }

  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await this.usersRepository.remove(user);
  }
}
</file>

<file path="backend/src/scripts/grant-admin-simple.ts">
import { DataSource } from 'typeorm';
import * as dotenv from 'dotenv';

// .env 파일 로드
dotenv.config({ path: '../../.env' });

async function grantAdminAccess() {
  const dataSource = new DataSource({
    type: 'postgres',
    host: process.env.DATABASE_HOST || 'localhost',
    port: parseInt(process.env.DATABASE_PORT || '5432'),
    username: process.env.DATABASE_USER || 'workly',
    password: process.env.DATABASE_PASSWORD || 'workly123',
    database: process.env.DATABASE_NAME || 'workly',
    entities: [],
    synchronize: false,
  });

  try {
    await dataSource.initialize();
    console.log('데이터베이스 연결 성공');

    // 사용자 정보 확인
    const user = await dataSource.query(
      'SELECT id, email, name, role, "adminRole", "adminPermissions", status FROM users WHERE email = $1',
      ['abveo5@gmail.com']
    );

    if (user.length === 0) {
      console.log('❌ 사용자를 찾을 수 없습니다: abveo5@gmail.com');
      return;
    }

    console.log('✅ 사용자 찾음:', user[0]);

    // 슈퍼 어드민 권한 부여
    await dataSource.query(
      'UPDATE users SET "adminRole" = $1, "adminPermissions" = $2 WHERE email = $3',
      ['super_admin', ['*'], 'abveo5@gmail.com']
    );

    // 결과 확인
    const updatedUser = await dataSource.query(
      'SELECT id, email, name, role, "adminRole", "adminPermissions", status FROM users WHERE email = $1',
      ['abveo5@gmail.com']
    );

    console.log('🎉 어드민 권한이 성공적으로 부여되었습니다!');
    console.log('업데이트된 사용자 정보:', updatedUser[0]);

  } catch (error) {
    console.error('❌ 오류 발생:', error);
  } finally {
    await dataSource.destroy();
    console.log('데이터베이스 연결 종료');
  }
}

// 스크립트 실행
grantAdminAccess();
</file>

<file path="backend/src/scripts/grant-admin.ts">
import { DataSource } from 'typeorm';
import { User } from '../database/entities/user.entity';

enum AdminRole {
  SUPER_ADMIN = 'super_admin',
  ADMIN = 'admin',
  MODERATOR = 'moderator',
  SUPPORT = 'support'
}

async function grantAdminAccess() {
  const dataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    username: process.env.DB_USERNAME || 'workly_user',
    password: process.env.DB_PASSWORD || 'workly_password',
    database: process.env.DB_NAME || 'workly_db',
    entities: [User],
    synchronize: false,
  });

  try {
    await dataSource.initialize();
    console.log('데이터베이스 연결 성공');

    const userRepository = dataSource.getRepository(User);
    
    // abveo5@gmail.com 사용자 찾기
    const user = await userRepository.findOne({
      where: { email: 'abveo5@gmail.com' }
    });

    if (!user) {
      console.log('❌ 사용자를 찾을 수 없습니다: abveo5@gmail.com');
      return;
    }

    console.log('✅ 사용자 찾음:', user.email, user.name);
    console.log('현재 adminRole:', user.adminRole);
    console.log('현재 adminPermissions:', user.adminPermissions);

    // 슈퍼 어드민 권한 부여
    user.adminRole = AdminRole.SUPER_ADMIN;
    user.adminPermissions = ['*']; // 모든 권한
    
    await userRepository.save(user);
    
    console.log('🎉 어드민 권한이 성공적으로 부여되었습니다!');
    console.log('새로운 adminRole:', user.adminRole);
    console.log('새로운 adminPermissions:', user.adminPermissions);

  } catch (error) {
    console.error('❌ 오류 발생:', error);
  } finally {
    await dataSource.destroy();
    console.log('데이터베이스 연결 종료');
  }
}

// 스크립트 실행
grantAdminAccess();
</file>

<file path="backend/src/types/admin.types.ts">
/**
 * 워클리 어드민 패널 타입 정의 (백엔드 전용)
 */

export enum AdminRole {
  SUPER_ADMIN = 'super_admin',    // 모든 권한
  ADMIN = 'admin',                // 사용자/콘텐츠 관리
  MODERATOR = 'moderator',        // 콘텐츠 모더레이션만
  SUPPORT = 'support',            // 사용자 지원 (읽기 전용 + 기본 사용자 관리)
}

export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in-progress',
  IN_REVIEW = 'in-review',
  BLOCKED = 'blocked',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}
</file>

<file path="backend/test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "collectCoverageFrom": [
    "src/**/*.(t|j)s",
    "!src/**/*.d.ts",
    "!**/node_modules/**",
    "!**/main.ts",
    "!**/*.module.ts"
  ],
  "coverageDirectory": "./coverage-e2e",
  "moduleNameMapping": {
    "^@/(.*)$": "<rootDir>/src/$1",
    "^@shared/(.*)$": "<rootDir>/../shared/$1"
  },
  "setupFilesAfterEnv": ["<rootDir>/test/setup-e2e.ts"]
}
</file>

<file path="backend/test/setup-e2e.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { testDatabaseConfig } from './setup';

let app: INestApplication;

beforeAll(async () => {
  const moduleFixture: TestingModule = await Test.createTestingModule({
    imports: [
      TypeOrmModule.forRoot(testDatabaseConfig),
      // Add your app modules here
    ],
  }).compile();

  app = moduleFixture.createNestApplication();
  await app.init();
});

afterAll(async () => {
  if (app) {
    await app.close();
  }
});

export { app };
</file>

<file path="backend/test/setup.ts">
import { Test } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';

// Test Database Configuration
export const testDatabaseConfig = {
  type: 'postgres' as const,
  host: process.env.DATABASE_HOST || 'localhost',
  port: parseInt(process.env.DATABASE_PORT || '5432'),
  username: process.env.DATABASE_USERNAME || 'test_user',
  password: process.env.DATABASE_PASSWORD || 'test_password',
  database: process.env.DATABASE_NAME || 'workly_test',
  entities: [__dirname + '/../src/**/*.entity{.ts,.js}'],
  synchronize: true,
  dropSchema: true,
  logging: false,
};

// Global test setup
beforeAll(async () => {
  // Setup test database connection
});

afterAll(async () => {
  // Cleanup after all tests
});

beforeEach(async () => {
  // Setup before each test
});

afterEach(async () => {
  // Cleanup after each test
});
</file>

<file path="backend/.eslintrc.js">
module.exports = {
  extends: [
    '../.eslintrc.js',
    '@nestjs',
    'plugin:@typescript-eslint/recommended',
    'prettier',
  ],
  env: {
    node: true,
    jest: true,
  },
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/no-empty-function': 'warn',
    '@typescript-eslint/ban-types': 'warn',
    'prefer-const': 'error',
    'no-var': 'error',
    'no-console': 'off', // Backend에서는 console 사용 허용
    'no-debugger': 'warn',
  },
  overrides: [
    {
      files: ['**/*.spec.ts', '**/*.e2e-spec.ts'],
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
      },
    },
  ],
};
</file>

<file path="backend/jest.config.js">
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/main.ts',
    '!**/*.module.ts',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/$1',
    '^@shared/(.*)$': '<rootDir>/../../shared/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/../test/setup.ts'],
  coverageThreshold: {
    global: {
      branches: 75,
      functions: 75,
      lines: 75,
      statements: 75,
    },
  },
};
</file>

<file path="docs/admin-api-design.md">
# 워클리 어드민 API 설계

## 개요

워클리 어드민 패널을 위한 RESTful API 설계 문서입니다. 기존 NestJS 백엔드 구조를 확장하여 관리자 전용 엔드포인트를 제공합니다.

## 기본 구조

### API 베이스 경로
```
/api/admin/*  - 모든 관리자 API
```

### 인증 및 권한
- **인증**: JWT 토큰 기반 (기존과 동일)
- **권한**: Role-based Access Control (RBAC)
- **미들웨어**: AdminGuard, PermissionGuard

## API 엔드포인트 설계

### 1. 대시보드 API

#### GET /api/admin/dashboard
**목적**: 대시보드 메인 데이터 조회

**권한**: `admin:read`

**응답**:
```typescript
{
  "success": true,
  "data": {
    "kpis": {
      "totalUsers": 1245,
      "activeUsers": 892,
      "newUsersThisWeek": 47,
      "totalProjects": 156,
      "activeProjects": 89,
      "completedProjects": 67,
      "totalTasks": 2341,
      "completedTasks": 1876,
      "systemHealth": "healthy",
      "lastUpdated": "2025-08-04T10:30:00Z"
    },
    "charts": {
      "userGrowth": [...],
      "taskCompletion": [...],
      "projectStatus": [...],
      "serverMetrics": {...}
    },
    "recentActivity": [...]
  }
}
```

#### GET /api/admin/dashboard/kpis
**목적**: KPI 데이터만 개별 조회 (실시간 업데이트용)

#### GET /api/admin/dashboard/activity
**목적**: 최근 활동 로그 조회

**쿼리 파라미터**:
- `limit`: 조회할 개수 (기본: 20)
- `type`: 활동 타입 필터
- `since`: 특정 시점 이후 활동

### 2. 사용자 관리 API

#### GET /api/admin/users
**목적**: 사용자 목록 조회 (페이지네이션, 필터링, 검색)

**권한**: `users:read`

**쿼리 파라미터**:
```typescript
{
  page?: number;
  limit?: number;
  search?: string;           // 이름, 이메일 검색
  role?: string[];          // 역할 필터
  status?: string[];        // 상태 필터
  registrationDate?: {      // 가입일 범위
    start: string;
    end: string;
  };
  lastActivity?: {          // 마지막 활동일 범위
    start: string;
    end: string;
  };
  sortBy?: 'name' | 'email' | 'createdAt' | 'lastLoginAt';
  sortOrder?: 'asc' | 'desc';
}
```

**응답**:
```typescript
{
  "success": true,
  "data": UserWithStats[],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 1245,
    "totalPages": 63,
    "hasNext": true,
    "hasPrev": false
  }
}
```

#### GET /api/admin/users/:id
**목적**: 특정 사용자 상세 정보 조회

**권한**: `users:read`

#### PUT /api/admin/users/:id
**목적**: 사용자 정보 수정

**권한**: `users:update`

**요청 바디**:
```typescript
{
  name?: string;
  email?: string;
  role?: UserRole;
  status?: UserStatus;
  profile?: Partial<UserProfile>;
  preferences?: Partial<UserPreferences>;
}
```

#### DELETE /api/admin/users/:id
**목적**: 사용자 계정 삭제 (soft delete)

**권한**: `users:delete`

#### POST /api/admin/users/bulk-action
**목적**: 선택된 사용자들에 대한 일괄 작업

**권한**: `users:update`

**요청 바디**:
```typescript
{
  userIds: string[];
  action: 'activate' | 'deactivate' | 'suspend' | 'delete' | 'send_email';
  params?: {
    emailTemplate?: string;
    suspensionReason?: string;
    duration?: number;
  };
}
```

#### GET /api/admin/users/stats
**목적**: 사용자 관련 통계 데이터

**응답**:
```typescript
{
  "success": true,
  "data": {
    "totalUsers": 1245,
    "activeUsers": 892,
    "usersByRole": {
      "admin": 3,
      "manager": 12,
      "member": 1230
    },
    "usersByStatus": {
      "active": 892,
      "inactive": 245,
      "suspended": 8
    },
    "growthTrend": TimeSeriesData[],
    "registrationSources": {
      "email": 67,
      "google": 33
    }
  }
}
```

### 3. 프로젝트 관리 API

#### GET /api/admin/projects
**목적**: 프로젝트 목록 조회

**권한**: `projects:read`

**쿼리 파라미터**:
```typescript
{
  page?: number;
  limit?: number;
  search?: string;
  status?: string[];
  ownerId?: string;
  createdDate?: { start: string; end: string; };
  minMembers?: number;
  maxMembers?: number;
  hasRiskFlags?: boolean;
  sortBy?: 'name' | 'createdAt' | 'progress' | 'memberCount';
  sortOrder?: 'asc' | 'desc';
}
```

#### GET /api/admin/projects/:id
**목적**: 프로젝트 상세 정보 조회

#### PUT /api/admin/projects/:id
**목적**: 프로젝트 정보 수정 (관리자 개입)

**권한**: `projects:moderate`

#### POST /api/admin/projects/:id/close
**목적**: 프로젝트 강제 종료

**권한**: `projects:moderate`

#### GET /api/admin/projects/analytics
**목적**: 프로젝트 분석 데이터

**응답**:
```typescript
{
  "success": true,
  "data": {
    "successRate": 73.5,
    "averageCompletionTime": 45.2,
    "popularSkills": [...],
    "teamSizeDistribution": [...],
    "monthlyTrends": {...}
  }
}
```

### 4. 업무 관리 API

#### GET /api/admin/tasks
**목적**: 업무 목록 조회

**권한**: `tasks:read`

#### GET /api/admin/tasks/categories
**목적**: 업무 카테고리별 통계

#### GET /api/admin/tasks/automation
**목적**: 자동화 설정 조회

#### PUT /api/admin/tasks/automation
**목적**: 자동화 설정 변경

### 5. 콘텐츠 관리 API

#### GET /api/admin/content/reports
**목적**: 콘텐츠 신고 목록 조회

**권한**: `content:read`

**쿼리 파라미터**:
```typescript
{
  page?: number;
  limit?: number;
  status?: 'pending' | 'reviewed' | 'resolved' | 'dismissed';
  contentType?: 'project' | 'task' | 'comment' | 'message';
  reason?: ReportReason;
  reportedDate?: { start: string; end: string; };
  sortBy?: 'createdAt' | 'status' | 'reason';
  sortOrder?: 'asc' | 'desc';
}
```

#### GET /api/admin/content/reports/:id
**목적**: 특정 신고 상세 조회

#### POST /api/admin/content/reports/:id/action
**목적**: 신고에 대한 조치 실행

**권한**: `content:moderate`

**요청 바디**:
```typescript
{
  action: 'dismiss' | 'warn_user' | 'remove_content' | 'suspend_user';
  reason: string;
  duration?: number;        // 정지 기간 (일)
  notifyUser: boolean;
}
```

### 6. 시스템 설정 API

#### GET /api/admin/settings
**목적**: 시스템 설정 전체 조회

**권한**: `system:read`

#### PUT /api/admin/settings
**목적**: 시스템 설정 업데이트

**권한**: `system:configure`

#### GET /api/admin/settings/email-templates
**목적**: 이메일 템플릿 목록 조회

#### POST /api/admin/settings/email-templates
**목적**: 새 이메일 템플릿 생성

#### PUT /api/admin/settings/email-templates/:id
**목적**: 이메일 템플릿 수정

#### POST /api/admin/settings/test-email
**목적**: 테스트 이메일 발송

### 7. 시스템 모니터링 API

#### GET /api/admin/monitoring/metrics
**목적**: 실시간 시스템 메트릭 조회

**권한**: `system:monitoring`

**응답**:
```typescript
{
  "success": true,
  "data": {
    "server": ServerMetrics,
    "database": DatabaseMetrics,
    "api": APIMetrics,
    "timestamp": "2025-08-04T10:30:00Z"
  }
}
```

#### GET /api/admin/monitoring/errors
**목적**: 오류 로그 조회

**쿼리 파라미터**:
```typescript
{
  page?: number;
  limit?: number;
  level?: 'error' | 'warning' | 'info';
  since?: string;
  resolved?: boolean;
  search?: string;
}
```

#### POST /api/admin/monitoring/errors/:id/resolve
**목적**: 오류 해결 표시

#### GET /api/admin/monitoring/alerts
**목적**: 활성 알림 목록 조회

#### POST /api/admin/monitoring/alerts/:id/acknowledge
**목적**: 알림 확인 처리

### 8. 감사 로그 API

#### GET /api/admin/audit-logs
**목적**: 감사 로그 조회

**권한**: `system:read`

**쿼리 파라미터**:
```typescript
{
  page?: number;
  limit?: number;
  adminId?: string;
  action?: string;
  targetType?: 'user' | 'project' | 'task' | 'system' | 'settings';
  dateRange?: { start: string; end: string; };
  success?: boolean;
}
```

#### GET /api/admin/audit-logs/export
**목적**: 감사 로그 내보내기 (CSV/Excel)

## 보안 및 권한 관리

### 인증 미들웨어
```typescript
@Controller('admin')
@UseGuards(JwtAuthGuard, AdminGuard)
export class AdminController {
  // 모든 엔드포인트에 JWT 인증 + 관리자 권한 필요
}
```

### 권한 데코레이터
```typescript
@Get('users')
@RequirePermissions('users:read')
async getUsers() {
  // users:read 권한이 있는 관리자만 접근 가능
}

@Put('users/:id')
@RequirePermissions('users:update')
async updateUser() {
  // users:update 권한이 있는 관리자만 접근 가능
}
```

### 감사 로그 데코레이터
```typescript
@Put('users/:id')
@AuditLog('user_updated')
async updateUser(@Param('id') id: string, @Body() updateData: any) {
  // 모든 변경 사항이 자동으로 감사 로그에 기록됨
}
```

## 에러 처리

### 표준 에러 응답
```typescript
{
  "success": false,
  "message": "사용자를 찾을 수 없습니다.",
  "code": "USER_NOT_FOUND",
  "errors": [
    {
      "field": "userId",
      "message": "유효하지 않은 사용자 ID입니다."
    }
  ]
}
```

### HTTP 상태 코드
- `200`: 성공
- `201`: 생성 성공
- `400`: 잘못된 요청
- `401`: 인증 실패
- `403`: 권한 없음
- `404`: 리소스 없음
- `409`: 충돌 (중복 등)
- `422`: 검증 실패
- `500`: 서버 오류

## 성능 최적화

### 캐싱 전략
- **Redis**: KPI 데이터, 통계 정보 (5분 캐시)
- **메모리**: 시스템 설정 (1분 캐시)
- **HTTP**: 정적 데이터 (24시간 캐시)

### 페이지네이션
```typescript
// 모든 목록 API에 기본 페이지네이션 적용
{
  page: 1,        // 기본값
  limit: 20,      // 기본값, 최대 100
}
```

### 데이터베이스 최적화
- 인덱스: 자주 필터링되는 컬럼에 복합 인덱스
- 조인: 필요한 경우만 관련 데이터 포함
- 집계: 복잡한 통계는 배경 작업으로 미리 계산

## API 문서화

### Swagger 설정
```typescript
@ApiTags('Admin - Users')
@ApiOperation({ summary: '사용자 목록 조회' })
@ApiQuery({ name: 'page', required: false, type: Number })
@ApiQuery({ name: 'limit', required: false, type: Number })
@ApiResponse({ status: 200, description: '성공', type: PaginatedUsersResponse })
@ApiResponse({ status: 403, description: '권한 없음' })
```

### API 버전 관리
- 현재: `/api/admin/v1/*`
- 향후 버전 추가 시: `/api/admin/v2/*`

---

*이 API 설계는 워클리 어드민 패널의 백엔드 구현을 위한 명세서입니다. 실제 구현 과정에서 성능과 보안 요구사항에 따라 조정될 수 있습니다.*
</file>

<file path="docs/admin-components-design.md">
# 워클리 어드민 UI 컴포넌트 설계

## 개요

워클리 어드민 패널을 위한 UI 컴포넌트 라이브러리 설계입니다. 기존 워클리 디자인 시스템을 계승하되, 관리 도구의 특성에 맞게 확장된 컴포넌트들을 정의합니다.

## 컴포넌트 아키텍처

### 계층 구조
```
Admin Components
├── Layouts (페이지 레이아웃)
├── Navigation (네비게이션)
├── DataDisplay (데이터 표시)
├── Forms (양식 입력)
├── Feedback (피드백)
├── Charts (데이터 시각화)
└── Common (공통 컴포넌트)
```

### 네이밍 컨벤션
- 어드민 전용 컴포넌트: `Admin` 접두사 (`AdminTable`, `AdminCard`)
- 기존 컴포넌트 확장: `Enhanced` 접두사 (`EnhancedCard`, `EnhancedModal`)
- 데이터 시각화: `Chart` 접미사 (`UserGrowthChart`, `MetricsChart`)

## 1. 레이아웃 컴포넌트

### AdminLayout
```typescript
interface AdminLayoutProps {
  children: React.ReactNode;
  title?: string;
  subtitle?: string;
  breadcrumbs?: BreadcrumbItem[];
  actions?: React.ReactNode;
  sidebar?: boolean;
}

const AdminLayout: React.FC<AdminLayoutProps> = ({
  children,
  title,
  subtitle,
  breadcrumbs,
  actions,
  sidebar = true
}) => {
  return (
    <div className="min-h-screen bg-gray-50">
      <AdminHeader />
      <div className="flex">
        {sidebar && <AdminSidebar />}
        <main className="flex-1 p-6">
          <AdminPageHeader 
            title={title}
            subtitle={subtitle}
            breadcrumbs={breadcrumbs}
            actions={actions}
          />
          <div className="mt-6">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
};
```

### AdminSidebar
```typescript
interface AdminSidebarProps {
  collapsed?: boolean;
  onToggle?: () => void;
}

const AdminSidebar: React.FC<AdminSidebarProps> = ({
  collapsed = false,
  onToggle
}) => {
  const menuItems = [
    { icon: ChartBarIcon, label: '대시보드', href: '/admin' },
    { icon: UsersIcon, label: '사용자 관리', href: '/admin/users' },
    { icon: FolderIcon, label: '프로젝트 관리', href: '/admin/projects' },
    { icon: CheckSquareIcon, label: '업무 관리', href: '/admin/tasks' },
    { icon: ShieldCheckIcon, label: '콘텐츠 관리', href: '/admin/content' },
    { icon: CogIcon, label: '시스템 설정', href: '/admin/settings' },
    { icon: ServerIcon, label: '모니터링', href: '/admin/monitoring' },
  ];

  return (
    <aside className={cn(
      "bg-white border-r border-gray-200 transition-all duration-300",
      collapsed ? "w-16" : "w-64"
    )}>
      {/* 사이드바 내용 */}
    </aside>
  );
};
```

## 2. 데이터 표시 컴포넌트

### AdminTable
```typescript
interface AdminTableColumn<T> {
  key: keyof T;
  title: string;
  width?: string;
  sortable?: boolean;
  filterable?: boolean;
  render?: (value: any, record: T) => React.ReactNode;
}

interface AdminTableProps<T> {
  data: T[];
  columns: AdminTableColumn<T>[];
  loading?: boolean;
  pagination?: PaginationProps;
  selection?: {
    selectedRows: string[];
    onSelect: (keys: string[]) => void;
    bulkActions?: BulkAction[];
  };
  filters?: FilterConfig[];
  sorting?: SortConfig;
  onSort?: (field: string, direction: 'asc' | 'desc') => void;
}

const AdminTable = <T extends { id: string }>({
  data,
  columns,
  loading,
  pagination,
  selection,
  filters,
  sorting,
  onSort
}: AdminTableProps<T>) => {
  return (
    <div className="bg-white rounded-lg border border-gray-200">
      {/* 테이블 헤더 (필터, 검색, 액션) */}
      <div className="p-4 border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-4">
            {filters && <AdminTableFilters filters={filters} />}
            <AdminTableSearch onSearch={onSearch} />
          </div>
          {selection?.bulkActions && (
            <AdminBulkActions 
              selectedCount={selection.selectedRows.length}
              actions={selection.bulkActions}
            />
          )}
        </div>
      </div>
      
      {/* 테이블 본체 */}
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gray-50">
            <tr>
              {selection && (
                <th className="px-4 py-3 text-left">
                  <Checkbox 
                    checked={selection.selectedRows.length === data.length}
                    onChange={handleSelectAll}
                  />
                </th>
              )}
              {columns.map((column) => (
                <th key={column.key as string} className="px-4 py-3 text-left">
                  <div className="flex items-center space-x-2">
                    <span className="text-sm font-medium text-gray-900">
                      {column.title}
                    </span>
                    {column.sortable && (
                      <SortButton 
                        field={column.key as string}
                        current={sorting}
                        onSort={onSort}
                      />
                    )}
                  </div>
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {data.map((record) => (
              <AdminTableRow 
                key={record.id}
                record={record}
                columns={columns}
                selected={selection?.selectedRows.includes(record.id)}
                onSelect={() => handleRowSelect(record.id)}
              />
            ))}
          </tbody>
        </table>
      </div>
      
      {/* 페이지네이션 */}
      {pagination && (
        <div className="px-4 py-3 border-t border-gray-200">
          <AdminPagination {...pagination} />
        </div>
      )}
    </div>
  );
};
```

### KPICard
```typescript
interface KPICardProps {
  title: string;
  value: number | string;
  subtitle?: string;
  trend?: {
    value: number;
    direction: 'up' | 'down' | 'neutral';
    period: string;
  };
  icon?: React.ComponentType<any>;
  color?: 'blue' | 'green' | 'yellow' | 'red' | 'purple';
  loading?: boolean;
}

const KPICard: React.FC<KPICardProps> = ({
  title,
  value,
  subtitle,
  trend,
  icon: Icon,
  color = 'blue',
  loading
}) => {
  const colorClasses = {
    blue: 'text-blue-600 bg-blue-100',
    green: 'text-green-600 bg-green-100',
    yellow: 'text-yellow-600 bg-yellow-100',
    red: 'text-red-600 bg-red-100',
    purple: 'text-purple-600 bg-purple-100',
  };

  if (loading) {
    return <KPICardSkeleton />;
  }

  return (
    <div className="bg-white rounded-lg border border-gray-200 p-6">
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <p className="text-sm font-medium text-gray-600">{title}</p>
          <p className="text-3xl font-bold text-gray-900 mt-2">{value}</p>
          {subtitle && (
            <p className="text-sm text-gray-500 mt-1">{subtitle}</p>
          )}
        </div>
        {Icon && (
          <div className={cn("p-3 rounded-lg", colorClasses[color])}>
            <Icon className="w-6 h-6" />
          </div>
        )}
      </div>
      
      {trend && (
        <div className="mt-4 flex items-center">
          <div className={cn(
            "flex items-center text-sm font-medium",
            trend.direction === 'up' ? 'text-green-600' : 
            trend.direction === 'down' ? 'text-red-600' : 'text-gray-600'
          )}>
            {trend.direction === 'up' && <ArrowUpIcon className="w-4 h-4 mr-1" />}
            {trend.direction === 'down' && <ArrowDownIcon className="w-4 h-4 mr-1" />}
            {Math.abs(trend.value)}%
          </div>
          <span className="text-sm text-gray-500 ml-2">
            vs {trend.period}
          </span>
        </div>
      )}
    </div>
  );
};
```

### StatusBadge
```typescript
interface StatusBadgeProps {
  status: string;
  variant?: 'default' | 'outline';
  size?: 'sm' | 'md' | 'lg';
}

const StatusBadge: React.FC<StatusBadgeProps> = ({
  status,
  variant = 'default',
  size = 'md'
}) => {
  const getStatusConfig = (status: string) => {
    const configs = {
      active: { color: 'green', label: '활성' },
      inactive: { color: 'gray', label: '비활성' },
      pending: { color: 'yellow', label: '보류' },
      suspended: { color: 'red', label: '정지' },
      completed: { color: 'green', label: '완료' },
      in_progress: { color: 'blue', label: '진행중' },
      cancelled: { color: 'red', label: '취소' },
    };
    return configs[status] || { color: 'gray', label: status };
  };

  const config = getStatusConfig(status);
  
  return (
    <span className={cn(
      "inline-flex items-center font-medium rounded-full",
      {
        'px-2 py-1 text-xs': size === 'sm',
        'px-3 py-1 text-sm': size === 'md',
        'px-4 py-2 text-base': size === 'lg',
      },
      variant === 'default' ? [
        `bg-${config.color}-100 text-${config.color}-800`
      ] : [
        `border border-${config.color}-200 text-${config.color}-600`
      ]
    )}>
      {config.label}
    </span>
  );
};
```

## 3. 차트 컴포넌트

### BaseChart
```typescript
interface BaseChartProps {
  title?: string;
  subtitle?: string;
  data: any[];
  loading?: boolean;
  error?: string;
  height?: number;
  className?: string;
}

const BaseChart: React.FC<BaseChartProps & { children: React.ReactNode }> = ({
  title,
  subtitle,
  loading,
  error,
  height = 300,
  className,
  children
}) => {
  return (
    <div className={cn("bg-white rounded-lg border border-gray-200 p-6", className)}>
      {(title || subtitle) && (
        <div className="mb-4">
          {title && <h3 className="text-lg font-semibold text-gray-900">{title}</h3>}
          {subtitle && <p className="text-sm text-gray-600 mt-1">{subtitle}</p>}
        </div>
      )}
      
      <div style={{ height }}>
        {loading ? (
          <ChartSkeleton height={height} />
        ) : error ? (
          <ChartError message={error} />
        ) : (
          children
        )}
      </div>
    </div>
  );
};
```

### UserGrowthChart
```typescript
interface UserGrowthChartProps {
  data: TimeSeriesData[];
  period: 'daily' | 'weekly' | 'monthly';
  title?: string;
}

const UserGrowthChart: React.FC<UserGrowthChartProps> = ({
  data,
  period,
  title = "사용자 증가 추이"
}) => {
  return (
    <BaseChart title={title} data={data}>
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
          <XAxis 
            dataKey="date" 
            stroke="#6b7280"
            fontSize={12}
            tickFormatter={(value) => formatDate(value, period)}
          />
          <YAxis stroke="#6b7280" fontSize={12} />
          <Tooltip
            content={<CustomTooltip />}
            cursor={{ stroke: '#2563eb', strokeWidth: 1 }}
          />
          <Line
            type="monotone"
            dataKey="value"
            stroke="#2563eb"
            strokeWidth={2}
            dot={{ fill: '#2563eb', strokeWidth: 2, r: 4 }}
            activeDot={{ r: 6, fill: '#1d4ed8' }}
          />
        </LineChart>
      </ResponsiveContainer>
    </BaseChart>
  );
};
```

### MetricsChart
```typescript
interface MetricsChartProps {
  data: MetricsData;
  title?: string;
}

const MetricsChart: React.FC<MetricsChartProps> = ({
  data,
  title = "시스템 리소스"
}) => {
  const chartData = [
    { name: 'CPU', value: data.cpu, color: '#2563eb' },
    { name: 'Memory', value: data.memory, color: '#7c3aed' },
    { name: 'Disk', value: data.disk, color: '#059669' },
  ];

  return (
    <BaseChart title={title} data={chartData}>
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={chartData}>
          <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
          <XAxis dataKey="name" stroke="#6b7280" fontSize={12} />
          <YAxis stroke="#6b7280" fontSize={12} domain={[0, 100]} />
          <Tooltip 
            content={<CustomTooltip formatter={(value) => `${value}%`} />}
          />
          <Bar dataKey="value" fill="#2563eb" radius={[4, 4, 0, 0]} />
        </BarChart>
      </ResponsiveContainer>
    </BaseChart>
  );
};
```

## 4. 폼 컴포넌트

### AdminForm
```typescript
interface AdminFormProps {
  title?: string;
  onSubmit: (data: any) => void;
  loading?: boolean;
  children: React.ReactNode;
  actions?: React.ReactNode;
}

const AdminForm: React.FC<AdminFormProps> = ({
  title,
  onSubmit,
  loading,
  children,
  actions
}) => {
  return (
    <div className="bg-white rounded-lg border border-gray-200">
      {title && (
        <div className="px-6 py-4 border-b border-gray-200">
          <h3 className="text-lg font-semibold text-gray-900">{title}</h3>
        </div>
      )}
      
      <form onSubmit={onSubmit} className="p-6 space-y-6">
        {children}
        
        <div className="flex justify-end space-x-3 pt-6 border-t border-gray-200">
          {actions || (
            <>
              <Button variant="outline" type="button">
                취소
              </Button>
              <Button type="submit" loading={loading}>
                저장
              </Button>
            </>
          )}
        </div>
      </form>
    </div>
  );
};
```

### BulkActionBar
```typescript
interface BulkActionBarProps {
  selectedCount: number;
  actions: Array<{
    key: string;
    label: string;
    icon?: React.ComponentType<any>;
    variant?: 'default' | 'danger';
    onClick: () => void;
  }>;
  onClearSelection: () => void;
}

const BulkActionBar: React.FC<BulkActionBarProps> = ({
  selectedCount,
  actions,
  onClearSelection
}) => {
  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <CheckCircleIcon className="w-5 h-5 text-blue-600 mr-2" />
          <span className="text-sm text-blue-800">
            {selectedCount}개 항목이 선택됨
          </span>
          <button
            onClick={onClearSelection}
            className="ml-2 text-sm text-blue-600 hover:text-blue-700"
          >
            선택 해제
          </button>
        </div>
        
        <div className="flex items-center space-x-2">
          {actions.map((action) => (
            <Button
              key={action.key}
              variant={action.variant || 'default'}
              size="sm"
              onClick={action.onClick}
              icon={action.icon}
            >
              {action.label}
            </Button>
          ))}
        </div>
      </div>
    </div>
  );
};
```

## 5. 피드백 컴포넌트

### AdminAlert
```typescript
interface AdminAlertProps {
  type: 'info' | 'success' | 'warning' | 'error';
  title?: string;
  message: string;
  actions?: React.ReactNode;
  onClose?: () => void;
  className?: string;
}

const AdminAlert: React.FC<AdminAlertProps> = ({
  type,
  title,
  message,
  actions,
  onClose,
  className
}) => {
  const configs = {
    info: { 
      icon: InformationCircleIcon, 
      bgColor: 'bg-blue-50', 
      textColor: 'text-blue-800',
      iconColor: 'text-blue-400'
    },
    success: { 
      icon: CheckCircleIcon, 
      bgColor: 'bg-green-50', 
      textColor: 'text-green-800',
      iconColor: 'text-green-400'
    },
    warning: { 
      icon: ExclamationTriangleIcon, 
      bgColor: 'bg-yellow-50', 
      textColor: 'text-yellow-800',
      iconColor: 'text-yellow-400'
    },
    error: { 
      icon: XCircleIcon, 
      bgColor: 'bg-red-50', 
      textColor: 'text-red-800',
      iconColor: 'text-red-400'
    },
  };

  const config = configs[type];
  const Icon = config.icon;

  return (
    <div className={cn(
      "rounded-lg p-4",
      config.bgColor,
      className
    )}>
      <div className="flex">
        <Icon className={cn("w-5 h-5 mt-0.5 mr-3", config.iconColor)} />
        <div className="flex-1">
          {title && (
            <h3 className={cn("text-sm font-medium", config.textColor)}>
              {title}
            </h3>
          )}
          <p className={cn("text-sm", config.textColor, title ? "mt-1" : "")}>
            {message}
          </p>
          {actions && (
            <div className="mt-3">
              {actions}
            </div>
          )}
        </div>
        {onClose && (
          <button
            onClick={onClose}
            className={cn("ml-3", config.iconColor, "hover:opacity-75")}
          >
            <XMarkIcon className="w-5 h-5" />
          </button>
        )}
      </div>
    </div>
  );
};
```

### LoadingSpinner
```typescript
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  text?: string;
  className?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  text,
  className
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-6 h-6',
    lg: 'w-8 h-8'
  };

  return (
    <div className={cn("flex items-center justify-center", className)}>
      <div className="flex flex-col items-center">
        <div className={cn(
          "animate-spin rounded-full border-2 border-gray-300 border-t-blue-600",
          sizeClasses[size]
        )} />
        {text && (
          <p className="text-sm text-gray-600 mt-2">{text}</p>
        )}
      </div>
    </div>
  );
};
```

## 6. 네비게이션 컴포넌트

### Breadcrumbs
```typescript
interface BreadcrumbItem {
  label: string;
  href?: string;
  icon?: React.ComponentType<any>;
}

interface BreadcrumbsProps {
  items: BreadcrumbItem[];
}

const Breadcrumbs: React.FC<BreadcrumbsProps> = ({ items }) => {
  return (
    <nav className="flex" aria-label="Breadcrumb">
      <ol className="flex items-center space-x-2">
        {items.map((item, index) => (
          <li key={index} className="flex items-center">
            {index > 0 && (
              <ChevronRightIcon className="w-4 h-4 text-gray-400 mx-2" />
            )}
            {item.href ? (
              <Link
                href={item.href}
                className="flex items-center text-sm text-blue-600 hover:text-blue-700"
              >
                {item.icon && <item.icon className="w-4 h-4 mr-1" />}
                {item.label}
              </Link>
            ) : (
              <span className="flex items-center text-sm text-gray-600">
                {item.icon && <item.icon className="w-4 h-4 mr-1" />}
                {item.label}
              </span>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
};
```

## 스타일링 가이드

### CSS 클래스 패턴
```css
/* 어드민 전용 색상 확장 */
.admin-primary { @apply bg-admin-primary text-white; }
.admin-danger { @apply bg-red-600 text-white; }
.admin-warning { @apply bg-yellow-500 text-white; }
.admin-success { @apply bg-green-600 text-white; }

/* 정보 밀도 높은 테이블 */
.admin-table-dense td { @apply py-2 px-3; }
.admin-table-dense th { @apply py-3 px-3; }

/* 대시보드 그리드 */
.admin-grid { @apply grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4; }
.admin-grid-2 { @apply grid gap-6 grid-cols-1 lg:grid-cols-2; }

/* 상태 표시 */
.status-active { @apply bg-green-100 text-green-800; }
.status-inactive { @apply bg-gray-100 text-gray-800; }
.status-warning { @apply bg-yellow-100 text-yellow-800; }
.status-error { @apply bg-red-100 text-red-800; }
```

### 반응형 디자인
```typescript
const responsiveClasses = {
  mobile: 'block md:hidden',
  desktop: 'hidden md:block',
  sidebar: 'w-full md:w-64 lg:w-72',
  content: 'w-full md:pl-64 lg:pl-72',
  grid: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'
};
```

---

*이 컴포넌트 설계는 워클리 어드민 패널의 UI 일관성과 사용성을 보장하기 위한 가이드라인입니다. 실제 구현 시 접근성(a11y)과 성능을 고려하여 최적화됩니다.*
</file>

<file path="docs/admin-implementation-guide.md">
# 워클리 어드민 패널 구현 가이드

## 개요

워클리 어드민 패널의 전체 구현 프로세스를 단계별로 안내하는 가이드입니다. 이 문서는 개발자가 실제로 어드민 패널을 구현할 때 필요한 모든 정보를 제공합니다.

## 📋 구현 준비사항

### 필수 도구 및 라이브러리
```json
{
  "frontend": {
    "framework": "Next.js 14+",
    "language": "TypeScript",
    "styling": "Tailwind CSS",
    "charts": "recharts",
    "forms": "react-hook-form",
    "state": "zustand",
    "http": "axios"
  },
  "backend": {
    "framework": "NestJS",
    "database": "PostgreSQL + TypeORM",
    "auth": "JWT + Passport",
    "cache": "Redis",
    "validation": "class-validator"
  },
  "devops": {
    "docker": "Docker & Docker Compose",
    "monitoring": "Prometheus + Grafana (선택사항)"
  }
}
```

### 프로젝트 구조
```
workly/
├── frontend/
│   ├── src/
│   │   ├── app/
│   │   │   ├── admin/           # 어드민 패널 페이지
│   │   │   │   ├── page.tsx     # 대시보드
│   │   │   │   ├── users/       # 사용자 관리
│   │   │   │   ├── projects/    # 프로젝트 관리
│   │   │   │   ├── content/     # 콘텐츠 관리
│   │   │   │   └── settings/    # 시스템 설정
│   │   │   └── (auth)/          # 기존 사용자 앱
│   │   ├── components/
│   │   │   ├── admin/           # 어드민 전용 컴포넌트
│   │   │   └── ui/              # 공통 UI 컴포넌트
│   │   └── lib/
│   │       ├── admin-api.ts     # 어드민 API 클라이언트
│   │       └── permissions.ts   # 권한 관리
├── backend/
│   ├── src/
│   │   ├── modules/
│   │   │   ├── admin/           # 어드민 모듈
│   │   │   │   ├── controllers/
│   │   │   │   ├── services/
│   │   │   │   └── guards/
│   │   │   └── auth/            # 기존 인증 모듈 확장
│   │   └── database/
│   │       └── entities/        # 관리자 관련 엔티티
└── shared/
    └── types/
        └── admin.types.ts       # 어드민 타입 정의
```

## 🚀 Phase 1: 기본 인프라 구축 (1주)

### 1.1 백엔드 권한 시스템 구현

#### User 엔티티 확장
```typescript
// backend/src/database/entities/user.entity.ts
export class User {
  // 기존 필드들...
  
  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.MEMBER,
  })
  role: UserRole;

  @Column('simple-array', { nullable: true })
  adminPermissions?: string[];

  @Column({ nullable: true })
  lastAdminLogin?: Date;

  @Column({ default: false })
  twoFactorEnabled: boolean;

  @Column('simple-array', { nullable: true })
  allowedIPs?: string[];

  // 권한 확인 메서드들 추가
  isAdmin(): boolean {
    return ['SUPER_ADMIN', 'ADMIN', 'MODERATOR', 'SUPPORT'].includes(this.role);
  }

  hasAdminPermission(permission: string): boolean {
    if (this.role === 'SUPER_ADMIN') return true;
    return this.adminPermissions?.includes(permission) || false;
  }
}
```

#### 관리자 가드 구현
```typescript
// backend/src/modules/admin/guards/admin.guard.ts
@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    if (!user?.isAdmin()) {
      throw new ForbiddenException('관리자 권한이 필요합니다');
    }
    
    return true;
  }
}

// backend/src/modules/admin/guards/permissions.guard.ts
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.get<string[]>(
      'permissions',
      context.getHandler()
    );

    if (!requiredPermissions) return true;

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return requiredPermissions.every(permission =>
      user.hasAdminPermission(permission)
    );
  }
}
```

### 1.2 프론트엔드 라우팅 및 레이아웃

#### 어드민 레이아웃 컴포넌트
```typescript
// frontend/src/components/admin/AdminLayout.tsx
'use client';

import { useAuth } from '@/hooks/useAuth';
import { usePermissions } from '@/hooks/usePermissions';
import { redirect } from 'next/navigation';

interface AdminLayoutProps {
  children: React.ReactNode;
}

export default function AdminLayout({ children }: AdminLayoutProps) {
  const { user, loading } = useAuth();
  
  if (loading) return <AdminLoadingSpinner />;
  
  if (!user?.isAdmin()) {
    redirect('/auth/login');
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <AdminHeader />
      <div className="flex">
        <AdminSidebar />
        <main className="flex-1 p-6">
          {children}
        </main>
      </div>
    </div>
  );
}
```

#### 어드민 루트 페이지
```typescript
// frontend/src/app/admin/page.tsx
import { Metadata } from 'next';
import AdminDashboard from '@/components/admin/AdminDashboard';
import { ProtectedRoute } from '@/components/admin/ProtectedRoute';

export const metadata: Metadata = {
  title: '관리자 대시보드 - Workly',
  description: 'Workly 관리자 패널',
};

export default function AdminPage() {
  return (
    <ProtectedRoute permissions={[]}>
      <AdminDashboard />
    </ProtectedRoute>
  );
}
```

### 1.3 API 클라이언트 구현

```typescript
// frontend/src/lib/admin-api.ts
import axios from 'axios';
import { getAuthToken } from '@/lib/auth';

const adminApi = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL + '/admin',
  timeout: 10000,
});

// 인터셉터 설정
adminApi.interceptors.request.use((config) => {
  const token = getAuthToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

adminApi.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 토큰 만료 또는 권한 없음
      window.location.href = '/auth/login';
    }
    return Promise.reject(error);
  }
);

// API 메서드들
export const adminApiService = {
  // 대시보드
  getDashboard: () => adminApi.get('/dashboard'),
  
  // 사용자 관리
  getUsers: (params: any) => adminApi.get('/users', { params }),
  getUser: (id: string) => adminApi.get(`/users/${id}`),
  updateUser: (id: string, data: any) => adminApi.put(`/users/${id}`, data),
  deleteUser: (id: string) => adminApi.delete(`/users/${id}`),
  bulkUserAction: (data: any) => adminApi.post('/users/bulk-action', data),
  
  // 프로젝트 관리
  getProjects: (params: any) => adminApi.get('/projects', { params }),
  getProject: (id: string) => adminApi.get(`/projects/${id}`),
  
  // 시스템 설정
  getSettings: () => adminApi.get('/settings'),
  updateSettings: (data: any) => adminApi.put('/settings', data),
};
```

## 🔧 Phase 2: 핵심 관리 기능 (3주)

### 2.1 사용자 관리 구현

#### 백엔드 컨트롤러
```typescript
// backend/src/modules/admin/controllers/users.controller.ts
@Controller('admin/users')
@UseGuards(JwtAuthGuard, AdminGuard, PermissionsGuard)
export class AdminUsersController {
  constructor(private usersService: AdminUsersService) {}

  @Get()
  @RequirePermissions('users:read')
  async getUsers(@Query() query: GetUsersQueryDto) {
    return this.usersService.getUsers(query);
  }

  @Get(':id')
  @RequirePermissions('users:read')
  async getUser(@Param('id') id: string) {
    return this.usersService.getUserById(id);
  }

  @Put(':id')
  @RequirePermissions('users:update')
  @AuditLog('user_updated')
  async updateUser(
    @Param('id') id: string,
    @Body() updateData: UpdateUserDto
  ) {
    return this.usersService.updateUser(id, updateData);
  }

  @Delete(':id')
  @RequirePermissions('users:delete')
  @AuditLog('user_deleted')
  async deleteUser(@Param('id') id: string) {
    return this.usersService.softDeleteUser(id);
  }

  @Post('bulk-action')
  @RequirePermissions('users:update')
  @AuditLog('users_bulk_action')
  async bulkAction(@Body() actionData: BulkUserActionDto) {
    return this.usersService.performBulkAction(actionData);
  }
}
```

#### 프론트엔드 사용자 목록 페이지
```typescript
// frontend/src/app/admin/users/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { AdminTable } from '@/components/admin/AdminTable';
import { UserFilters } from '@/components/admin/UserFilters';
import { BulkActionBar } from '@/components/admin/BulkActionBar';
import { adminApiService } from '@/lib/admin-api';

export default function AdminUsersPage() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20,
    total: 0
  });
  const [selectedUsers, setSelectedUsers] = useState<string[]>([]);
  const [filters, setFilters] = useState({});

  useEffect(() => {
    loadUsers();
  }, [pagination.page, pagination.limit, filters]);

  const loadUsers = async () => {
    try {
      setLoading(true);
      const response = await adminApiService.getUsers({
        page: pagination.page,
        limit: pagination.limit,
        ...filters
      });
      
      setUsers(response.data.data);
      setPagination(prev => ({
        ...prev,
        total: response.data.pagination.total
      }));
    } catch (error) {
      console.error('사용자 목록 로드 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleBulkAction = async (action: string) => {
    try {
      await adminApiService.bulkUserAction({
        userIds: selectedUsers,
        action
      });
      
      setSelectedUsers([]);
      loadUsers();
    } catch (error) {
      console.error('일괄 작업 실패:', error);
    }
  };

  const columns = [
    {
      key: 'name',
      title: '이름',
      sortable: true,
      render: (value: string, record: any) => (
        <div className="flex items-center">
          <img
            src={record.avatar || '/default-avatar.png'}
            alt={value}
            className="w-8 h-8 rounded-full mr-3"
          />
          <div>
            <div className="font-medium">{value}</div>
            <div className="text-sm text-gray-500">{record.email}</div>
          </div>
        </div>
      )
    },
    {
      key: 'role',
      title: '역할',
      render: (value: string) => (
        <StatusBadge status={value} />
      )
    },
    {
      key: 'status',
      title: '상태',
      render: (value: string) => (
        <StatusBadge status={value} />
      )
    },
    {
      key: 'lastLoginAt',
      title: '마지막 로그인',
      render: (value: string) => (
        value ? new Date(value).toLocaleDateString() : '없음'
      )
    },
    {
      key: 'actions',
      title: '작업',
      render: (value: any, record: any) => (
        <UserActions user={record} onUpdate={loadUsers} />
      )
    }
  ];

  const bulkActions = [
    {
      key: 'activate',
      label: '활성화',
      icon: CheckIcon,
      onClick: () => handleBulkAction('activate')
    },
    {
      key: 'deactivate',
      label: '비활성화',
      icon: XMarkIcon,
      onClick: () => handleBulkAction('deactivate')
    },
    {
      key: 'send_email',
      label: '이메일 발송',
      icon: EnvelopeIcon,
      onClick: () => handleBulkAction('send_email')
    }
  ];

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-900">사용자 관리</h1>
        <PermissionGate permissions="users:create">
          <Button onClick={() => setShowCreateModal(true)}>
            사용자 생성
          </Button>
        </PermissionGate>
      </div>

      <UserFilters 
        filters={filters}
        onChange={setFilters}
        onReset={() => setFilters({})}
      />

      {selectedUsers.length > 0 && (
        <BulkActionBar
          selectedCount={selectedUsers.length}
          actions={bulkActions}
          onClearSelection={() => setSelectedUsers([])}
        />
      )}

      <AdminTable
        data={users}
        columns={columns}
        loading={loading}
        pagination={{
          ...pagination,
          onChange: (page, limit) => setPagination(prev => ({ ...prev, page, limit }))
        }}
        selection={{
          selectedRows: selectedUsers,
          onSelect: setSelectedUsers,
          bulkActions
        }}
      />
    </div>
  );
}
```

### 2.2 대시보드 구현

#### 대시보드 컴포넌트
```typescript
// frontend/src/components/admin/AdminDashboard.tsx
'use client';

import { useState, useEffect } from 'react';
import { KPICard } from '@/components/admin/KPICard';
import { UserGrowthChart } from '@/components/admin/charts/UserGrowthChart';
import { MetricsChart } from '@/components/admin/charts/MetricsChart';
import { RecentActivity } from '@/components/admin/RecentActivity';
import { adminApiService } from '@/lib/admin-api';

export default function AdminDashboard() {
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadDashboardData();
    
    // 5분마다 KPI 데이터 자동 새로고침
    const interval = setInterval(loadKPIs, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, []);

  const loadDashboardData = async () => {
    try {
      const response = await adminApiService.getDashboard();
      setDashboardData(response.data);
    } catch (error) {
      console.error('대시보드 데이터 로드 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadKPIs = async () => {
    try {
      const response = await adminApiService.getDashboardKPIs();
      setDashboardData(prev => ({ ...prev, kpis: response.data }));
    } catch (error) {
      console.error('KPI 데이터 로드 실패:', error);
    }
  };

  if (loading) {
    return <DashboardSkeleton />;
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-900">대시보드</h1>
        <div className="text-sm text-gray-500">
          마지막 업데이트: {new Date(dashboardData.kpis.lastUpdated).toLocaleTimeString()}
        </div>
      </div>

      {/* KPI 카드들 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <KPICard
          title="총 사용자"
          value={dashboardData.kpis.totalUsers.toLocaleString()}
          trend={{
            value: 12,
            direction: 'up',
            period: '지난 주'
          }}
          icon={UsersIcon}
          color="blue"
        />
        <KPICard
          title="활성 사용자"
          value={dashboardData.kpis.activeUsers.toLocaleString()}
          trend={{
            value: 8,
            direction: 'up',
            period: '지난 주'
          }}
          icon={UserCheckIcon}
          color="green"
        />
        <KPICard
          title="진행 중인 프로젝트"
          value={dashboardData.kpis.activeProjects.toLocaleString()}
          trend={{
            value: 3,
            direction: 'down',
            period: '지난 주'
          }}
          icon={FolderIcon}
          color="purple"
        />
        <KPICard
          title="시스템 상태"
          value={dashboardData.kpis.systemHealth === 'healthy' ? '정상' : '경고'}
          icon={ServerIcon}
          color={dashboardData.kpis.systemHealth === 'healthy' ? 'green' : 'yellow'}
        />
      </div>

      {/* 차트 섹션 */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <UserGrowthChart
          data={dashboardData.charts.userGrowth}
          period="daily"
        />
        <MetricsChart
          data={dashboardData.charts.serverMetrics}
        />
      </div>

      {/* 최근 활동 */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2">
          <div className="bg-white rounded-lg border border-gray-200">
            <div className="p-6 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-900">프로젝트 현황</h3>
            </div>
            <div className="p-6">
              <ProjectStatusChart data={dashboardData.charts.projectStatus} />
            </div>
          </div>
        </div>
        
        <RecentActivity activities={dashboardData.recentActivity} />
      </div>
    </div>
  );
}
```

## 🎨 Phase 3: 고급 기능 (2주)

### 3.1 실시간 모니터링

#### WebSocket 연결
```typescript
// frontend/src/hooks/useRealTimeMonitoring.ts
import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

export const useRealTimeMonitoring = () => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [metrics, setMetrics] = useState(null);
  const [alerts, setAlerts] = useState([]);

  useEffect(() => {
    const newSocket = io(process.env.NEXT_PUBLIC_WEBSOCKET_URL + '/admin', {
      auth: {
        token: getAuthToken()
      }
    });

    newSocket.on('metrics-update', (data) => {
      setMetrics(data);
    });

    newSocket.on('new-alert', (alert) => {
      setAlerts(prev => [alert, ...prev]);
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, []);

  return { metrics, alerts };
};
```

### 3.2 데이터 시각화 고도화

#### 고급 차트 컴포넌트
```typescript
// frontend/src/components/admin/charts/AdvancedMetricsChart.tsx
interface AdvancedMetricsChartProps {
  data: any[];
  metrics: string[];
  timeRange: 'hour' | 'day' | 'week' | 'month';
}

export const AdvancedMetricsChart: React.FC<AdvancedMetricsChartProps> = ({
  data,
  metrics,
  timeRange
}) => {
  const [selectedMetrics, setSelectedMetrics] = useState(metrics);

  return (
    <BaseChart title="시스템 메트릭스" data={data}>
      <div className="mb-4 flex flex-wrap gap-2">
        {metrics.map(metric => (
          <Button
            key={metric}
            size="sm"
            variant={selectedMetrics.includes(metric) ? 'default' : 'outline'}
            onClick={() => toggleMetric(metric)}
          >
            {metric}
          </Button>
        ))}
      </div>
      
      <ResponsiveContainer width="100%" height={400}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis 
            dataKey="timestamp"
            tickFormatter={(value) => formatTime(value, timeRange)}
          />
          <YAxis />
          <Tooltip content={<MultiMetricTooltip />} />
          <Legend />
          
          {selectedMetrics.map((metric, index) => (
            <Line
              key={metric}
              type="monotone"
              dataKey={metric}
              stroke={CHART_COLORS[index]}
              strokeWidth={2}
              dot={false}
            />
          ))}
        </LineChart>
      </ResponsiveContainer>
    </BaseChart>
  );
};
```

## ⚡ Phase 4: 최적화 및 테스트 (1주)

### 4.1 성능 최적화

#### 데이터 로딩 최적화
```typescript
// frontend/src/hooks/useAdminData.ts
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { adminApiService } from '@/lib/admin-api';

export const useAdminUsers = (params: any) => {
  return useQuery({
    queryKey: ['admin-users', params],
    queryFn: () => adminApiService.getUsers(params),
    staleTime: 5 * 60 * 1000, // 5분
    cacheTime: 10 * 60 * 1000, // 10분
  });
};

export const useAdminDashboard = () => {
  return useQuery({
    queryKey: ['admin-dashboard'],
    queryFn: () => adminApiService.getDashboard(),
    refetchInterval: 5 * 60 * 1000, // 5분마다 자동 새로고침
  });
};
```

#### 무한 스크롤 구현
```typescript
// frontend/src/hooks/useInfiniteAdminData.ts
import { useInfiniteQuery } from '@tanstack/react-query';

export const useInfiniteAdminUsers = (filters: any) => {
  return useInfiniteQuery({
    queryKey: ['admin-users-infinite', filters],
    queryFn: ({ pageParam = 1 }) =>
      adminApiService.getUsers({ ...filters, page: pageParam }),
    getNextPageParam: (lastPage) =>
      lastPage.pagination.hasNext ? lastPage.pagination.page + 1 : undefined,
  });
};
```

### 4.2 보안 강화

#### CSP 헤더 설정
```typescript
// frontend/next.config.js
const nextConfig = {
  async headers() {
    return [
      {
        source: '/admin/:path*',
        headers: [
          {
            key: 'Content-Security-Policy',
            value: `
              default-src 'self';
              script-src 'self' 'unsafe-eval' 'unsafe-inline';
              style-src 'self' 'unsafe-inline';
              img-src 'self' data: https:;
              connect-src 'self' ${process.env.NEXT_PUBLIC_API_URL};
            `.replace(/\s+/g, ' ').trim()
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          }
        ]
      }
    ];
  }
};
```

## 🧪 테스트 전략

### 단위 테스트
```typescript
// frontend/src/components/admin/__tests__/AdminTable.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { AdminTable } from '../AdminTable';

describe('AdminTable', () => {
  const mockData = [
    { id: '1', name: 'Test User', email: 'test@test.com', role: 'MEMBER' }
  ];

  const mockColumns = [
    { key: 'name', title: '이름' },
    { key: 'email', title: '이메일' },
    { key: 'role', title: '역할' }
  ];

  it('데이터를 올바르게 렌더링한다', () => {
    render(<AdminTable data={mockData} columns={mockColumns} />);
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
    expect(screen.getByText('test@test.com')).toBeInTheDocument();
  });

  it('정렬 기능이 동작한다', () => {
    const onSort = jest.fn();
    render(
      <AdminTable 
        data={mockData} 
        columns={mockColumns} 
        onSort={onSort}
      />
    );
    
    fireEvent.click(screen.getByText('이름'));
    expect(onSort).toHaveBeenCalledWith('name', 'asc');
  });
});
```

### E2E 테스트
```typescript
// e2e/admin.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Admin Panel', () => {
  test.beforeEach(async ({ page }) => {
    // 관리자로 로그인
    await page.goto('/auth/login');
    await page.fill('input[type="email"]', 'admin@workly.com');
    await page.fill('input[type="password"]', 'adminpassword');
    await page.click('button[type="submit"]');
    await page.waitForURL('/admin');
  });

  test('대시보드가 올바르게 로드된다', async ({ page }) => {
    await expect(page.locator('h1')).toContainText('대시보드');
    await expect(page.locator('[data-testid="kpi-cards"]')).toBeVisible();
    await expect(page.locator('[data-testid="user-growth-chart"]')).toBeVisible();
  });

  test('사용자 목록을 조회할 수 있다', async ({ page }) => {
    await page.click('a[href="/admin/users"]');
    await page.waitForURL('/admin/users');
    
    await expect(page.locator('h1')).toContainText('사용자 관리');
    await expect(page.locator('[data-testid="users-table"]')).toBeVisible();
  });

  test('사용자 정보를 수정할 수 있다', async ({ page }) => {
    await page.goto('/admin/users');
    await page.click('[data-testid="user-edit-button"]:first-child');
    
    await page.fill('input[name="name"]', 'Updated Name');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('.success-message')).toBeVisible();
  });
});
```

## 📊 모니터링 및 알림

### 로깅 설정
```typescript
// backend/src/modules/admin/admin.module.ts
import { Logger } from '@nestjs/common';

@Module({
  // ...
  providers: [
    {
      provide: 'ADMIN_LOGGER',
      useValue: new Logger('AdminModule')
    },
    // ...
  ]
})
export class AdminModule {}
```

### 슬랙 알림 연동
```typescript
// backend/src/modules/admin/services/notification.service.ts
@Injectable()
export class AdminNotificationService {
  private readonly slackWebhook = process.env.SLACK_WEBHOOK_URL;

  async sendAdminAlert(alert: {
    type: string;
    message: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    adminId?: string;
  }) {
    if (!this.slackWebhook) return;

    const color = {
      low: '#36a64f',
      medium: '#ff9800',
      high: '#f44336',
      critical: '#9c27b0'
    }[alert.severity];

    const payload = {
      attachments: [{
        color,
        title: `🚨 Admin Alert: ${alert.type}`,
        text: alert.message,
        fields: [
          {
            title: 'Severity',
            value: alert.severity.toUpperCase(),
            short: true
          },
          {
            title: 'Time',
            value: new Date().toISOString(),
            short: true
          }
        ]
      }]
    };

    try {
      await axios.post(this.slackWebhook, payload);
    } catch (error) {
      console.error('Slack 알림 전송 실패:', error);
    }
  }
}
```

## 🚀 배포 가이드

### Docker 컨테이너화
```dockerfile
# 어드민 패널용 Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci --only=production

COPY frontend/ .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app

COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/public ./public

EXPOSE 3000
CMD ["node", "server.js"]
```

### 환경변수 설정
```bash
# .env.production
NEXT_PUBLIC_API_URL=https://api.workly.com
NEXT_PUBLIC_WEBSOCKET_URL=wss://api.workly.com

# 백엔드 환경변수
ADMIN_JWT_SECRET=super-secure-admin-secret
ADMIN_SESSION_TIMEOUT=1800000
ADMIN_ALLOWED_IPS=192.168.1.0/24,10.0.0.0/8
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
```

## 📈 성공 지표 및 모니터링

### 핵심 지표
- **응답 시간**: API 응답 < 200ms, 페이지 로드 < 2초
- **가용성**: 99.9% 업타임
- **보안**: 무단 접근 시도 0건, 모든 관리 작업 감사 로그 100%
- **사용성**: 관리 작업 완료 시간 50% 단축

### 모니터링 대시보드
- **Grafana**: 시스템 메트릭스, API 성능, 사용자 활동
- **Sentry**: 오류 추적 및 성능 모니터링
- **CloudWatch**: AWS 인프라 모니터링 (배포 시)

---

*이 구현 가이드는 워클리 어드민 패널의 전체 개발 프로세스를 안내합니다. 각 단계를 순서대로 따라하면 완전한 기능의 어드민 패널을 구축할 수 있습니다.*
</file>

<file path="docs/admin-panel-design.md">
# 워클리 어드민 패널 설계 문서

## 📋 개요

워클리 앱의 관리자를 위한 웹 기반 어드민 패널 설계 문서입니다. 기존 워클리 앱의 디자인 시스템과 아키텍처를 계승하여 일관성 있는 관리 도구를 제공합니다.

## 🎯 목적 및 목표

### 핵심 목적
- **효율적인 사용자 관리**: 회원 가입부터 계정 관리까지 원스톱 관리
- **콘텐츠 품질 관리**: 프로젝트, 업무, 목표 데이터의 품질 유지
- **시스템 운영 지원**: 성능 모니터링, 오류 추적, 시스템 설정
- **비즈니스 인사이트**: 사용자 행동 분석, 서비스 성장 지표 제공

### 주요 사용자
- **시스템 관리자**: 전체 시스템 관리 권한
- **서비스 매니저**: 콘텐츠 및 사용자 관리 권한
- **고객 지원팀**: 사용자 문의 처리 및 계정 관리

## 🏗️ 시스템 아키텍처

### 전체 구조
```
워클리 생태계
├── 메인 앱 (/)
│   ├── 사용자 인터페이스
│   ├── 프로젝트 협업 도구
│   └── 개인 생산성 도구
├── 어드민 패널 (/admin)
│   ├── 관리자 대시보드
│   ├── 사용자 관리 도구
│   ├── 콘텐츠 관리 시스템
│   └── 시스템 모니터링
└── API 백엔드
    ├── 공통 API (/api/v1/*)
    ├── 관리자 API (/api/admin/*)
    └── 권한 기반 접근 제어
```

### 기술 스택
- **프론트엔드**: Next.js 14 + TypeScript + Tailwind CSS
- **백엔드**: NestJS + TypeORM + PostgreSQL (기존 구조 확장)
- **인증**: JWT + Role-based Access Control
- **데이터 시각화**: Chart.js / Recharts
- **상태 관리**: Zustand (기존과 동일)

## 🎨 디자인 시스템

### 기본 원칙
워클리의 핵심 디자인 원칙을 계승하되, 관리 도구의 특성을 반영:

1. **극도의 간결함**: 정보 밀도는 높이되 시각적 복잡성은 최소화
2. **단일 컬러 시스템**: Primary Blue (#2563eb) 기반 확장
3. **데이터 중심**: 차트, 테이블, 지표가 핵심인 인터페이스

### 확장된 컬러 팔레트
```css
/* 기존 워클리 컬러 */
--primary: #2563eb;        /* Primary Blue */
--primary-hover: #1d4ed8;  /* Primary Hover */
--primary-light: #dbeafe; /* Primary Light */

/* 어드민 전용 확장 컬러 */
--admin-primary: #1e40af;   /* 더 진한 블루 (권위감) */
--success: #059669;         /* 성공/승인 */
--warning: #d97706;         /* 경고/대기 */
--danger: #dc2626;          /* 오류/거부 */
--info: #0284c7;           /* 정보/알림 */

/* 데이터 시각화 */
--chart-1: #2563eb;
--chart-2: #7c3aed;
--chart-3: #dc2626;
--chart-4: #059669;
--chart-5: #d97706;
```

### 레이아웃 시스템
```
Desktop (>= 1024px)
┌─────────────────────────────────────────────────┐
│ Header (h-16): 로고 + 네비 + 사용자 메뉴           │
├─────────────┬───────────────────────────────────┤
│ Sidebar     │ Main Content                      │
│ (w-64)      │ (flex-1)                         │
│             │                                   │
│ - Dashboard │ ┌─────────────────────────────────┐ │
│ - Users     │ │ Page Header                     │ │
│ - Projects  │ ├─────────────────────────────────┤ │
│ - Tasks     │ │                                 │ │
│ - Content   │ │ Page Content                    │ │
│ - Settings  │ │ (cards, tables, charts)         │ │
│ - System    │ │                                 │ │
│             │ └─────────────────────────────────┘ │
└─────────────┴───────────────────────────────────┘

Tablet (768px - 1023px)
┌─────────────────────────────────────────────────┐
│ Header + Mobile Menu Toggle                      │
├─────────────────────────────────────────────────┤
│ Overlay Sidebar (collapsed by default)           │
│ Main Content (full width)                        │
└─────────────────────────────────────────────────┘
```

## 📱 화면별 상세 설계

### 1. 대시보드 (/)
**목적**: 시스템 전반의 상태를 한눈에 파악

```typescript
interface DashboardData {
  kpis: {
    totalUsers: number;
    activeUsers: number;
    totalProjects: number;
    completedTasks: number;
    systemHealth: 'healthy' | 'warning' | 'critical';
  };
  charts: {
    userGrowth: TimeSeriesData[];
    taskCompletion: TimeSeriesData[];
    projectStatus: PieChartData[];
    serverMetrics: MetricsData;
  };
  recentActivity: ActivityLog[];
}
```

**핵심 컴포넌트**:
- **KPI Cards**: 4x1 그리드로 주요 지표 요약
- **Growth Chart**: 사용자/프로젝트 증가 추이 (라인 차트)
- **Task Completion**: 업무 완료율 트렌드 (영역 차트)
- **System Status**: 서버 상태, API 응답시간 (실시간)
- **Recent Activity**: 최근 24시간 주요 활동 로그

### 2. 사용자 관리 (/users)
**목적**: 모든 사용자 계정의 생성, 수정, 삭제, 권한 관리

```typescript
interface UserManagement {
  users: PaginatedList<UserWithStats>;
  filters: {
    role: UserRole[];
    status: UserStatus[];
    registrationDate: DateRange;
    lastActivity: DateRange;
  };
  bulkActions: {
    changeStatus: (userIds: string[], status: UserStatus) => void;
    sendEmail: (userIds: string[], template: EmailTemplate) => void;
    exportData: (userIds: string[]) => void;
  };
}
```

**핵심 기능**:
- **사용자 목록**: 검색, 다중 필터, 정렬, 페이지네이션
- **사용자 상세**: 프로필 편집, 권한 변경, 활동 이력
- **일괄 작업**: 선택된 사용자들에 대한 상태 변경, 이메일 발송
- **통계**: 가입 추이, 활성도 분석, 권한별 분포
- **내보내기**: Excel/CSV 형태로 사용자 데이터 내보내기

### 3. 프로젝트 관리 (/projects)
**목적**: 모든 프로젝트의 현황 파악 및 품질 관리

```typescript
interface ProjectManagement {
  projects: PaginatedList<ProjectWithMetrics>;
  analytics: {
    successRate: number;
    averageCompletionTime: number;
    popularSkills: SkillStats[];
    teamSizeDistribution: number[];
  };
  moderation: {
    reportedProjects: ProjectReport[];
    pendingApproval: Project[];
  };
}
```

**핵심 기능**:
- **프로젝트 목록**: 상태별 필터링, 진행률 시각화
- **프로젝트 상세**: 멤버 관리, 업무 현황, 채팅 로그 검토
- **품질 관리**: 신고된 프로젝트 검토, 승인 대기 프로젝트
- **분석**: 성공률, 완료 시간, 인기 스킬 통계
- **개입 도구**: 프로젝트 중단, 멤버 제재, 공지사항 전송

### 4. 업무 관리 (/tasks)
**목적**: 플랫폼 내 모든 업무의 품질과 분류 관리

```typescript
interface TaskManagement {
  tasks: PaginatedList<TaskWithContext>;
  categories: {
    uncategorized: number;
    blocked: number;
    overdue: number;
    highPriority: number;
  };
  automation: {
    autoLabeling: boolean;
    duplicateDetection: boolean;
    spamFilter: boolean;
  };
}
```

**핵심 기능**:
- **업무 목록**: 프로젝트별, 사용자별, 상태별 필터링
- **업무 상세**: 내용 검토, 라벨링, 중복 체크
- **자동화 관리**: AI 기반 자동 분류, 스팸 필터링
- **품질 지표**: 완료율, 평균 처리 시간, 난이도 분포
- **이슈 관리**: 신고된 업무, 차단된 업무 처리

### 5. 콘텐츠 관리 (/content)
**목적**: 앱 내 모든 사용자 생성 콘텐츠의 모더레이션

```typescript
interface ContentManagement {
  content: {
    posts: PaginatedList<PostWithFlags>;
    comments: PaginatedList<CommentWithFlags>;
    files: PaginatedList<FileWithMetadata>;
  };
  moderation: {
    reported: ContentReport[];
    flagged: FlaggedContent[];
    pending: PendingContent[];
  };
  policies: ContentPolicy[];
}
```

**핵심 기능**:
- **콘텐츠 목록**: 타입별, 상태별 콘텐츠 브라우징
- **모더레이션 큐**: 신고된 콘텐츠 검토 및 처리
- **자동 필터링**: 부적절한 콘텐츠 자동 탐지
- **정책 관리**: 커뮤니티 가이드라인 및 정책 설정
- **통계**: 콘텐츠 생성 추이, 신고 패턴 분석

### 6. 시스템 설정 (/settings)
**목적**: 앱 전반의 설정과 기능 토글 관리

```typescript
interface SystemSettings {
  app: {
    maintenanceMode: boolean;
    newUserRegistration: boolean;
    projectCreation: boolean;
    fileUpload: boolean;
    maxFileSize: number;
  };
  notifications: {
    templates: EmailTemplate[];
    pushSettings: PushNotificationConfig;
    frequencies: NotificationFrequency[];
  };
  integrations: {
    googleOAuth: OAuthConfig;
    emailService: EmailServiceConfig;
    fileStorage: StorageConfig;
  };
}
```

**핵심 기능**:
- **앱 설정**: 기능 활성화/비활성화, 제한값 설정
- **알림 관리**: 이메일/푸시 템플릿 편집, 발송 스케줄
- **통합 서비스**: OAuth, 이메일, 파일 스토리지 설정
- **보안 설정**: 비밀번호 정책, 세션 만료, 2FA 설정
- **백업 & 복구**: 데이터 백업 스케줄, 복구 지점 관리

### 7. 시스템 모니터링 (/system)
**목적**: 서버 상태, 성능, 오류 모니터링

```typescript
interface SystemMonitoring {
  metrics: {
    server: ServerMetrics;
    database: DatabaseMetrics;
    api: APIMetrics;
    errors: ErrorLog[];
  };
  alerts: {
    active: Alert[];
    history: AlertHistory[];
    rules: AlertRule[];
  };
  logs: {
    application: ApplicationLog[];
    security: SecurityLog[];
    audit: AuditLog[];
  };
}
```

**핵심 기능**:
- **실시간 모니터링**: CPU, 메모리, 디스크, 네트워크 사용률
- **API 성능**: 응답 시간, 처리량, 오류율
- **데이터베이스**: 쿼리 성능, 연결 상태, 용량 사용률
- **오류 추적**: 오류 로그, 스택 트레이스, 발생 빈도
- **알림 설정**: 임계값 기반 자동 알림, 에스컬레이션 규칙

## 🔐 권한 및 보안

### 권한 체계
```typescript
enum AdminRole {
  SUPER_ADMIN = 'super_admin',    // 모든 권한
  ADMIN = 'admin',                // 사용자/콘텐츠 관리
  MODERATOR = 'moderator',        // 콘텐츠 모더레이션만
  SUPPORT = 'support',            // 사용자 지원 (읽기 전용 + 기본 사용자 관리)
}

interface AdminPermissions {
  users: {
    read: boolean;
    create: boolean;
    update: boolean;
    delete: boolean;
    changeRole: boolean;
  };
  content: {
    read: boolean;
    moderate: boolean;
    delete: boolean;
  };
  system: {
    read: boolean;
    configure: boolean;
    maintenance: boolean;
  };
}
```

### 보안 조치
- **2FA 필수**: 모든 관리자 계정은 2단계 인증 필수
- **IP 제한**: 허용된 IP 대역에서만 접근 가능
- **세션 관리**: 30분 무활동 시 자동 로그아웃
- **감사 로그**: 모든 관리 작업 로그 기록 및 추적
- **데이터 마스킹**: 민감한 개인정보 마스킹 처리

## 📊 데이터 모델

### 관리자 전용 엔티티
```typescript
// 관리자 계정 (기존 User 엔티티 확장)
interface AdminUser extends User {
  adminRole: AdminRole;
  permissions: AdminPermissions;
  lastAdminLogin: Date;
  failedLoginAttempts: number;
  twoFactorEnabled: boolean;
  ipWhitelist: string[];
}

// 감사 로그
interface AuditLog {
  id: string;
  adminId: string;
  action: string;
  targetType: 'user' | 'project' | 'task' | 'system';
  targetId?: string;
  changes: Record<string, any>;
  ipAddress: string;
  userAgent: string;
  timestamp: Date;
}

// 시스템 설정
interface SystemConfig {
  id: string;
  key: string;
  value: any;
  type: 'boolean' | 'string' | 'number' | 'json';
  description: string;
  category: string;
  updatedBy: string;
  updatedAt: Date;
}

// 콘텐츠 신고
interface ContentReport {
  id: string;
  reporterId: string;
  contentType: 'project' | 'task' | 'comment';
  contentId: string;
  reason: ReportReason;
  description: string;
  status: 'pending' | 'reviewed' | 'resolved' | 'dismissed';
  reviewedBy?: string;
  reviewedAt?: Date;
  action?: 'no_action' | 'warning' | 'content_removed' | 'user_suspended';
  createdAt: Date;
}
```

## 🚀 구현 로드맵

### Phase 1: 기본 인프라 (2주)
- [x] 권한 기반 라우팅 시스템
- [x] 관리자 레이아웃 컴포넌트
- [x] 대시보드 기본 구조
- [x] 사용자 목록/상세 화면

### Phase 2: 핵심 관리 기능 (3주)
- [ ] 프로젝트 관리 화면
- [ ] 업무 관리 시스템
- [ ] 콘텐츠 모더레이션 도구
- [ ] 시스템 설정 인터페이스

### Phase 3: 고급 기능 (2주)
- [ ] 실시간 모니터링 대시보드
- [ ] 데이터 시각화 및 분석
- [ ] 알림 및 자동화 시스템
- [ ] 감사 로그 및 보안 강화

### Phase 4: 최적화 및 테스트 (1주)
- [ ] 성능 최적화
- [ ] 사용성 테스트
- [ ] 보안 검토
- [ ] 문서화 완료

## 📈 성공 지표

### 운영 효율성
- **관리 작업 처리 시간**: 50% 단축
- **오류 대응 시간**: 24시간 → 2시간
- **사용자 문의 해결률**: 95% 이상

### 시스템 안정성
- **서버 가동률**: 99.9% 이상
- **API 응답 시간**: 평균 200ms 이하
- **보안 인시던트**: 0건

### 데이터 품질
- **부적절한 콘텐츠 탐지율**: 95% 이상
- **스팸 필터링 정확도**: 98% 이상
- **사용자 만족도**: 4.5/5.0 이상

---

*이 문서는 워클리 어드민 패널의 설계 명세서입니다. 구현 과정에서 사용자 피드백과 기술적 제약사항에 따라 조정될 수 있습니다.*
</file>

<file path="docs/admin-rbac-design.md">
# 워클리 어드민 권한 관리 시스템 (RBAC) 설계

## 개요

워클리 어드민 패널의 Role-Based Access Control (RBAC) 시스템 설계입니다. 세분화된 권한 관리를 통해 보안성과 운영 효율성을 동시에 확보합니다.

## 권한 체계 구조

### 1. 역할 계층 구조
```
SUPER_ADMIN (최고 관리자)
├── 모든 권한 보유
├── 다른 관리자 계정 생성/삭제
└── 시스템 설정 변경

ADMIN (관리자)  
├── 사용자 관리 (생성/수정/삭제)
├── 콘텐츠 관리 (모든 프로젝트/업무)
├── 시스템 모니터링 (읽기)
└── 보고서 생성

MODERATOR (모더레이터)
├── 콘텐츠 검토 및 승인
├── 신고 처리
├── 사용자 경고/제재
└── 커뮤니티 가이드라인 관리

SUPPORT (고객 지원)
├── 사용자 문의 처리
├── 계정 문제 해결 (제한적)
├── 데이터 조회 (읽기 전용)
└── 기본 사용자 관리
```

### 2. 권한 매트릭스
```typescript
interface PermissionMatrix {
  [role: string]: {
    users: {
      read: boolean;
      create: boolean;
      update: boolean;
      delete: boolean;
      changeRole: boolean;
      viewSensitive: boolean;
    };
    content: {
      read: boolean;
      moderate: boolean;
      delete: boolean;
      featured: boolean;
    };
    projects: {
      read: boolean;
      moderate: boolean;
      close: boolean;
      featured: boolean;
      viewPrivate: boolean;
    };
    system: {
      read: boolean;
      configure: boolean;
      maintenance: boolean;
      monitoring: boolean;
      backup: boolean;
    };
    reports: {
      view: boolean;
      export: boolean;
      create: boolean;
    };
    audit: {
      view: boolean;
      export: boolean;
    };
  };
}

const PERMISSION_MATRIX: PermissionMatrix = {
  SUPER_ADMIN: {
    users: { read: true, create: true, update: true, delete: true, changeRole: true, viewSensitive: true },
    content: { read: true, moderate: true, delete: true, featured: true },
    projects: { read: true, moderate: true, close: true, featured: true, viewPrivate: true },
    system: { read: true, configure: true, maintenance: true, monitoring: true, backup: true },
    reports: { view: true, export: true, create: true },
    audit: { view: true, export: true }
  },
  ADMIN: {
    users: { read: true, create: true, update: true, delete: true, changeRole: false, viewSensitive: true },
    content: { read: true, moderate: true, delete: true, featured: true },
    projects: { read: true, moderate: true, close: true, featured: true, viewPrivate: true },
    system: { read: true, configure: false, maintenance: false, monitoring: true, backup: false },
    reports: { view: true, export: true, create: true },
    audit: { view: true, export: false }
  },
  MODERATOR: {
    users: { read: true, create: false, update: true, delete: false, changeRole: false, viewSensitive: false },
    content: { read: true, moderate: true, delete: true, featured: false },
    projects: { read: true, moderate: true, close: false, featured: false, viewPrivate: false },
    system: { read: false, configure: false, maintenance: false, monitoring: false, backup: false },
    reports: { view: true, export: false, create: false },
    audit: { view: false, export: false }
  },
  SUPPORT: {
    users: { read: true, create: false, update: true, delete: false, changeRole: false, viewSensitive: false },
    content: { read: true, moderate: false, delete: false, featured: false },
    projects: { read: true, moderate: false, close: false, featured: false, viewPrivate: false },
    system: { read: false, configure: false, maintenance: false, monitoring: false, backup: false },
    reports: { view: true, export: false, create: false },
    audit: { view: false, export: false }
  }
};
```

## 백엔드 구현

### 1. 권한 검증 데코레이터
```typescript
// permissions.decorator.ts
export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions);

// permissions.guard.ts
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.get<string[]>(
      'permissions',
      context.getHandler()
    );

    if (!requiredPermissions) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return this.hasPermissions(user, requiredPermissions);
  }

  private hasPermissions(user: any, permissions: string[]): boolean {
    const userPermissions = this.getUserPermissions(user.role);
    
    return permissions.every(permission => {
      const [resource, action] = permission.split(':');
      return userPermissions[resource]?.[action] === true;
    });
  }

  private getUserPermissions(role: string) {
    return PERMISSION_MATRIX[role] || {};
  }
}
```

### 2. 관리자 인증 가드
```typescript
// admin.guard.ts
@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    // 기본 사용자는 어드민 패널 접근 불가
    const adminRoles = ['SUPER_ADMIN', 'ADMIN', 'MODERATOR', 'SUPPORT'];
    return adminRoles.includes(user.role);
  }
}
```

### 3. 컨트롤러 적용 예시
```typescript
@Controller('admin/users')
@UseGuards(JwtAuthGuard, AdminGuard, PermissionsGuard)
export class AdminUsersController {
  @Get()
  @RequirePermissions('users:read')
  async getUsers(@Query() query: GetUsersDto) {
    return this.usersService.getUsers(query);
  }

  @Post()
  @RequirePermissions('users:create')
  async createUser(@Body() createUserDto: CreateUserDto) {
    return this.usersService.createUser(createUserDto);
  }

  @Put(':id')
  @RequirePermissions('users:update')
  async updateUser(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto
  ) {
    return this.usersService.updateUser(id, updateUserDto);
  }

  @Delete(':id')
  @RequirePermissions('users:delete')
  async deleteUser(@Param('id') id: string) {
    return this.usersService.deleteUser(id);
  }

  @Put(':id/role')
  @RequirePermissions('users:changeRole')
  async changeUserRole(
    @Param('id') id: string,
    @Body() changeRoleDto: ChangeRoleDto
  ) {
    return this.usersService.changeUserRole(id, changeRoleDto.role);
  }
}
```

### 4. 감사 로그 데코레이터
```typescript
// audit-log.decorator.ts
export const AuditLog = (action: string) =>
  SetMetadata('auditAction', action);

// audit-log.interceptor.ts
@Injectable()
export class AuditLogInterceptor implements NestInterceptor {
  constructor(private auditService: AuditService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const action = this.reflector.get<string>('auditAction', context.getHandler());
    
    if (!action) {
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    return next.handle().pipe(
      tap((result) => {
        this.auditService.log({
          adminId: user.id,
          adminName: user.name,
          action,
          targetType: this.extractTargetType(context),
          targetId: this.extractTargetId(request),
          changes: this.extractChanges(request, result),
          ipAddress: request.ip,
          userAgent: request.get('User-Agent'),
          timestamp: new Date(),
          success: true
        });
      }),
      catchError((error) => {
        this.auditService.log({
          adminId: user.id,
          adminName: user.name,
          action,
          targetType: this.extractTargetType(context),
          targetId: this.extractTargetId(request),
          ipAddress: request.ip,
          userAgent: request.get('User-Agent'),
          timestamp: new Date(),
          success: false,
          errorMessage: error.message
        });
        throw error;
      })
    );
  }
}
```

## 프론트엔드 구현

### 1. 권한 컨텍스트
```typescript
// hooks/usePermissions.ts
interface PermissionsContextType {
  permissions: AdminPermissions;
  hasPermission: (permission: string) => boolean;
  hasAnyPermission: (permissions: string[]) => boolean;
  hasAllPermissions: (permissions: string[]) => boolean;
}

const PermissionsContext = createContext<PermissionsContextType | null>(null);

export const PermissionsProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const { user } = useAuth();
  const permissions = getUserPermissions(user?.role);

  const hasPermission = useCallback((permission: string) => {
    const [resource, action] = permission.split(':');
    return permissions[resource]?.[action] === true;
  }, [permissions]);

  const hasAnyPermission = useCallback((perms: string[]) => {
    return perms.some(hasPermission);
  }, [hasPermission]);

  const hasAllPermissions = useCallback((perms: string[]) => {
    return perms.every(hasPermission);
  }, [hasPermission]);

  return (
    <PermissionsContext.Provider value={{
      permissions,
      hasPermission,
      hasAnyPermission,
      hasAllPermissions
    }}>
      {children}
    </PermissionsContext.Provider>
  );
};

export const usePermissions = () => {
  const context = useContext(PermissionsContext);
  if (!context) {
    throw new Error('usePermissions must be used within PermissionsProvider');
  }
  return context;
};
```

### 2. 권한 기반 컴포넌트
```typescript
// components/PermissionGate.tsx
interface PermissionGateProps {
  permissions: string | string[];
  require?: 'any' | 'all';
  fallback?: React.ReactNode;
  children: React.ReactNode;
}

export const PermissionGate: React.FC<PermissionGateProps> = ({
  permissions,
  require = 'any',
  fallback = null,
  children
}) => {
  const { hasPermission, hasAnyPermission, hasAllPermissions } = usePermissions();

  const permissionArray = Array.isArray(permissions) ? permissions : [permissions];
  
  let hasAccess = false;
  if (require === 'all') {
    hasAccess = hasAllPermissions(permissionArray);
  } else {
    hasAccess = hasAnyPermission(permissionArray);
  }

  return hasAccess ? <>{children}</> : <>{fallback}</>;
};

// 사용 예시
<PermissionGate permissions="users:create">
  <Button onClick={handleCreateUser}>
    사용자 생성
  </Button>
</PermissionGate>

<PermissionGate 
  permissions={['users:update', 'users:delete']}
  require="any"
  fallback={<span>권한이 없습니다</span>}
>
  <UserActions user={user} />
</PermissionGate>
```

### 3. 보호된 라우트
```typescript
// components/ProtectedRoute.tsx
interface ProtectedRouteProps {
  permissions: string | string[];
  require?: 'any' | 'all';
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  permissions,
  require = 'any',
  children
}) => {
  const { hasPermission, hasAnyPermission, hasAllPermissions } = usePermissions();
  const router = useRouter();

  const permissionArray = Array.isArray(permissions) ? permissions : [permissions];
  
  let hasAccess = false;
  if (require === 'all') {
    hasAccess = hasAllPermissions(permissionArray);
  } else {
    hasAccess = hasAnyPermission(permissionArray);
  }

  if (!hasAccess) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="text-center">
          <XCircleIcon className="w-16 h-16 text-red-400 mx-auto mb-4" />
          <h2 className="text-xl font-semibold text-gray-900 mb-2">
            접근 권한이 없습니다
          </h2>
          <p className="text-gray-600 mb-4">
            이 페이지에 접근할 권한이 없습니다.
          </p>
          <Button onClick={() => router.back()}>
            이전 페이지로
          </Button>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};
```

### 4. 네비게이션 필터링
```typescript
// components/AdminSidebar.tsx
const AdminSidebar: React.FC = () => {
  const { hasPermission } = usePermissions();

  const menuItems = [
    { 
      icon: ChartBarIcon, 
      label: '대시보드', 
      href: '/admin',
      permissions: [] // 모든 관리자 접근 가능
    },
    { 
      icon: UsersIcon, 
      label: '사용자 관리', 
      href: '/admin/users',
      permissions: ['users:read']
    },
    { 
      icon: FolderIcon, 
      label: '프로젝트 관리', 
      href: '/admin/projects',
      permissions: ['projects:read']
    },
    { 
      icon: ShieldCheckIcon, 
      label: '콘텐츠 관리', 
      href: '/admin/content',
      permissions: ['content:read']
    },
    { 
      icon: CogIcon, 
      label: '시스템 설정', 
      href: '/admin/settings',
      permissions: ['system:configure']
    },
    { 
      icon: ServerIcon, 
      label: '모니터링', 
      href: '/admin/monitoring',
      permissions: ['system:monitoring']
    }
  ];

  const filteredMenuItems = menuItems.filter(item => 
    item.permissions.length === 0 || 
    item.permissions.some(permission => hasPermission(permission))
  );

  return (
    <aside className="w-64 bg-white border-r border-gray-200">
      <nav className="mt-8">
        {filteredMenuItems.map((item) => (
          <SidebarItem key={item.href} {...item} />
        ))}
      </nav>
    </aside>
  );
};
```

## 보안 강화 조치

### 1. 세션 관리
```typescript
// 관리자 세션은 더 짧은 만료 시간
const ADMIN_SESSION_TIMEOUT = 30 * 60 * 1000; // 30분

// 민감한 작업 시 재인증 요구
interface SensitiveActionProps {
  onConfirm: () => void;
  action: string;
}

const SensitiveActionConfirm: React.FC<SensitiveActionProps> = ({
  onConfirm,
  action
}) => {
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);

  const handleConfirm = async () => {
    setLoading(true);
    try {
      await verifyAdminPassword(password);
      onConfirm();
    } catch (error) {
      // 오류 처리
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal title="작업 확인">
      <p className="mb-4">
        <strong>{action}</strong> 작업을 수행하시겠습니까?
      </p>
      <Input
        type="password"
        placeholder="현재 비밀번호를 입력하세요"
        value={password}
        onChange={setPassword}
      />
      <div className="flex justify-end space-x-2 mt-4">
        <Button variant="outline">취소</Button>
        <Button onClick={handleConfirm} loading={loading}>
          확인
        </Button>
      </div>
    </Modal>
  );
};
```

### 2. IP 제한
```typescript
// ip-restriction.guard.ts
@Injectable()
export class IpRestrictionGuard implements CanActivate {
  private readonly allowedIPs = process.env.ADMIN_ALLOWED_IPS?.split(',') || [];

  canActivate(context: ExecutionContext): boolean {
    if (this.allowedIPs.length === 0) {
      return true; // IP 제한 비활성화
    }

    const request = context.switchToHttp().getRequest();
    const clientIp = this.getClientIp(request);

    return this.allowedIPs.some(allowedIp => 
      this.isIpInRange(clientIp, allowedIp)
    );
  }

  private getClientIp(request: any): string {
    return request.headers['x-forwarded-for'] || 
           request.connection.remoteAddress || 
           request.socket.remoteAddress;
  }

  private isIpInRange(ip: string, range: string): boolean {
    // IP 범위 검증 로직
    if (range.includes('/')) {
      // CIDR 표기법 처리
      return this.isIpInCidr(ip, range);
    }
    return ip === range;
  }
}
```

### 3. 2FA (Two-Factor Authentication)
```typescript
// 2FA 필수 체크
@Injectable()
export class TwoFactorGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    // SUPER_ADMIN과 ADMIN은 2FA 필수
    const requiresTwoFactor = ['SUPER_ADMIN', 'ADMIN'].includes(user.role);
    
    if (requiresTwoFactor && !user.twoFactorEnabled) {
      throw new UnauthorizedException('2단계 인증이 필요합니다');
    }

    return true;
  }
}
```

## 모니터링 및 알림

### 1. 권한 변경 알림
```typescript
// 권한 변경 시 자동 알림
@EventPattern('admin.role.changed')
async handleRoleChanged(data: { userId: string; oldRole: string; newRole: string; changedBy: string }) {
  // 슬랙, 이메일 등으로 알림
  await this.notificationService.sendAdminAlert({
    type: 'role_changed',
    message: `사용자 ${data.userId}의 권한이 ${data.oldRole}에서 ${data.newRole}로 변경되었습니다.`,
    changedBy: data.changedBy,
    severity: 'high'
  });
}
```

### 2. 비정상 접근 탐지
```typescript
// 비정상 접근 패턴 감지
@Injectable()
export class AnomalyDetectionService {
  async detectSuspiciousActivity(adminId: string, action: string, context: any) {
    const recentActions = await this.auditService.getRecentActions(adminId, 24); // 24시간
    
    // 단시간 내 대량 작업
    if (recentActions.length > 100) {
      await this.alertService.sendAlert({
        type: 'bulk_actions',
        adminId,
        message: '24시간 내 100회 이상의 관리 작업이 감지되었습니다.'
      });
    }
    
    // 비정상 시간대 접근
    const hour = new Date().getHours();
    if (hour < 6 || hour > 22) {
      await this.alertService.sendAlert({
        type: 'off_hours_access',
        adminId,
        message: '업무 시간 외 관리자 접근이 감지되었습니다.'
      });
    }
  }
}
```

---

*이 RBAC 시스템은 워클리 어드민 패널의 보안과 운영 효율성을 보장하는 핵심 시스템입니다. 모든 관리 작업은 적절한 권한 검증과 감사 로그를 통해 추적 가능합니다.*
</file>

<file path="docs/PROJECT_STRUCTURE.md">
# 워클리 풀스택 프로젝트 구조

## 전체 프로젝트 구조

```
Workly/
├── 📁 frontend/                    # Next.js 프론트엔드
│   ├── 📁 src/
│   │   ├── 📁 app/                 # Next.js App Router
│   │   │   ├── 📁 (auth)/          # 인증 관련 페이지 그룹
│   │   │   │   ├── login/
│   │   │   │   └── register/
│   │   │   ├── 📁 (dashboard)/     # 대시보드 페이지 그룹
│   │   │   │   ├── page.tsx        # 홈(업무) 페이지
│   │   │   │   ├── projects/
│   │   │   │   ├── board/
│   │   │   │   ├── activity/
│   │   │   │   └── profile/
│   │   │   ├── 📁 api/             # API 라우트 (백엔드 프록시)
│   │   │   │   ├── auth/
│   │   │   │   └── proxy/
│   │   │   ├── globals.css
│   │   │   ├── layout.tsx
│   │   │   └── loading.tsx
│   │   ├── 📁 components/          # 재사용 컴포넌트
│   │   │   ├── 📁 ui/              # 기본 UI 컴포넌트
│   │   │   │   ├── button.tsx
│   │   │   │   ├── card.tsx
│   │   │   │   ├── modal.tsx
│   │   │   │   └── input.tsx
│   │   │   ├── 📁 navigation/      # 네비게이션 컴포넌트
│   │   │   │   ├── LeftNavigation.tsx
│   │   │   │   └── MobileNavigation.tsx
│   │   │   ├── 📁 layout/          # 레이아웃 컴포넌트
│   │   │   │   ├── Header.tsx
│   │   │   │   └── Sidebar.tsx
│   │   │   ├── 📁 dashboard/       # 대시보드 컴포넌트
│   │   │   │   ├── WorkDashboard.tsx
│   │   │   │   ├── StatCard.tsx
│   │   │   │   └── TaskList.tsx
│   │   │   ├── 📁 project/         # 프로젝트 관련 컴포넌트
│   │   │   │   ├── ProjectCard.tsx
│   │   │   │   ├── ProjectForm.tsx
│   │   │   │   └── ProjectDetail.tsx
│   │   │   ├── 📁 board/           # 게시판 컴포넌트
│   │   │   │   ├── PostCard.tsx
│   │   │   │   ├── PostForm.tsx
│   │   │   │   └── CommentSection.tsx
│   │   │   └── 📁 auth/            # 인증 컴포넌트
│   │   │       ├── LoginForm.tsx
│   │   │       ├── GoogleAuth.tsx
│   │   │       └── ProtectedRoute.tsx
│   │   ├── 📁 hooks/               # 커스텀 훅
│   │   │   ├── useAuth.ts
│   │   │   ├── useSocket.ts
│   │   │   ├── useProjects.ts
│   │   │   └── useTasks.ts
│   │   ├── 📁 services/            # API 서비스
│   │   │   ├── api.ts              # 기본 API 클라이언트
│   │   │   ├── auth.service.ts
│   │   │   ├── project.service.ts
│   │   │   ├── task.service.ts
│   │   │   ├── board.service.ts
│   │   │   └── socket.service.ts
│   │   ├── 📁 stores/              # 상태 관리 (Zustand)
│   │   │   ├── authStore.ts
│   │   │   ├── projectStore.ts
│   │   │   ├── taskStore.ts
│   │   │   └── socketStore.ts
│   │   ├── 📁 types/               # TypeScript 타입 정의
│   │   │   ├── auth.types.ts
│   │   │   ├── project.types.ts
│   │   │   ├── task.types.ts
│   │   │   ├── board.types.ts
│   │   │   └── common.types.ts
│   │   └── 📁 utils/               # 유틸리티 함수
│   │       ├── constants.ts
│   │       ├── validation.ts
│   │       ├── helpers.ts
│   │       └── socket-client.ts
│   ├── 📁 public/                  # 정적 파일
│   │   ├── icons/
│   │   ├── images/
│   │   └── favicon.ico
│   ├── package.json
│   ├── next.config.js
│   ├── tailwind.config.ts
│   └── tsconfig.json
│
├── 📁 backend/                     # NestJS 백엔드
│   ├── 📁 src/
│   │   ├── 📁 app/                 # 앱 진입점
│   │   │   ├── app.controller.ts
│   │   │   ├── app.module.ts
│   │   │   └── app.service.ts
│   │   ├── 📁 config/              # 설정 파일
│   │   │   ├── database.config.ts
│   │   │   ├── auth.config.ts
│   │   │   ├── storage.config.ts
│   │   │   └── socket.config.ts
│   │   ├── 📁 common/              # 공통 모듈
│   │   │   ├── 📁 decorators/      # 커스텀 데코레이터
│   │   │   ├── 📁 guards/          # 가드 (인증, 권한)
│   │   │   │   ├── jwt-auth.guard.ts
│   │   │   │   ├── google-auth.guard.ts
│   │   │   │   └── roles.guard.ts
│   │   │   ├── 📁 interceptors/    # 인터셉터
│   │   │   ├── 📁 pipes/           # 파이프 (검증)
│   │   │   ├── 📁 filters/         # 예외 필터
│   │   │   └── 📁 middleware/      # 미들웨어
│   │   ├── 📁 database/            # 데이터베이스 관련
│   │   │   ├── 📁 entities/        # TypeORM 엔티티
│   │   │   │   ├── user.entity.ts
│   │   │   │   ├── project.entity.ts
│   │   │   │   ├── task.entity.ts
│   │   │   │   ├── board.entity.ts
│   │   │   │   ├── comment.entity.ts
│   │   │   │   └── file.entity.ts
│   │   │   ├── 📁 migrations/      # 데이터베이스 마이그레이션
│   │   │   ├── 📁 seeds/           # 초기 데이터
│   │   │   └── database.module.ts
│   │   ├── 📁 modules/             # 기능별 모듈
│   │   │   ├── 📁 auth/            # 인증 모듈
│   │   │   │   ├── auth.controller.ts
│   │   │   │   ├── auth.service.ts
│   │   │   │   ├── auth.module.ts
│   │   │   │   ├── 📁 strategies/
│   │   │   │   │   ├── jwt.strategy.ts
│   │   │   │   │   └── google.strategy.ts
│   │   │   │   └── 📁 dto/
│   │   │   │       ├── login.dto.ts
│   │   │   │       └── register.dto.ts
│   │   │   ├── 📁 users/           # 사용자 모듈
│   │   │   │   ├── users.controller.ts
│   │   │   │   ├── users.service.ts
│   │   │   │   ├── users.module.ts
│   │   │   │   └── 📁 dto/
│   │   │   │       └── create-user.dto.ts
│   │   │   ├── 📁 projects/        # 프로젝트 모듈
│   │   │   │   ├── projects.controller.ts
│   │   │   │   ├── projects.service.ts
│   │   │   │   ├── projects.module.ts
│   │   │   │   └── 📁 dto/
│   │   │   │       ├── create-project.dto.ts
│   │   │   │       └── update-project.dto.ts
│   │   │   ├── 📁 tasks/           # 업무 모듈
│   │   │   │   ├── tasks.controller.ts
│   │   │   │   ├── tasks.service.ts
│   │   │   │   ├── tasks.module.ts
│   │   │   │   └── 📁 dto/
│   │   │   │       ├── create-task.dto.ts
│   │   │   │       └── update-task.dto.ts
│   │   │   ├── 📁 board/           # 게시판 모듈
│   │   │   │   ├── board.controller.ts
│   │   │   │   ├── board.service.ts
│   │   │   │   ├── board.module.ts
│   │   │   │   └── 📁 dto/
│   │   │   │       ├── create-post.dto.ts
│   │   │   │       └── create-comment.dto.ts
│   │   │   ├── 📁 files/           # 파일 관리 모듈
│   │   │   │   ├── files.controller.ts
│   │   │   │   ├── files.service.ts
│   │   │   │   ├── files.module.ts
│   │   │   │   └── 📁 storage/
│   │   │   │       ├── local.storage.ts
│   │   │   │       └── s3.storage.ts
│   │   │   └── 📁 notifications/   # 알림 모듈
│   │   │       ├── notifications.controller.ts
│   │   │       ├── notifications.service.ts
│   │   │       ├── notifications.module.ts
│   │   │       └── notifications.gateway.ts
│   │   ├── 📁 websockets/          # Socket.io 관련
│   │   │   ├── websockets.gateway.ts
│   │   │   ├── websockets.module.ts
│   │   │   └── 📁 events/
│   │   │       ├── task.events.ts
│   │   │       ├── project.events.ts
│   │   │       └── notification.events.ts
│   │   └── main.ts                 # 앱 진입점
│   ├── 📁 uploads/                 # 로컬 파일 업로드 (개발용)
│   ├── 📁 test/                    # 테스트 파일
│   ├── package.json
│   ├── nest-cli.json
│   └── tsconfig.json
│
├── 📁 shared/                      # 공유 라이브러리
│   ├── 📁 types/                   # 공통 타입 정의
│   │   ├── api.types.ts
│   │   ├── socket.types.ts
│   │   └── common.types.ts
│   ├── 📁 constants/               # 공통 상수
│   │   ├── api-endpoints.ts
│   │   ├── socket-events.ts
│   │   └── app-constants.ts
│   └── 📁 utils/                   # 공통 유틸리티
│       ├── validation.ts
│       └── helpers.ts
│
├── 📁 docs/                        # 프로젝트 문서
│   ├── 📁 api/                     # API 문서
│   ├── 📁 database/                # 데이터베이스 스키마
│   └── 📁 deployment/              # 배포 가이드
│
├── 📁 scripts/                     # 유틸리티 스크립트
│   ├── setup.sh                    # 초기 설정 스크립트
│   ├── migrate.sh                  # 데이터베이스 마이그레이션
│   └── deploy.sh                   # 배포 스크립트
│
├── 📁 .github/                     # GitHub Actions
│   └── 📁 workflows/
│       ├── frontend-ci.yml
│       └── backend-ci.yml
│
├── docker-compose.yml              # 개발 환경 Docker
├── docker-compose.prod.yml         # 프로덕션 환경 Docker
├── .env.example                    # 환경 변수 예시
├── .gitignore
├── README.md
└── CLAUDE.md                       # Claude Code 설정
```

## 주요 기술 스택별 폴더 설명

### 🎨 Frontend (Next.js + TypeScript + Tailwind)
- **App Router 구조**: 페이지 그룹핑으로 관련 기능 분리
- **컴포넌트 계층화**: ui → layout → feature 순서
- **상태 관리**: Zustand 기반 모듈별 스토어
- **API 통신**: 서비스 레이어 패턴

### 🔧 Backend (NestJS + TypeORM + PostgreSQL)
- **모듈 기반 구조**: 기능별 독립 모듈
- **계층화 아키텍처**: Controller → Service → Repository
- **공통 모듈**: 인증, 권한, 검증 등
- **데이터베이스**: 엔티티, 마이그레이션, 시드 분리

### 🔐 Authentication (JWT + Google OAuth)
- **전략 패턴**: JWT/Google 인증 전략 분리
- **가드 시스템**: 라우트 보호 및 권한 체크
- **토큰 관리**: 리프레시 토큰 포함 완전한 인증 플로우

### ⚡ Real-time (Socket.io)
- **Gateway 패턴**: 실시간 이벤트 처리
- **이벤트 분리**: 모듈별 이벤트 타입 정의
- **클라이언트 연동**: 프론트엔드 소켓 서비스

### 📁 File Storage (Local/AWS S3)
- **전략 패턴**: 로컬/클라우드 스토리지 추상화
- **파일 관리**: 업로드, 다운로드, 삭제 통합 API
- **보안**: 인증된 사용자만 파일 접근 가능

## 개발 환경 설정

### Frontend 설정
```bash
cd frontend
npm install
npm run dev
```

### Backend 설정
```bash
cd backend
npm install
npm run start:dev
```

### Database 설정
```bash
docker-compose up -d postgres
cd backend
npm run migration:run
npm run seed:run
```

## API 통신 구조

### REST API
- `/api/auth/*` - 인증 관련
- `/api/users/*` - 사용자 관리
- `/api/projects/*` - 프로젝트 관리
- `/api/tasks/*` - 업무 관리
- `/api/board/*` - 게시판
- `/api/files/*` - 파일 관리

### WebSocket Events
- `task:created` - 새 업무 생성
- `task:updated` - 업무 상태 변경
- `project:joined` - 프로젝트 참여
- `notification:new` - 새 알림

## 배포 전략

### 개발 환경
- Docker Compose로 로컬 개발 환경 구성
- 핫 리로드 지원

### 프로덕션 환경
- Frontend: Vercel 또는 Netlify
- Backend: AWS EC2 + RDS
- 파일 스토리지: AWS S3
- 실시간 통신: Redis Adapter
</file>

<file path="frontend/src/app/admin/audit-logs/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { 
  MagnifyingGlassIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
} from '@heroicons/react/24/outline';

interface AuditLog {
  id: string;
  adminId: string;
  adminName: string;
  action: string;
  targetType: string;
  targetId?: string;
  targetName?: string;
  changes?: {
    before?: Record<string, any>;
    after?: Record<string, any>;
  };
  ipAddress: string;
  userAgent: string;
  timestamp: string;
  success: boolean;
  errorMessage?: string;
}

interface AuditFilters {
  search: string;
  adminId: string;
  action: string;
  targetType: string;
  success: string;
  dateRange: {
    start: string;
    end: string;
  };
}

export default function AuditLogsManagement() {
  const [auditLogs, setAuditLogs] = useState<AuditLog[]>([]);
  const [filteredLogs, setFilteredLogs] = useState<AuditLog[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [filters, setFilters] = useState<AuditFilters>({
    search: '',
    adminId: '',
    action: '',
    targetType: '',
    success: '',
    dateRange: {
      start: '',
      end: '',
    },
  });

  // 임시 데이터
  useEffect(() => {
    const fetchAuditLogs = async () => {
      try {
        // 실제로는 API 호출
        // const response = await fetch('/api/admin/audit-logs');
        // const data = await response.json();
        
        // 임시 데이터
        const mockLogs: AuditLog[] = [
          {
            id: '1',
            adminId: '1',
            adminName: '시스템 관리자',
            action: '사용자 역할 변경',
            targetType: 'user',
            targetId: '2',
            targetName: '김사용자',
            changes: {
              before: { role: 'MEMBER' },
              after: { role: 'MANAGER' },
            },
            ipAddress: '192.168.1.100',
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            timestamp: '2024-01-15T10:30:00Z',
            success: true,
          },
          {
            id: '2',
            adminId: '2',
            adminName: '이관리자',
            action: '프로젝트 삭제',
            targetType: 'project',
            targetId: '5',
            targetName: '테스트 프로젝트',
            ipAddress: '192.168.1.101',
            userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            timestamp: '2024-01-15T09:15:00Z',
            success: true,
          },
          {
            id: '3',
            adminId: '1',
            adminName: '시스템 관리자',
            action: '시스템 설정 변경',
            targetType: 'settings',
            changes: {
              before: { maintenanceMode: false },
              after: { maintenanceMode: true },
            },
            ipAddress: '192.168.1.100',
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            timestamp: '2024-01-15T08:45:00Z',
            success: false,
            errorMessage: '권한이 부족합니다',
          },
          {
            id: '4',
            adminId: '3',
            adminName: '박모더레이터',
            action: '대시보드 조회',
            targetType: 'system',
            ipAddress: '192.168.1.102',
            userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15',
            timestamp: '2024-01-15T07:20:00Z',
            success: true,
          },
          {
            id: '5',
            adminId: '1',
            adminName: '시스템 관리자',
            action: '사용자 계정 정지',
            targetType: 'user',
            targetId: '10',
            targetName: '스팸사용자',
            changes: {
              before: { status: 'ACTIVE' },
              after: { status: 'SUSPENDED' },
            },
            ipAddress: '192.168.1.100',
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            timestamp: '2024-01-14T16:30:00Z',
            success: true,
          },
        ];
        
        setAuditLogs(mockLogs);
        setFilteredLogs(mockLogs);
      } catch (error) {
        console.error('감사 로그 데이터 로드 오류:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchAuditLogs();
  }, []);

  // 필터링 효과
  useEffect(() => {
    let filtered = auditLogs;

    if (filters.search) {
      filtered = filtered.filter(log =>
        log.adminName.toLowerCase().includes(filters.search.toLowerCase()) ||
        log.action.toLowerCase().includes(filters.search.toLowerCase()) ||
        log.targetName?.toLowerCase().includes(filters.search.toLowerCase())
      );
    }

    if (filters.adminId) {
      filtered = filtered.filter(log => log.adminId === filters.adminId);
    }

    if (filters.action) {
      filtered = filtered.filter(log => log.action.includes(filters.action));
    }

    if (filters.targetType) {
      filtered = filtered.filter(log => log.targetType === filters.targetType);
    }

    if (filters.success !== '') {
      filtered = filtered.filter(log => log.success.toString() === filters.success);
    }

    if (filters.dateRange.start) {
      filtered = filtered.filter(log => 
        new Date(log.timestamp) >= new Date(filters.dateRange.start)
      );
    }

    if (filters.dateRange.end) {
      filtered = filtered.filter(log => 
        new Date(log.timestamp) <= new Date(filters.dateRange.end)
      );
    }

    setFilteredLogs(filtered);
  }, [filters, auditLogs]);

  const handleFilterChange = (key: string, value: string) => {
    if (key.includes('.')) {
      const [parent, child] = key.split('.');
      setFilters(prev => ({
        ...prev,
        [parent]: {
          ...(prev[parent as keyof AuditFilters] as any),
          [child]: value,
        },
      }));
    } else {
      setFilters(prev => ({ ...prev, [key]: value }));
    }
  };

  const getSuccessBadge = (success: boolean) => {
    return success ? (
      <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <CheckCircleIcon className="w-3 h-3 mr-1" />
        성공
      </span>
    ) : (
      <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
        <XCircleIcon className="w-3 h-3 mr-1" />
        실패
      </span>
    );
  };

  const getTargetTypeBadge = (targetType: string) => {
    const badges = {
      user: 'bg-blue-100 text-blue-800',
      project: 'bg-purple-100 text-purple-800',
      task: 'bg-orange-100 text-orange-800',
      settings: 'bg-gray-100 text-gray-800',
      system: 'bg-indigo-100 text-indigo-800',
    };
    
    const labels = {
      user: '사용자',
      project: '프로젝트',
      task: '업무',
      settings: '설정',
      system: '시스템',
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${badges[targetType as keyof typeof badges] || 'bg-gray-100 text-gray-800'}`}>
        {labels[targetType as keyof typeof labels] || targetType}
      </span>
    );
  };

  const formatTimestamp = (timestamp: string) => {
    const date = new Date(timestamp);
    return date.toLocaleString('ko-KR', {
      year: 'numeric',
      month: '2-digit',  
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="border-b border-gray-200 pb-4">
        <h1 className="text-2xl font-bold text-gray-900">감사 로그</h1>
        <p className="mt-1 text-sm text-gray-600">
          관리자 활동 기록을 확인하고 감사하세요
        </p>
      </div>

      {/* 통계 카드 */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <ClockIcon className="h-8 w-8 text-blue-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">총 로그</p>
              <p className="text-2xl font-bold text-gray-900">{auditLogs.length}</p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <CheckCircleIcon className="h-8 w-8 text-green-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">성공</p>
              <p className="text-2xl font-bold text-gray-900">
                {auditLogs.filter(log => log.success).length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <XCircleIcon className="h-8 w-8 text-red-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">실패</p>
              <p className="text-2xl font-bold text-gray-900">
                {auditLogs.filter(log => !log.success).length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <div className="h-8 w-8 bg-purple-500 rounded-full flex items-center justify-center">
                <span className="text-white font-bold text-sm">
                  {new Set(auditLogs.map(log => log.adminId)).size}
                </span>
              </div>
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">활성 관리자</p>
              <p className="text-2xl font-bold text-gray-900">
                {new Set(auditLogs.map(log => log.adminId)).size}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* 필터 영역 */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {/* 검색 */}
          <div className="lg:col-span-1">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              검색
            </label>
            <div className="relative">
              <MagnifyingGlassIcon className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
              <input
                type="text"
                placeholder="관리자명, 액션, 대상 검색"
                value={filters.search}
                onChange={(e) => handleFilterChange('search', e.target.value)}
                className="pl-10 w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              />
            </div>
          </div>

          {/* 대상 유형 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              대상 유형
            </label>
            <select
              value={filters.targetType}
              onChange={(e) => handleFilterChange('targetType', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="user">사용자</option>
              <option value="project">프로젝트</option>
              <option value="task">업무</option>
              <option value="settings">설정</option>
              <option value="system">시스템</option>
            </select>
          </div>

          {/* 성공/실패 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              결과
            </label>
            <select
              value={filters.success}
              onChange={(e) => handleFilterChange('success', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="true">성공</option>
              <option value="false">실패</option>
            </select>
          </div>

          {/* 시작 날짜 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              시작 날짜
            </label>
            <input
              type="date"
              value={filters.dateRange.start}
              onChange={(e) => handleFilterChange('dateRange.start', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            />
          </div>

          {/* 종료 날짜 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              종료 날짜
            </label>
            <input
              type="date"
              value={filters.dateRange.end}
              onChange={(e) => handleFilterChange('dateRange.end', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            />
          </div>
        </div>
      </div>

      {/* 감사 로그 목록 */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-900">
              감사 로그 ({filteredLogs.length}개)
            </h2>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  시간
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  관리자
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  액션
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  대상
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  결과
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  IP 주소
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredLogs.map((log) => (
                <tr key={log.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {formatTimestamp(log.timestamp)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm font-medium text-gray-900">{log.adminName}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">{log.action}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="space-y-1">
                      {getTargetTypeBadge(log.targetType)}
                      {log.targetName && (
                        <div className="text-xs text-gray-500">{log.targetName}</div>
                      )}
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="space-y-1">
                      {getSuccessBadge(log.success)}
                      {log.errorMessage && (
                        <div className="text-xs text-red-600">{log.errorMessage}</div>
                      )}
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {log.ipAddress}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {filteredLogs.length === 0 && (
          <div className="text-center py-12">
            <ClockIcon className="mx-auto h-12 w-12 text-gray-400" />
            <h3 className="mt-2 text-sm font-medium text-gray-900">로그가 없습니다</h3>
            <p className="mt-1 text-sm text-gray-500">필터 조건을 변경해보세요.</p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/admin/projects/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { 
  MagnifyingGlassIcon,
  FolderIcon,
  UsersIcon,
  ClipboardDocumentListIcon,
  TrashIcon,
  EyeIcon,
} from '@heroicons/react/24/outline';

interface Project {
  id: string;
  name: string;
  description?: string;
  status: string;
  progress: number;
  memberCount: number;
  taskCount: number;
  completedTaskCount: number;
  createdAt: string;
  updatedAt: string;
  ownerId: string;
  ownerName: string;
}

interface ProjectFilters {
  search: string;
  status: string;
}

export default function ProjectsManagement() {
  const [projects, setProjects] = useState<Project[]>([]);
  const [filteredProjects, setFilteredProjects] = useState<Project[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [filters, setFilters] = useState<ProjectFilters>({
    search: '',
    status: '',
  });

  // 임시 데이터
  useEffect(() => {
    const fetchProjects = async () => {
      try {
        // 실제로는 API 호출
        // const response = await fetch('/api/admin/projects');
        // const data = await response.json();
        
        // 임시 데이터
        const mockProjects: Project[] = [
          {
            id: '1',
            name: '워클리 웹 플랫폼 개발',
            description: 'CPER 워크플로우 기반 업무 관리 플랫폼',
            status: 'IN_PROGRESS',
            progress: 75,
            memberCount: 5,
            taskCount: 32,
            completedTaskCount: 24,
            createdAt: '2024-01-01T00:00:00Z',
            updatedAt: '2024-01-15T10:30:00Z',
            ownerId: '1',
            ownerName: '김프로젝트',
          },
          {
            id: '2',
            name: '모바일 앱 리뉴얼',
            description: '사용자 경험 개선을 위한 UI/UX 리뉴얼',
            status: 'COMPLETED',
            progress: 100,
            memberCount: 3,
            taskCount: 18,
            completedTaskCount: 18,
            createdAt: '2023-12-01T00:00:00Z',
            updatedAt: '2024-01-10T15:22:00Z',
            ownerId: '2',
            ownerName: '이디자인',
          },
          {
            id: '3',
            name: '데이터 마이그레이션',
            description: '레거시 시스템에서 새 플랫폼으로 데이터 이전',
            status: 'PLANNING',
            progress: 25,
            memberCount: 2,
            taskCount: 8,
            completedTaskCount: 2,
            createdAt: '2024-01-10T00:00:00Z',
            updatedAt: '2024-01-14T09:15:00Z',
            ownerId: '3',
            ownerName: '박데이터',
          },
          {
            id: '4',
            name: '보안 강화 프로젝트',
            description: '시스템 보안 취약점 점검 및 개선',
            status: 'ON_HOLD',
            progress: 10,
            memberCount: 4,
            taskCount: 15,
            completedTaskCount: 1,
            createdAt: '2023-12-15T00:00:00Z',
            updatedAt: '2024-01-05T12:00:00Z',
            ownerId: '4',
            ownerName: '최보안',
          },
        ];
        
        setProjects(mockProjects);
        setFilteredProjects(mockProjects);
      } catch (error) {
        console.error('프로젝트 데이터 로드 오류:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchProjects();
  }, []);

  // 필터링 효과
  useEffect(() => {
    let filtered = projects;

    if (filters.search) {
      filtered = filtered.filter(project =>
        project.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        project.description?.toLowerCase().includes(filters.search.toLowerCase()) ||
        project.ownerName.toLowerCase().includes(filters.search.toLowerCase())
      );
    }

    if (filters.status) {
      filtered = filtered.filter(project => project.status === filters.status);
    }

    setFilteredProjects(filtered);
  }, [filters, projects]);

  const handleFilterChange = (key: keyof ProjectFilters, value: string) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };

  const getStatusBadge = (status: string) => {
    const badges = {
      PLANNING: 'bg-blue-100 text-blue-800',
      IN_PROGRESS: 'bg-yellow-100 text-yellow-800',
      COMPLETED: 'bg-green-100 text-green-800',
      ON_HOLD: 'bg-gray-100 text-gray-800',
      CANCELLED: 'bg-red-100 text-red-800',
    };
    
    const labels = {
      PLANNING: '계획중',
      IN_PROGRESS: '진행중',
      COMPLETED: '완료',
      ON_HOLD: '보류',
      CANCELLED: '취소',
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${badges[status as keyof typeof badges] || 'bg-gray-100 text-gray-800'}`}>
        {labels[status as keyof typeof labels] || status}
      </span>
    );
  };

  const getProgressBar = (progress: number) => {
    const colorClass = progress === 100 ? 'bg-green-500' : progress >= 75 ? 'bg-blue-500' : progress >= 50 ? 'bg-yellow-500' : 'bg-gray-500';
    
    return (
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className={`h-2 rounded-full ${colorClass}`}
          style={{ width: `${progress}%` }}
        />
      </div>
    );
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="border-b border-gray-200 pb-4">
        <h1 className="text-2xl font-bold text-gray-900">프로젝트 관리</h1>
        <p className="mt-1 text-sm text-gray-600">
          전체 프로젝트 목록을 확인하고 관리하세요
        </p>
      </div>

      {/* 통계 카드 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <FolderIcon className="h-8 w-8 text-blue-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">전체 프로젝트</p>
              <p className="text-2xl font-bold text-gray-900">{projects.length}</p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <div className="h-8 w-8 bg-yellow-500 rounded-full flex items-center justify-center">
                <span className="text-white font-bold text-sm">
                  {projects.filter(p => p.status === 'IN_PROGRESS').length}
                </span>
              </div>
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">진행중</p>
              <p className="text-2xl font-bold text-gray-900">
                {projects.filter(p => p.status === 'IN_PROGRESS').length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <div className="h-8 w-8 bg-green-500 rounded-full flex items-center justify-center">
                <span className="text-white font-bold text-sm">
                  {projects.filter(p => p.status === 'COMPLETED').length}
                </span>
              </div>
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">완료</p>
              <p className="text-2xl font-bold text-gray-900">
                {projects.filter(p => p.status === 'COMPLETED').length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <UsersIcon className="h-8 w-8 text-purple-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-600">평균 팀원 수</p>
              <p className="text-2xl font-bold text-gray-900">
                {projects.length > 0 ? Math.round(projects.reduce((sum, p) => sum + p.memberCount, 0) / projects.length) : 0}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* 필터 영역 */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* 검색 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              검색
            </label>
            <div className="relative">
              <MagnifyingGlassIcon className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
              <input
                type="text"
                placeholder="프로젝트명, 설명, 소유자 검색"
                value={filters.search}
                onChange={(e) => handleFilterChange('search', e.target.value)}
                className="pl-10 w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              />
            </div>
          </div>

          {/* 상태 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              상태
            </label>
            <select
              value={filters.status}
              onChange={(e) => handleFilterChange('status', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="PLANNING">계획중</option>
              <option value="IN_PROGRESS">진행중</option>
              <option value="COMPLETED">완료</option>
              <option value="ON_HOLD">보류</option>
              <option value="CANCELLED">취소</option>
            </select>
          </div>
        </div>
      </div>

      {/* 프로젝트 목록 */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-900">
              프로젝트 목록 ({filteredProjects.length}개)
            </h2>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  프로젝트
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  소유자
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  상태
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  진행률
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  팀/업무
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  생성일
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  작업
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredProjects.map((project) => (
                <tr key={project.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4">
                    <div>
                      <div className="text-sm font-medium text-gray-900">{project.name}</div>
                      {project.description && (
                        <div className="text-sm text-gray-500 truncate max-w-xs">
                          {project.description}
                        </div>
                      )}
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">{project.ownerName}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    {getStatusBadge(project.status)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      <div className="w-16 mr-2">
                        {getProgressBar(project.progress)}
                      </div>
                      <span className="text-sm text-gray-900">{project.progress}%</span>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center space-x-4 text-sm text-gray-900">
                      <div className="flex items-center">
                        <UsersIcon className="h-4 w-4 text-gray-400 mr-1" />
                        {project.memberCount}
                      </div>
                      <div className="flex items-center">
                        <ClipboardDocumentListIcon className="h-4 w-4 text-gray-400 mr-1" />
                        {project.completedTaskCount}/{project.taskCount}
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {new Date(project.createdAt).toLocaleDateString('ko-KR')}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <div className="flex items-center justify-end space-x-2">
                      <button className="text-indigo-600 hover:text-indigo-900">
                        <EyeIcon className="h-4 w-4" />
                      </button>
                      <button className="text-red-600 hover:text-red-900">
                        <TrashIcon className="h-4 w-4" />
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {filteredProjects.length === 0 && (
          <div className="text-center py-12">
            <FolderIcon className="mx-auto h-12 w-12 text-gray-400" />
            <h3 className="mt-2 text-sm font-medium text-gray-900">프로젝트가 없습니다</h3>
            <p className="mt-1 text-sm text-gray-500">필터 조건을 변경해보세요.</p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/admin/settings/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { 
  Cog6ToothIcon,
  BellIcon,
  ShieldCheckIcon,
  GlobeAltIcon,
  CloudIcon,
  ExclamationTriangleIcon,
} from '@heroicons/react/24/outline';

interface SystemSettings {
  app: {
    maintenanceMode: boolean;
    newUserRegistration: boolean;
    projectCreation: boolean;
    fileUpload: boolean;
    maxFileSize: number;
    maxProjectMembers: number;
    taskDeadlineWarningDays: number;
  };
  notifications: {
    emailEnabled: boolean;
    pushEnabled: boolean;
    dailyDigestEnabled: boolean;
    weeklyReportEnabled: boolean;
  };
  security: {
    passwordMinLength: number;
    passwordRequireSpecialChar: boolean;
    sessionTimeoutMinutes: number;
    maxLoginAttempts: number;
    twoFactorRequired: boolean;
  };
  features: {
    realTimeChat: boolean;
    fileSharing: boolean;
    integrations: boolean;
    analytics: boolean;
    apiAccess: boolean;
  };
}

export default function SystemSettings() {
  const [settings, setSettings] = useState<SystemSettings | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [activeTab, setActiveTab] = useState('app');

  // 임시 데이터
  useEffect(() => {
    const fetchSettings = async () => {
      try {
        // 실제로는 API 호출
        // const response = await fetch('/api/admin/settings');
        // const data = await response.json();
        
        // 임시 데이터
        const mockSettings: SystemSettings = {
          app: {
            maintenanceMode: false,
            newUserRegistration: true,
            projectCreation: true,
            fileUpload: true,
            maxFileSize: 10,
            maxProjectMembers: 50,
            taskDeadlineWarningDays: 3,
          },
          notifications: {
            emailEnabled: true,
            pushEnabled: true,
            dailyDigestEnabled: true,
            weeklyReportEnabled: true,
          },
          security: {
            passwordMinLength: 8,
            passwordRequireSpecialChar: true,
            sessionTimeoutMinutes: 120,
            maxLoginAttempts: 5,
            twoFactorRequired: false,
          },
          features: {
            realTimeChat: true,
            fileSharing: true,
            integrations: false,
            analytics: true,
            apiAccess: false,
          },
        };
        
        setSettings(mockSettings);
      } catch (error) {
        console.error('설정 데이터 로드 오류:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSettings();
  }, []);

  const handleSaveSettings = async () => {
    if (!settings) return;

    setIsSaving(true);
    try {
      // 실제로는 API 호출
      // const response = await fetch('/api/admin/settings', {
      //   method: 'PUT',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify(settings),
      // });
      
      // 임시로 2초만 기다리기
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      alert('설정이 성공적으로 저장되었습니다.');
    } catch (error) {
      console.error('설정 저장 오류:', error);
      alert('설정 저장 중 오류가 발생했습니다.');
    } finally {
      setIsSaving(false);
    }
  };

  const updateSetting = (section: keyof SystemSettings, key: string, value: any) => {
    if (!settings) return;
    
    setSettings(prev => ({
      ...prev!,
      [section]: {
        ...prev![section],
        [key]: value,
      },
    }));
  };

  const tabs = [
    { id: 'app', name: '애플리케이션', icon: Cog6ToothIcon },
    { id: 'notifications', name: '알림', icon: BellIcon },
    { id: 'security', name: '보안', icon: ShieldCheckIcon },
    { id: 'features', name: '기능', icon: GlobeAltIcon },
  ];

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  if (!settings) {
    return (
      <div className="text-center py-12">
        <ExclamationTriangleIcon className="mx-auto h-12 w-12 text-red-400" />
        <h3 className="mt-2 text-sm font-medium text-gray-900">설정을 불러올 수 없습니다</h3>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="border-b border-gray-200 pb-4">
        <h1 className="text-2xl font-bold text-gray-900">시스템 설정</h1>
        <p className="mt-1 text-sm text-gray-600">
          워클리 시스템의 전반적인 설정을 관리하세요
        </p>
      </div>

      <div className="flex">
        {/* 사이드바 탭 */}
        <div className="w-64 bg-white rounded-lg shadow p-4 h-fit">
          <nav className="space-y-2">
            {tabs.map((tab) => {
              const Icon = tab.icon;
              return (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`w-full flex items-center px-3 py-2 text-sm font-medium rounded-md ${
                    activeTab === tab.id
                      ? 'bg-indigo-100 text-indigo-700'
                      : 'text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  <Icon className="mr-3 h-5 w-5" />
                  {tab.name}
                </button>
              );
            })}
          </nav>
        </div>

        {/* 메인 콘텐츠 */}
        <div className="flex-1 ml-6">
          <div className="bg-white rounded-lg shadow">
            {/* 애플리케이션 설정 */}
            {activeTab === 'app' && (
              <div className="p-6">
                <h2 className="text-lg font-semibold text-gray-900 mb-6">애플리케이션 설정</h2>
                
                {/* 유지보수 모드 */}
                <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-yellow-800">유지보수 모드</h3>
                      <p className="text-sm text-yellow-700">시스템을 일시적으로 사용 중단할 수 있습니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.app.maintenanceMode}
                        onChange={(e) => updateSetting('app', 'maintenanceMode', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-yellow-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-yellow-600"></div>
                    </label>
                  </div>
                </div>

                <div className="space-y-6">
                  {/* 사용자 등록 */}
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">신규 사용자 등록 허용</h3>
                      <p className="text-sm text-gray-500">새로운 사용자의 회원가입을 허용합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.app.newUserRegistration}
                        onChange={(e) => updateSetting('app', 'newUserRegistration', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  {/* 프로젝트 생성 */}
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">프로젝트 생성 허용</h3>
                      <p className="text-sm text-gray-500">사용자의 새 프로젝트 생성을 허용합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.app.projectCreation}
                        onChange={(e) => updateSetting('app', 'projectCreation', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  {/* 파일 업로드 */}
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">파일 업로드 허용</h3>
                      <p className="text-sm text-gray-500">사용자의 파일 업로드를 허용합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.app.fileUpload}
                        onChange={(e) => updateSetting('app', 'fileUpload', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  {/* 최대 파일 크기 */}
                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      최대 파일 크기 (MB)
                    </label>
                    <input
                      type="number"
                      min="1"
                      max="100"
                      value={settings.app.maxFileSize}
                      onChange={(e) => updateSetting('app', 'maxFileSize', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>

                  {/* 최대 프로젝트 멤버 수 */}
                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      프로젝트당 최대 멤버 수
                    </label>
                    <input
                      type="number"
                      min="1"
                      max="1000"
                      value={settings.app.maxProjectMembers}
                      onChange={(e) => updateSetting('app', 'maxProjectMembers', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>

                  {/* 업무 마감일 경고 */}
                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      업무 마감일 경고 (일 전)
                    </label>
                    <input
                      type="number"
                      min="1"
                      max="30"
                      value={settings.app.taskDeadlineWarningDays}
                      onChange={(e) => updateSetting('app', 'taskDeadlineWarningDays', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>
                </div>
              </div>
            )}

            {/* 알림 설정 */}
            {activeTab === 'notifications' && (
              <div className="p-6">
                <h2 className="text-lg font-semibold text-gray-900 mb-6">알림 설정</h2>
                
                <div className="space-y-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">이메일 알림</h3>
                      <p className="text-sm text-gray-500">이메일을 통한 알림을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.notifications.emailEnabled}
                        onChange={(e) => updateSetting('notifications', 'emailEnabled', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">푸시 알림</h3>
                      <p className="text-sm text-gray-500">브라우저 푸시 알림을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.notifications.pushEnabled}
                        onChange={(e) => updateSetting('notifications', 'pushEnabled', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">일일 요약</h3>
                      <p className="text-sm text-gray-500">매일 활동 요약을 발송합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.notifications.dailyDigestEnabled}
                        onChange={(e) => updateSetting('notifications', 'dailyDigestEnabled', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">주간 리포트</h3>
                      <p className="text-sm text-gray-500">매주 성과 리포트를 발송합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.notifications.weeklyReportEnabled}
                        onChange={(e) => updateSetting('notifications', 'weeklyReportEnabled', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>
                </div>
              </div>
            )}

            {/* 보안 설정 */}
            {activeTab === 'security' && (
              <div className="p-6">
                <h2 className="text-lg font-semibold text-gray-900 mb-6">보안 설정</h2>
                
                <div className="space-y-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      최소 비밀번호 길이
                    </label>
                    <input
                      type="number"
                      min="6"
                      max="32"
                      value={settings.security.passwordMinLength}
                      onChange={(e) => updateSetting('security', 'passwordMinLength', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">특수문자 포함 필수</h3>
                      <p className="text-sm text-gray-500">비밀번호에 특수문자를 포함하도록 강제합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.security.passwordRequireSpecialChar}
                        onChange={(e) => updateSetting('security', 'passwordRequireSpecialChar', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      세션 타임아웃 (분)
                    </label>
                    <input
                      type="number"
                      min="15"
                      max="480"
                      value={settings.security.sessionTimeoutMinutes}
                      onChange={(e) => updateSetting('security', 'sessionTimeoutMinutes', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-900 mb-1">
                      최대 로그인 시도 횟수
                    </label>
                    <input
                      type="number"
                      min="3"
                      max="10"
                      value={settings.security.maxLoginAttempts}
                      onChange={(e) => updateSetting('security', 'maxLoginAttempts', parseInt(e.target.value))}
                      className="w-32 border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">2단계 인증 필수</h3>
                      <p className="text-sm text-gray-500">모든 사용자에게 2단계 인증을 강제합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.security.twoFactorRequired}
                        onChange={(e) => updateSetting('security', 'twoFactorRequired', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>
                </div>
              </div>
            )}

            {/* 기능 설정 */}
            {activeTab === 'features' && (
              <div className="p-6">
                <h2 className="text-lg font-semibold text-gray-900 mb-6">기능 설정</h2>
                
                <div className="space-y-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">실시간 채팅</h3>
                      <p className="text-sm text-gray-500">프로젝트 내 실시간 채팅 기능을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.features.realTimeChat}
                        onChange={(e) => updateSetting('features', 'realTimeChat', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">파일 공유</h3>
                      <p className="text-sm text-gray-500">프로젝트 내 파일 공유 기능을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.features.fileSharing}
                        onChange={(e) => updateSetting('features', 'fileSharing', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">외부 통합</h3>
                      <p className="text-sm text-gray-500">Slack, Notion 등 외부 서비스 통합을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.features.integrations}
                        onChange={(e) => updateSetting('features', 'integrations', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">분석 기능</h3>
                      <p className="text-sm text-gray-500">사용자 활동 분석 및 통계 기능을 활성화합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.features.analytics}
                        onChange={(e) => updateSetting('features', 'analytics', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">API 접근</h3>
                      <p className="text-sm text-gray-500">외부 애플리케이션의 API 접근을 허용합니다</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={settings.features.apiAccess}
                        onChange={(e) => updateSetting('features', 'apiAccess', e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                  </div>
                </div>
              </div>
            )}

            {/* 저장 버튼 */}
            <div className="px-6 py-4 bg-gray-50 border-t border-gray-200 rounded-b-lg">
              <div className="flex justify-end">
                <button
                  onClick={handleSaveSettings}
                  disabled={isSaving}
                  className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
                >
                  {isSaving ? (
                    <>
                      <CloudIcon className="mr-2 h-4 w-4 animate-spin" />
                      저장 중...
                    </>
                  ) : (
                    <>
                      <CloudIcon className="mr-2 h-4 w-4" />
                      설정 저장
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/admin/layout.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import { useAuthStore } from '@/lib/stores/authStore';
import { 
  HomeIcon, 
  UsersIcon, 
  FolderIcon, 
  Cog6ToothIcon,
  ChartBarIcon,
  DocumentTextIcon,
  ShieldCheckIcon,
  ExclamationTriangleIcon,
} from '@heroicons/react/24/outline';
import { AdminNavItem, ADMIN_PERMISSIONS } from '@/components/admin';

interface AdminLayoutProps {
  children: React.ReactNode;
}

export default function AdminLayout({ children }: AdminLayoutProps) {
  const router = useRouter();
  const { user, checkAuth } = useAuthStore();
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initAuth = async () => {
      await checkAuth();
      setIsLoading(false);
    };
    initAuth();
  }, [checkAuth]);

  // 로딩 중이거나 인증 상태를 확인하는 중
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  // 어드민 권한이 없는 경우
  if (!user?.adminRole) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6 text-center">
          <ExclamationTriangleIcon className="h-16 w-16 text-red-500 mx-auto mb-4" />
          <h1 className="text-2xl font-bold text-gray-900 mb-2">접근 권한이 없습니다</h1>
          <p className="text-gray-600 mb-4">어드민 패널에 접근하려면 관리자 권한이 필요합니다.</p>
          <button
            onClick={() => router.push('/')}
            className="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 transition-colors"
          >
            홈으로 돌아가기
          </button>
        </div>
      </div>
    );
  }

  const navigationItems = [
    {
      name: '대시보드',
      href: '/admin',
      icon: HomeIcon,
      permissions: ADMIN_PERMISSIONS.DASHBOARD_READ,
      exact: true,
    },
    {
      name: '사용자 관리',
      href: '/admin/users',
      icon: UsersIcon,
      permissions: ADMIN_PERMISSIONS.USERS_READ,
    },
    {
      name: '프로젝트 관리',
      href: '/admin/projects',
      icon: FolderIcon,
      permissions: ADMIN_PERMISSIONS.PROJECTS_READ,
    },
    {
      name: '통계 분석',
      href: '/admin/analytics',
      icon: ChartBarIcon,
      permissions: ADMIN_PERMISSIONS.DASHBOARD_READ,
    },
    {
      name: '감사 로그',
      href: '/admin/audit-logs',
      icon: DocumentTextIcon,
      permissions: ADMIN_PERMISSIONS.AUDIT_READ,
    },
    {
      name: '시스템 설정',
      href: '/admin/settings',
      icon: Cog6ToothIcon,
      permissions: ADMIN_PERMISSIONS.SETTINGS_READ,
    },
  ];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 사이드바 */}
      <div className="fixed inset-y-0 left-0 z-50 w-64 bg-white shadow-lg">
        {/* 로고 영역 */}
        <div className="flex items-center justify-center h-16 px-4 border-b border-gray-200">
          <div className="flex items-center">
            <ShieldCheckIcon className="h-8 w-8 text-indigo-600" />
            <span className="ml-2 text-xl font-bold text-gray-900">워클리 어드민</span>
          </div>
        </div>

        {/* 관리자 정보 */}
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <div className="h-10 w-10 rounded-full bg-indigo-600 flex items-center justify-center">
                <span className="text-sm font-medium text-white">
                  {user?.name?.charAt(0) || 'A'}
                </span>
              </div>
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-gray-900">{user?.name}</p>
              <p className="text-xs text-gray-500">
                {user?.adminRole === 'super_admin' && '슈퍼 관리자'}
                {user?.adminRole === 'admin' && '관리자'}
                {user?.adminRole === 'moderator' && '모더레이터'}
                {user?.adminRole === 'support' && '지원팀'}
              </p>
            </div>
          </div>
        </div>

        {/* 네비게이션 메뉴 */}
        <nav className="mt-4 px-4 space-y-2">
          {navigationItems.map((item, index) => (
            <AdminNavItem
              key={index}
              href={item.href}
              permissions={item.permissions}
              icon={item.icon}
              exact={item.exact}
            >
              {item.name}
            </AdminNavItem>
          ))}
        </nav>

        {/* 하단 로그아웃 */}
        <div className="absolute bottom-0 w-full p-4 border-t border-gray-200">
          <button
            onClick={() => {
              // 로그아웃 로직
              router.push('/');
            }}
            className="w-full flex items-center px-3 py-2 text-sm font-medium rounded-md text-gray-700 hover:bg-gray-100 hover:text-gray-900 transition-colors"
          >
            <span>메인으로 돌아가기</span>
          </button>
        </div>
      </div>

      {/* 메인 콘텐츠 */}
      <div className="pl-64">
        <main className="py-6">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/auth/layout.tsx">
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: '인증 - 워클리',
  description: '워클리 로그인 및 인증',
}

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen bg-background">
      {children}
    </div>
  )
}
</file>

<file path="frontend/src/app/goals/page.tsx">
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { 
  PlusIcon, 
  FlagIcon, 
  CheckCircleIcon, 
  ClockIcon, 
  ChartBarIcon,
  CalendarIcon,
  UsersIcon
} from '@heroicons/react/24/outline'
import Header from '@/components/layout/Header'
import MainContainer from '@/components/layout/MainContainer'
import FilterManager from '@/components/ui/FilterManager'
import WorklyFloatingActionButton from '@/components/ui/WorklyFloatingActionButton'
import LoginBanner from '@/components/ui/LoginBanner'
import { isAuthenticated } from '@/lib/auth'
import { 
  Goal, 
  GoalStatus, 
  GoalPriority, 
  GoalType, 
  GoalTimeframe,
  CreateGoalDto 
} from '@/shared/types/goal.types'

// 목업 목표 데이터
const mockGoals: Goal[] = [
  {
    id: '1',
    title: '워클리 플랫폼 완성',
    description: '사용자들이 목표를 효과적으로 관리할 수 있는 플랫폼 구축',
    status: GoalStatus.ACTIVE,
    priority: GoalPriority.HIGH,
    type: GoalType.ORGANIZATIONAL,
    timeframe: GoalTimeframe.MEDIUM_TERM,
    startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
    targetDate: new Date(Date.now() + 150 * 24 * 60 * 60 * 1000).toISOString(),
    progress: 75,
    metrics: [
      {
        id: 'm1',
        name: '사용자 등록 수',
        targetValue: 1000,
        currentValue: 750,
        unit: '명',
        description: '베타 테스트 사용자 확보'
      },
      {
        id: 'm2',
        name: '기능 완성도',
        targetValue: 100,
        currentValue: 85,
        unit: '%',
        description: '핵심 기능 개발 완료'
      }
    ],
    tags: ['플랫폼', 'MVP', '사업'],
    color: '#3B82F6',
    icon: '🚀',
    ownerId: 'user1',
    owner: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    projectCount: 3,
    completedProjectCount: 2,
    createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isOverdue: false,
    isDueSoon: false
  },
  {
    id: '2',
    title: '개인 역량 강화',
    description: '새로운 기술 스택 습득 및 전문성 향상',
    status: GoalStatus.ACTIVE,
    priority: GoalPriority.MEDIUM,
    type: GoalType.PERSONAL,
    timeframe: GoalTimeframe.LONG_TERM,
    startDate: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000).toISOString(),
    targetDate: new Date(Date.now() + 300 * 24 * 60 * 60 * 1000).toISOString(),
    progress: 45,
    metrics: [
      {
        id: 'm3',
        name: '학습 시간',
        targetValue: 200,
        currentValue: 90,
        unit: '시간',
        description: '온라인 강의 및 실습'
      }
    ],
    tags: ['학습', '역량개발', '개인성장'],
    color: '#10B981',
    icon: '📚',
    ownerId: 'user1',
    owner: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    projectCount: 2,
    completedProjectCount: 0,
    createdAt: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isOverdue: false,
    isDueSoon: false
  },
  {
    id: '3',
    title: '건강한 라이프 스타일',
    description: '규칙적인 운동과 건강한 식습관 유지',
    status: GoalStatus.COMPLETED,
    priority: GoalPriority.HIGH,
    type: GoalType.PERSONAL,
    timeframe: GoalTimeframe.SHORT_TERM,
    startDate: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(),
    targetDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    completedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    progress: 100,
    metrics: [
      {
        id: 'm4',
        name: '운동 일수',
        targetValue: 60,
        currentValue: 65,
        unit: '일',
        description: '3개월간 운동 지속'
      }
    ],
    tags: ['건강', '운동', '습관'],
    color: '#8B5CF6',
    icon: '💪',
    ownerId: 'user1',
    owner: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    projectCount: 1,
    completedProjectCount: 1,
    createdAt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    isOverdue: false,
    isDueSoon: false
  }
]

// 목표 카드 컴포넌트
function GoalCard({ goal, onClick }: { goal: Goal; onClick: () => void }) {
  const getStatusColor = (status: GoalStatus) => {
    switch (status) {
      case GoalStatus.ACTIVE: return 'text-blue-600 bg-blue-100'
      case GoalStatus.COMPLETED: return 'text-green-600 bg-green-100'
      case GoalStatus.ON_HOLD: return 'text-yellow-600 bg-yellow-100'
      case GoalStatus.CANCELLED: return 'text-red-600 bg-red-100'
      default: return 'text-gray-600 bg-gray-100'
    }
  }

  const getStatusLabel = (status: GoalStatus) => {
    switch (status) {
      case GoalStatus.ACTIVE: return '진행 중'
      case GoalStatus.COMPLETED: return '완료'
      case GoalStatus.ON_HOLD: return '보류'
      case GoalStatus.CANCELLED: return '취소'
      case GoalStatus.DRAFT: return '초안'
      default: return '알 수 없음'
    }
  }

  const getPriorityColor = (priority: GoalPriority) => {
    switch (priority) {
      case GoalPriority.URGENT: return 'text-red-600'
      case GoalPriority.HIGH: return 'text-orange-600'
      case GoalPriority.MEDIUM: return 'text-blue-600'
      case GoalPriority.LOW: return 'text-gray-600'
      default: return 'text-gray-600'
    }
  }

  return (
    <div 
      className="p-6 hover:bg-gray-50 transition-all duration-200 cursor-pointer group border-l-4"
      style={{ borderLeftColor: goal.color }}
      onClick={onClick}
    >
      {/* 목표 헤더 */}
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center space-x-3 flex-1">
          <div 
            className="w-12 h-12 rounded-lg flex items-center justify-center text-white font-semibold text-lg"
            style={{ backgroundColor: goal.color }}
          >
            {goal.icon}
          </div>
          <div className="flex-1">
            <div className="flex items-center space-x-2 mb-1">
              <h3 className="font-semibold text-gray-900 group-hover:text-gray-700">
                {goal.title}
              </h3>
              <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(goal.status)}`}>
                {getStatusLabel(goal.status)}
              </span>
            </div>
            <p className="text-sm text-gray-500 line-clamp-2">{goal.description}</p>
          </div>
        </div>
        <div className={`text-sm font-medium ${getPriorityColor(goal.priority)}`}>
          {goal.priority.toUpperCase()}
        </div>
      </div>

      {/* 진행률 */}
      <div className="mb-4">
        <div className="flex items-center justify-between text-sm mb-2">
          <span className="text-gray-600">목표 달성률</span>
          <span className="font-medium">{goal.progress}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div 
            className="h-2 rounded-full transition-all duration-300"
            style={{ 
              width: `${goal.progress}%`,
              backgroundColor: goal.color 
            }}
          />
        </div>
      </div>

      {/* 메트릭 정보 */}
      {goal.metrics.length > 0 && (
        <div className="mb-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {goal.metrics.slice(0, 2).map((metric) => (
              <div key={metric.id} className="bg-gray-50 rounded-lg p-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-gray-600">{metric.name}</span>
                  <span className="text-sm font-medium">
                    {metric.currentValue}/{metric.targetValue} {metric.unit}
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-1 mt-2">
                  <div 
                    className="h-1 rounded-full bg-blue-500 transition-all duration-300"
                    style={{ width: `${Math.min((metric.currentValue / metric.targetValue) * 100, 100)}%` }}
                  />
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* 프로젝트 및 일정 정보 */}
      <div className="flex items-center justify-between text-sm text-gray-500">
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-1">
            <UsersIcon className="w-4 h-4" />
            <span>{goal.completedProjectCount}/{goal.projectCount} 프로젝트</span>
          </div>
          {goal.targetDate && (
            <div className="flex items-center space-x-1">
              <CalendarIcon className="w-4 h-4" />
              <span>
                {new Date(goal.targetDate).toLocaleDateString('ko-KR')}까지
              </span>
            </div>
          )}
        </div>
        <div className="flex items-center space-x-1">
          <ChartBarIcon className="w-4 h-4 text-green-600" />
          <span className="text-green-600">순조롭게 진행</span>
        </div>
      </div>

      {/* 태그 */}
      {goal.tags.length > 0 && (
        <div className="flex flex-wrap gap-1 mt-3">
          {goal.tags.slice(0, 3).map((tag, index) => (
            <span
              key={index}
              className="inline-block px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full"
            >
              {tag}
            </span>
          ))}
          {goal.tags.length > 3 && (
            <span className="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded-full">
              +{goal.tags.length - 3}
            </span>
          )}
        </div>
      )}
    </div>
  )
}

export default function GoalsPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [goals, setGoals] = useState<Goal[]>(mockGoals)
  const [isLoading, setIsLoading] = useState(false)
  const [activeFilter, setActiveFilter] = useState('전체 목표')
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  // 필터 설정 상태
  const [showOnlyMyGoals, setShowOnlyMyGoals] = useState(false)
  const [goalSortOrder, setGoalSortOrder] = useState('progress')
  const [progressRange, setProgressRange] = useState<[number, number]>([0, 100])
  const [timeframeFilter, setTimeframeFilter] = useState<string[]>([])
  const [statusFilter, setStatusFilter] = useState('all')

  // 로그인 상태 초기화
  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  // 기본 필터 칩들
  const defaultChips = [
    { 
      id: 'all',
      label: '전체 목표', 
      isDefault: true,
      conditions: [],
      count: goals.length,
      icon: <FlagIcon className="w-4 h-4" />,
      color: 'gray' as const
    },
    { 
      id: 'active',
      label: '진행 중', 
      isDefault: true,
      conditions: [{ key: 'status', operator: 'equals' as const, value: GoalStatus.ACTIVE, label: '상태: 진행 중' }],
      count: goals.filter(g => g.status === GoalStatus.ACTIVE).length,
      icon: <ClockIcon className="w-4 h-4" />,
      color: 'blue' as const
    },
    { 
      id: 'completed',
      label: '완료됨', 
      isDefault: true,
      conditions: [{ key: 'status', operator: 'equals' as const, value: GoalStatus.COMPLETED, label: '상태: 완료' }],
      count: goals.filter(g => g.status === GoalStatus.COMPLETED).length,
      icon: <CheckCircleIcon className="w-4 h-4" />,
      color: 'green' as const
    },
    { 
      id: 'high-priority',
      label: '중요 목표', 
      isDefault: true,
      conditions: [{ key: 'priority', operator: 'in' as const, value: [GoalPriority.HIGH, GoalPriority.URGENT], label: '우선순위: 높음+긴급' }],
      count: goals.filter(g => g.priority === GoalPriority.HIGH || g.priority === GoalPriority.URGENT).length,
      icon: <ChartBarIcon className="w-4 h-4" />,
      color: 'orange' as const
    },
  ]

  // 필터링된 목표 목록
  const filteredGoals = goals.filter(goal => {
    switch (activeFilter) {
      case '진행 중':
        return goal.status === GoalStatus.ACTIVE
      case '완료됨':
        return goal.status === GoalStatus.COMPLETED
      case '중요 목표':
        return goal.priority === GoalPriority.HIGH || goal.priority === GoalPriority.URGENT
      case '전체 목표':
      default:
        return true
    }
  })


  const handleGoalClick = (goal: Goal) => {
    router.push(`/goals/${goal.id}`)
  }

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      {/* 헤더 */}
      <Header title="목표" />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 필터 관리자 - 로그인된 사용자만 표시 */}
        {isLoggedIn && (
          <div className="mb-0">
            <FilterManager
            defaultChips={defaultChips}
            activeChipId={activeFilter}
            onChipChange={setActiveFilter}
            settingsTitle="목표 필터 설정"
            settings={[
              {
                key: 'myOnly',
                label: '내 목표만',
                type: 'toggle',
                value: showOnlyMyGoals,
                onChange: setShowOnlyMyGoals
              },
              {
                key: 'progress',
                label: '달성률 범위',
                type: 'range',
                value: progressRange,
                onChange: setProgressRange
              },
              {
                key: 'timeframe',
                label: '시간 범위',
                type: 'tag-selector',
                value: timeframeFilter,
                options: ['short_term', 'medium_term', 'long_term'],
                onChange: setTimeframeFilter
              },
              {
                key: 'status',
                label: '상태',
                type: 'select',
                value: statusFilter,
                options: ['all', 'active', 'completed', 'on_hold'],
                onChange: setStatusFilter
              },
              {
                key: 'sort',
                label: '정렬 기준',
                type: 'select',
                value: goalSortOrder,
                options: ['progress', 'deadline', 'priority', 'created'],
                onChange: setGoalSortOrder
              }
            ]}
            getChipCount={(conditions) => {
              let filteredGoals = goals
              
              conditions.forEach(condition => {
                switch (condition.key) {
                  case 'status':
                    filteredGoals = filteredGoals.filter(g => g.status === condition.value)
                    break
                  case 'priority':
                    if (Array.isArray(condition.value)) {
                      filteredGoals = filteredGoals.filter(g => condition.value.includes(g.priority))
                    }
                    break
                }
              })
              
              return filteredGoals.length
            }}
            />
          </div>
        )}

        {/* 목표 목록 */}
        <div className="bg-white border border-gray-200 overflow-hidden">
          {isLoading ? (
            <div className="p-8 text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-600 mx-auto"></div>
              <p className="text-gray-500 mt-2">목표를 불러오는 중...</p>
            </div>
          ) : filteredGoals.length === 0 ? (
            <div className="p-8 text-center">
              <FlagIcon className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-600 mb-1">목표가 없습니다</h3>
              <p className="text-gray-500 text-sm mb-4">우측 하단의 수집함 버튼(+)을 눌러 목표를 추가해보세요!</p>
            </div>
          ) : (
            <div className="divide-y divide-gray-100">
              {filteredGoals.map((goal) => (
                <GoalCard
                  key={goal.id}
                  goal={goal}
                  onClick={() => handleGoalClick(goal)}
                />
              ))}
            </div>
          )}
        </div>
      </MainContainer>
      
      {/* 워클리 플로팅 액션 버튼 */}
      <WorklyFloatingActionButton 
        onTaskCreated={(task) => {
          console.log('CPER 업무 생성:', task)
          // TODO: 목표 관련 업무 생성 로직 구현
        }}
        onInboxItemCreated={(inboxItem) => {
          console.log('빠른 수집:', inboxItem)
          // TODO: 목표 관련 아이디어 수집 로직 구현
        }}
      />
    </div>
  )
}
</file>

<file path="frontend/src/app/inbox/page.tsx">
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { 
  PlusIcon, 
  InboxIcon, 
  ClockIcon, 
  CheckCircleIcon, 
  ExclamationTriangleIcon,
  DocumentTextIcon,
  LightBulbIcon,
  LinkIcon,
  MicrophoneIcon,
  CalendarIcon
} from '@heroicons/react/24/outline'
import Header from '@/components/layout/Header'
import MainContainer from '@/components/layout/MainContainer'
import FilterManager from '@/components/ui/FilterManager'
import WorklyFloatingActionButton from '@/components/ui/WorklyFloatingActionButton'
import LoginBanner from '@/components/ui/LoginBanner'
import PlanWorkflowModal from '@/components/workflow/PlanWorkflowModal'
import { isAuthenticated } from '@/lib/auth'
import { 
  InboxItem, 
  InboxItemType, 
  InboxItemStatus, 
  InboxItemPriority,
  QuickCaptureDto 
} from '@/shared/types/inbox.types'

// 목업 수집함 데이터 (CPER 워크플로우의 '수집' 단계)
const mockInboxItems: InboxItem[] = [
  {
    id: '1',
    title: '사용자 피드백 정리',
    content: '베타 테스트 사용자들로부터 받은 피드백을 정리하고 개선 방향 수립',
    type: InboxItemType.TASK_IDEA,
    status: InboxItemStatus.CAPTURED,
    priority: InboxItemPriority.HIGH,
    source: 'manual',
    captureContext: {
      timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString()
    },
    attachments: [],
    relatedUrls: [],
    tags: ['피드백', '개선', 'UX'],
    userId: 'user1',
    user: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    createdAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    daysSinceCapture: 0
  },
  {
    id: '2',
    title: '새로운 디자인 시스템 아이디어',
    content: '더 일관성 있는 UI를 위한 컴포넌트 기반 디자인 시스템 구축 아이디어',
    type: InboxItemType.PROJECT_IDEA,
    status: InboxItemStatus.CLARIFIED,
    priority: InboxItemPriority.MEDIUM,
    source: 'web_clipper',
    captureContext: {
      url: 'https://example.com/design-systems',
      timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
    },
    attachments: [],
    relatedUrls: ['https://example.com/design-systems'],
    tags: ['디자인', '시스템', 'UI'],
    scheduledFor: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    userId: 'user1',
    user: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(),
    daysSinceCapture: 1
  },
  {
    id: '3',
    title: '팀 회의 메모',
    content: '주간 스프린트 회의에서 논의된 주요 이슈들과 액션 아이템',
    type: InboxItemType.MEETING_NOTE,
    status: InboxItemStatus.ORGANIZED,
    priority: InboxItemPriority.MEDIUM,
    source: 'mobile_app',
    captureContext: {
      deviceType: 'iPhone',
      timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
    },
    attachments: [],
    relatedUrls: [],
    tags: ['회의', '스프린트', '액션아이템'],
    processedInto: {
      type: 'task',
      id: 'task-123',
      title: '스프린트 백로그 업데이트'
    },
    processedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    userId: 'user1',
    user: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    daysSinceCapture: 3
  },
  {
    id: '4',
    title: '영감을 주는 아티클',
    content: '생산성 앱의 미래에 대한 흥미로운 관점',
    type: InboxItemType.INSPIRATION,
    status: InboxItemStatus.DEFERRED,
    priority: InboxItemPriority.LOW,
    source: 'web_clipper',
    captureContext: {
      url: 'https://example.com/productivity-future',
      timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
    },
    attachments: [],
    relatedUrls: ['https://example.com/productivity-future'],
    tags: ['영감', '미래', '생산성'],
    scheduledFor: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
    userId: 'user1',
    user: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
    daysSinceCapture: 5
  }
]

// 타입별 아이콘 매핑
const getTypeIcon = (type: InboxItemType) => {
  switch (type) {
    case InboxItemType.QUICK_NOTE: return DocumentTextIcon
    case InboxItemType.TASK_IDEA: return CheckCircleIcon
    case InboxItemType.PROJECT_IDEA: return LightBulbIcon
    case InboxItemType.GOAL_IDEA: return LightBulbIcon
    case InboxItemType.MEETING_NOTE: return DocumentTextIcon
    case InboxItemType.FEEDBACK: return ExclamationTriangleIcon
    case InboxItemType.INSPIRATION: return LightBulbIcon
    case InboxItemType.REMINDER: return ClockIcon
    case InboxItemType.LINK: return LinkIcon
    case InboxItemType.FILE: return DocumentTextIcon
    default: return DocumentTextIcon
  }
}

// 상태별 색상 및 라벨
const getStatusInfo = (status: InboxItemStatus) => {
  switch (status) {
    case InboxItemStatus.CAPTURED:
      return { color: 'text-blue-600 bg-blue-100', label: '수집됨' }
    case InboxItemStatus.CLARIFIED:
      return { color: 'text-yellow-600 bg-yellow-100', label: '명확화됨' }
    case InboxItemStatus.ORGANIZED:
      return { color: 'text-green-600 bg-green-100', label: '정리됨' }
    case InboxItemStatus.DEFERRED:
      return { color: 'text-purple-600 bg-purple-100', label: '미루어짐' }
    default:
      return { color: 'text-gray-600 bg-gray-100', label: '알 수 없음' }
  }
}

// 우선순위 색상
const getPriorityColor = (priority: InboxItemPriority) => {
  switch (priority) {
    case InboxItemPriority.URGENT: return 'text-red-600'
    case InboxItemPriority.HIGH: return 'text-orange-600'
    case InboxItemPriority.MEDIUM: return 'text-blue-600'
    case InboxItemPriority.LOW: return 'text-gray-600'
    default: return 'text-gray-600'
  }
}

// 수집함 아이템 카드 컴포넌트
function InboxItemCard({ item, onClick }: { item: InboxItem; onClick: () => void }) {
  const TypeIcon = getTypeIcon(item.type)
  const statusInfo = getStatusInfo(item.status)
  
  return (
    <div 
      className="p-6 hover:bg-gray-50 transition-all duration-200 cursor-pointer group"
      onClick={onClick}
    >
      {/* 아이템 헤더 */}
      <div className="flex items-start justify-between mb-3">
        <div className="flex items-center space-x-3 flex-1">
          <div className="w-10 h-10 rounded-lg bg-amber-100 flex items-center justify-center">
            <TypeIcon className="w-5 h-5 text-amber-600" />
          </div>
          <div className="flex-1">
            <div className="flex items-center space-x-2 mb-1">
              <h3 className="font-medium text-gray-900 group-hover:text-gray-700">
                {item.title}
              </h3>
              <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${statusInfo.color}`}>
                {statusInfo.label}
              </span>
            </div>
            <p className="text-sm text-gray-500 line-clamp-2">{item.content}</p>
          </div>
        </div>
        <div className={`text-xs font-medium ${getPriorityColor(item.priority)}`}>
          {item.priority.toUpperCase()}
        </div>
      </div>

      {/* 처리 결과 (정리된 항목만) */}
      {item.processedInto && (
        <div className="mb-3 p-3 bg-green-50 rounded-lg border border-green-200">
          <div className="flex items-center space-x-2">
            <CheckCircleIcon className="w-4 h-4 text-green-600" />
            <span className="text-sm text-green-800">
              <span className="font-medium">{item.processedInto.type === 'task' ? '업무' : item.processedInto.type === 'project' ? '프로젝트' : '목표'}</span>로 전환: 
              <span className="ml-1">{item.processedInto.title}</span>
            </span>
          </div>
        </div>
      )}

      {/* 스케줄 정보 */}
      {item.scheduledFor && (
        <div className="mb-3 flex items-center space-x-2 text-sm text-gray-600">
          <CalendarIcon className="w-4 h-4" />
          <span>
            {new Date(item.scheduledFor).toLocaleDateString('ko-KR')}에 다시 검토
          </span>
        </div>
      )}

      {/* 메타 정보 */}
      <div className="flex items-center justify-between text-sm text-gray-500">
        <div className="flex items-center space-x-4">
          <span>{item.daysSinceCapture}일 전 수집</span>
          <span className="capitalize">{item.source.replace('_', ' ')}</span>
          {item.relatedUrls.length > 0 && (
            <div className="flex items-center space-x-1">
              <LinkIcon className="w-4 h-4" />
              <span>{item.relatedUrls.length}개 링크</span>
            </div>
          )}
        </div>
        <div className="text-xs">
          {new Date(item.createdAt).toLocaleTimeString('ko-KR', { 
            hour: '2-digit', 
            minute: '2-digit' 
          })}
        </div>
      </div>

      {/* 태그 */}
      {item.tags.length > 0 && (
        <div className="flex flex-wrap gap-1 mt-3">
          {item.tags.slice(0, 3).map((tag, index) => (
            <span
              key={index}
              className="inline-block px-2 py-1 text-xs bg-amber-100 text-amber-800 rounded-full"
            >
              {tag}
            </span>
          ))}
          {item.tags.length > 3 && (
            <span className="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded-full">
              +{item.tags.length - 3}
            </span>
          )}
        </div>
      )}
    </div>
  )
}

export default function InboxPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [inboxItems, setInboxItems] = useState<InboxItem[]>(mockInboxItems)
  const [isLoading, setIsLoading] = useState(false)
  const [activeFilter, setActiveFilter] = useState('모든 항목')
  const [isQuickCaptureOpen, setIsQuickCaptureOpen] = useState(false)
  const [quickCaptureText, setQuickCaptureText] = useState('')
  const [selectedItemForPlan, setSelectedItemForPlan] = useState<InboxItem | null>(null)
  const [isPlanModalOpen, setIsPlanModalOpen] = useState(false)
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  // 필터 설정 상태
  const [showOnlyPending, setShowOnlyPending] = useState(false)
  const [sortOrder, setSortOrder] = useState('recent')
  const [typeFilter, setTypeFilter] = useState<string[]>([])
  const [priorityFilter, setPriorityFilter] = useState<string[]>([])

  // 로그인 상태 초기화
  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  // 기본 필터 칩들 (CPER 워크플로우 기반)
  const defaultChips = [
    { 
      id: 'all',
      label: '모든 항목', 
      isDefault: true,
      conditions: [],
      count: inboxItems.length,
      icon: <InboxIcon className="w-4 h-4" />,
      color: 'gray' as const
    },
    { 
      id: 'captured',
      label: '수집됨', 
      isDefault: true,
      conditions: [{ key: 'status', operator: 'equals' as const, value: InboxItemStatus.CAPTURED, label: '상태: 수집됨' }],
      count: inboxItems.filter(i => i.status === InboxItemStatus.CAPTURED).length,
      icon: <InboxIcon className="w-4 h-4" />,
      color: 'blue' as const
    },
    { 
      id: 'clarified',
      label: '명확화됨', 
      isDefault: true,
      conditions: [{ key: 'status', operator: 'equals' as const, value: InboxItemStatus.CLARIFIED, label: '상태: 명확화됨' }],
      count: inboxItems.filter(i => i.status === InboxItemStatus.CLARIFIED).length,
      icon: <ClockIcon className="w-4 h-4" />,
      color: 'orange' as const
    },
    { 
      id: 'organized',
      label: '정리됨', 
      isDefault: true,
      conditions: [{ key: 'status', operator: 'equals' as const, value: InboxItemStatus.ORGANIZED, label: '상태: 정리됨' }],
      count: inboxItems.filter(i => i.status === InboxItemStatus.ORGANIZED).length,
      icon: <CheckCircleIcon className="w-4 h-4" />,
      color: 'green' as const
    },
    { 
      id: 'urgent',
      label: '긴급', 
      isDefault: true,
      conditions: [{ key: 'priority', operator: 'equals' as const, value: InboxItemPriority.URGENT, label: '우선순위: 긴급' }],
      count: inboxItems.filter(i => i.priority === InboxItemPriority.URGENT).length,
      icon: <ExclamationTriangleIcon className="w-4 h-4" />,
      color: 'red' as const
    },
  ]

  // 필터링된 수집함 항목
  const filteredItems = inboxItems.filter(item => {
    switch (activeFilter) {
      case '수집됨':
        return item.status === InboxItemStatus.CAPTURED
      case '명확화됨':
        return item.status === InboxItemStatus.CLARIFIED
      case '정리됨':
        return item.status === InboxItemStatus.ORGANIZED
      case '긴급':
        return item.priority === InboxItemPriority.URGENT
      case '모든 항목':
      default:
        return true
    }
  })

  // 쿼리 파라미터 처리
  useEffect(() => {
    const action = searchParams.get('action')
    if (action === 'quick-capture') {
      setIsQuickCaptureOpen(true)
      router.replace('/inbox')
    }
  }, [searchParams, router])

  const handleQuickCapture = () => {
    setIsQuickCaptureOpen(true)
  }

  const handleSubmitQuickCapture = () => {
    if (!quickCaptureText.trim()) return

    // 새 항목 생성 (목업)
    const newItem: InboxItem = {
      id: Date.now().toString(),
      title: quickCaptureText.trim(),
      content: quickCaptureText.trim(),
      type: InboxItemType.QUICK_NOTE,
      status: InboxItemStatus.CAPTURED,
      priority: InboxItemPriority.MEDIUM,
      source: 'manual',
      captureContext: {
        timestamp: new Date().toISOString()
      },
      attachments: [],
      relatedUrls: [],
      tags: [],
      userId: 'user1',
      user: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      daysSinceCapture: 0
    }

    setInboxItems(prev => [newItem, ...prev])
    setQuickCaptureText('')
    setIsQuickCaptureOpen(false)
  }

  const handleItemClick = (item: InboxItem) => {
    if (item.status === InboxItemStatus.CAPTURED || item.status === InboxItemStatus.CLARIFIED) {
      // 계획 모달 열기
      setSelectedItemForPlan(item)
      setIsPlanModalOpen(true)
    } else {
      router.push(`/inbox/${item.id}`)
    }
  }

  const handlePlanComplete = (processedItem: InboxItem) => {
    setInboxItems(prev => prev.map(item => 
      item.id === processedItem.id ? processedItem : item
    ))
    setSelectedItemForPlan(null)
    setIsPlanModalOpen(false)
  }

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      {/* 헤더 */}
      <Header title="수집함" />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* CPER 워크플로우 인디케이터 */}
      <div className="bg-gradient-to-r from-amber-500 to-orange-500 text-white px-6 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <InboxIcon className="w-5 h-5" />
            <span className="font-medium">CPER 워크플로우 - 수집(Capture) 단계</span>
          </div>
          <button
            onClick={handleQuickCapture}
            className="flex items-center space-x-2 px-3 py-1 bg-white bg-opacity-20 rounded-lg hover:bg-opacity-30 transition-colors"
          >
            <PlusIcon className="w-4 h-4" />
            <span className="text-sm">빠른 수집</span>
          </button>
        </div>
      </div>
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 필터 관리자 - 로그인된 사용자만 표시 */}
        {isLoggedIn && (
          <div className="mb-0">
            <FilterManager
            defaultChips={defaultChips}
            activeChipId={activeFilter}
            onChipChange={setActiveFilter}
            settingsTitle="수집함 필터 설정"
            settings={[
              {
                key: 'pendingOnly',
                label: '처리 대기 항목만',
                type: 'toggle',
                value: showOnlyPending,
                onChange: setShowOnlyPending
              },
              {
                key: 'type',
                label: '항목 유형',
                type: 'tag-selector',
                value: typeFilter,
                options: ['quick_note', 'task_idea', 'project_idea', 'meeting_note', 'inspiration'],
                onChange: setTypeFilter
              },
              {
                key: 'priority',
                label: '우선순위',
                type: 'tag-selector',
                value: priorityFilter,
                options: ['urgent', 'high', 'medium', 'low'],
                onChange: setPriorityFilter
              },
              {
                key: 'sort',
                label: '정렬 기준',
                type: 'select',
                value: sortOrder,
                options: ['recent', 'priority', 'type', 'status'],
                onChange: setSortOrder
              }
            ]}
            getChipCount={(conditions) => {
              let filteredItems = inboxItems
              
              conditions.forEach(condition => {
                switch (condition.key) {
                  case 'status':
                    filteredItems = filteredItems.filter(i => i.status === condition.value)
                    break
                  case 'priority':
                    filteredItems = filteredItems.filter(i => i.priority === condition.value)
                    break
                }
              })
              
              return filteredItems.length
            }}
            />
          </div>
        )}

        {/* 수집함 항목 목록 */}
        <div className="bg-white border border-gray-200 overflow-hidden">
          {isLoading ? (
            <div className="p-8 text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-amber-600 mx-auto"></div>
              <p className="text-gray-500 mt-2">수집함을 불러오는 중...</p>
            </div>
          ) : filteredItems.length === 0 ? (
            <div className="p-8 text-center">
              <InboxIcon className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-600 mb-1">수집함이 비어있습니다</h3>
              <p className="text-gray-500 text-sm mb-4">아이디어나 할 일을 빠르게 수집해보세요!</p>
              <button
                onClick={handleQuickCapture}
                className="inline-flex items-center space-x-2 px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600"
              >
                <PlusIcon className="w-4 h-4" />
                <span>빠른 수집</span>
              </button>
            </div>
          ) : (
            <div className="divide-y divide-gray-100">
              {filteredItems.map((item) => (
                <InboxItemCard
                  key={item.id}
                  item={item}
                  onClick={() => handleItemClick(item)}
                />
              ))}
            </div>
          )}
        </div>
      </MainContainer>
      
      {/* 워클리 플로팅 액션 버튼 */}
      <WorklyFloatingActionButton 
        onTaskCreated={(task) => {
          console.log('CPER 업무 생성:', task)
          // TODO: 수집함에서 업무 생성 로직 구현
        }}
        onInboxItemCreated={(inboxItem) => {
          console.log('빠른 수집:', inboxItem)
          // 수집함 페이지에서는 빠른 수집이 바로 목록에 추가되어야 함
          setInboxItems(prev => [inboxItem, ...prev])
        }}
      />

      {/* 빠른 수집 모달 */}
      {isQuickCaptureOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-25">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <div className="flex items-center space-x-2 mb-4">
              <InboxIcon className="w-5 h-5 text-amber-600" />
              <h3 className="text-lg font-semibold">빠른 수집</h3>
            </div>
            <textarea
              value={quickCaptureText}
              onChange={(e) => setQuickCaptureText(e.target.value)}
              placeholder="떠오른 아이디어나 할 일을 입력하세요..."
              className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-transparent resize-none"
              rows={4}
              autoFocus
            />
            <div className="flex justify-end space-x-3 mt-4">
              <button
                onClick={() => setIsQuickCaptureOpen(false)}
                className="px-4 py-2 text-gray-600 hover:text-gray-800"
              >
                취소
              </button>
              <button
                onClick={handleSubmitQuickCapture}
                disabled={!quickCaptureText.trim()}
                className="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                수집하기
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 계획 워크플로우 모달 */}
      {selectedItemForPlan && (
        <PlanWorkflowModal
          isOpen={isPlanModalOpen}
          onClose={() => {
            setIsPlanModalOpen(false)
            setSelectedItemForPlan(null)
          }}
          inboxItem={selectedItemForPlan}
          onProcessComplete={handlePlanComplete}
        />
      )}
    </div>
  )
}
</file>

<file path="frontend/src/app/profile/page.tsx">
'use client'

import { useState } from 'react'
import { 
  UserIcon,
  ChartBarIcon,
  StarIcon,
  TrophyIcon,
  FireIcon,
  UsersIcon,
  ChevronRightIcon,
  ClockIcon,
  FolderIcon,
  DocumentTextIcon
} from '@heroicons/react/24/outline'
import {
  TrophyIcon as TrophyIconSolid,
  StarIcon as StarIconSolid
} from '@heroicons/react/24/solid'
import Header from '@/components/layout/Header'
import MainContainer from '@/components/layout/MainContainer'
import WorklyFloatingActionButton from '@/components/ui/WorklyFloatingActionButton'
import LoginBanner from '@/components/ui/LoginBanner'
import ReviewWorkflowDashboard from '@/components/workflow/ReviewWorkflowDashboard'

// 목업 사용자 데이터
const mockUser = {
  id: 'user1',
  name: '김워클리',
  email: 'workly@example.com',
  avatar: null,
  joinedAt: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString(),
  worklyMethodologyAdoption: '85%',
  cperCyclesCompleted: 24,
  totalTasksCompleted: 156,
  currentStreak: 7,
  // 게이미피케이션 데이터
  level: 12,
  currentXP: 2850,
  nextLevelXP: 3200,
  reputation: 1425,
  totalBadges: 8,
  currentSeason: 'Q4 - 비전가 시즌',
  seasonRank: 156,
  totalUsers: 2847,
  followers: 23,
  following: 18
}

// 목업 업적/배지 데이터
const mockBadges = [
  { id: 1, name: '첫 걸음', description: '첫 번째 업무 완료', icon: '🎯', rarity: 'common', earned: true },
  { id: 2, name: '연속 도전자', description: '7일 연속 업무 완료', icon: '🔥', rarity: 'rare', earned: true },
  { id: 3, name: '협업의 달인', description: '10개 프로젝트 완료', icon: '🤝', rarity: 'epic', earned: true },
  { id: 4, name: '지식 나눔이', description: '위키 문서 5개 작성', icon: '📚', rarity: 'rare', earned: false }
]

// 목업 스킬 데이터
const mockSkills = [
  { name: 'UX 디자인', level: 8, progress: 75, category: 'Design' },
  { name: '프로젝트 관리', level: 6, progress: 40, category: 'Management' },
  { name: 'React 개발', level: 9, progress: 20, category: 'Development' },
  { name: '데이터 분석', level: 4, progress: 85, category: 'Analysis' }
]

// 목업 최근 활동 데이터
const mockRecentActivities = [
  { id: 1, type: 'task', title: '사용자 인터페이스 리뷰 완료', time: '2시간 전', xp: 50 },
  { id: 2, type: 'project', title: '워클리 프론트엔드 프로젝트 참여', time: '1일 전', xp: 100 },
  { id: 3, type: 'badge', title: '협업의 달인 배지 획득', time: '3일 전', xp: 200 },
  { id: 4, type: 'wiki', title: 'React 최적화 가이드 작성', time: '1주 전', xp: 75 }
]

// 프로필 페이지는 활동 기능에 집중

export default function ProfilePage() {
  const [showReviewDashboard, setShowReviewDashboard] = useState(false)

  const handleLogout = () => {
    console.log('로그아웃')
    // TODO: 로그아웃 처리
  }

  if (showReviewDashboard) {
    return (
      <div className="min-h-screen bg-gray-50">
        <Header title="주간 리뷰" />
        <LoginBanner />
        <MainContainer>
          <div className="mb-4">
            <button
              onClick={() => setShowReviewDashboard(false)}
              className="px-3 py-1 text-sm bg-gray-600 text-white rounded-lg hover:bg-gray-700"
            >
              ← 프로필로 돌아가기
            </button>
          </div>
          <ReviewWorkflowDashboard />
        </MainContainer>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      {/* 헤더 */}
      <Header title="프로필" />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 사용자 정보 카드 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center space-x-4 mb-4">
            <div className="w-16 h-16 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 flex items-center justify-center">
              {mockUser.avatar ? (
                <img 
                  src={mockUser.avatar} 
                  alt={mockUser.name}
                  className="w-16 h-16 rounded-full object-cover"
                />
              ) : (
                <UserIcon className="w-8 h-8 text-white" />
              )}
            </div>
            <div>
              <h2 className="text-xl font-bold text-gray-900">{mockUser.name}</h2>
              <p className="text-gray-600">{mockUser.email}</p>
              <p className="text-sm text-gray-500">
                {new Date(mockUser.joinedAt).toLocaleDateString('ko-KR')}부터 워클리 사용
              </p>
            </div>
          </div>
          
          {/* 워클리 방법론 통계 */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-6">
            <div className="text-center">
              <div className="text-2xl font-bold text-blue-600">{mockUser.worklyMethodologyAdoption}</div>
              <div className="text-sm text-gray-500">방법론 활용도</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-green-600">{mockUser.cperCyclesCompleted}</div>
              <div className="text-sm text-gray-500">CPER 사이클</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-purple-600">{mockUser.totalTasksCompleted}</div>
              <div className="text-sm text-gray-500">완료한 업무</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-amber-600">{mockUser.currentStreak}</div>
              <div className="text-sm text-gray-500">연속 실행 일</div>
            </div>
          </div>
        </div>

        {/* CPER 리뷰 섹션 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">CPER 워크플로우 리뷰</h3>
              <p className="text-gray-600 text-sm">주간 성과를 분석하고 개선점을 찾아보세요</p>
            </div>
            <button
              onClick={() => setShowReviewDashboard(true)}
              className="flex items-center space-x-2 px-4 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg hover:from-blue-700 hover:to-purple-700"
            >
              <ChartBarIcon className="w-4 h-4" />
              <span>리뷰 시작</span>
            </button>
          </div>
          
          {/* 간단한 미리보기 */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="bg-blue-50 rounded-lg p-4">
              <div className="text-blue-600 font-semibold text-sm mb-1">이번 주 완료율</div>
              <div className="text-2xl font-bold text-blue-900">78%</div>
            </div>
            <div className="bg-green-50 rounded-lg p-4">
              <div className="text-green-600 font-semibold text-sm mb-1">집중 시간</div>
              <div className="text-2xl font-bold text-green-900">18.2h</div>
            </div>
            <div className="bg-purple-50 rounded-lg p-4">
              <div className="text-purple-600 font-semibold text-sm mb-1">생산성 지수</div>
              <div className="text-2xl font-bold text-purple-900">85</div>
            </div>
          </div>
        </div>

        {/* 성장 시스템 대시보드 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">성장 시스템</h3>
              <p className="text-gray-600 text-sm">레벨, 경험치, 업적을 확인하세요</p>
            </div>
            <div className="flex items-center space-x-2 text-amber-600">
              <TrophyIconSolid className="w-5 h-5" />
              <span className="font-bold">Level {mockUser.level}</span>
            </div>
          </div>
          
          {/* XP 진행률 바 */}
          <div className="mb-6">
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium text-gray-600">경험치 (XP)</span>
              <span className="text-sm text-gray-500">{mockUser.currentXP} / {mockUser.nextLevelXP}</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-3">
              <div 
                className="bg-gradient-to-r from-blue-400 to-blue-600 h-3 rounded-full transition-all duration-300"
                style={{ width: `${(mockUser.currentXP / mockUser.nextLevelXP) * 100}%` }}
              ></div>
            </div>
            <p className="text-xs text-gray-500 mt-1">다음 레벨까지 {mockUser.nextLevelXP - mockUser.currentXP} XP</p>
          </div>

          {/* 핵심 지표 */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="text-center p-3 bg-gradient-to-br from-purple-50 to-purple-100 rounded-lg">
              <div className="flex items-center justify-center mb-2">
                <StarIconSolid className="w-6 h-6 text-purple-600" />
              </div>
              <div className="text-xl font-bold text-purple-700">{mockUser.reputation}</div>
              <div className="text-xs text-purple-600">평판 점수</div>
            </div>
            <div className="text-center p-3 bg-gradient-to-br from-amber-50 to-amber-100 rounded-lg">
              <div className="flex items-center justify-center mb-2">
                <TrophyIconSolid className="w-6 h-6 text-amber-600" />
              </div>
              <div className="text-xl font-bold text-amber-700">{mockUser.totalBadges}</div>
              <div className="text-xs text-amber-600">획득 배지</div>
            </div>
            <div className="text-center p-3 bg-gradient-to-br from-blue-50 to-blue-100 rounded-lg">
              <div className="flex items-center justify-center mb-2">
                <FireIcon className="w-6 h-6 text-blue-600" />
              </div>
              <div className="text-xl font-bold text-blue-700">{mockUser.seasonRank}</div>
              <div className="text-xs text-blue-600">시즌 순위</div>
            </div>
            <div className="text-center p-3 bg-gradient-to-br from-green-50 to-green-100 rounded-lg">
              <div className="flex items-center justify-center mb-2">
                <UsersIcon className="w-6 h-6 text-green-600" />
              </div>
              <div className="text-xl font-bold text-green-700">{mockUser.followers}</div>
              <div className="text-xs text-green-600">팔로워</div>
            </div>
          </div>
        </div>

        {/* 업적 및 배지 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">업적 및 배지</h3>
              <p className="text-gray-600 text-sm">달성한 업적과 획득한 배지를 확인하세요</p>
            </div>
            <button className="text-blue-600 hover:text-blue-700 text-sm font-medium flex items-center">
              전체 보기
              <ChevronRightIcon className="w-4 h-4 ml-1" />
            </button>
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {mockBadges.map((badge) => (
              <div 
                key={badge.id}
                className={`p-4 rounded-lg border-2 transition-all ${
                  badge.earned 
                    ? 'border-gray-200 bg-white shadow-sm' 
                    : 'border-dashed border-gray-300 bg-gray-50 opacity-60'
                }`}
              >
                <div className="text-center">
                  <div className="text-3xl mb-2">{badge.icon}</div>
                  <div className={`font-semibold text-sm ${badge.earned ? 'text-gray-900' : 'text-gray-500'}`}>
                    {badge.name}
                  </div>
                  <div className={`text-xs mt-1 ${badge.earned ? 'text-gray-600' : 'text-gray-400'}`}>
                    {badge.description}
                  </div>
                  <div className={`inline-block px-2 py-1 mt-2 rounded-full text-xs font-medium ${
                    badge.rarity === 'epic' ? 'bg-purple-100 text-purple-700' :
                    badge.rarity === 'rare' ? 'bg-blue-100 text-blue-700' :
                    'bg-gray-100 text-gray-700'
                  }`}>
                    {badge.rarity === 'epic' ? '전설' : badge.rarity === 'rare' ? '희귀' : '일반'}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* 스킬 트리 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">스킬 트리</h3>
              <p className="text-gray-600 text-sm">전문 분야별 역량 개발 현황</p>
            </div>
            <button className="text-blue-600 hover:text-blue-700 text-sm font-medium flex items-center">
              상세 보기
              <ChevronRightIcon className="w-4 h-4 ml-1" />
            </button>
          </div>
          
          <div className="space-y-4">
            {mockSkills.map((skill, index) => (
              <div key={index} className="border rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <div>
                    <span className="font-semibold text-gray-900">{skill.name}</span>
                    <span className="ml-2 px-2 py-1 bg-gray-100 rounded-full text-xs text-gray-600">
                      {skill.category}
                    </span>
                  </div>
                  <div className="text-right">
                    <div className="text-lg font-bold text-blue-600">Lv.{skill.level}</div>
                  </div>
                </div>
                <div className="flex items-center">
                  <div className="flex-1 bg-gray-200 rounded-full h-2 mr-3">
                    <div 
                      className="bg-gradient-to-r from-blue-500 to-purple-500 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${skill.progress}%` }}
                    ></div>
                  </div>
                  <span className="text-sm text-gray-500 w-12">{skill.progress}%</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* 시즌 및 리더보드 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">현재 시즌</h3>
              <p className="text-gray-600 text-sm">{mockUser.currentSeason}</p>
            </div>
            <div className="text-right">
              <div className="text-2xl font-bold text-indigo-600">#{mockUser.seasonRank}</div>
              <div className="text-xs text-gray-500">/ {mockUser.totalUsers}명</div>
            </div>
          </div>
          
          <div className="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-lg p-4">
            <div className="flex items-center justify-between">
              <div>
                <div className="font-semibold text-indigo-900">비전가 시즌 도전과제</div>
                <div className="text-sm text-indigo-700 mt-1">회고와 장기 목표 설정에 집중하세요</div>
              </div>
              <div className="text-3xl">🌟</div>
            </div>
          </div>
        </div>

        {/* 최근 활동 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">최근 활동</h3>
              <p className="text-gray-600 text-sm">최근 완료한 업무와 참여한 활동들</p>
            </div>
            <button className="text-blue-600 hover:text-blue-700 text-sm font-medium flex items-center">
              전체 히스토리
              <ChevronRightIcon className="w-4 h-4 ml-1" />
            </button>
          </div>
          
          <div className="space-y-3">
            {mockRecentActivities.map((activity) => (
              <div key={activity.id} className="flex items-center justify-between p-3 hover:bg-gray-50 rounded-lg transition-colors">
                <div className="flex items-center space-x-3">
                  <div className={`w-8 h-8 rounded-full flex items-center justify-center ${
                    activity.type === 'task' ? 'bg-blue-100' :
                    activity.type === 'project' ? 'bg-green-100' :
                    activity.type === 'badge' ? 'bg-purple-100' :
                    'bg-amber-100'
                  }`}>
                    {activity.type === 'task' && <ClockIcon className="w-4 h-4 text-blue-600" />}
                    {activity.type === 'project' && <FolderIcon className="w-4 h-4 text-green-600" />}
                    {activity.type === 'badge' && <TrophyIcon className="w-4 h-4 text-purple-600" />}
                    {activity.type === 'wiki' && <DocumentTextIcon className="w-4 h-4 text-amber-600" />}
                  </div>
                  <div>
                    <div className="font-medium text-gray-900">{activity.title}</div>
                    <div className="text-sm text-gray-500">{activity.time}</div>
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-sm font-semibold text-amber-600">+{activity.xp} XP</div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* 소셜 네트워크 */}
        <div className="bg-white rounded-lg border p-6 mb-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">네트워크</h3>
              <p className="text-gray-600 text-sm">팔로워와 팔로잉 현황</p>
            </div>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div className="text-center p-4 bg-blue-50 rounded-lg">
              <div className="text-2xl font-bold text-blue-600">{mockUser.followers}</div>
              <div className="text-sm text-blue-700">팔로워</div>
            </div>
            <div className="text-center p-4 bg-green-50 rounded-lg">
              <div className="text-2xl font-bold text-green-600">{mockUser.following}</div>
              <div className="text-sm text-green-700">팔로잉</div>
            </div>
          </div>
        </div>
      </MainContainer>
      
      {/* 워클리 플로팅 액션 버튼 */}
      <WorklyFloatingActionButton 
        onAddTask={() => console.log('업무 추가')}
        onAddProject={() => console.log('프로젝트 추가')}
        onAddGoal={() => console.log('목표 추가')}
      />
    </div>
  )
}
</file>

<file path="frontend/src/components/admin/AdminButton.tsx">
'use client';

import { ReactNode, ButtonHTMLAttributes } from 'react';
import PermissionGuard from './PermissionGuard';

interface AdminButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  /**
   * 필요한 권한 목록
   */
  permissions: string | string[];
  
  /**
   * 권한 확인 모드
   */
  mode?: 'all' | 'any';
  
  /**
   * 위험한 액션임을 나타내는 스타일 적용
   */
  variant?: 'primary' | 'secondary' | 'danger';
  
  /**
   * 버튼 크기
   */
  size?: 'sm' | 'md' | 'lg';
  
  /**
   * 로딩 상태
   */
  loading?: boolean;
  
  /**
   * 권한이 없을 때 보여줄 내용 (기본: 숨김)
   */
  fallback?: ReactNode;
  
  children: ReactNode;
}

/**
 * 권한 기반 어드민 버튼 컴포넌트
 * 사용자의 권한에 따라 버튼을 표시/숨김 처리
 * 
 * @example
 * <AdminButton 
 *   permissions="admin:users:delete"
 *   variant="danger"
 *   onClick={handleDeleteUser}
 * >
 *   사용자 삭제
 * </AdminButton>
 */
export default function AdminButton({
  permissions,
  mode = 'all',
  variant = 'primary',
  size = 'md',
  loading = false,
  fallback,
  className = '',
  children,
  disabled,
  ...props
}: AdminButtonProps) {
  // 기본 스타일 클래스
  const baseClasses = [
    'inline-flex items-center justify-center font-medium rounded-md',
    'focus:outline-none focus:ring-2 focus:ring-offset-2',
    'transition-colors duration-200',
    'disabled:opacity-50 disabled:cursor-not-allowed',
  ];

  // 크기별 클래스
  const sizeClasses = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-sm',
    lg: 'px-6 py-3 text-base',
  };

  // 변형별 클래스
  const variantClasses = {
    primary: [
      'bg-indigo-600 text-white',
      'hover:bg-indigo-700',
      'focus:ring-indigo-500',
      'disabled:bg-indigo-300',
    ].join(' '),
    secondary: [
      'bg-white text-gray-700 border border-gray-300',
      'hover:bg-gray-50',
      'focus:ring-indigo-500',
      'disabled:bg-gray-100',
    ].join(' '),
    danger: [
      'bg-red-600 text-white',
      'hover:bg-red-700',
      'focus:ring-red-500',
      'disabled:bg-red-300',
    ].join(' '),
  };

  // 최종 클래스 조합
  const buttonClasses = [
    ...baseClasses,
    sizeClasses[size],
    variantClasses[variant],
    className,
  ].join(' ');

  const buttonContent = (
    <button
      {...props}
      className={buttonClasses}
      disabled={disabled || loading}
    >
      {loading && (
        <svg
          className={`animate-spin -ml-1 mr-2 ${size === 'sm' ? 'h-3 w-3' : size === 'lg' ? 'h-5 w-5' : 'h-4 w-4'} text-current`}
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      )}
      {children}
    </button>
  );

  return (
    <PermissionGuard 
      permissions={permissions} 
      mode={mode}
      fallback={fallback}
    >
      {buttonContent}
    </PermissionGuard>
  );
}

/**
 * 사용자 삭제 전용 버튼
 */
export function DeleteUserButton({
  onClick,
  loading,
  children = '삭제',
  ...props
}: Omit<AdminButtonProps, 'permissions' | 'variant'> & {
  onClick?: () => void;
}) {
  return (
    <AdminButton
      permissions="admin:users:delete"
      variant="danger"
      size="sm"
      onClick={onClick}
      loading={loading}
      {...props}
    >
      {children}
    </AdminButton>
  );
}

/**
 * 사용자 편집 전용 버튼
 */
export function EditUserButton({
  onClick,
  loading,
  children = '편집',
  ...props
}: Omit<AdminButtonProps, 'permissions' | 'variant'> & {
  onClick?: () => void;
}) {
  return (
    <AdminButton
      permissions="admin:users:update"
      variant="secondary"
      size="sm"
      onClick={onClick}
      loading={loading}
      {...props}
    >
      {children}
    </AdminButton>
  );
}

/**
 * 프로젝트 삭제 전용 버튼
 */
export function DeleteProjectButton({
  onClick,
  loading,
  children = '삭제',
  ...props
}: Omit<AdminButtonProps, 'permissions' | 'variant'> & {
  onClick?: () => void;
}) {
  return (
    <AdminButton
      permissions="admin:projects:delete"
      variant="danger"
      size="sm"
      onClick={onClick}
      loading={loading}
      {...props}
    >
      {children}
    </AdminButton>
  );
}
</file>

<file path="frontend/src/components/admin/AdminNavItem.tsx">
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { ReactNode } from 'react';
import PermissionGuard from './PermissionGuard';

interface AdminNavItemProps {
  /**
   * 링크 경로
   */
  href: string;
  
  /**
   * 필요한 권한
   */
  permissions: string | string[];
  
  /**
   * 권한 확인 모드
   */
  mode?: 'all' | 'any';
  
  /**
   * 아이콘 컴포넌트
   */
  icon?: React.ComponentType<{ className?: string }>;
  
  /**
   * 뱃지 표시 (알림 개수 등)
   */
  badge?: number | string;
  
  /**
   * 외부 링크 여부
   */
  external?: boolean;
  
  /**
   * 정확한 경로 매칭 여부 (기본: false)
   */
  exact?: boolean;
  
  children: ReactNode;
}

/**
 * 권한 기반 어드민 네비게이션 아이템 컴포넌트
 * 사용자의 권한에 따라 네비게이션 아이템을 표시/숨김 처리
 * 
 * @example
 * <AdminNavItem 
 *   href="/admin/users"
 *   permissions="admin:users:read"
 *   icon={UsersIcon}
 * >
 *   사용자 관리
 * </AdminNavItem>
 */
export default function AdminNavItem({
  href,
  permissions,
  mode = 'all',
  icon: Icon,
  badge,
  external = false,
  exact = false,
  children,
}: AdminNavItemProps) {
  const pathname = usePathname();
  
  // 활성 상태 확인
  const isActive = exact 
    ? pathname === href
    : pathname.startsWith(href);

  // 기본 스타일 클래스
  const baseClasses = [
    'group flex items-center px-3 py-2 text-sm font-medium rounded-md',
    'transition-colors duration-200',
  ];

  // 활성/비활성 상태 클래스
  const stateClasses = isActive
    ? 'bg-indigo-100 text-indigo-700'
    : 'text-gray-700 hover:bg-gray-100 hover:text-gray-900';

  // 최종 클래스 조합
  const linkClasses = [...baseClasses, stateClasses].join(' ');

  // 아이콘 클래스
  const iconClasses = [
    'mr-3 h-5 w-5',
    isActive 
      ? 'text-indigo-500' 
      : 'text-gray-400 group-hover:text-gray-500'
  ].join(' ');

  const linkContent = (
    <div className="flex items-center justify-between w-full">
      <div className="flex items-center">
        {Icon && <Icon className={iconClasses} />}
        <span>{children}</span>
      </div>
      {badge && (
        <span className={`ml-2 inline-flex items-center justify-center px-2 py-0.5 rounded-full text-xs font-medium ${
          isActive 
            ? 'bg-indigo-200 text-indigo-800' 
            : 'bg-gray-200 text-gray-800'
        }`}>
          {badge}
        </span>
      )}
    </div>
  );

  const LinkComponent = external ? 'a' : Link;
  const linkProps = external 
    ? { href, target: '_blank', rel: 'noopener noreferrer' }
    : { href };

  return (
    <PermissionGuard permissions={permissions} mode={mode}>
      <LinkComponent {...linkProps} className={linkClasses}>
        {linkContent}
      </LinkComponent>
    </PermissionGuard>
  );
}

/**
 * 어드민 네비게이션 그룹 컴포넌트
 * 관련된 네비게이션 아이템들을 그룹화
 */
interface AdminNavGroupProps {
  /**
   * 그룹 제목
   */
  title: string;
  
  /**
   * 그룹 전체에 적용할 권한 (선택적)
   */
  permissions?: string | string[];
  
  /**
   * 권한 확인 모드
   */
  mode?: 'all' | 'any';
  
  /**
   * 접힐 수 있는 그룹 여부
   */
  collapsible?: boolean;
  
  /**
   * 초기 접힘 상태 (collapsible이 true일 때만 적용)
   */
  defaultCollapsed?: boolean;
  
  children: ReactNode;
}

export function AdminNavGroup({
  title,
  permissions,
  mode = 'all',
  collapsible = false,
  defaultCollapsed = false,
  children,
}: AdminNavGroupProps) {
  const [isCollapsed, setIsCollapsed] = React.useState(defaultCollapsed);

  const groupContent = (
    <div className="mb-4">
      <div className="flex items-center justify-between mb-2">
        <h3 className="px-3 text-xs font-semibold text-gray-500 uppercase tracking-wider">
          {title}
        </h3>
        {collapsible && (
          <button
            onClick={() => setIsCollapsed(!isCollapsed)}
            className="p-1 text-gray-400 hover:text-gray-600"
          >
            <svg
              className={`h-4 w-4 transform transition-transform ${
                isCollapsed ? 'rotate-0' : 'rotate-180'
              }`}
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>
        )}
      </div>
      {(!collapsible || !isCollapsed) && (
        <div className="space-y-1">
          {children}
        </div>
      )}
    </div>
  );

  return permissions ? (
    <PermissionGuard permissions={permissions} mode={mode}>
      {groupContent}
    </PermissionGuard>
  ) : (
    groupContent
  );
}

// React import for useState
import React from 'react';
</file>

<file path="frontend/src/components/admin/index.ts">
// 어드민 컴포넌트 통합 내보내기
export { default as PermissionGuard, usePermissions } from './PermissionGuard';
export { 
  default as AdminButton,
  DeleteUserButton,
  EditUserButton,
  DeleteProjectButton,
} from './AdminButton';
export { 
  default as AdminNavItem,
  AdminNavGroup,
} from './AdminNavItem';

// 권한 상수들
export const ADMIN_PERMISSIONS = {
  // 사용자 관리
  USERS_READ: 'admin:users:read',
  USERS_CREATE: 'admin:users:create',
  USERS_UPDATE: 'admin:users:update',
  USERS_DELETE: 'admin:users:delete',
  
  // 역할 관리
  ROLES_MANAGE: 'admin:roles:manage',
  
  // 프로젝트 관리
  PROJECTS_READ: 'admin:projects:read',
  PROJECTS_CREATE: 'admin:projects:create',
  PROJECTS_UPDATE: 'admin:projects:update',
  PROJECTS_DELETE: 'admin:projects:delete',
  
  // 업무 관리
  TASKS_READ: 'admin:tasks:read',
  TASKS_CREATE: 'admin:tasks:create',
  TASKS_UPDATE: 'admin:tasks:update',
  TASKS_DELETE: 'admin:tasks:delete',
  
  // 시스템 설정
  SETTINGS_READ: 'admin:settings:read',
  SETTINGS_UPDATE: 'admin:settings:update',
  
  // 감사 로그
  AUDIT_READ: 'admin:audit:read',
  
  // 대시보드
  DASHBOARD_READ: 'admin:dashboard:read',
  
  // 프로필 관리
  PROFILE_READ: 'admin:profile:read',
  PROFILE_UPDATE: 'admin:profile:update',
} as const;

// 역할별 기본 권한 그룹 (읽기 전용)
export const ROLE_PERMISSION_GROUPS = {
  SUPER_ADMIN: Object.values(ADMIN_PERMISSIONS),
  
  ADMIN: [
    ADMIN_PERMISSIONS.USERS_READ,
    ADMIN_PERMISSIONS.USERS_CREATE,
    ADMIN_PERMISSIONS.USERS_UPDATE,
    ADMIN_PERMISSIONS.PROJECTS_READ,
    ADMIN_PERMISSIONS.PROJECTS_CREATE,
    ADMIN_PERMISSIONS.PROJECTS_UPDATE,
    ADMIN_PERMISSIONS.PROJECTS_DELETE,
    ADMIN_PERMISSIONS.TASKS_READ,
    ADMIN_PERMISSIONS.TASKS_CREATE,
    ADMIN_PERMISSIONS.TASKS_UPDATE,
    ADMIN_PERMISSIONS.TASKS_DELETE,
    ADMIN_PERMISSIONS.SETTINGS_READ,
    ADMIN_PERMISSIONS.AUDIT_READ,
    ADMIN_PERMISSIONS.DASHBOARD_READ,
    ADMIN_PERMISSIONS.PROFILE_READ,
    ADMIN_PERMISSIONS.PROFILE_UPDATE,
  ],
  
  MODERATOR: [
    ADMIN_PERMISSIONS.USERS_READ,
    ADMIN_PERMISSIONS.USERS_UPDATE,
    ADMIN_PERMISSIONS.PROJECTS_READ,
    ADMIN_PERMISSIONS.PROJECTS_UPDATE,
    ADMIN_PERMISSIONS.TASKS_READ,
    ADMIN_PERMISSIONS.TASKS_UPDATE,
    ADMIN_PERMISSIONS.DASHBOARD_READ,
    ADMIN_PERMISSIONS.PROFILE_READ,
    ADMIN_PERMISSIONS.PROFILE_UPDATE,
  ],
  
  SUPPORT: [
    ADMIN_PERMISSIONS.USERS_READ,
    ADMIN_PERMISSIONS.PROJECTS_READ,
    ADMIN_PERMISSIONS.TASKS_READ,
    ADMIN_PERMISSIONS.DASHBOARD_READ,
    ADMIN_PERMISSIONS.PROFILE_READ,
  ],
} as const;

// 권한 그룹 유틸리티
export const PERMISSION_GROUPS = {
  USER_MANAGEMENT: [
    ADMIN_PERMISSIONS.USERS_READ,
    ADMIN_PERMISSIONS.USERS_CREATE,
    ADMIN_PERMISSIONS.USERS_UPDATE,
    ADMIN_PERMISSIONS.USERS_DELETE,
    ADMIN_PERMISSIONS.ROLES_MANAGE,
  ],
  
  PROJECT_MANAGEMENT: [
    ADMIN_PERMISSIONS.PROJECTS_READ,
    ADMIN_PERMISSIONS.PROJECTS_CREATE,
    ADMIN_PERMISSIONS.PROJECTS_UPDATE,
    ADMIN_PERMISSIONS.PROJECTS_DELETE,
  ],
  
  TASK_MANAGEMENT: [
    ADMIN_PERMISSIONS.TASKS_READ,
    ADMIN_PERMISSIONS.TASKS_CREATE,
    ADMIN_PERMISSIONS.TASKS_UPDATE,
    ADMIN_PERMISSIONS.TASKS_DELETE,
  ],
  
  SYSTEM_ADMINISTRATION: [
    ADMIN_PERMISSIONS.SETTINGS_READ,
    ADMIN_PERMISSIONS.SETTINGS_UPDATE,
    ADMIN_PERMISSIONS.AUDIT_READ,
  ],
  
  BASIC_ACCESS: [
    ADMIN_PERMISSIONS.DASHBOARD_READ,
    ADMIN_PERMISSIONS.PROFILE_READ,
    ADMIN_PERMISSIONS.PROFILE_UPDATE,
  ],
} as const;
</file>

<file path="frontend/src/components/admin/PermissionGuard.tsx">
'use client';

import { ReactNode } from 'react';
import { useAuthStore } from '@/lib/stores/authStore';

interface PermissionGuardProps {
  /**
   * 필요한 권한 목록
   * 배열로 전달하면 AND 조건 (모든 권한 필요)
   * 문자열로 전달하면 해당 권한만 확인
   */
  permissions: string | string[];
  
  /**
   * 권한 확인 모드
   * 'all': 모든 권한이 있어야 함 (기본값)
   * 'any': 하나 이상의 권한이 있으면 됨
   */
  mode?: 'all' | 'any';
  
  /**
   * 권한이 없을 때 보여줄 컴포넌트
   * 기본적으로 아무것도 렌더링하지 않음
   */
  fallback?: ReactNode;
  
  /**
   * 슈퍼 관리자는 모든 권한을 가진 것으로 처리할지 여부
   */
  allowSuperAdmin?: boolean;
  
  children: ReactNode;
}

/**
 * 사용자의 권한에 따라 컴포넌트를 조건부로 렌더링하는 가드 컴포넌트
 * 
 * @example
 * // 단일 권한 확인
 * <PermissionGuard permissions="admin:users:read">
 *   <UserList />
 * </PermissionGuard>
 * 
 * @example
 * // 여러 권한 확인 (모든 권한 필요)
 * <PermissionGuard permissions={["admin:users:read", "admin:users:update"]}>
 *   <UserEditForm />
 * </PermissionGuard>
 * 
 * @example
 * // 여러 권한 중 하나만 있으면 됨
 * <PermissionGuard 
 *   permissions={["admin:users:read", "admin:projects:read"]} 
 *   mode="any"
 * >
 *   <Dashboard />
 * </PermissionGuard>
 * 
 * @example
 * // 권한이 없을 때 대체 컴포넌트 표시
 * <PermissionGuard 
 *   permissions="admin:users:delete"
 *   fallback={<span className="text-gray-400">권한 없음</span>}
 * >
 *   <DeleteButton />
 * </PermissionGuard>
 */
export default function PermissionGuard({
  permissions,
  mode = 'all',
  fallback = null,
  allowSuperAdmin = true,
  children,
}: PermissionGuardProps) {
  const { user } = useAuthStore();

  // 로그인하지 않았거나 어드민 권한이 없는 경우
  if (!user || !user.adminRole) {
    return <>{fallback}</>;
  }

  // 슈퍼 관리자는 모든 권한을 가진 것으로 처리
  if (allowSuperAdmin && user.adminRole === 'super_admin') {
    return <>{children}</>;
  }

  // 권한 목록을 배열로 정규화
  const requiredPermissions = Array.isArray(permissions) ? permissions : [permissions];
  
  // 사용자의 권한 목록
  const userPermissions = user.adminPermissions || [];

  // 권한 확인 로직
  const hasPermission = mode === 'all'
    ? requiredPermissions.every(permission => userPermissions.includes(permission))
    : requiredPermissions.some(permission => userPermissions.includes(permission));

  return hasPermission ? <>{children}</> : <>{fallback}</>;
}

/**
 * 권한 확인을 위한 유틸리티 훅
 * 컴포넌트 내에서 권한을 확인해야 할 때 사용
 */
export function usePermissions() {
  const { user } = useAuthStore();

  const hasPermission = (
    permissions: string | string[],
    mode: 'all' | 'any' = 'all'
  ): boolean => {
    // 로그인하지 않았거나 어드민 권한이 없는 경우
    if (!user || !user.adminRole) {
      return false;
    }

    // 슈퍼 관리자는 모든 권한을 가진 것으로 처리
    if (user.adminRole === 'super_admin') {
      return true;
    }

    // 권한 목록을 배열로 정규화
    const requiredPermissions = Array.isArray(permissions) ? permissions : [permissions];
    
    // 사용자의 권한 목록
    const userPermissions = user.adminPermissions || [];

    // 권한 확인 로직
    return mode === 'all'
      ? requiredPermissions.every(permission => userPermissions.includes(permission))
      : requiredPermissions.some(permission => userPermissions.includes(permission));
  };

  const hasAnyPermission = (permissions: string[]): boolean => {
    return hasPermission(permissions, 'any');
  };

  const hasAllPermissions = (permissions: string[]): boolean => {
    return hasPermission(permissions, 'all');
  };

  const isAdmin = (): boolean => {
    return user?.adminRole !== undefined;
  };

  const isSuperAdmin = (): boolean => {
    return user?.adminRole === 'super_admin';
  };

  const getAdminRoleLabel = (): string => {
    switch (user?.adminRole) {
      case 'super_admin':
        return '슈퍼 관리자';
      case 'admin':
        return '관리자';
      case 'moderator':
        return '모더레이터';
      case 'support':
        return '지원팀';
      default:
        return '권한 없음';
    }
  };

  return {
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
    isAdmin,
    isSuperAdmin,
    getAdminRoleLabel,
    adminRole: user?.adminRole,
    adminPermissions: user?.adminPermissions || [],
  };
}
</file>

<file path="frontend/src/components/auth/GoogleLoginButton.tsx">
'use client';

import React from 'react';

interface GoogleLoginButtonProps {
  onLogin?: () => void;
  isLoading?: boolean;
  disabled?: boolean;
  text?: string;
}

export default function GoogleLoginButton({ 
  onLogin, 
  isLoading = false, 
  disabled = false,
  text = 'Google로 로그인'
}: GoogleLoginButtonProps) {
  const handleGoogleLogin = () => {
    if (onLogin) {
      onLogin();
    } else {
      // 기본 Google OAuth 로그인 처리
      const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';
      window.location.href = `${backendUrl}/auth/google`;
    }
  };

  return (
    <button
      type="button"
      onClick={handleGoogleLogin}
      disabled={isLoading || disabled}
      className="w-full flex justify-center items-center px-4 py-3 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
    >
      {isLoading ? (
        <>
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          로그인 중...
        </>
      ) : (
        <>
          {/* Google 로고 SVG */}
          <svg
            className="w-5 h-5 mr-3"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill="#4285F4"
              d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
            />
            <path
              fill="#34A853"
              d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
            />
            <path
              fill="#FBBC05"
              d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
            />
            <path
              fill="#EA4335"
              d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
            />
          </svg>
          {text}
        </>
      )}
    </button>
  );
}
</file>

<file path="frontend/src/components/auth/LoginForm.tsx">
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Eye, EyeOff, Mail, Lock, LogIn } from 'lucide-react';

interface LoginFormData {
  email: string;
  password: string;
  rememberMe: boolean;
}

interface LoginFormProps {
  onSubmit?: (data: LoginFormData) => Promise<void>;
  isLoading?: boolean;
}

export default function LoginForm({ onSubmit, isLoading = false }: LoginFormProps) {
  const router = useRouter();
  const [formData, setFormData] = useState<LoginFormData>({
    email: '',
    password: '',
    rememberMe: false,
  });
  const [showPassword, setShowPassword] = useState(false);
  const [errors, setErrors] = useState<Partial<LoginFormData>>({});

  const validateForm = (): boolean => {
    const newErrors: Partial<LoginFormData> = {};

    if (!formData.email) {
      newErrors.email = '이메일을 입력해주세요';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = '올바른 이메일 형식이 아닙니다';
    }

    if (!formData.password) {
      newErrors.password = '비밀번호를 입력해주세요';
    } else if (formData.password.length < 8) {
      newErrors.password = '비밀번호는 최소 8자 이상이어야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;

    try {
      if (onSubmit) {
        await onSubmit(formData);
      } else {
        // 기본 로그인 처리
        console.log('로그인 데이터:', formData);
        router.push('/dashboard');
      }
    } catch (error) {
      console.error('로그인 오류:', error);
    }
  };

  const handleInputChange = (field: keyof LoginFormData, value: string | boolean) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // 에러 상태 초기화
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  };

  return (
    <div className="w-full max-w-md mx-auto">
      <div className="bg-white rounded-2xl shadow-xl p-8">
        {/* 헤더 */}
        <div className="text-center mb-8">
          <div className="inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mb-4">
            <LogIn className="w-8 h-8 text-blue-600" />
          </div>
          <h1 className="text-2xl font-bold text-gray-900 mb-2">워클리에 로그인</h1>
          <p className="text-gray-600">계정에 로그인하여 업무를 시작하세요</p>
        </div>

        {/* 로그인 폼 */}
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* 이메일 입력 */}
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-2">
              이메일
            </label>
            <div className="relative">
              <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <Mail className="h-5 w-5 text-gray-400" />
              </div>
              <input
                type="email"
                id="email"
                value={formData.email}
                onChange={(e) => handleInputChange('email', e.target.value)}
                className={`block w-full pl-10 pr-3 py-3 border rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
                  errors.email ? 'border-red-300' : 'border-gray-300'
                }`}
                placeholder="이메일을 입력하세요"
                disabled={isLoading}
              />
            </div>
            {errors.email && (
              <p className="mt-1 text-sm text-red-600">{errors.email}</p>
            )}
          </div>

          {/* 비밀번호 입력 */}
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-2">
              비밀번호
            </label>
            <div className="relative">
              <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <Lock className="h-5 w-5 text-gray-400" />
              </div>
              <input
                type={showPassword ? 'text' : 'password'}
                id="password"
                value={formData.password}
                onChange={(e) => handleInputChange('password', e.target.value)}
                className={`block w-full pl-10 pr-12 py-3 border rounded-lg shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
                  errors.password ? 'border-red-300' : 'border-gray-300'
                }`}
                placeholder="비밀번호를 입력하세요"
                disabled={isLoading}
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 pr-3 flex items-center"
                onClick={() => setShowPassword(!showPassword)}
                disabled={isLoading}
              >
                {showPassword ? (
                  <EyeOff className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                ) : (
                  <Eye className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                )}
              </button>
            </div>
            {errors.password && (
              <p className="mt-1 text-sm text-red-600">{errors.password}</p>
            )}
          </div>

          {/* 로그인 유지 & 비밀번호 찾기 */}
          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                type="checkbox"
                checked={formData.rememberMe}
                onChange={(e) => handleInputChange('rememberMe', e.target.checked)}
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                disabled={isLoading}
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-700">
                로그인 유지
              </label>
            </div>
            <Link
              href="/auth/forgot-password"
              className="text-sm text-blue-600 hover:text-blue-500 font-medium"
            >
              비밀번호 찾기
            </Link>
          </div>

          {/* 로그인 버튼 */}
          <button
            type="submit"
            disabled={isLoading}
            className="w-full flex justify-center items-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {isLoading ? (
              <>
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                로그인 중...
              </>
            ) : (
              '로그인'
            )}
          </button>
        </form>

        {/* 회원가입 링크 */}
        <div className="mt-8 text-center">
          <p className="text-sm text-gray-600">
            계정이 없으신가요?{' '}
            <Link
              href="/auth/register"
              className="font-medium text-blue-600 hover:text-blue-500"
            >
              회원가입
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/auth/SocialLogin.tsx">
'use client';

import React from 'react';
import GoogleLoginButton from './GoogleLoginButton';

interface SocialLoginProps {
  isLoading?: boolean;
  showDivider?: boolean;
  dividerText?: string;
}

export default function SocialLogin({ 
  isLoading = false, 
  showDivider = true, 
  dividerText = '또는' 
}: SocialLoginProps) {
  const handleGoogleLogin = () => {
    console.log('Google 로그인 시작');
    // Google OAuth 로그인 로직 구현
  };

  return (
    <div className="w-full">
      {/* 구분선 */}
      {showDivider && (
        <div className="relative my-6">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-4 bg-white text-gray-500 font-medium">{dividerText}</span>
          </div>
        </div>
      )}

      {/* 소셜 로그인 버튼들 */}
      <div className="space-y-3">
        {/* Google 로그인 */}
        <GoogleLoginButton
          onLogin={handleGoogleLogin}
          isLoading={isLoading}
          text="Google로 계속하기"
        />

        {/* 추후 다른 소셜 로그인 추가 예정 */}
        {/* 
        <button
          type="button"
          className="w-full flex justify-center items-center px-4 py-3 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          disabled={isLoading}
        >
          <span className="mr-3">🍎</span>
          Apple로 계속하기
        </button>

        <button
          type="button"
          className="w-full flex justify-center items-center px-4 py-3 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          disabled={isLoading}
        >
          <span className="mr-3">💼</span>
          Microsoft로 계속하기
        </button>
        */}
      </div>

      {/* 보안 안내 */}
      <div className="mt-6 text-center">
        <p className="text-xs text-gray-500">
          소셜 로그인을 사용하면{' '}
          <a href="/terms" className="text-blue-600 hover:text-blue-500 underline">
            서비스 이용약관
          </a>
          {' '}및{' '}
          <a href="/privacy" className="text-blue-600 hover:text-blue-500 underline">
            개인정보 처리방침
          </a>
          에 동의하는 것으로 간주됩니다.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/board/KnowledgeWiki.tsx">
'use client'

import { useState } from 'react'
import { Search, BookOpen, User, Eye, ThumbsUp, Clock, Tag, Star, FileText, Plus, TrendingUp } from 'lucide-react'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'

interface KnowledgeWikiProps {
  searchQuery: string
}

interface WikiArticle {
  id: string
  title: string
  summary: string
  content: string
  author: {
    name: string
    avatar: string
    reputation: number
  }
  category: string
  tags: string[]
  views: number
  likes: number
  createdAt: string
  updatedAt: string
  difficulty: 'beginner' | 'intermediate' | 'advanced'
  readTime: number
  isFeatured: boolean
}

// 임시 데이터
const mockArticles: WikiArticle[] = [
  {
    id: '1',
    title: 'React Hook 완벽 가이드',
    summary: 'React Hook의 기본 개념부터 고급 패턴까지 상세히 설명합니다. useState, useEffect, useContext 등 핵심 Hook들의 실전 사용법을 다룹니다.',
    content: '# React Hook 완벽 가이드\n\nReact Hook은...',
    author: {
      name: '김개발',
      avatar: '/avatars/kim.jpg',
      reputation: 1250
    },
    category: 'Frontend',
    tags: ['React', 'JavaScript', 'Hook', 'Frontend'],
    views: 1542,
    likes: 89,
    createdAt: '2024-01-15',
    updatedAt: '2024-01-20',
    difficulty: 'intermediate',
    readTime: 12,
    isFeatured: true
  },
  {
    id: '2',
    title: 'TypeScript 타입 시스템 심화',
    summary: 'TypeScript의 고급 타입 시스템을 활용한 타입 안전성 향상 방법을 설명합니다. 제네릭, 유니온 타입, 조건부 타입 등을 다룹니다.',
    content: '# TypeScript 타입 시스템 심화\n\n타입 시스템은...',
    author: {
      name: '박타입',
      avatar: '/avatars/park.jpg',
      reputation: 2100
    },
    category: 'Programming',
    tags: ['TypeScript', 'Types', 'Programming', 'JavaScript'],
    views: 892,
    likes: 67,
    createdAt: '2024-01-10',
    updatedAt: '2024-01-18',
    difficulty: 'advanced',
    readTime: 18,
    isFeatured: false
  },
  {
    id: '3',
    title: 'UX 디자인 기초: 사용자 중심 설계',
    summary: '사용자 경험 디자인의 기본 원칙과 방법론을 소개합니다. 사용자 조사, 와이어프레임, 프로토타이핑까지 전체 과정을 다룹니다.',
    content: '# UX 디자인 기초\n\n사용자 중심 설계는...',
    author: {
      name: '이디자인',
      avatar: '/avatars/lee.jpg',
      reputation: 1680
    },
    category: 'Design',
    tags: ['UX', 'Design', 'User Research', 'Prototyping'],
    views: 2156,
    likes: 134,
    createdAt: '2024-01-08',
    updatedAt: '2024-01-16',
    difficulty: 'beginner',
    readTime: 15,
    isFeatured: true
  }
]

const categories = ['전체', 'Frontend', 'Backend', 'Design', 'Programming', 'DevOps', 'Marketing']
const difficulties = [
  { key: 'all', label: '전체 수준' },
  { key: 'beginner', label: '초급' },
  { key: 'intermediate', label: '중급' },
  { key: 'advanced', label: '고급' }
]

const difficultyColors = {
  beginner: 'bg-green-100 text-green-800',
  intermediate: 'bg-yellow-100 text-yellow-800',
  advanced: 'bg-red-100 text-red-800'
}

const difficultyLabels = {
  beginner: '초급',
  intermediate: '중급',
  advanced: '고급'
}

export default function KnowledgeWiki({ searchQuery }: KnowledgeWikiProps) {
  const [selectedCategory, setSelectedCategory] = useState('전체')
  const [selectedDifficulty, setSelectedDifficulty] = useState('all')
  const [sortBy, setSortBy] = useState<'latest' | 'popular' | 'likes'>('latest')

  const filteredArticles = mockArticles.filter(article => {
    const matchesSearch = article.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         article.summary.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         article.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()))
    
    const matchesCategory = selectedCategory === '전체' || article.category === selectedCategory
    const matchesDifficulty = selectedDifficulty === 'all' || article.difficulty === selectedDifficulty
    
    return matchesSearch && matchesCategory && matchesDifficulty
  }).sort((a, b) => {
    switch (sortBy) {
      case 'popular':
        return b.views - a.views
      case 'likes':
        return b.likes - a.likes
      case 'latest':
      default:
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    }
  })

  const featuredArticles = mockArticles.filter(article => article.isFeatured)

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  return (
    <div className="space-y-4">


      {/* 위키 문서 목록 */}
      <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">

        {filteredArticles.length === 0 ? (
          <div className="p-8 text-center">
            <BookOpen className="w-8 h-8 text-gray-400 mx-auto mb-3" />
            <h3 className="text-base font-medium text-gray-900 mb-1">검색 결과가 없습니다</h3>
            <p className="text-sm text-gray-500">다른 조건으로 검색해보세요.</p>
          </div>
        ) : (
          <div className="divide-y divide-gray-100">
            {filteredArticles.map((article, index) => (
              <div key={article.id} className={`p-4 hover:bg-gray-50 transition-colors cursor-pointer ${index === filteredArticles.length - 1 ? '' : ''}`}>
                <div className="flex justify-between items-start mb-3">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      <h3 className="text-base font-medium text-gray-900">{article.title}</h3>
                      <span className={`px-2 py-1 text-xs font-medium rounded-full ${difficultyColors[article.difficulty]}`}>
                        {difficultyLabels[article.difficulty]}
                      </span>
                      <span className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded-full">
                        {article.category}
                      </span>
                    </div>
                    
                    <p className="text-sm text-gray-600 mb-3 line-clamp-2">{article.summary}</p>
                    
                    {/* 태그 */}
                    <div className="flex flex-wrap gap-1 mb-3">
                      {article.tags.slice(0, 3).map((tag, index) => (
                        <span key={index} className="px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded flex items-center gap-1">
                          <Tag className="w-3 h-3" />
                          {tag}
                        </span>
                      ))}
                      {article.tags.length > 3 && (
                        <span className="px-2 py-1 text-xs text-gray-500">+{article.tags.length - 3}</span>
                      )}
                    </div>
                  </div>
                  
                  <div className="text-right ml-4">
                    <div className="flex items-center text-xs text-gray-500 mb-2">
                      <Clock className="w-3 h-3 mr-1" />
                      {article.readTime}분 읽기
                    </div>
                  </div>
                </div>

                <div className="flex items-center justify-between text-xs text-gray-500 border-t border-gray-100 pt-3">
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-2">
                      <User className="w-3 h-3" />
                      <span>{article.author.name}</span>
                      <span className="text-xs text-gray-600">평판 {article.author.reputation}</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <Eye className="w-3 h-3" />
                      {article.views.toLocaleString()}회
                    </div>
                    <div className="flex items-center gap-1">
                      <ThumbsUp className="w-3 h-3" />
                      {article.likes}
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-gray-400">
                      업데이트: {formatDate(article.updatedAt)}
                    </span>
                    <Button variant="outline" size="sm">
                      <FileText className="w-3 h-3 mr-1" />
                      읽기
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* 통계 섹션 */}
      <div className="bg-white border border-gray-200 rounded-lg p-4">
        <div className="flex items-center gap-2 mb-3">
          <TrendingUp className="w-4 h-4 text-green-500" />
          <h3 className="text-sm font-medium text-gray-900">위키 통계</h3>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">{mockArticles.length}</div>
            <div className="text-xs text-gray-500">총 문서 수</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">
              {mockArticles.reduce((sum, article) => sum + article.views, 0).toLocaleString()}
            </div>
            <div className="text-xs text-gray-500">총 조회수</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">
              {mockArticles.reduce((sum, article) => sum + article.likes, 0)}
            </div>
            <div className="text-xs text-gray-500">총 좋아요</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">{categories.length - 1}</div>
            <div className="text-xs text-gray-500">카테고리 수</div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/board/MissionBoard.tsx">
'use client'

import { useState } from 'react'
import { Search, MapPin, Clock, DollarSign, User, Briefcase, Star, Filter } from 'lucide-react'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'

interface MissionBoardProps {
  searchQuery: string
}

interface Mission {
  id: string
  title: string
  description: string
  client: string
  budget: {
    type: 'fixed' | 'hourly'
    amount: number
  }
  deadline: string
  location: string
  skills: string[]
  proposals: number
  rating: number
  postedAt: string
  category: 'development' | 'design' | 'marketing' | 'writing' | 'consulting'
}

// 임시 데이터
const mockMissions: Mission[] = [
  {
    id: '1',
    title: 'React 웹 애플리케이션 개발',
    description: '사용자 관리 시스템이 포함된 React 기반 웹 애플리케이션을 개발해주실 개발자를 찾습니다. TypeScript와 Next.js 경험이 있으시면 더욱 좋습니다.',
    client: 'TechCorp',
    budget: { type: 'fixed', amount: 3000000 },
    deadline: '2024-03-15',
    location: '원격',
    skills: ['React', 'TypeScript', 'Next.js', 'Node.js'],
    proposals: 12,
    rating: 4.8,
    postedAt: '2024-01-10',
    category: 'development'
  },
  {
    id: '2',
    title: 'UX/UI 디자인 리뉴얼',
    description: '기존 모바일 앱의 UX/UI를 모던하고 사용자 친화적으로 리디자인해주실 디자이너를 찾습니다.',
    client: 'StartupA',
    budget: { type: 'hourly', amount: 50000 },
    deadline: '2024-02-28',
    location: '서울',
    skills: ['Figma', 'UX Design', 'UI Design', 'Prototyping'],
    proposals: 8,
    rating: 4.9,
    postedAt: '2024-01-12',
    category: 'design'
  },
  {
    id: '3',
    title: '마케팅 전략 수립 및 실행',
    description: '신제품 런칭을 위한 종합적인 디지털 마케팅 전략을 수립하고 실행해주실 마케터를 찾습니다.',
    client: 'BrandCo',
    budget: { type: 'fixed', amount: 2500000 },
    deadline: '2024-04-01',
    location: '부산',
    skills: ['Digital Marketing', 'SEO', 'Social Media', 'Analytics'],
    proposals: 15,
    rating: 4.7,
    postedAt: '2024-01-08',
    category: 'marketing'
  }
]

const categoryLabels = {
  development: '개발',
  design: '디자인',
  marketing: '마케팅',
  writing: '라이팅',
  consulting: '컨설팅'
}

export default function MissionBoard({ searchQuery }: MissionBoardProps) {
  const [selectedCategory, setSelectedCategory] = useState<string>('all')
  const [budgetFilter, setBudgetFilter] = useState<string>('all')
  const [locationFilter, setLocationFilter] = useState<string>('all')

  const categories = ['all', 'development', 'design', 'marketing', 'writing', 'consulting']

  const filteredMissions = mockMissions.filter(mission => {
    const matchesSearch = mission.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         mission.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         mission.skills.some(skill => skill.toLowerCase().includes(searchQuery.toLowerCase()))
    
    const matchesCategory = selectedCategory === 'all' || mission.category === selectedCategory
    
    let matchesBudget = true
    if (budgetFilter !== 'all') {
      const amount = mission.budget.amount
      switch (budgetFilter) {
        case '1000000-':
          matchesBudget = amount < 1000000
          break
        case '1000000-3000000':
          matchesBudget = amount >= 1000000 && amount <= 3000000
          break
        case '3000000+':
          matchesBudget = amount > 3000000
          break
      }
    }
    
    const matchesLocation = locationFilter === 'all' || mission.location === locationFilter
    
    return matchesSearch && matchesCategory && matchesBudget && matchesLocation
  })

  const formatBudget = (budget: Mission['budget']) => {
    const formattedAmount = new Intl.NumberFormat('ko-KR').format(budget.amount)
    return budget.type === 'fixed' 
      ? `${formattedAmount}원 (고정)`
      : `${formattedAmount}원/시간`
  }

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  return (
    <div className="space-y-4">

      {/* 임무 목록 */}
      <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">

        {filteredMissions.length === 0 ? (
          <div className="p-8 text-center">
            <Briefcase className="w-8 h-8 text-gray-400 mx-auto mb-3" />
            <h3 className="text-base font-medium text-gray-900 mb-1">검색 결과가 없습니다</h3>
            <p className="text-sm text-gray-500">다른 조건으로 검색해보세요.</p>
          </div>
        ) : (
          <div className="divide-y divide-gray-100">
            {filteredMissions.map((mission, index) => (
              <div key={mission.id} className={`p-4 hover:bg-gray-50 transition-colors cursor-pointer ${index === filteredMissions.length - 1 ? '' : ''}`}>
                <div className="flex justify-between items-start mb-3">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      <h3 className="text-base font-medium text-gray-900">{mission.title}</h3>
                      <span className="px-2 py-1 text-xs font-medium bg-gray-100 text-gray-700 rounded-full">
                        {categoryLabels[mission.category]}
                      </span>
                    </div>
                    <p className="text-sm text-gray-600 mb-3 line-clamp-2">{mission.description}</p>
                    
                    {/* 스킬 태그 */}
                    <div className="flex flex-wrap gap-1 mb-3">
                      {mission.skills.slice(0, 3).map((skill, index) => (
                        <span key={index} className="px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded">
                          {skill}
                        </span>
                      ))}
                      {mission.skills.length > 3 && (
                        <span className="px-2 py-1 text-xs text-gray-500">+{mission.skills.length - 3}</span>
                      )}
                    </div>
                  </div>
                  
                  <div className="text-right ml-4">
                    <div className="text-base font-semibold text-gray-900 mb-1">
                      {formatBudget(mission.budget)}
                    </div>
                    <div className="flex items-center text-xs text-gray-500">
                      <Star className="w-3 h-3 text-yellow-400 mr-1" />
                      {mission.rating}
                    </div>
                  </div>
                </div>

                <div className="flex items-center justify-between text-xs text-gray-500 border-t border-gray-100 pt-3">
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-1">
                      <User className="w-3 h-3" />
                      {mission.client}
                    </div>
                    <div className="flex items-center gap-1">
                      <MapPin className="w-3 h-3" />
                      {mission.location}
                    </div>
                    <div className="flex items-center gap-1">
                      <Clock className="w-3 h-3" />
                      마감: {formatDate(mission.deadline)}
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-gray-600 font-medium">{mission.proposals}개 제안</span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/board/ProjectShowcase.tsx">
'use client'

import { useState } from 'react'
import { Search, Heart, Eye, MessageCircle, User, Calendar, Tag, ExternalLink, Image, Video, Github, Globe, Award, TrendingUp } from 'lucide-react'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'

interface ProjectShowcaseProps {
  searchQuery: string
}

interface ShowcaseProject {
  id: string
  title: string
  description: string
  author: {
    name: string
    avatar: string
    level: number
    reputation: number
  }
  category: string
  tags: string[]
  images: string[]
  videoUrl?: string
  links: {
    demo?: string
    github?: string
    website?: string
  }
  stats: {
    views: number
    likes: number
    comments: number
  }
  createdAt: string
  isFeatured: boolean
  challenges: string[]
  solutions: string[]
  lessons: string[]
  technologies: string[]
  teamMembers?: {
    name: string
    role: string
    avatar: string
  }[]
}

// 임시 데이터
const mockProjects: ShowcaseProject[] = [
  {
    id: '1',
    title: '실시간 협업 화이트보드 애플리케이션',
    description: '팀이 실시간으로 함께 작업할 수 있는 화이트보드 앱을 개발했습니다. Socket.io를 활용한 실시간 동기화와 Canvas API를 이용한 드로잉 기능을 구현했습니다.',
    author: {
      name: '김협업',
      avatar: '/avatars/kim.jpg',
      level: 15,
      reputation: 2340
    },
    category: '웹 개발',
    tags: ['React', 'Socket.io', 'Canvas', 'TypeScript', 'Node.js'],
    images: [
      '/projects/whiteboard-1.jpg',
      '/projects/whiteboard-2.jpg',
      '/projects/whiteboard-3.jpg'
    ],
    videoUrl: '/projects/whiteboard-demo.mp4',
    links: {
      demo: 'https://whiteboard-demo.com',
      github: 'https://github.com/user/whiteboard',
      website: 'https://whiteboard-app.com'
    },
    stats: {
      views: 1234,
      likes: 89,
      comments: 23
    },
    createdAt: '2024-01-15',
    isFeatured: true,
    challenges: [
      '실시간 데이터 동기화의 성능 최적화',
      '다양한 브라우저에서의 Canvas 호환성',
      '대용량 데이터 처리'
    ],
    solutions: [
      'WebSocket 연결 풀링과 데이터 압축으로 성능 개선',
      'Fabric.js 라이브러리 도입으로 브라우저 호환성 해결',
      'Virtual scrolling과 lazy loading 적용'
    ],
    lessons: [
      '실시간 애플리케이션에서의 상태 관리 중요성',
      '사용자 경험을 위한 오프라인 모드 필요성',
      '확장 가능한 아키텍처 설계의 중요성'
    ],
    technologies: ['React', 'TypeScript', 'Socket.io', 'Canvas API', 'Node.js', 'MongoDB'],
    teamMembers: [
      { name: '김협업', role: 'Frontend Developer', avatar: '/avatars/kim.jpg' },
      { name: '박실시간', role: 'Backend Developer', avatar: '/avatars/park.jpg' },
      { name: '이디자인', role: 'UI/UX Designer', avatar: '/avatars/lee.jpg' }
    ]
  },
  {
    id: '2',
    title: 'AI 기반 개인 학습 도우미',
    description: 'OpenAI API를 활용하여 개인화된 학습 경험을 제공하는 모바일 앱을 개발했습니다. 사용자의 학습 패턴을 분석하고 맞춤형 콘텐츠를 추천합니다.',
    author: {
      name: '박AI',
      avatar: '/avatars/park.jpg',
      level: 12,
      reputation: 1890
    },
    category: '모바일 앱',
    tags: ['React Native', 'AI', 'Machine Learning', 'OpenAI', 'Firebase'],
    images: [
      '/projects/ai-tutor-1.jpg',
      '/projects/ai-tutor-2.jpg'
    ],
    links: {
      demo: 'https://ai-tutor-demo.com',
      github: 'https://github.com/user/ai-tutor'
    },
    stats: {
      views: 867,
      likes: 56,
      comments: 18
    },
    createdAt: '2024-01-12',
    isFeatured: false,
    challenges: [
      'AI 응답의 정확성과 관련성 확보',
      '사용자 개인정보 보호',
      '모바일 환경에서의 성능 최적화'
    ],
    solutions: [
      'Prompt engineering과 fine-tuning으로 응답 품질 개선',
      '로컬 데이터 처리와 암호화로 프라이버시 보호',
      '캐싱과 압축으로 데이터 사용량 최소화'
    ],
    lessons: [
      'AI 서비스에서의 사용자 신뢰 구축 중요성',
      '점진적 기능 개선의 효과',
      '사용자 피드백 수집의 중요성'
    ],
    technologies: ['React Native', 'OpenAI API', 'Firebase', 'TensorFlow Lite'],
    teamMembers: [
      { name: '박AI', role: 'Full Stack Developer', avatar: '/avatars/park.jpg' },
      { name: '최ML', role: 'ML Engineer', avatar: '/avatars/choi.jpg' }
    ]
  },
  {
    id: '3',
    title: '지속가능한 패션 플랫폼',
    description: '친환경 패션 브랜드들을 연결하는 이커머스 플랫폼을 디자인하고 개발했습니다. 지속가능성 지표와 브랜드 스토리를 중심으로 한 독특한 UX를 제공합니다.',
    author: {
      name: '이그린',
      avatar: '/avatars/lee.jpg',
      level: 8,
      reputation: 1245
    },
    category: '이커머스',
    tags: ['Next.js', 'Tailwind CSS', 'Stripe', 'Sustainability', 'E-commerce'],
    images: [
      '/projects/eco-fashion-1.jpg',
      '/projects/eco-fashion-2.jpg',
      '/projects/eco-fashion-3.jpg'
    ],
    links: {
      demo: 'https://eco-fashion-demo.com',
      website: 'https://green-fashion.com'
    },
    stats: {
      views: 654,
      likes: 42,
      comments: 12
    },
    createdAt: '2024-01-08',
    isFeatured: true,
    challenges: [
      '복잡한 지속가능성 데이터의 시각화',
      '다양한 브랜드 요구사항 통합',
      '신뢰할 수 있는 결제 시스템 구축'
    ],
    solutions: [
      '인터랙티브 차트와 인포그래픽으로 데이터 표현',
      '모듈식 아키텍처로 확장성 확보',
      'Stripe Connect를 활용한 멀티벤더 결제'
    ],
    lessons: [
      '사회적 가치와 비즈니스 모델의 조화',
      '사용자 교육의 중요성',
      '스토리텔링이 주는 브랜드 차별화 효과'
    ],
    technologies: ['Next.js', 'Tailwind CSS', 'Stripe', 'PostgreSQL', 'Vercel']
  }
]

const categories = ['전체', '웹 개발', '모바일 앱', '이커머스', '게임', '디자인', '데이터 과학']
const sortOptions = [
  { key: 'latest', label: '최신순' },
  { key: 'popular', label: '인기순' },
  { key: 'likes', label: '좋아요순' },
  { key: 'views', label: '조회수순' }
]

export default function ProjectShowcase({ searchQuery }: ProjectShowcaseProps) {
  const [selectedCategory, setSelectedCategory] = useState('전체')
  const [sortBy, setSortBy] = useState<'latest' | 'popular' | 'likes' | 'views'>('latest')

  const filteredProjects = mockProjects.filter(project => {
    const matchesSearch = project.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         project.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         project.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()))
    
    const matchesCategory = selectedCategory === '전체' || project.category === selectedCategory
    
    return matchesSearch && matchesCategory
  }).sort((a, b) => {
    switch (sortBy) {
      case 'popular':
        return (b.stats.views + b.stats.likes) - (a.stats.views + a.stats.likes)
      case 'likes':
        return b.stats.likes - a.stats.likes
      case 'views':
        return b.stats.views - a.stats.views
      case 'latest':
      default:
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    }
  })

  const featuredProjects = mockProjects.filter(project => project.isFeatured)

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  return (
    <div className="space-y-4">


      {/* 프로젝트 목록 */}
      <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">

        {filteredProjects.length === 0 ? (
          <div className="p-8 text-center">
            <Image className="w-8 h-8 text-gray-400 mx-auto mb-3" />
            <h3 className="text-base font-medium text-gray-900 mb-1">검색 결과가 없습니다</h3>
            <p className="text-sm text-gray-500">다른 조건으로 검색해보세요.</p>
          </div>
        ) : (
          <div className="divide-y divide-gray-100">
            {filteredProjects.map((project, index) => (
              <div key={project.id} className={`p-4 hover:bg-gray-50 transition-colors cursor-pointer ${index === filteredProjects.length - 1 ? '' : ''}`}>
                <div className="flex justify-between items-start mb-3">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      <h3 className="text-base font-medium text-gray-900">{project.title}</h3>
                      <span className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded-full">
                        {project.category}
                      </span>
                      {project.isFeatured && (
                        <Award className="w-4 h-4 text-yellow-500" />
                      )}
                    </div>
                    
                    <p className="text-sm text-gray-600 mb-3 line-clamp-2">{project.description}</p>
                    
                    {/* 기술 스택 */}
                    <div className="flex flex-wrap gap-1 mb-3">
                      {project.technologies.slice(0, 4).map((tech, index) => (
                        <span key={index} className="px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded">
                          {tech}
                        </span>
                      ))}
                      {project.technologies.length > 4 && (
                        <span className="px-2 py-1 text-xs text-gray-500">+{project.technologies.length - 4}</span>
                      )}
                    </div>

                    {/* 팀 멤버 */}
                    {project.teamMembers && (
                      <div className="mb-3">
                        <div className="flex items-center gap-2 text-xs text-gray-600">
                          <User className="w-3 h-3" />
                          <span>팀:</span>
                          {project.teamMembers.slice(0, 3).map((member, index) => (
                            <span key={index}>{member.name}{index < 2 && index < project.teamMembers!.length - 1 ? ', ' : ''}</span>
                          ))}
                          {project.teamMembers.length > 3 && (
                            <span>외 {project.teamMembers.length - 3}명</span>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                  
                  {/* 프로젝트 썸네일 */}
                  <div className="w-20 h-16 bg-gray-100 rounded border border-gray-200 ml-4 flex items-center justify-center">
                    {project.videoUrl ? (
                      <Video className="w-4 h-4 text-gray-400" />
                    ) : (
                      <Image className="w-4 h-4 text-gray-400" />
                    )}
                  </div>
                </div>

                {/* 도전과제와 해결책 */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3 p-3 bg-gray-50 rounded-lg">
                  <div>
                    <h5 className="text-xs font-medium text-gray-700 mb-1">주요 도전과제</h5>
                    <ul className="text-xs text-gray-600 space-y-1">
                      {project.challenges.slice(0, 1).map((challenge, index) => (
                        <li key={index} className="flex items-start gap-1">
                          <span className="text-red-500 mt-0.5">•</span>
                          <span className="line-clamp-1">{challenge}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                  <div>
                    <h5 className="text-xs font-medium text-gray-700 mb-1">핵심 해결책</h5>
                    <ul className="text-xs text-gray-600 space-y-1">
                      {project.solutions.slice(0, 1).map((solution, index) => (
                        <li key={index} className="flex items-start gap-1">
                          <span className="text-green-500 mt-0.5">•</span>
                          <span className="line-clamp-1">{solution}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>

                <div className="flex items-center justify-between text-xs text-gray-500 border-t border-gray-100 pt-3">
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-2">
                      <User className="w-3 h-3" />
                      <span>{project.author.name}</span>
                      <span className="text-xs text-gray-600">Lv.{project.author.level}</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <Eye className="w-3 h-3" />
                      {project.stats.views.toLocaleString()}회
                    </div>
                    <div className="flex items-center gap-1">
                      <Heart className="w-3 h-3" />
                      {project.stats.likes}
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-gray-400">
                      {formatDate(project.createdAt)}
                    </span>
                    <Button variant="outline" size="sm">
                      <ExternalLink className="w-3 h-3 mr-1" />
                      보기
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* 통계 섹션 */}
      <div className="bg-white border border-gray-200 rounded-lg p-4">
        <div className="flex items-center gap-2 mb-3">
          <TrendingUp className="w-4 h-4 text-green-500" />
          <h3 className="text-sm font-medium text-gray-900">쇼케이스 통계</h3>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">{mockProjects.length}</div>
            <div className="text-xs text-gray-500">총 프로젝트</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">
              {mockProjects.reduce((sum, project) => sum + project.stats.views, 0).toLocaleString()}
            </div>
            <div className="text-xs text-gray-500">총 조회수</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">
              {mockProjects.reduce((sum, project) => sum + project.stats.likes, 0)}
            </div>
            <div className="text-xs text-gray-500">총 좋아요</div>
          </div>
          <div className="text-center">
            <div className="text-xl font-semibold text-gray-900">{categories.length - 1}</div>
            <div className="text-xs text-gray-500">카테고리 수</div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/home/HomeTaskDashboard.tsx">
'use client'

import React, { useState, useEffect, useMemo } from 'react'
import { GTDTask, HomeDashboardFilter, TaskStatus, MomentumScore } from '@/types/task.types'
import TaskCard from '@/components/tasks/TaskCard'
import { Search, Filter, Plus } from 'lucide-react'

interface HomeTaskDashboardProps {
  tasks: GTDTask[]
  onTaskToggle?: (taskId: string) => void
  onTaskEdit?: (task: GTDTask) => void
  onCreateTask?: () => void
  isLoading?: boolean
}

export default function HomeTaskDashboard({
  tasks,
  onTaskToggle,
  onTaskEdit,
  onCreateTask,
  isLoading = false
}: HomeTaskDashboardProps) {
  const [activeFilter, setActiveFilter] = useState<HomeDashboardFilter>('today')
  const [searchQuery, setSearchQuery] = useState('')
  const [showSearch, setShowSearch] = useState(false)

  // 모멘텀 점수 계산 함수
  const calculateMomentumScore = (task: GTDTask): MomentumScore => {
    let reach = 5 // 기본값
    let impact = 5
    let confidence = task.clarified ? 8 : 4
    let effort = 5

    // Reach: 프로젝트 중요도 (프로젝트가 있으면 +2)
    if (task.projectId) {
      reach += 2
    }

    // Impact: 마감일과 우선순위 기반
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate)
      const now = new Date()
      const daysDiff = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 3600 * 24))
      
      if (daysDiff < 0) impact = 10 // 지난 업무
      else if (daysDiff === 0) impact = 9 // 오늘 마감
      else if (daysDiff === 1) impact = 8 // 내일 마감
      else if (daysDiff <= 3) impact = 7 // 3일 이내
      else if (daysDiff <= 7) impact = 6 // 일주일 이내
      else impact = 4 // 그 이후
    }

    // 우선순위 보너스
    switch (task.priority) {
      case 'urgent': impact += 3; break
      case 'high': impact += 2; break
      case 'medium': impact += 1; break
      case 'low': break
    }

    // Effort: 예상 시간 역가중치
    if (task.estimatedHours) {
      if (task.estimatedHours <= 1) effort = 9
      else if (task.estimatedHours <= 2) effort = 8
      else if (task.estimatedHours <= 4) effort = 6
      else if (task.estimatedHours <= 8) effort = 4
      else effort = 2
    }

    // 2분 규칙 보너스
    if (task.canComplete2Minutes) {
      effort = 10
      confidence = 10
    }

    // 점수 정규화 (0-10)
    reach = Math.min(10, Math.max(0, reach))
    impact = Math.min(10, Math.max(0, impact))
    confidence = Math.min(10, Math.max(0, confidence))
    effort = Math.min(10, Math.max(0, effort))

    // 총점 계산 (가중 평균)
    const total = (reach * 0.2 + impact * 0.4 + confidence * 0.2 + effort * 0.2)

    return { reach, impact, confidence, effort, total }
  }

  // 업무 목록 필터링 및 정렬
  const filteredAndSortedTasks = useMemo(() => {
    let filtered = tasks

    // 검색 필터링
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase()
      filtered = filtered.filter(task => 
        task.title.toLowerCase().includes(query) ||
        task.description?.toLowerCase().includes(query) ||
        task.project?.name.toLowerCase().includes(query)
      )
    }

    // 상태별 필터링
    switch (activeFilter) {
      case 'today':
        filtered = filtered.filter(task => 
          task.status !== TaskStatus.DONE && 
          task.status !== TaskStatus.CANCELLED &&
          task.gtdContext === 'next'
        )
        break
      case 'completed':
        filtered = filtered.filter(task => 
          task.status === TaskStatus.DONE
        )
        break
      case 'someday':
        filtered = filtered.filter(task => 
          task.gtdContext === 'someday'
        )
        break
      case 'all':
        // 모든 업무 표시
        break
    }

    // 모멘텀 점수 계산 및 업데이트
    const tasksWithScore = filtered.map(task => ({
      ...task,
      momentumScore: calculateMomentumScore(task)
    }))

    // 정렬: 완료된 업무는 별도, 나머지는 모멘텀 점수순
    if (activeFilter === 'completed') {
      return tasksWithScore.sort((a, b) => 
        new Date(b.completedAt || b.updatedAt).getTime() - 
        new Date(a.completedAt || a.updatedAt).getTime()
      )
    } else {
      return tasksWithScore.sort((a, b) => 
        b.momentumScore.total - a.momentumScore.total
      )
    }
  }, [tasks, activeFilter, searchQuery])

  // 필터 옵션
  const filterOptions = [
    { key: 'today' as const, label: '오늘', count: filteredAndSortedTasks.length },
    { key: 'completed' as const, label: '완료됨', count: tasks.filter(t => t.status === TaskStatus.DONE).length },
    { key: 'all' as const, label: '전체', count: tasks.length },
    { key: 'someday' as const, label: '나중에', count: tasks.filter(t => t.gtdContext === 'someday').length },
  ]

  const renderFilterTabs = () => (
    <div className="flex items-center gap-1 p-1 bg-gray-100 rounded-lg mb-4">
      {filterOptions.map(option => (
        <button
          key={option.key}
          onClick={() => setActiveFilter(option.key)}
          className={`px-3 py-2 rounded-md text-sm font-medium transition-colors flex-1 ${
            activeFilter === option.key
              ? 'bg-white text-gray-900 shadow-sm'
              : 'text-gray-600 hover:text-gray-900 hover:bg-gray-50'
          }`}
        >
          {option.label}
          {option.count > 0 && (
            <span className={`ml-1 text-xs ${
              activeFilter === option.key ? 'text-gray-600' : 'text-gray-400'
            }`}>
              {option.count}
            </span>
          )}
        </button>
      ))}
    </div>
  )

  const renderSearchBar = () => (
    <div className={`transition-all duration-300 overflow-hidden ${
      showSearch ? 'max-h-20 mb-4' : 'max-h-0'
    }`}>
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
        <input
          type="text"
          placeholder="업무, 프로젝트 검색..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full pl-10 pr-4 py-2 border border-gray-200 rounded-lg 
                   focus:ring-2 focus:ring-blue-500 focus:border-transparent 
                   bg-white text-sm"
          autoFocus={showSearch}
        />
      </div>
    </div>
  )

  const renderTopSection = () => (
    <div className="p-4 border-b border-gray-100">
      {/* 헤더 */}
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-lg font-semibold text-gray-900">
          내 업무
        </h1>
        <div className="flex items-center gap-2">
          <button
            onClick={() => setShowSearch(!showSearch)}
            className={`p-2 rounded-lg transition-colors ${
              showSearch ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'
            }`}
            aria-label="검색"
          >
            <Search className="w-5 h-5" />
          </button>
          <button
            onClick={onCreateTask}
            className="p-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors"
            aria-label="업무 추가"
          >
            <Plus className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* 검색바 */}
      {renderSearchBar()}

      {/* 필터 탭 */}
      {renderFilterTabs()}
    </div>
  )

  const renderTaskList = () => {
    if (isLoading) {
      return (
        <div className="p-8 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
          <p className="text-gray-500 mt-2">업무를 불러오는 중...</p>
        </div>
      )
    }

    if (filteredAndSortedTasks.length === 0) {
      return (
        <div className="p-8 text-center">
          <div className="text-gray-400 mb-2">
            {activeFilter === 'today' && '📋'}
            {activeFilter === 'completed' && '✅'}
            {activeFilter === 'someday' && '🔮'}
            {activeFilter === 'all' && '📝'}
          </div>
          <h3 className="text-lg font-medium text-gray-600 mb-1">
            {searchQuery ? '검색 결과가 없습니다' : 
             activeFilter === 'today' ? '오늘 할 업무가 없습니다' :
             activeFilter === 'completed' ? '완료된 업무가 없습니다' :
             activeFilter === 'someday' ? '나중에 할 업무가 없습니다' :
             '업무가 없습니다'}
          </h3>
          <p className="text-gray-500 text-sm">
            {!searchQuery && activeFilter === 'today' && '새로운 업무를 추가해보세요!'}
          </p>
        </div>
      )
    }

    return (
      <div className="divide-y divide-gray-100">
        {filteredAndSortedTasks.map((task, index) => (
          <TaskCard
            key={task.id}
            task={task}
            isLast={index === filteredAndSortedTasks.length - 1}
            onToggleComplete={onTaskToggle}
            onEdit={onTaskEdit}
            showMomentumScore={activeFilter === 'today'}
          />
        ))}
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
      {renderTopSection()}
      {renderTaskList()}
    </div>
  )
}
</file>

<file path="frontend/src/components/inbox/CPERModal.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { 
  XMarkIcon,
  InboxIcon,
  ArrowRightIcon,
  ArrowLeftIcon,
  CheckCircleIcon,
  LightBulbIcon,
  ClipboardDocumentIcon,
  FolderPlusIcon,
  FlagIcon,
  ClockIcon,
  PlayIcon,
  ChartBarIcon
} from '@heroicons/react/24/outline'
import { HierarchyType, CPERStage, WorklyTask, HierarchyChoice } from '@/shared/types/workly-core.types'

// CPER 모달 Props
interface CPERModalProps {
  isOpen: boolean
  onClose: () => void
  initialContent?: string
  onTaskCreated?: (task: WorklyTask) => void
  onInboxItemCreated?: (inboxItem: any) => void
}

// CPER 단계 정의
enum CPERStep {
  CAPTURE = 0,
  PLAN = 1,
  EXECUTE = 2,
  REVIEW = 3
}

// 계획 단계의 하위 단계
enum PlanSubStep {
  CLARIFY = 0,
  ORGANIZE = 1,
  DETAIL = 2
}

// 수집 타입
const captureTypes = [
  {
    id: 'idea' as const,
    label: '아이디어',
    description: '떠오른 생각이나 영감을 수집',
    icon: LightBulbIcon,
    color: 'text-amber-600 bg-amber-100',
    borderColor: 'border-amber-200'
  },
  {
    id: 'task' as const,
    label: '업무',
    description: '해야 할 작업이나 할 일',
    icon: ClipboardDocumentIcon,
    color: 'text-blue-600 bg-blue-100',
    borderColor: 'border-blue-200'
  },
  {
    id: 'project' as const,
    label: '프로젝트',
    description: '큰 목표나 여러 업무의 묶음',
    icon: FolderPlusIcon,
    color: 'text-green-600 bg-green-100',
    borderColor: 'border-green-200'
  },
  {
    id: 'goal' as const,
    label: '목표',
    description: '장기적인 목표나 성과지표',
    icon: FlagIcon,
    color: 'text-purple-600 bg-purple-100',
    borderColor: 'border-purple-200'
  }
]

// 단계별 테마 색상
const stageThemes = {
  [CPERStep.CAPTURE]: {
    primary: 'blue',
    bg: 'bg-blue-50',
    border: 'border-blue-200',
    text: 'text-blue-900',
    button: 'bg-blue-500 hover:bg-blue-600'
  },
  [CPERStep.PLAN]: {
    primary: 'green',
    bg: 'bg-green-50',
    border: 'border-green-200', 
    text: 'text-green-900',
    button: 'bg-green-500 hover:bg-green-600'
  },
  [CPERStep.EXECUTE]: {
    primary: 'amber',
    bg: 'bg-amber-50',
    border: 'border-amber-200',
    text: 'text-amber-900',
    button: 'bg-amber-500 hover:bg-amber-600'
  },
  [CPERStep.REVIEW]: {
    primary: 'purple',
    bg: 'bg-purple-50',
    border: 'border-purple-200',
    text: 'text-purple-900',
    button: 'bg-purple-500 hover:bg-purple-600'
  }
}

export default function CPERModal({
  isOpen,
  onClose,
  initialContent = '',
  onTaskCreated,
  onInboxItemCreated
}: CPERModalProps) {
  // 단계 상태
  const [currentStep, setCurrentStep] = useState<CPERStep>(CPERStep.CAPTURE)
  const [planSubStep, setPlanSubStep] = useState<PlanSubStep>(PlanSubStep.CLARIFY)
  
  // 수집 단계 데이터
  const [captureData, setCaptureData] = useState({
    type: 'idea' as const,
    title: '',
    content: initialContent,
    tags: [] as string[]
  })

  // 계획 단계 데이터
  const [planData, setPlanData] = useState({
    // 명확화
    isActionable: false,
    canComplete2Minutes: false,
    nextAction: '',
    timeEstimate: 30, // 분 단위
    
    // 구조화
    hierarchyChoice: {
      type: HierarchyType.INDEPENDENT,
      projectId: undefined,
      goalId: undefined
    } as HierarchyChoice,
    
    // 상세 계획
    priority: 'medium' as const,
    dueDate: '',
    description: '',
    finalTitle: ''
  })

  // 실행 단계 데이터
  const [executeData, setExecuteData] = useState({
    isToday: false,
    isFocused: false,
    startImmediately: false
  })

  // UI 상태
  const [isTransitioning, setIsTransitioning] = useState(false)
  const modalRef = useRef<HTMLDivElement>(null)

  // ESC 키 처리
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    if (isOpen) {
      document.addEventListener('keydown', handleEsc)
      return () => document.removeEventListener('keydown', handleEsc)
    }
  }, [isOpen, onClose])

  // 모달 초기화
  useEffect(() => {
    if (isOpen) {
      setCurrentStep(CPERStep.CAPTURE)
      setPlanSubStep(PlanSubStep.CLARIFY)
      setCaptureData({
        type: 'idea',
        title: '',
        content: initialContent,
        tags: []
      })
      setPlanData({
        isActionable: false,
        canComplete2Minutes: false,
        nextAction: '',
        timeEstimate: 30,
        hierarchyChoice: {
          type: HierarchyType.INDEPENDENT
        },
        priority: 'medium',
        dueDate: '',
        description: '',
        finalTitle: ''
      })
      setExecuteData({
        isToday: false,
        isFocused: false,
        startImmediately: false
      })
    }
  }, [isOpen, initialContent])

  // 단계 전환
  const handleStepTransition = async (newStep: CPERStep) => {
    setIsTransitioning(true)
    
    // 애니메이션 딜레이
    setTimeout(() => {
      setCurrentStep(newStep)
      setIsTransitioning(false)
    }, 150)
  }

  // 빠른 수집 (1단계만 수행)
  const handleQuickCapture = async () => {
    if (!captureData.content.trim()) return

    const inboxItem = {
      id: Date.now().toString(),
      title: captureData.title || captureData.content.substring(0, 50),
      content: captureData.content,
      type: captureData.type,
      status: 'captured',
      priority: 'medium',
      tags: captureData.tags,
      createdAt: new Date().toISOString()
    }

    onInboxItemCreated?.(inboxItem)
    onClose()
  }

  // 다음 단계로 진행
  const handleNextStep = () => {
    if (currentStep === CPERStep.CAPTURE) {
      handleStepTransition(CPERStep.PLAN)
    } else if (currentStep === CPERStep.PLAN) {
      if (planSubStep < PlanSubStep.DETAIL) {
        setPlanSubStep(planSubStep + 1)
      } else {
        handleStepTransition(CPERStep.EXECUTE)
      }
    } else if (currentStep === CPERStep.EXECUTE) {
      handleCreateTask()
    }
  }

  // 이전 단계로 이동
  const handlePreviousStep = () => {
    if (currentStep === CPERStep.EXECUTE) {
      handleStepTransition(CPERStep.PLAN)
      setPlanSubStep(PlanSubStep.DETAIL)
    } else if (currentStep === CPERStep.PLAN) {
      if (planSubStep > PlanSubStep.CLARIFY) {
        setPlanSubStep(planSubStep - 1)
      } else {
        handleStepTransition(CPERStep.CAPTURE)
      }
    }
  }

  // 최종 업무 생성
  const handleCreateTask = async () => {
    const task: WorklyTask = {
      id: Date.now().toString(),
      title: planData.finalTitle || captureData.title || captureData.content.substring(0, 50),
      description: planData.description || captureData.content,
      status: 'todo' as any,
      priority: planData.priority as any,
      type: 'task' as any,
      
      hierarchyType: planData.hierarchyChoice.type,
      projectId: planData.hierarchyChoice.projectId,
      goalId: planData.hierarchyChoice.goalId,
      
      cperWorkflow: {
        stage: CPERStage.PLANNED,
        capturedAt: new Date().toISOString(),
        plannedAt: new Date().toISOString(),
        planningData: {
          isActionable: planData.isActionable,
          canComplete2Minutes: planData.canComplete2Minutes,
          timeEstimate: planData.timeEstimate,
          priorityReasoning: `사용자가 ${planData.priority} 우선순위로 설정`,
          hierarchyChoice: planData.hierarchyChoice,
          nextAction: planData.nextAction
        }
      },
      
      isToday: executeData.isToday,
      isFocused: executeData.isFocused,
      nextAction: planData.nextAction,
      estimatedMinutes: planData.timeEstimate,
      actualMinutes: 0,
      
      assigneeId: 'user1', // TODO: 실제 사용자 ID
      assignee: {
        id: 'user1',
        name: '김워클리',
        email: 'workly@example.com'
      },
      
      tags: captureData.tags,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }

    onTaskCreated?.(task)
    
    if (executeData.startImmediately) {
      // TODO: 즉시 실행 모드로 전환
      console.log('즉시 실행 모드 시작:', task.title)
    }
    
    onClose()
  }

  // 현재 단계의 테마
  const currentTheme = stageThemes[currentStep]

  // 다음 단계 진행 가능 여부
  const canProceed = () => {
    if (currentStep === CPERStep.CAPTURE) {
      return captureData.content.trim().length > 0
    } else if (currentStep === CPERStep.PLAN) {
      if (planSubStep === PlanSubStep.CLARIFY) {
        return planData.nextAction.trim().length > 0
      } else if (planSubStep === PlanSubStep.ORGANIZE) {
        return true // 계층구조는 기본값 사용 가능
      } else {
        return (planData.finalTitle || captureData.title || captureData.content).trim().length > 0
      }
    } else if (currentStep === CPERStep.EXECUTE) {
      return true
    }
    return false
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-25">
      <div 
        ref={modalRef}
        className={`bg-white rounded-2xl shadow-2xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden transition-all duration-300 ${
          isTransitioning ? 'scale-95 opacity-75' : 'scale-100 opacity-100'
        }`}
      >
        {/* 헤더 */}
        <div className={`flex items-center justify-between p-6 border-b-2 ${currentTheme.border} ${currentTheme.bg}`}>
          <div className="flex items-center space-x-4">
            {/* 단계 아이콘 */}
            <div className={`w-12 h-12 rounded-xl ${currentTheme.button} flex items-center justify-center text-white`}>
              {currentStep === CPERStep.CAPTURE && <InboxIcon className="w-6 h-6" />}
              {currentStep === CPERStep.PLAN && <LightBulbIcon className="w-6 h-6" />}
              {currentStep === CPERStep.EXECUTE && <PlayIcon className="w-6 h-6" />}
              {currentStep === CPERStep.REVIEW && <ChartBarIcon className="w-6 h-6" />}
            </div>
            
            {/* 단계 정보 */}
            <div>
              <h2 className={`text-xl font-bold ${currentTheme.text}`}>
                {currentStep === CPERStep.CAPTURE && 'Capture - 수집'}
                {currentStep === CPERStep.PLAN && 'Plan - 계획'}
                {currentStep === CPERStep.EXECUTE && 'Execute - 실행'}
                {currentStep === CPERStep.REVIEW && 'Review - 검토'}
              </h2>
              <p className="text-sm text-gray-600">
                {currentStep === CPERStep.CAPTURE && '아이디어나 할 일을 빠르게 수집하세요'}
                {currentStep === CPERStep.PLAN && '수집된 내용을 구체적으로 계획하세요'}
                {currentStep === CPERStep.EXECUTE && '실행 준비를 완료하세요'}
                {currentStep === CPERStep.REVIEW && '결과를 검토하고 개선점을 찾으세요'}
              </p>
            </div>
          </div>

          {/* 진행률 표시 */}
          <div className="flex items-center space-x-3">
            <div className="flex space-x-1">
              {[0, 1, 2, 3].map((step) => (
                <div
                  key={step}
                  className={`w-3 h-3 rounded-full transition-all duration-200 ${
                    step <= currentStep 
                      ? currentTheme.button.replace('hover:', '').replace('bg-', 'bg-').split(' ')[0]
                      : 'bg-gray-200'
                  }`}
                />
              ))}
            </div>
            <span className="text-sm text-gray-500">{currentStep + 1}/4</span>
          </div>

          {/* 닫기 버튼 */}
          <button
            onClick={onClose}
            className="w-8 h-8 rounded-lg hover:bg-gray-100 flex items-center justify-center transition-colors"
          >
            <XMarkIcon className="w-5 h-5 text-gray-500" />
          </button>
        </div>

        {/* 컨텐츠 영역 */}
        <div className="p-6 max-h-[60vh] overflow-y-auto">
          {/* 1단계: Capture */}
          {currentStep === CPERStep.CAPTURE && (
            <CaptureStep
              data={captureData}
              onChange={setCaptureData}
              onQuickCapture={handleQuickCapture}
            />
          )}

          {/* 2단계: Plan */}
          {currentStep === CPERStep.PLAN && (
            <PlanStep
              captureData={captureData}
              planData={planData}
              subStep={planSubStep}
              onChange={setPlanData}
            />
          )}

          {/* 3단계: Execute */}
          {currentStep === CPERStep.EXECUTE && (
            <ExecuteStep
              captureData={captureData}
              planData={planData}
              executeData={executeData}
              onChange={setExecuteData}
            />
          )}
        </div>

        {/* 하단 액션 버튼 */}
        <div className={`px-6 py-4 border-t ${currentTheme.border} ${currentTheme.bg} flex justify-between`}>
          <div className="flex space-x-3">
            {currentStep > CPERStep.CAPTURE && (
              <button
                onClick={handlePreviousStep}
                className="flex items-center space-x-2 px-4 py-2 text-gray-600 hover:text-gray-800 font-medium transition-colors"
              >
                <ArrowLeftIcon className="w-4 h-4" />
                <span>이전</span>
              </button>
            )}

            {currentStep === CPERStep.CAPTURE && (
              <button
                onClick={handleQuickCapture}
                disabled={!captureData.content.trim()}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                빠른 수집만
              </button>
            )}
          </div>

          <div className="flex space-x-3">
            <button
              onClick={onClose}
              className="px-6 py-2 text-gray-600 hover:text-gray-800 font-medium transition-colors"
            >
              취소
            </button>
            
            <button
              onClick={handleNextStep}
              disabled={!canProceed()}
              className={`px-6 py-2 rounded-lg font-medium text-white transition-all flex items-center space-x-2 ${
                canProceed() 
                  ? currentTheme.button
                  : 'bg-gray-300 cursor-not-allowed'
              }`}
            >
              <span>
                {currentStep === CPERStep.CAPTURE && '계획하기'}
                {currentStep === CPERStep.PLAN && planSubStep < PlanSubStep.DETAIL && '다음'}
                {currentStep === CPERStep.PLAN && planSubStep === PlanSubStep.DETAIL && '실행 준비'}
                {currentStep === CPERStep.EXECUTE && '업무 생성'}
              </span>
              <ArrowRightIcon className="w-4 h-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

// 1단계: Capture 컴포넌트
interface CaptureStepProps {
  data: any
  onChange: (data: any) => void
  onQuickCapture: () => void
}

function CaptureStep({ data, onChange, onQuickCapture }: CaptureStepProps) {
  const handleTypeSelect = (type: string) => {
    onChange({ ...data, type })
  }

  return (
    <div className="space-y-6">
      {/* 타입 선택 */}
      <div>
        <h3 className="text-lg font-semibold text-gray-900 mb-4">무엇을 수집하시겠어요?</h3>
        <div className="grid grid-cols-2 gap-3">
          {captureTypes.map((type) => {
            const Icon = type.icon
            const isSelected = data.type === type.id
            
            return (
              <button
                key={type.id}
                onClick={() => handleTypeSelect(type.id)}
                className={`p-4 rounded-xl border-2 transition-all text-left ${
                  isSelected
                    ? `${type.borderColor} ${type.color.split(' ')[1]} ring-2 ring-opacity-20`
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <div className="flex items-center space-x-3 mb-2">
                  <div className={`w-8 h-8 rounded-lg ${type.color} flex items-center justify-center`}>
                    <Icon className="w-5 h-5" />
                  </div>
                  <span className="font-medium text-gray-900">{type.label}</span>
                </div>
                <p className="text-xs text-gray-500">{type.description}</p>
              </button>
            )
          })}
        </div>
      </div>

      {/* 내용 입력 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          떠오른 생각을 자유롭게 적어보세요
        </label>
        <textarea
          value={data.content}
          onChange={(e) => onChange({ ...data, content: e.target.value })}
          placeholder="예: 사용자 피드백을 정리해서 개선사항을 도출해야겠다..."
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
          rows={6}
          autoFocus
        />
      </div>

      {/* 제목 (선택적) */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          제목 (선택사항)
        </label>
        <input
          type="text"
          value={data.title}
          onChange={(e) => onChange({ ...data, title: e.target.value })}
          placeholder="간단한 제목을 입력하세요"
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
      </div>

      {/* 빠른 수집 안내 */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div className="flex items-center space-x-2 text-blue-800">
          <CheckCircleIcon className="w-5 h-5" />
          <span className="font-medium">빠른 수집 팁</span>
        </div>
        <p className="text-sm text-blue-700 mt-1">
          지금 바로 저장하고 싶다면 "빠른 수집만" 버튼을 누르세요. 
          나중에 수집함에서 다시 정리할 수 있습니다.
        </p>
      </div>
    </div>
  )
}

// 2단계: Plan 컴포넌트 (별도 파일로 분리 예정)
interface PlanStepProps {
  captureData: any
  planData: any
  subStep: PlanSubStep
  onChange: (data: any) => void
}

function PlanStep({ captureData, planData, subStep, onChange }: PlanStepProps) {
  // 명확화 단계
  if (subStep === PlanSubStep.CLARIFY) {
    return (
      <div className="space-y-6">
        <h3 className="text-lg font-semibold text-gray-900">수집한 내용을 명확히 해보세요</h3>
        
        {/* 실행 가능성 확인 */}
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h4 className="font-medium text-green-900 mb-3">실행 가능성 확인</h4>
          
          <div className="space-y-3">
            <label className="flex items-center space-x-3">
              <input
                type="checkbox"
                checked={planData.isActionable}
                onChange={(e) => onChange({ ...planData, isActionable: e.target.checked })}
                className="w-5 h-5 text-green-600 rounded focus:ring-green-500"
              />
              <span className="text-sm text-green-800">지금 바로 실행할 수 있는 구체적인 행동인가요?</span>
            </label>
            
            <label className="flex items-center space-x-3">
              <input
                type="checkbox"
                checked={planData.canComplete2Minutes}
                onChange={(e) => onChange({ ...planData, canComplete2Minutes: e.target.checked })}
                className="w-5 h-5 text-green-600 rounded focus:ring-green-500"
              />
              <span className="text-sm text-green-800">2분 안에 완료할 수 있나요?</span>
            </label>
          </div>
        </div>

        {/* 다음 액션 정의 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            첫 번째로 해야 할 구체적인 행동은 무엇인가요? *
          </label>
          <input
            type="text"
            value={planData.nextAction}
            onChange={(e) => onChange({ ...planData, nextAction: e.target.value })}
            placeholder="예: 구글 드라이브에서 피드백 파일 찾기"
            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent"
          />
        </div>

        {/* 시간 추정 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            예상 소요 시간 (분)
          </label>
          <input
            type="number"
            value={planData.timeEstimate}
            onChange={(e) => onChange({ ...planData, timeEstimate: parseInt(e.target.value) || 30 })}
            min="5"
            max="480"
            className="w-32 px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent"
          />
        </div>
      </div>
    )
  }

  // 구조화 단계
  if (subStep === PlanSubStep.ORGANIZE) {
    return (
      <div className="space-y-6">
        <h3 className="text-lg font-semibold text-gray-900">이 업무를 어떻게 관리하시겠어요?</h3>
        
        {/* 계층구조 선택 */}
        <div className="space-y-4">
          {Object.values(HierarchyType).map((type) => (
            <label
              key={type}
              className={`flex items-start space-x-3 p-4 border-2 rounded-xl cursor-pointer transition-all ${
                planData.hierarchyChoice.type === type
                  ? 'border-green-300 bg-green-50'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
            >
              <input
                type="radio"
                name="hierarchy"
                value={type}
                checked={planData.hierarchyChoice.type === type}
                onChange={(e) => onChange({
                  ...planData,
                  hierarchyChoice: { ...planData.hierarchyChoice, type: e.target.value as HierarchyType }
                })}
                className="w-5 h-5 text-green-600 mt-0.5"
              />
              <div>
                <div className="font-medium text-gray-900">
                  {type === HierarchyType.INDEPENDENT && '독립적 업무'}
                  {type === HierarchyType.PROJECT_ONLY && '프로젝트의 일부'}
                  {type === HierarchyType.GOAL_DIRECT && '목표의 일부'}
                  {type === HierarchyType.FULL_HIERARCHY && '프로젝트 → 목표'}
                </div>
                <div className="text-sm text-gray-600 mt-1">
                  {type === HierarchyType.INDEPENDENT && '간단하고 빠르게 처리할 수 있는 업무'}
                  {type === HierarchyType.PROJECT_ONLY && '특정 프로젝트에 속하지만 상위 목표는 없음'}
                  {type === HierarchyType.GOAL_DIRECT && '목표에 직접 연결되는 중요한 업무'}
                  {type === HierarchyType.FULL_HIERARCHY && '프로젝트를 통해 목표에 기여하는 업무'}
                </div>
              </div>
            </label>
          ))}
        </div>

        {/* 프로젝트/목표 선택 UI (필요시) */}
        {planData.hierarchyChoice.type !== HierarchyType.INDEPENDENT && (
          <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
            <p className="text-sm text-amber-800">
              💡 프로젝트나 목표 선택은 다음 단계에서 설정할 수 있습니다.
            </p>
          </div>
        )}
      </div>
    )
  }

  // 상세 계획 단계
  return (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">마지막으로 세부사항을 정리해보세요</h3>
      
      {/* 최종 제목 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          업무 제목 *
        </label>
        <input
          type="text"
          value={planData.finalTitle}
          onChange={(e) => onChange({ ...planData, finalTitle: e.target.value })}
          placeholder={captureData.title || captureData.content.substring(0, 50)}
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent"
        />
      </div>

      {/* 우선순위 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          우선순위
        </label>
        <select
          value={planData.priority}
          onChange={(e) => onChange({ ...planData, priority: e.target.value })}
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent"
        >
          <option value="low">낮음</option>
          <option value="medium">보통</option>
          <option value="high">높음</option>
          <option value="urgent">긴급</option>
        </select>
      </div>

      {/* 마감일 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          마감일 (선택사항)
        </label>
        <input
          type="date"
          value={planData.dueDate}
          onChange={(e) => onChange({ ...planData, dueDate: e.target.value })}
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent"
        />
      </div>

      {/* 상세 설명 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          상세 설명 (선택사항)
        </label>
        <textarea
          value={planData.description}
          onChange={(e) => onChange({ ...planData, description: e.target.value })}
          placeholder="추가적인 설명이나 참고사항을 입력하세요"
          className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-green-500 focus:border-transparent resize-none"
          rows={3}
        />
      </div>
    </div>
  )
}

// 3단계: Execute 컴포넌트
interface ExecuteStepProps {
  captureData: any
  planData: any
  executeData: any
  onChange: (data: any) => void
}

function ExecuteStep({ captureData, planData, executeData, onChange }: ExecuteStepProps) {
  return (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">실행 준비를 완료하세요</h3>
      
      {/* 업무 요약 */}
      <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
        <h4 className="font-medium text-amber-900 mb-2">생성될 업무</h4>
        <div className="space-y-1 text-sm text-amber-800">
          <div><span className="font-medium">제목:</span> {planData.finalTitle || captureData.title || captureData.content.substring(0, 50)}</div>
          <div><span className="font-medium">다음 액션:</span> {planData.nextAction}</div>
          <div><span className="font-medium">예상 시간:</span> {planData.timeEstimate}분</div>
          <div><span className="font-medium">우선순위:</span> {planData.priority}</div>
          <div><span className="font-medium">관리 방식:</span> {
            planData.hierarchyChoice.type === HierarchyType.INDEPENDENT ? '독립적 업무' :
            planData.hierarchyChoice.type === HierarchyType.PROJECT_ONLY ? '프로젝트의 일부' :
            planData.hierarchyChoice.type === HierarchyType.GOAL_DIRECT ? '목표의 일부' : '프로젝트 → 목표'
          }</div>
        </div>
      </div>

      {/* 실행 옵션 */}
      <div className="space-y-4">
        <h4 className="font-medium text-gray-900">실행 옵션</h4>
        
        <label className="flex items-center space-x-3">
          <input
            type="checkbox"
            checked={executeData.isToday}
            onChange={(e) => onChange({ ...executeData, isToday: e.target.checked })}
            className="w-5 h-5 text-amber-600 rounded focus:ring-amber-500"
          />
          <div>
            <span className="font-medium text-gray-900">오늘 할 일로 설정</span>
            <p className="text-sm text-gray-600">홈화면의 "오늘 할 일" 목록에 표시됩니다</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3">
          <input
            type="checkbox"
            checked={executeData.isFocused}
            onChange={(e) => onChange({ ...executeData, isFocused: e.target.checked })}
            className="w-5 h-5 text-amber-600 rounded focus:ring-amber-500"
          />
          <div>
            <span className="font-medium text-gray-900">집중 업무로 설정</span>
            <p className="text-sm text-gray-600">가장 중요한 업무로 하이라이트 표시됩니다</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3">
          <input
            type="checkbox"
            checked={executeData.startImmediately}
            onChange={(e) => onChange({ ...executeData, startImmediately: e.target.checked })}
            className="w-5 h-5 text-amber-600 rounded focus:ring-amber-500"
          />
          <div>
            <span className="font-medium text-gray-900">지금 바로 시작</span>
            <p className="text-sm text-gray-600">업무 생성 후 즉시 실행 모드로 전환됩니다</p>
          </div>
        </label>
      </div>

      {/* 시간 관리 팁 */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div className="flex items-center space-x-2 text-blue-800 mb-2">
          <ClockIcon className="w-5 h-5" />
          <span className="font-medium">시간 관리 팁</span>
        </div>
        <p className="text-sm text-blue-700">
          {planData.canComplete2Minutes 
            ? '2분 안에 완료할 수 있는 업무라면 지금 바로 처리하는 것이 좋습니다.'
            : `${planData.timeEstimate}분 예상 소요 시간을 고려하여 적절한 시간대에 실행하세요.`
          }
        </p>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/inbox/InboxModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { 
  XMarkIcon,
  InboxIcon,
  ClipboardDocumentIcon,
  FolderPlusIcon,
  FlagIcon,
  PlusIcon,
  CheckCircleIcon
} from '@heroicons/react/24/outline'

interface InboxModalProps {
  isOpen: boolean
  onClose: () => void
  onAddTask?: (title: string, content: string) => void
  onAddProject?: (title: string, content: string) => void  
  onAddGoal?: (title: string, content: string) => void
  onQuickCapture?: (content: string) => void
}

interface CaptureItem {
  id: string
  type: 'task' | 'project' | 'goal' | 'idea'
  title: string
  content: string
  icon: any
  color: string
}

export default function InboxModal({
  isOpen,
  onClose,
  onAddTask,
  onAddProject,
  onAddGoal,
  onQuickCapture
}: InboxModalProps) {
  const [captureText, setCaptureText] = useState('')
  const [selectedType, setSelectedType] = useState<'task' | 'project' | 'goal' | 'idea'>('idea')
  const [title, setTitle] = useState('')
  const [showTitleInput, setShowTitleInput] = useState(false)

  // ESC 키로 모달 닫기
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    if (isOpen) {
      document.addEventListener('keydown', handleEsc)
      return () => document.removeEventListener('keydown', handleEsc)
    }
  }, [isOpen, onClose])

  // 모달이 열릴 때 상태 초기화
  useEffect(() => {
    if (isOpen) {
      setCaptureText('')
      setTitle('')
      setShowTitleInput(false)
      setSelectedType('idea')
    }
  }, [isOpen])

  const captureTypes = [
    {
      id: 'idea' as const,
      label: '아이디어',
      description: '떠오른 생각이나 영감을 수집',
      icon: InboxIcon,
      color: 'text-amber-600 bg-amber-100',
      borderColor: 'border-amber-200'
    },
    {
      id: 'task' as const,
      label: '업무',
      description: '해야 할 작업이나 할 일',
      icon: ClipboardDocumentIcon,
      color: 'text-blue-600 bg-blue-100',
      borderColor: 'border-blue-200'
    },
    {
      id: 'project' as const,
      label: '프로젝트',
      description: '큰 목표나 여러 업무의 묶음',
      icon: FolderPlusIcon,
      color: 'text-green-600 bg-green-100',
      borderColor: 'border-green-200'
    },
    {
      id: 'goal' as const,
      label: '목표',
      description: '장기적인 목표나 성과지표',
      icon: FlagIcon,
      color: 'text-purple-600 bg-purple-100',
      borderColor: 'border-purple-200'
    }
  ]

  const selectedTypeInfo = captureTypes.find(type => type.id === selectedType)

  const handleSubmit = () => {
    if (!captureText.trim()) return

    const finalTitle = title.trim() || captureText.trim().split('\n')[0].substring(0, 50)
    const content = captureText.trim()

    switch (selectedType) {
      case 'task':
        onAddTask?.(finalTitle, content)
        break
      case 'project':
        onAddProject?.(finalTitle, content)
        break
      case 'goal':
        onAddGoal?.(finalTitle, content)
        break
      case 'idea':
      default:
        onQuickCapture?.(content)
        break
    }

    onClose()
  }

  const handleTypeSelect = (type: typeof selectedType) => {
    setSelectedType(type)
    setShowTitleInput(type !== 'idea')
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-25">
      <div className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-hidden">
        {/* 헤더 */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 rounded-xl bg-gradient-to-r from-amber-500 to-orange-500 flex items-center justify-center">
              <InboxIcon className="w-6 h-6 text-white" />
            </div>
            <div>
              <h2 className="text-xl font-bold text-gray-900">수집함</h2>
              <p className="text-sm text-gray-500">CPER 워크플로우의 핵심 생성 기능</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 rounded-lg hover:bg-gray-100 flex items-center justify-center transition-colors"
          >
            <XMarkIcon className="w-5 h-5 text-gray-500" />
          </button>
        </div>

        {/* 타입 선택 */}
        <div className="p-6 border-b border-gray-200">
          <h3 className="text-sm font-medium text-gray-700 mb-3">무엇을 생성하시겠어요?</h3>
          <div className="grid grid-cols-2 gap-3">
            {captureTypes.map((type) => {
              const Icon = type.icon
              const isSelected = selectedType === type.id
              
              return (
                <button
                  key={type.id}
                  onClick={() => handleTypeSelect(type.id)}
                  className={`p-4 rounded-xl border-2 transition-all text-left ${
                    isSelected
                      ? `${type.borderColor} ${type.color.split(' ')[1]} ring-2 ring-opacity-20`
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <div className="flex items-center space-x-3 mb-2">
                    <div className={`w-8 h-8 rounded-lg ${type.color} flex items-center justify-center`}>
                      <Icon className="w-5 h-5" />
                    </div>
                    <span className="font-medium text-gray-900">{type.label}</span>
                  </div>
                  <p className="text-xs text-gray-500">{type.description}</p>
                </button>
              )
            })}
          </div>
        </div>

        {/* 내용 입력 */}
        <div className="p-6">
          {showTitleInput && (
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                제목
              </label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder={`${selectedTypeInfo?.label} 제목을 입력하세요`}
                className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-transparent"
              />
            </div>
          )}

          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              {selectedType === 'idea' ? '내용' : '상세 내용'}
            </label>
            <textarea
              value={captureText}
              onChange={(e) => setCaptureText(e.target.value)}
              placeholder={`${selectedTypeInfo?.label}에 대해 자세히 설명해주세요...`}
              className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-transparent resize-none"
              rows={6}
              autoFocus
            />
          </div>

          {/* 액션 버튼 */}
          <div className="flex justify-end space-x-3">
            <button
              onClick={onClose}
              className="px-6 py-3 text-gray-600 hover:text-gray-800 font-medium transition-colors"
            >
              취소
            </button>
            <button
              onClick={handleSubmit}
              disabled={!captureText.trim()}
              className={`px-6 py-3 rounded-xl font-medium transition-all flex items-center space-x-2 ${
                captureText.trim()
                  ? `${selectedTypeInfo?.color.split(' ')[1].replace('bg-', 'bg-').replace('-100', '-500')} text-white hover:${selectedTypeInfo?.color.split(' ')[1].replace('bg-', 'bg-').replace('-100', '-600')}`
                  : 'bg-gray-200 text-gray-400 cursor-not-allowed'
              }`}
            >
              <PlusIcon className="w-5 h-5" />
              <span>{selectedTypeInfo?.label} 생성</span>
            </button>
          </div>
        </div>

        {/* 하단 안내 */}
        <div className="px-6 py-4 bg-gray-50 border-t border-gray-200">
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <CheckCircleIcon className="w-4 h-4" />
            <span>수집된 항목은 CPER 워크플로우에 따라 계획 단계로 이동됩니다</span>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/projects/ProjectObjectiveManager.tsx">
'use client'

import React, { useState } from 'react'
import { Target, Plus, CheckCircle, Edit2, Trash2, Calendar, BarChart3, TrendingUp } from 'lucide-react'
import { Project, ProjectObjective, ProjectKeyResult } from '@/types/project.types'

interface ProjectObjectiveManagerProps {
  project: Project
  onObjectiveUpdate?: (objectiveId: string, data: Partial<ProjectObjective>) => void
  onKeyResultUpdate?: (keyResultId: string, data: Partial<ProjectKeyResult>) => void
  onObjectiveCreate?: (data: Omit<ProjectObjective, 'id'>) => void
  onKeyResultCreate?: (objectiveId: string, data: Omit<ProjectKeyResult, 'id' | 'objectiveId'>) => void
}

export default function ProjectObjectiveManager({
  project,
  onObjectiveUpdate,
  onKeyResultUpdate,
  onObjectiveCreate,
  onKeyResultCreate
}: ProjectObjectiveManagerProps) {
  const [isAddingObjective, setIsAddingObjective] = useState(false)
  const [editingObjective, setEditingObjective] = useState<string | null>(null)
  const [addingKeyResultTo, setAddingKeyResultTo] = useState<string | null>(null)
  const [newObjective, setNewObjective] = useState({ title: '', description: '' })
  const [newKeyResult, setNewKeyResult] = useState({ 
    title: '', 
    description: '', 
    targetValue: 0, 
    currentValue: 0, 
    unit: '' 
  })

  // 목표 추가
  const handleAddObjective = () => {
    if (!newObjective.title.trim()) return

    onObjectiveCreate?.({
      title: newObjective.title,
      description: newObjective.description || undefined,
      completed: false
    })

    setNewObjective({ title: '', description: '' })
    setIsAddingObjective(false)
  }

  // 핵심 결과 추가
  const handleAddKeyResult = (objectiveId: string) => {
    if (!newKeyResult.title.trim()) return

    onKeyResultCreate?.(objectiveId, {
      title: newKeyResult.title,
      description: newKeyResult.description || undefined,
      targetValue: newKeyResult.targetValue,
      currentValue: newKeyResult.currentValue,
      unit: newKeyResult.unit,
      completed: false
    })

    setNewKeyResult({ title: '', description: '', targetValue: 0, currentValue: 0, unit: '' })
    setAddingKeyResultTo(null)
  }

  // 목표 완료 토글
  const handleToggleObjective = (objective: ProjectObjective) => {
    onObjectiveUpdate?.(objective.id, {
      completed: !objective.completed,
      completedAt: !objective.completed ? new Date().toISOString() : undefined
    })
  }

  // 핵심 결과 진행률 업데이트
  const handleUpdateKeyResultProgress = (keyResult: ProjectKeyResult, currentValue: number) => {
    const completed = currentValue >= keyResult.targetValue
    onKeyResultUpdate?.(keyResult.id, {
      currentValue,
      completed,
      completedAt: completed ? new Date().toISOString() : undefined
    })
  }

  // 진행률 계산
  const calculateProgress = (current: number, target: number) => {
    if (target === 0) return 0
    return Math.min((current / target) * 100, 100)
  }

  // 전체 프로젝트 진행률 계산
  const calculateOverallProgress = () => {
    if (project.objectives.length === 0) return 0
    
    const totalKeyResults = project.keyResults.length
    if (totalKeyResults === 0) return 0
    
    const completedKeyResults = project.keyResults.filter(kr => kr.completed).length
    return Math.round((completedKeyResults / totalKeyResults) * 100)
  }

  return (
    <div className="bg-white rounded-lg border border-gray-200 p-6">
      {/* 헤더 */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-3">
          <Target className="w-6 h-6 text-blue-600" />
          <div>
            <h3 className="text-lg font-semibold text-gray-900">목표 및 핵심 결과 (OKR)</h3>
            <p className="text-sm text-gray-500">프로젝트의 목표와 측정 가능한 결과를 관리합니다</p>
          </div>
        </div>
        <div className="flex items-center space-x-3">
          <div className="text-right">
            <div className="text-2xl font-bold text-blue-600">{calculateOverallProgress()}%</div>
            <div className="text-xs text-gray-500">전체 진행률</div>
          </div>
          <button
            onClick={() => setIsAddingObjective(true)}
            className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            <Plus className="w-4 h-4" />
            <span>목표 추가</span>
          </button>
        </div>
      </div>

      {/* 전체 진행률 시각화 */}
      <div className="mb-6 p-4 bg-gray-50 rounded-lg">
        <div className="flex items-center justify-between text-sm mb-2">
          <span className="text-gray-600">프로젝트 전체 진행률</span>
          <span className="font-medium">{calculateOverallProgress()}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-3">
          <div 
            className="bg-blue-600 h-3 rounded-full transition-all duration-300"
            style={{ width: `${calculateOverallProgress()}%` }}
          />
        </div>
        <div className="flex items-center justify-between text-xs text-gray-500 mt-2">
          <span>{project.keyResults.filter(kr => kr.completed).length} / {project.keyResults.length} 완료</span>
          <span>{project.objectives.filter(obj => obj.completed).length} / {project.objectives.length} 목표 달성</span>
        </div>
      </div>

      {/* 새 목표 추가 폼 */}
      {isAddingObjective && (
        <div className="mb-6 p-4 border border-blue-200 rounded-lg bg-blue-50">
          <h4 className="font-medium text-gray-900 mb-3">새 목표 추가</h4>
          <div className="space-y-3">
            <input
              type="text"
              value={newObjective.title}
              onChange={(e) => setNewObjective(prev => ({ ...prev, title: e.target.value }))}
              placeholder="목표 제목 (예: 새로운 마케팅 웹사이트 런칭)"
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <textarea
              value={newObjective.description}
              onChange={(e) => setNewObjective(prev => ({ ...prev, description: e.target.value }))}
              placeholder="목표 설명 (선택사항)"
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <div className="flex space-x-3">
              <button
                onClick={handleAddObjective}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                목표 추가
              </button>
              <button
                onClick={() => setIsAddingObjective(false)}
                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
              >
                취소
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 목표 목록 */}
      <div className="space-y-6">
        {project.objectives.map((objective) => {
          const objectiveKeyResults = project.keyResults.filter(kr => kr.objectiveId === objective.id)
          const completedKRs = objectiveKeyResults.filter(kr => kr.completed).length
          const objectiveProgress = objectiveKeyResults.length > 0 
            ? Math.round((completedKRs / objectiveKeyResults.length) * 100) 
            : 0

          return (
            <div key={objective.id} className="border border-gray-200 rounded-lg p-4">
              {/* 목표 헤더 */}
              <div className="flex items-start justify-between mb-4">
                <div className="flex items-start space-x-3 flex-1">
                  <button
                    onClick={() => handleToggleObjective(objective)}
                    className={`mt-1 ${objective.completed ? 'text-green-600' : 'text-gray-400'}`}
                  >
                    <CheckCircle className="w-5 h-5" />
                  </button>
                  <div className="flex-1">
                    <h4 className={`font-medium ${objective.completed ? 'line-through text-gray-500' : 'text-gray-900'}`}>
                      {objective.title}
                    </h4>
                    {objective.description && (
                      <p className="text-sm text-gray-600 mt-1">{objective.description}</p>
                    )}
                    <div className="flex items-center space-x-4 mt-2">
                      <div className="flex items-center space-x-1 text-sm text-gray-500">
                        <BarChart3 className="w-4 h-4" />
                        <span>{objectiveProgress}% 완료</span>
                      </div>
                      <div className="flex items-center space-x-1 text-sm text-gray-500">
                        <TrendingUp className="w-4 h-4" />
                        <span>{completedKRs}/{objectiveKeyResults.length} KR</span>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <button
                    onClick={() => setAddingKeyResultTo(objective.id)}
                    className="p-2 hover:bg-gray-100 rounded-lg"
                    title="핵심 결과 추가"
                  >
                    <Plus className="w-4 h-4 text-gray-500" />
                  </button>
                  <button
                    onClick={() => setEditingObjective(objective.id)}
                    className="p-2 hover:bg-gray-100 rounded-lg"
                    title="목표 편집"
                  >
                    <Edit2 className="w-4 h-4 text-gray-500" />
                  </button>
                </div>
              </div>

              {/* 목표 진행률 바 */}
              <div className="mb-4">
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className={`h-2 rounded-full transition-all duration-300 ${
                      objective.completed ? 'bg-green-600' : 'bg-blue-600'
                    }`}
                    style={{ width: `${objectiveProgress}%` }}
                  />
                </div>
              </div>

              {/* 핵심 결과 추가 폼 */}
              {addingKeyResultTo === objective.id && (
                <div className="mb-4 p-3 border border-green-200 rounded-lg bg-green-50">
                  <h5 className="font-medium text-gray-900 mb-3">새 핵심 결과 추가</h5>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <input
                      type="text"
                      value={newKeyResult.title}
                      onChange={(e) => setNewKeyResult(prev => ({ ...prev, title: e.target.value }))}
                      placeholder="핵심 결과 제목"
                      className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                    />
                    <input
                      type="text"
                      value={newKeyResult.unit}
                      onChange={(e) => setNewKeyResult(prev => ({ ...prev, unit: e.target.value }))}
                      placeholder="단위 (예: 명, %, 건)"
                      className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                    />
                    <input
                      type="number"
                      value={newKeyResult.targetValue}
                      onChange={(e) => setNewKeyResult(prev => ({ ...prev, targetValue: Number(e.target.value) }))}
                      placeholder="목표값"
                      className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                    />
                    <input
                      type="number"
                      value={newKeyResult.currentValue}
                      onChange={(e) => setNewKeyResult(prev => ({ ...prev, currentValue: Number(e.target.value) }))}
                      placeholder="현재값"
                      className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                    />
                  </div>
                  <div className="flex space-x-3 mt-3">
                    <button
                      onClick={() => handleAddKeyResult(objective.id)}
                      className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                    >
                      핵심 결과 추가
                    </button>
                    <button
                      onClick={() => setAddingKeyResultTo(null)}
                      className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                    >
                      취소
                    </button>
                  </div>
                </div>
              )}

              {/* 핵심 결과 목록 */}
              <div className="space-y-3">
                {objectiveKeyResults.map((keyResult) => {
                  const progress = calculateProgress(keyResult.currentValue, keyResult.targetValue)
                  
                  return (
                    <div key={keyResult.id} className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
                      <CheckCircle className={`w-4 h-4 ${keyResult.completed ? 'text-green-600' : 'text-gray-400'}`} />
                      <div className="flex-1">
                        <div className="flex items-center justify-between mb-1">
                          <span className={`text-sm font-medium ${keyResult.completed ? 'line-through text-gray-500' : 'text-gray-900'}`}>
                            {keyResult.title}
                          </span>
                          <span className="text-sm text-gray-600">
                            {keyResult.currentValue} / {keyResult.targetValue} {keyResult.unit}
                          </span>
                        </div>
                        <div className="flex items-center space-x-2">
                          <div className="flex-1 bg-gray-200 rounded-full h-1.5">
                            <div 
                              className={`h-1.5 rounded-full transition-all duration-300 ${
                                keyResult.completed ? 'bg-green-600' : 'bg-blue-600'
                              }`}
                              style={{ width: `${progress}%` }}
                            />
                          </div>
                          <span className="text-xs text-gray-500 w-12">{Math.round(progress)}%</span>
                        </div>
                      </div>
                      <div className="flex items-center space-x-1">
                        <input
                          type="number"
                          value={keyResult.currentValue}
                          onChange={(e) => handleUpdateKeyResultProgress(keyResult, Number(e.target.value))}
                          className="w-16 px-2 py-1 text-xs border border-gray-300 rounded focus:ring-1 focus:ring-blue-500"
                        />
                        <span className="text-xs text-gray-500">/{keyResult.targetValue}</span>
                      </div>
                    </div>
                  )
                })}
                
                {objectiveKeyResults.length === 0 && (
                  <div className="text-center py-4 text-gray-500">
                    <Target className="w-8 h-8 text-gray-400 mx-auto mb-2" />
                    <p className="text-sm">아직 핵심 결과가 없습니다</p>
                    <button
                      onClick={() => setAddingKeyResultTo(objective.id)}
                      className="text-sm text-blue-600 hover:text-blue-800 mt-1"
                    >
                      첫 번째 핵심 결과 추가하기
                    </button>
                  </div>
                )}
              </div>
            </div>
          )
        })}

        {project.objectives.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            <Target className="w-12 h-12 text-gray-400 mx-auto mb-3" />
            <h4 className="font-medium text-gray-900 mb-2">아직 목표가 설정되지 않았습니다</h4>
            <p className="text-sm mb-4">프로젝트의 첫 번째 목표를 설정해보세요</p>
            <button
              onClick={() => setIsAddingObjective(true)}
              className="inline-flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              <Plus className="w-4 h-4" />
              <span>목표 추가하기</span>
            </button>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/projects/SlashCommandInput.tsx">
'use client'

import React, { useState, useEffect } from 'react'
import { Calendar, User, Target, BookOpen, Command } from 'lucide-react'
import { ProjectMember } from '@/types/project.types'

interface SlashCommand {
  command: string
  description: string
  parameters: SlashCommandParameter[]
  example: string
  icon: React.ReactNode
}

interface SlashCommandParameter {
  name: string
  type: 'text' | 'user' | 'date' | 'select'
  required: boolean
  description: string
  options?: string[]
}

interface SlashCommandInputProps {
  input: string
  onCommandExecute: (command: string, params: any) => void
  onCancel: () => void
  members: ProjectMember[]
}

export default function SlashCommandInput({
  input,
  onCommandExecute,
  onCancel,
  members
}: SlashCommandInputProps) {
  const [selectedCommand, setSelectedCommand] = useState<SlashCommand | null>(null)
  const [parameters, setParameters] = useState<{ [key: string]: any }>({})
  const [currentParameterIndex, setCurrentParameterIndex] = useState(0)

  // 사용 가능한 슬래시 명령어 정의
  const availableCommands: SlashCommand[] = [
    {
      command: 'add-task',
      description: '새 업무를 생성하고 담당자를 지정합니다',
      icon: <Target className="w-4 h-4" />,
      parameters: [
        {
          name: 'title',
          type: 'text',
          required: true,
          description: '업무 제목'
        },
        {
          name: 'assignee',
          type: 'user',
          required: true,
          description: '담당자'
        },
        {
          name: 'dueDate',
          type: 'date',
          required: false,
          description: '마감일'
        },
        {
          name: 'priority',
          type: 'select',
          required: false,
          description: '우선순위',
          options: ['low', 'medium', 'high', 'urgent']
        }
      ],
      example: '/add-task UI 디자인 완료 @김디자이너 2024-01-30'
    },
    {
      command: 'delegate',
      description: '기존 업무를 다른 멤버에게 재할당합니다',
      icon: <User className="w-4 h-4" />,
      parameters: [
        {
          name: 'taskId',
          type: 'text',
          required: true,
          description: '업무 ID 또는 제목'
        },
        {
          name: 'toUser',
          type: 'user',
          required: true,
          description: '새 담당자'
        }
      ],
      example: '/delegate #123 @박개발자'
    },
    {
      command: 'set-milestone',
      description: '새로운 프로젝트 마일스톤을 설정합니다',
      icon: <Target className="w-4 h-4" />,
      parameters: [
        {
          name: 'name',
          type: 'text',
          required: true,
          description: '마일스톤 이름'
        },
        {
          name: 'dueDate',
          type: 'date',
          required: true,
          description: '마감일'
        },
        {
          name: 'description',
          type: 'text',
          required: false,
          description: '상세 설명'
        }
      ],
      example: '/set-milestone "Beta 버전 출시" 2024-02-15'
    },
    {
      command: 'link-wiki',
      description: '게시판의 위키 문서를 채팅에 연결합니다',
      icon: <BookOpen className="w-4 h-4" />,
      parameters: [
        {
          name: 'documentName',
          type: 'text',
          required: true,
          description: '위키 문서명'
        }
      ],
      example: '/link-wiki "React 컴포넌트 가이드"'
    }
  ]

  // 입력값에서 명령어 파싱
  useEffect(() => {
    if (!input.startsWith('/')) {
      setSelectedCommand(null)
      setParameters({})
      setCurrentParameterIndex(0)
      return
    }

    const commandText = input.slice(1).split(' ')[0]
    const command = availableCommands.find(cmd => cmd.command === commandText)
    
    if (command && command !== selectedCommand) {
      setSelectedCommand(command)
      setParameters({})
      setCurrentParameterIndex(0)
    }

    // 기본 파라미터 파싱 (간단한 구현)
    if (command) {
      const args = input.slice(1).split(' ').slice(1)
      const newParams: { [key: string]: any } = {}
      
      args.forEach((arg, index) => {
        if (command.parameters[index]) {
          const param = command.parameters[index]
          if (param.type === 'user' && arg.startsWith('@')) {
            newParams[param.name] = arg.slice(1)
          } else {
            newParams[param.name] = arg
          }
        }
      })
      
      setParameters(newParams)
    }
  }, [input, selectedCommand])

  // 명령어 실행
  const handleExecuteCommand = () => {
    if (!selectedCommand) return

    // 필수 파라미터 검증
    const missingRequired = selectedCommand.parameters
      .filter(param => param.required && !parameters[param.name])
      .map(param => param.name)

    if (missingRequired.length > 0) {
      console.warn('필수 파라미터 누락:', missingRequired)
      return
    }

    onCommandExecute(selectedCommand.command, parameters)
  }

  // 파라미터 값 업데이트
  const handleParameterChange = (paramName: string, value: any) => {
    setParameters(prev => ({
      ...prev,
      [paramName]: value
    }))
  }

  // 명령어 목록 표시
  if (!selectedCommand) {
    const filteredCommands = availableCommands.filter(cmd =>
      cmd.command.toLowerCase().includes(input.slice(1).toLowerCase())
    )

    return (
      <div className="p-4 bg-white border-b border-gray-200">
        <div className="flex items-center space-x-2 mb-3">
          <Command className="w-4 h-4 text-gray-500" />
          <span className="text-sm font-medium text-gray-700">사용 가능한 명령어</span>
        </div>
        
        <div className="space-y-2">
          {filteredCommands.map((command) => (
            <div
              key={command.command}
              className="flex items-start space-x-3 p-3 hover:bg-gray-50 rounded-lg cursor-pointer"
              onClick={() => setSelectedCommand(command)}
            >
              <div className="text-blue-600 mt-0.5">
                {command.icon}
              </div>
              <div className="flex-1">
                <div className="flex items-center space-x-2">
                  <span className="font-mono text-sm font-medium text-blue-600">
                    /{command.command}
                  </span>
                </div>
                <p className="text-sm text-gray-600 mt-1">{command.description}</p>
                <p className="text-xs text-gray-500 mt-1 font-mono">
                  예시: {command.example}
                </p>
              </div>
            </div>
          ))}
        </div>

        <div className="mt-3 pt-3 border-t border-gray-100">
          <button
            onClick={onCancel}
            className="text-sm text-gray-500 hover:text-gray-700"
          >
            ESC를 눌러 취소
          </button>
        </div>
      </div>
    )
  }

  // 선택된 명령어의 파라미터 입력 폼
  return (
    <div className="p-4 bg-white border-b border-gray-200">
      <div className="flex items-center space-x-2 mb-4">
        <div className="text-blue-600">
          {selectedCommand.icon}
        </div>
        <span className="font-mono text-sm font-medium text-blue-600">
          /{selectedCommand.command}
        </span>
        <span className="text-sm text-gray-600">- {selectedCommand.description}</span>
      </div>

      <div className="space-y-3">
        {selectedCommand.parameters.map((param, index) => (
          <div key={param.name} className="flex items-center space-x-3">
            <div className="w-20 text-sm text-gray-600 text-right">
              {param.name}
              {param.required && <span className="text-red-500 ml-1">*</span>}
            </div>
            
            <div className="flex-1">
              {param.type === 'text' && (
                <input
                  type="text"
                  value={parameters[param.name] || ''}
                  onChange={(e) => handleParameterChange(param.name, e.target.value)}
                  placeholder={param.description}
                  className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              )}
              
              {param.type === 'user' && (
                <select
                  value={parameters[param.name] || ''}
                  onChange={(e) => handleParameterChange(param.name, e.target.value)}
                  className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                  <option value="">담당자 선택...</option>
                  {members.map((member) => (
                    <option key={member.id} value={member.user.name}>
                      {member.user.name}
                    </option>
                  ))}
                </select>
              )}
              
              {param.type === 'date' && (
                <input
                  type="date"
                  value={parameters[param.name] || ''}
                  onChange={(e) => handleParameterChange(param.name, e.target.value)}
                  className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              )}
              
              {param.type === 'select' && param.options && (
                <select
                  value={parameters[param.name] || ''}
                  onChange={(e) => handleParameterChange(param.name, e.target.value)}
                  className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                  <option value="">{param.description} 선택...</option>
                  {param.options.map((option) => (
                    <option key={option} value={option}>
                      {option === 'low' ? '낮음' :
                       option === 'medium' ? '보통' :
                       option === 'high' ? '높음' :
                       option === 'urgent' ? '긴급' : option}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        ))}
      </div>

      <div className="flex items-center justify-between mt-4 pt-3 border-t border-gray-100">
        <button
          onClick={onCancel}
          className="text-sm text-gray-500 hover:text-gray-700"
        >
          취소
        </button>
        
        <div className="flex items-center space-x-3">
          <span className="text-xs text-gray-500">
            Enter 키로 실행
          </span>
          <button
            onClick={handleExecuteCommand}
            className="px-4 py-2 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 disabled:opacity-50"
            disabled={selectedCommand.parameters.some(param => 
              param.required && !parameters[param.name]
            )}
          >
            실행
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/ResponsiveTaskCard.tsx">
'use client'

import { useState, useRef, useCallback, useEffect } from 'react'
import { createPortal } from 'react-dom'
import { 
  CheckCircleIcon, 
  FlagIcon,
  TrashIcon,
  UserGroupIcon,
  PauseIcon,
  RectangleStackIcon,
  EllipsisHorizontalIcon,
  CalendarIcon
} from '@heroicons/react/24/outline'
import { TaskStatus, TaskPriority } from '@/types/task.types'
import { useIsTouch } from '@/hooks/useDeviceType'

// 워클리 업무 인터페이스
interface WorklyTask {
  id: string
  title: string
  description?: string
  status: TaskStatus
  priority: TaskPriority
  goalId?: string
  projectId?: string
  assigneeId: string
  assignee: {
    id: string
    name: string
    email: string
  }
  dueDate?: string
  scheduledDate?: string
  tags: string[]
  createdAt: string
  updatedAt: string
  isToday?: boolean
  isFocused?: boolean
}

interface ResponsiveTaskCardProps {
  task: WorklyTask
  onClick: () => void
  onDelete: (taskId: string) => void
  onDelegate: (taskId: string) => void
  onDefer: (taskId: string) => void
  onConvertToProject: (taskId: string) => void
  onDragStart?: (taskId: string) => void
  onDragEnd?: () => void
  isDragMode?: boolean
  onSetDueDate?: (taskId: string, date: string) => void
  onDueDateUpdated?: (taskId: string, date: string) => void
  keepCalendarOpen?: boolean
}

export default function ResponsiveTaskCard({
  task,
  onClick,
  onDelete,
  onDelegate,
  onDefer,
  onConvertToProject,
  onDragStart,
  onDragEnd,
  isDragMode = false,
  onSetDueDate,
  onDueDateUpdated,
  keepCalendarOpen = false
}: ResponsiveTaskCardProps) {
  const isTouch = useIsTouch()
  
  // 터치 디바이스용 상태
  const [swipeState, setSwipeState] = useState<'idle' | 'left' | 'right'>('idle')
  const [dragOffset, setDragOffset] = useState(0)
  const [isLongPressing, setIsLongPressing] = useState(false)
  const [isDragging, setIsDragging] = useState(false)
  
  // 데스크톱용 상태
  const [isHovered, setIsHovered] = useState(false)
  const [showActionMenu, setShowActionMenu] = useState(false)
  const [menuPosition, setMenuPosition] = useState<{top: number, right: number} | null>(null)
  const [isDesktopDragging, setIsDesktopDragging] = useState(false)
  
  const cardRef = useRef<HTMLDivElement>(null)
  const menuButtonRef = useRef<HTMLButtonElement>(null)
  const startXRef = useRef<number>(0)
  const startYRef = useRef<number>(0)
  const longPressTimerRef = useRef<NodeJS.Timeout | null>(null)
  const isDragDetectedRef = useRef(false)
  const prevDueDateRef = useRef<string | undefined>(task.dueDate)

  // 메뉴 외부 클릭 감지
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (showActionMenu && menuButtonRef.current && !menuButtonRef.current.contains(event.target as Node)) {
        setShowActionMenu(false)
      }
    }

    if (showActionMenu) {
      // 약간의 지연 후 이벤트 리스너 등록 (버튼 클릭 이벤트와 충돌 방지)
      const timer = setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside)
      }, 100)
      
      return () => {
        clearTimeout(timer)
        document.removeEventListener('mousedown', handleClickOutside)
      }
    }
  }, [showActionMenu])

  // 날짜 업데이트 감지
  useEffect(() => {
    if (prevDueDateRef.current !== task.dueDate && task.dueDate) {
      onDueDateUpdated?.(task.id, task.dueDate)
      
      // ref 업데이트
      prevDueDateRef.current = task.dueDate
    }
    
    prevDueDateRef.current = task.dueDate
  }, [task.dueDate, task.id, onDueDateUpdated])

  // PRD 준수: Primary Blue 중심의 마감일 시각화
  const getDueDateVisualization = (dueDate?: string) => {
    if (!dueDate) return { 
      color: 'bg-gray-200', 
      topText: '무기한',
      bottomText: '',
      textColor: 'text-gray-600'
    }
    
    const today = new Date()
    const due = new Date(dueDate)
    const diffDays = Math.ceil((due.getTime() - today.getTime()) / (1000 * 3600 * 24))
    
    if (diffDays < 0) return { 
      color: 'bg-red-500', 
      topText: `${Math.abs(diffDays)}일`,
      bottomText: '지남',
      textColor: 'text-white'
    }
    if (diffDays === 0) return { 
      color: 'bg-blue-600',
      topText: '오늘',
      bottomText: '마감',
      textColor: 'text-white'
    }
    if (diffDays <= 3) return { 
      color: 'bg-blue-500', 
      topText: `${diffDays}일`,
      bottomText: '남음',
      textColor: 'text-white'
    }
    if (diffDays <= 7) return { 
      color: 'bg-blue-400', 
      topText: `${diffDays}일`,
      bottomText: '남음',
      textColor: 'text-white'
    }
    if (diffDays <= 30) return { 
      color: 'bg-blue-300', 
      topText: `${diffDays}일`,
      bottomText: '남음',
      textColor: 'text-blue-900'
    }
    
    return { 
      color: 'bg-gray-100', 
      topText: due.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }),
      bottomText: '마감',
      textColor: 'text-gray-700'
    }
  }

  // 체크박스 클릭 처리
  const handleCheckboxClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    console.log('Toggle task status:', task.id)
  }

  // === 터치 디바이스용 이벤트 핸들러 ===
  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (!isTouch || isDragMode) return
    
    // 이벤트 전파 중단 - 달력 외부 클릭 감지 방지
    e.stopPropagation()
    
    startXRef.current = e.clientX
    startYRef.current = e.clientY
    isDragDetectedRef.current = false

    // 0.5초 후 드래그 모드 활성화
    longPressTimerRef.current = setTimeout(() => {
      if (!isDragDetectedRef.current) {
        setIsLongPressing(true)
        setIsDragging(true)
        
        if ('vibrate' in navigator) {
          navigator.vibrate(50)
        }
        
        onDragStart?.(task.id)
      }
    }, 500)

    if (cardRef.current) {
      cardRef.current.setPointerCapture(e.pointerId)
    }
  }, [isTouch, isDragMode, onDragStart, task.id])

  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!isTouch || isDragMode || isLongPressing) return

    const deltaX = e.clientX - startXRef.current
    const deltaY = e.clientY - startYRef.current
    
    if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 10) {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current)
        longPressTimerRef.current = null
      }
      return
    }

    if (Math.abs(deltaX) > 30) {
      isDragDetectedRef.current = true
      
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current)
        longPressTimerRef.current = null
      }

      setDragOffset(deltaX)
      
      if (deltaX < -80) {
        setSwipeState('left')
      } else if (deltaX > 80) {
        setSwipeState('right')
      } else {
        setSwipeState('idle')
      }
    }
  }, [isTouch, isDragMode, isLongPressing])

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!isTouch) return

    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current)
      longPressTimerRef.current = null
    }

    if (isDragging) {
      setIsDragging(false)
      setIsLongPressing(false)
      onDragEnd?.()
      return
    }

    if (swipeState === 'left' && Math.abs(dragOffset) > 120) {
      onDelete(task.id)
    } else if (swipeState === 'right' && dragOffset > 120) {
      console.log('Show action menu for task:', task.id)
    } else if (!isDragDetectedRef.current && Math.abs(dragOffset) < 10) {
      onClick()
    }

    setSwipeState('idle')
    setDragOffset(0)
    setIsLongPressing(false)

    if (cardRef.current) {
      cardRef.current.releasePointerCapture(e.pointerId)
    }
  }, [isTouch, isDragging, swipeState, dragOffset, onDragEnd, onDelete, task.id, onClick])

  // === 데스크톱용 이벤트 핸들러 ===
  const handleMouseEnter = () => {
    if (!isTouch) {
      setIsHovered(true)
    }
  }

  const handleMouseLeave = () => {
    if (!isTouch) {
      setIsHovered(false)
      setShowActionMenu(false)
    }
  }

  const handleDesktopClick = () => {
    if (!isTouch) {
      onClick()
    }
  }

  const handleActionMenuToggle = (e: React.MouseEvent) => {
    e.stopPropagation()
    
    if (!showActionMenu && menuButtonRef.current) {
      const rect = menuButtonRef.current.getBoundingClientRect()
      setMenuPosition({
        top: rect.bottom + 5,
        right: window.innerWidth - rect.right
      })
      
      // 다음 tick에서 메뉴 상태 변경 (이벤트 전파 방지)
      setTimeout(() => {
        setShowActionMenu(true)
      }, 0)
    } else {
      setShowActionMenu(false)
    }
  }

  // === 데스크톱 드래그 앤 드롭 핸들러 ===
  const handleDragStart = (e: React.DragEvent) => {
    if (isTouch) return
    
    // 이벤트 전파 중단 - 달력 외부 클릭 감지 방지
    e.stopPropagation()
    
    e.dataTransfer.setData('text/plain', task.id)
    e.dataTransfer.effectAllowed = 'move'
    
    // 드래그 이미지를 작은 크기로 설정
    const dragImage = document.createElement('div')
    dragImage.className = 'w-12 h-12 bg-blue-100 border-2 border-blue-300 rounded-lg flex items-center justify-center text-xs font-medium text-blue-700 shadow-lg'
    dragImage.style.position = 'absolute'
    dragImage.style.top = '-1000px'
    dragImage.innerHTML = task.title.substring(0, 2).toUpperCase()
    document.body.appendChild(dragImage)
    
    e.dataTransfer.setDragImage(dragImage, 24, 24)
    
    // 정리
    setTimeout(() => {
      document.body.removeChild(dragImage)
    }, 0)
    
    setIsDesktopDragging(true)
    onDragStart?.(task.id)
  }

  const handleDragEnd = (e: React.DragEvent) => {
    if (isTouch) return
    
    setIsDesktopDragging(false)
    
    // keepCalendarOpen이 true이면 달력을 열어둔 채로 onDragEnd 호출
    onDragEnd?.()
    
    // 드래그가 성공적으로 완료되었을 때의 추가 로직
    if (e.dataTransfer.dropEffect === 'move') {
      // 드롭이 성공했을 때 달력 유지 신호 전송
      console.log('드래그 앤 드롭 성공 - 달력 유지')
    }
  }

  const handleDateSelect = (e: React.MouseEvent) => {
    e.stopPropagation()
    
    // 간단한 날짜 선택을 위한 프롬프트 (향후 달력 컴포넌트로 대체 가능)
    const dateInput = prompt('마감일을 입력하세요 (YYYY-MM-DD 형식):')
    if (dateInput && onSetDueDate) {
      const date = new Date(dateInput)
      if (!isNaN(date.getTime())) {
        onSetDueDate(task.id, dateInput)
      } else {
        alert('올바른 날짜 형식이 아닙니다. YYYY-MM-DD 형식으로 입력해주세요.')
      }
    }
    setShowActionMenu(false)
  }

  const dueDateInfo = getDueDateVisualization(task.dueDate)
  const isCompleted = task.status === TaskStatus.DONE

  return (
    <div className="relative overflow-hidden">
      {/* 터치 디바이스: 스와이프 백그라운드 액션들 */}
      {isTouch && swipeState !== 'idle' && (
        <>
          {swipeState === 'left' && (
            <div className="absolute inset-y-0 right-0 flex items-center justify-center w-20 bg-red-500">
              <TrashIcon className="w-6 h-6 text-white" />
            </div>
          )}
          
          {swipeState === 'right' && (
            <div className="absolute inset-y-0 left-0 flex items-center gap-2 px-4 bg-blue-100">
              <button
                onClick={() => onDelegate(task.id)}
                className="flex items-center justify-center w-12 h-12 bg-blue-500 text-white rounded-full"
              >
                <UserGroupIcon className="w-5 h-5" />
              </button>
              <button
                onClick={() => onDefer(task.id)}
                className="flex items-center justify-center w-12 h-12 bg-gray-500 text-white rounded-full"
              >
                <PauseIcon className="w-5 h-5" />
              </button>
              <button
                onClick={() => onConvertToProject(task.id)}
                className="flex items-center justify-center w-12 h-12 bg-green-500 text-white rounded-full"
              >
                <RectangleStackIcon className="w-5 h-5" />
              </button>
            </div>
          )}
        </>
      )}

      {/* 메인 카드 */}
      <div 
        ref={cardRef}
        className={`
          p-4 bg-white transition-all duration-300 cursor-pointer group
          ${task.isToday ? 'bg-blue-50/30' : ''}
          ${task.isFocused ? 'ring-2 ring-blue-200' : ''}
          ${isCompleted ? 'opacity-60' : ''}
          ${isTouch && isLongPressing ? 'scale-105 shadow-lg ring-2 ring-blue-300' : 'hover:bg-gray-50'}
          ${isDragging ? 'z-50 shadow-xl' : ''}
          ${isDesktopDragging ? 'scale-110 rotate-2 shadow-2xl z-50 opacity-90' : ''}
        `}
        style={isTouch ? {
          transform: `translateX(${dragOffset}px)`,
          transition: isDragDetectedRef.current ? 'none' : 'transform 0.2s ease-out'
        } : isDesktopDragging ? {
          transform: 'scale(1.1) rotate(2deg)',
          transition: 'all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        } : {
          transition: 'all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        }}
        draggable={!isTouch && !isCompleted}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerUp}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onClick={handleDesktopClick}
      >
        <div className="flex items-center gap-4 min-h-[60px]">
          {/* 좌측: 큰 체크박스 */}
          <div className="flex-shrink-0 flex items-center justify-center">
            <button
              onClick={handleCheckboxClick}
              className={`w-7 h-7 rounded border-2 flex items-center justify-center transition-all ${
                isCompleted 
                  ? 'bg-green-500 border-green-500 text-white' 
                  : 'border-gray-300 hover:border-blue-500 hover:bg-blue-50'
              }`}
            >
              {isCompleted && (
                <CheckCircleIcon className="w-4 h-4" />
              )}
            </button>
          </div>

          {/* 중앙: 콘텐츠 영역 */}
          <div className="flex-1 min-w-0 py-1">
            <h3 className={`workly-card-title mb-1 ${
              isCompleted ? 'line-through text-gray-500' : 'group-hover:text-gray-700'
            }`}>
              {task.title}
            </h3>
            
            {task.description && (
              <p className={`workly-caption line-clamp-2 mb-2 ${
                isCompleted ? 'text-gray-400' : ''
              }`}>
                {task.description}
              </p>
            )}
            
            <div className="flex flex-wrap gap-1">
              {(task.goalId || task.projectId) && (
                <span className="inline-flex items-center gap-1 px-2 py-1 text-xs font-medium text-blue-700 bg-blue-100 rounded-full">
                  <FlagIcon className="w-3 h-3" />
                  {task.goalId ? '목표' : '프로젝트'}
                </span>
              )}
              
              {task.tags.slice(0, 2).map((tag, index) => (
                <span
                  key={index}
                  className="inline-block px-2 py-1 text-xs text-gray-600 bg-gray-100 rounded-full"
                >
                  {tag}
                </span>
              ))}
              
              {task.tags.length > 2 && (
                <span className="inline-block px-2 py-1 text-xs text-gray-500">
                  +{task.tags.length - 2}
                </span>
              )}
            </div>
          </div>

          {/* 우측: 마감일 + 데스크톱 더보기 버튼 */}
          <div className="flex-shrink-0 flex items-center gap-3">
            {/* 마감일 시각화 */}
            <div className={`w-12 h-12 rounded-full ${dueDateInfo.color} flex flex-col items-center justify-center transition-all duration-300`}>
              <span className={`font-bold text-xs leading-tight ${dueDateInfo.textColor}`}>
                {dueDateInfo.topText}
              </span>
              {dueDateInfo.bottomText && (
                <span className={`font-medium text-xs leading-tight ${dueDateInfo.textColor}`}>
                  {dueDateInfo.bottomText}
                </span>
              )}
            </div>

            {/* 데스크톱: 더보기 버튼 (항상 보임) */}
            {!isTouch && (
              <button
                ref={menuButtonRef}
                onClick={handleActionMenuToggle}
                className="w-9 h-9 flex items-center justify-center text-gray-500 hover:bg-gray-50 rounded-md transition-colors"
                title="더 많은 액션"
              >
                <EllipsisHorizontalIcon className="w-5 h-5" />
              </button>
            )}
          </div>
        </div>
      </div>

      {/* 터치 디바이스: 드래그 모드 시 시각적 피드백 */}
      {isTouch && isLongPressing && (
        <div className="absolute inset-x-0 bottom-0 h-1 bg-blue-500 animate-pulse"></div>
      )}

      {/* Portal로 렌더링되는 더보기 메뉴 */}
      {!isTouch && showActionMenu && menuPosition && typeof window !== 'undefined' && createPortal(
        <div 
          className="fixed w-36 bg-white border border-gray-200 rounded-lg shadow-xl z-[999]"
          style={{
            top: menuPosition.top,
            right: menuPosition.right
          }}
          onClick={(e) => e.stopPropagation()}
        >
            <button
              onClick={handleDateSelect}
              className="w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 first:rounded-t-lg flex items-center gap-2"
            >
              <CalendarIcon className="w-4 h-4" />
              날짜 설정
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation()
                onDelegate(task.id)
                setShowActionMenu(false)
              }}
              className="w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 flex items-center gap-2"
            >
              <UserGroupIcon className="w-4 h-4" />
              위임
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation()
                onDefer(task.id)
                setShowActionMenu(false)
              }}
              className="w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 flex items-center gap-2"
            >
              <PauseIcon className="w-4 h-4" />
              보류
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation()
                onConvertToProject(task.id)
                setShowActionMenu(false)
              }}
              className="w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 flex items-center gap-2"
            >
              <RectangleStackIcon className="w-4 h-4" />
              프로젝트로 전환
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation()
                if (window.confirm('정말로 이 업무를 삭제하시겠습니까?')) {
                  onDelete(task.id)
                }
                setShowActionMenu(false)
              }}
              className="w-full px-3 py-2 text-left text-sm text-red-600 hover:bg-red-50 last:rounded-b-lg flex items-center gap-2"
            >
              <TrashIcon className="w-4 h-4" />
              삭제
            </button>
        </div>,
        document.body
      )}

    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/TaskDetailModal.tsx">
'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import dynamic from 'next/dynamic'
import { 
  XMarkIcon, 
  ArrowsPointingOutIcon,
  ArrowsPointingInIcon,
  CalendarDaysIcon,
  ClockIcon,
  LinkIcon,
  CheckCircleIcon,
  PlusIcon,
  DocumentTextIcon,
  PencilIcon,
  TrashIcon,
  MagnifyingGlassIcon,
  ArrowRightIcon,
  ArrowLeftIcon,
  ArrowsRightLeftIcon,
  PlayIcon,
  StopIcon,
  ClockIcon as ClockSolidIcon,
  ArrowTopRightOnSquareIcon,
  BookOpenIcon,
  GlobeAltIcon,
  DocumentIcon,
  FilmIcon,
  PhotoIcon
} from '@heroicons/react/24/outline'
import { TaskDetail, ChecklistItem, TaskRelationship, WikiReference, TaskStatus, TaskPriority } from '@/types/task.types'
import { worklyApi } from '@/lib/api/workly-api'

// WorklyMDXEditor를 동적으로 로드 (SSR 방지)
const WorklyMDXEditor = dynamic(
  () => import('../ui/WorklyMDXEditor'),
  { 
    ssr: false,
    loading: () => <div className="h-64 bg-gray-50 rounded-lg animate-pulse flex items-center justify-center">
      <p className="text-gray-500">에디터 로딩 중...</p>
    </div>
  }
)

interface TaskDetailModalProps {
  task: TaskDetail | null
  isOpen: boolean
  onClose: () => void
  onSave: (taskDetail: TaskDetail) => void
}

export default function TaskDetailModal({
  task,
  isOpen,
  onClose,
  onSave
}: TaskDetailModalProps) {
  const [isFullScreen, setIsFullScreen] = useState(false)
  const [localTask, setLocalTask] = useState<TaskDetail | null>(null)
  const [editingChecklistId, setEditingChecklistId] = useState<string | null>(null)
  const [showTaskSearch, setShowTaskSearch] = useState(false)
  const [taskSearchQuery, setTaskSearchQuery] = useState('')
  const [isTimerRunning, setIsTimerRunning] = useState(false)
  const [timerStartTime, setTimerStartTime] = useState<Date | null>(null)
  const [currentSessionTime, setCurrentSessionTime] = useState(0)
  const [showWikiForm, setShowWikiForm] = useState(false)
  const [newWikiTitle, setNewWikiTitle] = useState('')
  const [newWikiUrl, setNewWikiUrl] = useState('')
  const [newWikiDescription, setNewWikiDescription] = useState('')
  const [urlValidation, setUrlValidation] = useState<{ isValid: boolean; message: string } | null>(null)
  const [editingWikiId, setEditingWikiId] = useState<string | null>(null)
  const [isSaving, setIsSaving] = useState(false)
  const modalRef = useRef<HTMLDivElement>(null)
  const titleRef = useRef<HTMLInputElement>(null)
  const timerIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // 모달이 열릴 때 로컬 상태 초기화
  useEffect(() => {
    if (isOpen && task) {
      setLocalTask({ ...task })
      // 제목 입력 필드에 포커스 (약간의 지연 후)
      setTimeout(() => {
        titleRef.current?.focus()
      }, 100)
    }
  }, [isOpen, task])

  // ESC 키로 모달 닫기
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown)
      document.body.style.overflow = 'hidden'
      
      return () => {
        document.removeEventListener('keydown', handleKeyDown)
        document.body.style.overflow = 'unset'
      }
    }
  }, [isOpen, onClose])

  // 모달 외부 클릭으로 닫기 (전체화면이 아닐 때만)
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (!isFullScreen && modalRef.current && !modalRef.current.contains(event.target as Node)) {
        onClose()
      }
    }

    if (isOpen && !isFullScreen) {
      document.addEventListener('mousedown', handleClickOutside)
      return () => document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isOpen, isFullScreen, onClose])

  // Debounced 저장 함수
  const debouncedSave = useCallback((taskData: TaskDetail) => {
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current)
    }

    saveTimeoutRef.current = setTimeout(async () => {
      try {
        setIsSaving(true)
        await worklyApi.tasks.updateDetail(taskData.id, {
          title: taskData.title,
          description: taskData.description,
          descriptionMarkdown: taskData.descriptionMarkdown,
          status: taskData.status,
          priority: taskData.priority,
          dueDate: taskData.dueDate,
          checklist: taskData.checklist,
          relationships: taskData.relationships,
          wikiReferences: taskData.wikiReferences,
          estimatedTimeMinutes: taskData.estimatedTimeMinutes,
          loggedTimeMinutes: taskData.loggedTimeMinutes,
          tags: taskData.tags,
          customFields: taskData.customFields
        })
      } catch (error) {
        console.error('자동 저장 실패:', error)
      } finally {
        setIsSaving(false)
      }
    }, 1500) // 1.5초 후 저장
  }, [])

  // 로컬 업무 업데이트
  const updateLocalTask = (updates: Partial<TaskDetail>) => {
    if (!localTask) return
    const updatedTask = { ...localTask, ...updates }
    setLocalTask(updatedTask)
    
    // 자동 저장 (debounced)
    debouncedSave(updatedTask)
  }

  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
    }
  }, [])

  // 체크리스트 아이템 토글
  const toggleChecklistItem = (itemId: string) => {
    if (!localTask) return
    
    const updatedChecklist = localTask.checklist.map(item =>
      item.id === itemId ? { ...item, completed: !item.completed } : item
    )
    
    updateLocalTask({ checklist: updatedChecklist })
  }

  // 체크리스트 아이템 추가
  const addChecklistItem = (text: string) => {
    if (!localTask || !text.trim()) return
    
    const newItem: ChecklistItem = {
      id: `checklist-${Date.now()}`,
      text: text.trim(),
      completed: false,
      order: localTask.checklist.length
    }
    
    updateLocalTask({ 
      checklist: [...localTask.checklist, newItem] 
    })
  }

  // 체크리스트 아이템 편집
  const updateChecklistItem = (itemId: string, text: string) => {
    if (!localTask) return
    
    const updatedChecklist = localTask.checklist.map(item =>
      item.id === itemId ? { ...item, text: text.trim() } : item
    )
    
    updateLocalTask({ checklist: updatedChecklist })
  }

  // 체크리스트 아이템 삭제
  const deleteChecklistItem = (itemId: string) => {
    if (!localTask) return
    
    const updatedChecklist = localTask.checklist.filter(item => item.id !== itemId)
    
    updateLocalTask({ checklist: updatedChecklist })
  }

  // 업무 관계 추가
  const addTaskRelationship = (targetTaskId: string, type: 'blocks' | 'blocked_by' | 'related') => {
    if (!localTask) return
    
    const newRelationship: TaskRelationship = {
      id: `rel-${Date.now()}`,
      targetTaskId,
      type,
      targetTask: {
        // 목업 데이터 - 실제로는 API에서 가져와야 함
        id: targetTaskId,
        title: `관련 업무 #${targetTaskId}`,
        status: 'todo' as any,
        priority: 'medium' as any,
        type: 'task' as any,
        assigneeId: 'user1',
        reporterId: 'user1',
        reporter: { id: 'user1', firstName: '김', lastName: '워클리', email: 'workly@example.com' },
        actualHours: 0,
        progress: 0,
        tags: [],
        customFields: {},
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        subtasks: [],
        labels: [],
        comments: [],
        dependencies: [],
        dependents: [],
        watchers: [],
        timeEntries: []
      }
    }
    
    updateLocalTask({ 
      relationships: [...localTask.relationships, newRelationship] 
    })
    
    setShowTaskSearch(false)
    setTaskSearchQuery('')
  }

  // 업무 관계 삭제
  const removeTaskRelationship = (relationshipId: string) => {
    if (!localTask) return
    
    const updatedRelationships = localTask.relationships.filter(rel => rel.id !== relationshipId)
    
    updateLocalTask({ relationships: updatedRelationships })
  }

  // 목업 업무 데이터 (검색용)
  const mockAvailableTasks = [
    { id: '1', title: '워클리 네비게이션 시스템 최종 점검' },
    { id: '2', title: 'CPER 워크플로우 문서 작성' },
    { id: '3', title: '사용자 피드백 수집 및 분석' },
    { id: '4', title: '데이터베이스 성능 최적화' },
    { id: '5', title: '모바일 반응형 디자인 개선' },
    { id: '6', title: '차세대 기능 기획' }
  ].filter(task => task.id !== localTask?.id) // 자기 자신 제외

  // 검색된 업무 목록
  const filteredTasks = mockAvailableTasks.filter(task =>
    task.title.toLowerCase().includes(taskSearchQuery.toLowerCase())
  )

  // 시간 형식 변환 함수
  const formatTime = (minutes: number): string => {
    const hours = Math.floor(minutes / 60)
    const mins = minutes % 60
    if (hours > 0) {
      return `${hours}시간 ${mins}분`
    }
    return `${mins}분`
  }

  // 타이머 시작
  const startTimer = () => {
    setIsTimerRunning(true)
    setTimerStartTime(new Date())
    setCurrentSessionTime(0)
    
    timerIntervalRef.current = setInterval(() => {
      setCurrentSessionTime(prev => prev + 1)
    }, 60000) // 1분마다 업데이트
  }

  // 타이머 정지
  const stopTimer = () => {
    if (timerIntervalRef.current) {
      clearInterval(timerIntervalRef.current)
      timerIntervalRef.current = null
    }
    
    if (timerStartTime && localTask) {
      const endTime = new Date()
      const sessionMinutes = Math.round((endTime.getTime() - timerStartTime.getTime()) / 60000)
      const newLoggedTime = (localTask.loggedTimeMinutes || 0) + sessionMinutes
      
      updateLocalTask({ loggedTimeMinutes: newLoggedTime })
    }
    
    setIsTimerRunning(false)
    setTimerStartTime(null)
    setCurrentSessionTime(0)
  }

  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return () => {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current)
      }
    }
  }, [])

  // 문서 타입에 따른 아이콘 반환
  const getDocumentIcon = (url: string) => {
    if (!url) return DocumentTextIcon
    
    try {
      const lowerUrl = url.toLowerCase()
      const pathname = new URL(url).pathname.toLowerCase()
      
      // 위키 사이트들
      if (lowerUrl.includes('wiki') || lowerUrl.includes('notion') || lowerUrl.includes('confluence')) {
        return BookOpenIcon
      }
      
      // 미디어 파일들
      if (pathname.match(/\.(jpg|jpeg|png|gif|webp|svg)$/)) {
        return PhotoIcon
      }
      
      if (pathname.match(/\.(mp4|webm|mov|avi|mkv)$/)) {
        return FilmIcon
      }
      
      // 문서 파일들
      if (pathname.match(/\.(pdf|doc|docx|ppt|pptx|xls|xlsx)$/)) {
        return DocumentIcon
      }
      
      // 웹 페이지
      if (lowerUrl.startsWith('http')) {
        return GlobeAltIcon
      }
    } catch {
      // URL 파싱 실패 시 기본 아이콘
    }
    
    return DocumentTextIcon
  }

  // 문서 타입에 따른 색상 반환
  const getDocumentColor = (url: string) => {
    if (!url) return 'text-blue-600'
    
    try {
      const lowerUrl = url.toLowerCase()
      const pathname = new URL(url).pathname.toLowerCase()
      
      // 위키 사이트들
      if (lowerUrl.includes('wiki') || lowerUrl.includes('notion') || lowerUrl.includes('confluence')) {
        return 'text-green-600'
      }
      
      // 미디어 파일들
      if (pathname.match(/\.(jpg|jpeg|png|gif|webp|svg)$/)) {
        return 'text-purple-600'
      }
      
      if (pathname.match(/\.(mp4|webm|mov|avi|mkv)$/)) {
        return 'text-red-600'
      }
      
      // 문서 파일들
      if (pathname.match(/\.(pdf|doc|docx|ppt|pptx|xls|xlsx)$/)) {
        return 'text-orange-600'
      }
    } catch {
      // URL 파싱 실패 시 기본 색상
    }
    
    // 웹 페이지
    return 'text-blue-600'
  }

  // URL 유효성 검증
  const validateUrl = (url: string): { isValid: boolean; message: string } => {
    if (!url.trim()) {
      return { isValid: false, message: 'URL을 입력해주세요.' }
    }
    
    try {
      const urlObj = new URL(url)
      
      // 프로토콜 검증
      if (!['http:', 'https:'].includes(urlObj.protocol)) {
        return { isValid: false, message: 'HTTP 또는 HTTPS URL만 허용됩니다.' }
      }
      
      // 기본적인 호스트명 검증
      if (!urlObj.hostname || urlObj.hostname.length < 1) {
        return { isValid: false, message: '올바른 도메인 이름을 입력해주세요.' }
      }
      
      return { isValid: true, message: '유효한 URL입니다.' }
    } catch {
      return { isValid: false, message: '올바른 URL 형식이 아닙니다.' }
    }
  }

  // URL 입력 시 유효성 검증
  const handleUrlChange = (url: string) => {
    setNewWikiUrl(url)
    
    if (url.trim()) {
      const validation = validateUrl(url)
      setUrlValidation(validation)
    } else {
      setUrlValidation(null)
    }
  }

  // 위키 편집 시작
  const startEditingWiki = (wiki: WikiReference) => {
    setEditingWikiId(wiki.id)
    setNewWikiTitle(wiki.title)
    setNewWikiUrl(wiki.url)
    setNewWikiDescription(wiki.description || '')
    setUrlValidation(validateUrl(wiki.url))
    setShowWikiForm(true)
  }

  // 위키 레퍼런스 추가/수정
  const addWikiReference = () => {
    if (!localTask || !newWikiTitle.trim() || !newWikiUrl.trim()) return
    
    // URL 유효성 최종 검증
    const validation = validateUrl(newWikiUrl)
    if (!validation.isValid) {
      setUrlValidation(validation)
      return
    }
    
    if (editingWikiId) {
      // 기존 위키 수정
      const updatedWikiReferences = localTask.wikiReferences.map(wiki =>
        wiki.id === editingWikiId
          ? {
              ...wiki,
              title: newWikiTitle.trim(),
              url: newWikiUrl.trim(),
              description: newWikiDescription.trim() || undefined
            }
          : wiki
      )
      
      updateLocalTask({ wikiReferences: updatedWikiReferences })
    } else {
      // 새 위키 추가
      const newWiki: WikiReference = {
        id: `wiki-${Date.now()}`,
        title: newWikiTitle.trim(),
        url: newWikiUrl.trim(),
        description: newWikiDescription.trim() || undefined
      }
      
      updateLocalTask({ 
        wikiReferences: [...localTask.wikiReferences, newWiki] 
      })
    }
    
    setNewWikiTitle('')
    setNewWikiUrl('')
    setNewWikiDescription('')
    setUrlValidation(null)
    setEditingWikiId(null)
    setShowWikiForm(false)
  }

  // 위키 레퍼런스 삭제
  const removeWikiReference = (wikiId: string) => {
    if (!localTask) return
    
    const updatedWikiReferences = localTask.wikiReferences.filter(wiki => wiki.id !== wikiId)
    
    updateLocalTask({ wikiReferences: updatedWikiReferences })
  }

  // 저장 핸들러
  const handleSave = async () => {
    if (!localTask) return

    try {
      // API를 통해 실제 백엔드에 저장
      const updatedTask = await worklyApi.tasks.updateDetail(localTask.id, {
        title: localTask.title,
        description: localTask.description,
        descriptionMarkdown: localTask.descriptionMarkdown,
        status: localTask.status,
        priority: localTask.priority,
        dueDate: localTask.dueDate,
        checklist: localTask.checklist,
        relationships: localTask.relationships,
        wikiReferences: localTask.wikiReferences,
        estimatedTimeMinutes: localTask.estimatedTimeMinutes,
        loggedTimeMinutes: localTask.loggedTimeMinutes,
        tags: localTask.tags,
        customFields: localTask.customFields
      })

      // 부모 컴포넌트에 업데이트된 태스크 전달
      onSave(updatedTask as TaskDetail)
      onClose()
    } catch (error) {
      console.error('태스크 저장 실패:', error)
      // 에러 처리 - 실제로는 토스트 알림 등을 표시할 수 있음
      alert('태스크 저장에 실패했습니다. 다시 시도해주세요.')
    }
  }

  if (!isOpen || !localTask) return null

  return (
    <div className={`fixed inset-0 z-50 ${isFullScreen ? 'bg-white' : 'bg-black bg-opacity-50 flex items-center justify-center p-4'}`}>
      <div 
        ref={modalRef}
        className={`
          bg-white rounded-lg shadow-xl
          ${isFullScreen 
            ? 'w-full h-full max-w-none max-h-none rounded-none' 
            : 'w-full max-w-4xl max-h-[90vh]'
          }
          flex flex-col overflow-hidden
        `}
      >
        {/* 헤더 */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200 bg-white">
          <div className="flex items-center gap-3">
            <h1 className="text-lg font-semibold text-gray-900">업무 상세</h1>
            {isSaving && (
              <span className="text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded-full animate-pulse">
                저장 중...
              </span>
            )}
            <div className="flex items-center gap-1">
              {/* 상태 배지 */}
              <span className={`px-2 py-1 text-xs font-medium rounded-full ${
                localTask.status === TaskStatus.DONE ? 'bg-green-100 text-green-700' :
                localTask.status === TaskStatus.IN_PROGRESS ? 'bg-blue-100 text-blue-700' :
                localTask.status === TaskStatus.IN_REVIEW ? 'bg-purple-100 text-purple-700' :
                'bg-gray-100 text-gray-700'
              }`}>
                {localTask.status === TaskStatus.DONE ? '완료' :
                 localTask.status === TaskStatus.IN_PROGRESS ? '진행 중' :
                 localTask.status === TaskStatus.IN_REVIEW ? '검토 중' :
                 '할 일'}
              </span>
              
              {/* 우선순위 배지 */}
              <span className={`px-2 py-1 text-xs font-medium rounded-full ${
                localTask.priority === TaskPriority.URGENT ? 'bg-red-100 text-red-700' :
                localTask.priority === TaskPriority.HIGH ? 'bg-blue-100 text-blue-700' :
                localTask.priority === TaskPriority.MEDIUM ? 'bg-blue-50 text-blue-600' :
                'bg-gray-100 text-gray-600'
              }`}>
                {localTask.priority === TaskPriority.URGENT ? '긴급' :
                 localTask.priority === TaskPriority.HIGH ? '높음' :
                 localTask.priority === TaskPriority.MEDIUM ? '보통' :
                 '낮음'}
              </span>
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            {/* 전체화면 토글 */}
            <button
              onClick={() => setIsFullScreen(!isFullScreen)}
              className="w-10 h-10 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors"
              aria-label={isFullScreen ? '창 모드' : '전체화면'}
            >
              {isFullScreen ? (
                <ArrowsPointingInIcon className="w-5 h-5" />
              ) : (
                <ArrowsPointingOutIcon className="w-5 h-5" />
              )}
            </button>
            
            {/* 닫기 버튼 */}
            <button
              onClick={onClose}
              className="w-10 h-10 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors"
              aria-label="닫기"
            >
              <XMarkIcon className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* 메인 콘텐츠 */}
        <div className="flex-1 overflow-y-auto">
          <div className="max-w-4xl mx-auto p-6 space-y-8">
            {/* 제목 */}
            <div>
              <input
                ref={titleRef}
                type="text"
                value={localTask.title}
                onChange={(e) => updateLocalTask({ title: e.target.value })}
                className="w-full text-3xl font-bold text-gray-900 border-none outline-none bg-transparent placeholder-gray-400 resize-none"
                placeholder="업무 제목을 입력하세요"
              />
            </div>

            {/* 메타 정보 */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* 마감일 */}
              <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
                <CalendarDaysIcon className="w-5 h-5 text-gray-500" />
                <div>
                  <label className="text-sm font-medium text-gray-700">마감일</label>
                  <input
                    type="date"
                    value={localTask.dueDate ? localTask.dueDate.split('T')[0] : ''}
                    onChange={(e) => updateLocalTask({ dueDate: e.target.value ? e.target.value + 'T00:00:00.000Z' : undefined })}
                    className="block text-sm text-gray-900 bg-transparent border-none outline-none"
                  />
                </div>
              </div>

              {/* 시간 추적 */}
              <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
                <ClockSolidIcon className="w-5 h-5 text-gray-500" />
                <div className="flex-1">
                  <label className="text-sm font-medium text-gray-700">시간 추적</label>
                  <div className="flex items-center gap-2 mt-1">
                    {isTimerRunning ? (
                      <>
                        <button
                          onClick={stopTimer}
                          className="flex items-center gap-1 px-2 py-1 text-xs font-medium text-red-600 bg-red-50 hover:bg-red-100 rounded transition-colors"
                        >
                          <StopIcon className="w-3 h-3" />
                          정지
                        </button>
                        <span className="text-xs text-red-600 font-medium">
                          진행 중 ({currentSessionTime}분)
                        </span>
                      </>
                    ) : (
                      <button
                        onClick={startTimer}
                        className="flex items-center gap-1 px-2 py-1 text-xs font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded transition-colors"
                      >
                        <PlayIcon className="w-3 h-3" />
                        시작
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>

            {/* 시간 관리 섹션 */}
            <div className="bg-blue-50 rounded-lg p-4">
              <h4 className="text-sm font-semibold text-gray-900 mb-3 flex items-center gap-2">
                <ClockIcon className="w-4 h-4" />
                시간 관리
              </h4>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* 예상 시간 */}
                <div>
                  <label className="block text-xs font-medium text-gray-600 mb-1">예상 시간</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      value={localTask.estimatedTimeMinutes || ''}
                      onChange={(e) => updateLocalTask({ estimatedTimeMinutes: e.target.value ? parseInt(e.target.value) : undefined })}
                      placeholder="0"
                      className="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <span className="text-xs text-gray-500">분</span>
                    {localTask.estimatedTimeMinutes && (
                      <span className="text-xs text-gray-600">
                        ({formatTime(localTask.estimatedTimeMinutes)})
                      </span>
                    )}
                  </div>
                </div>

                {/* 실제 시간 */}
                <div>
                  <label className="block text-xs font-medium text-gray-600 mb-1">실제 시간</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      value={localTask.loggedTimeMinutes || ''}
                      onChange={(e) => updateLocalTask({ loggedTimeMinutes: e.target.value ? parseInt(e.target.value) : undefined })}
                      placeholder="0"
                      className="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <span className="text-xs text-gray-500">분</span>
                    {localTask.loggedTimeMinutes && (
                      <span className="text-xs text-gray-600">
                        ({formatTime(localTask.loggedTimeMinutes)})
                      </span>
                    )}
                  </div>
                </div>
              </div>

              {/* 시간 비교 */}
              {localTask.estimatedTimeMinutes && localTask.loggedTimeMinutes && (
                <div className="mt-3 pt-3 border-t border-blue-200">
                  <div className="flex items-center justify-between text-xs">
                    <span className="text-gray-600">진행률:</span>
                    <span className={`font-medium ${
                      localTask.loggedTimeMinutes > localTask.estimatedTimeMinutes 
                        ? 'text-red-600' 
                        : 'text-green-600'
                    }`}>
                      {Math.round((localTask.loggedTimeMinutes / localTask.estimatedTimeMinutes) * 100)}%
                      {localTask.loggedTimeMinutes > localTask.estimatedTimeMinutes && ' (초과)'}
                    </span>
                  </div>
                  
                  {/* 프로그레스 바 */}
                  <div className="mt-1 w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full transition-all duration-300 ${
                        localTask.loggedTimeMinutes > localTask.estimatedTimeMinutes 
                          ? 'bg-red-500' 
                          : 'bg-blue-500'
                      }`}
                      style={{
                        width: `${Math.min((localTask.loggedTimeMinutes / localTask.estimatedTimeMinutes) * 100, 100)}%`
                      }}
                    />
                  </div>
                </div>
              )}
            </div>

            {/* 설명 (MDX 에디터) */}
            <div>
              <h3 className="text-lg font-semibold text-gray-900 mb-3 flex items-center gap-2">
                <DocumentTextIcon className="w-5 h-5" />
                설명
              </h3>
              <WorklyMDXEditor
                markdown={localTask.descriptionMarkdown || localTask.description || ''}
                onChange={(value) => updateLocalTask({ 
                  descriptionMarkdown: value,
                  description: value // 기본 description도 동기화
                })}
                placeholder="업무에 대한 자세한 설명을 입력하세요..."
              />
            </div>

            {/* 체크리스트 */}
            <div>
              <h3 className="text-lg font-semibold text-gray-900 mb-3 flex items-center gap-2">
                <CheckCircleIcon className="w-5 h-5" />
                체크리스트
                {localTask.checklist.length > 0 && (
                  <span className="text-sm text-gray-500">
                    ({localTask.checklist.filter(item => item.completed).length}/{localTask.checklist.length})
                  </span>
                )}
              </h3>
              
              <div className="space-y-2">
                {localTask.checklist.map((item) => (
                  <div key={item.id} className="group flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg transition-colors">
                    <button
                      onClick={() => toggleChecklistItem(item.id)}
                      className={`w-5 h-5 rounded border-2 flex items-center justify-center transition-colors ${
                        item.completed 
                          ? 'bg-blue-600 border-blue-600 text-white' 
                          : 'border-gray-300 hover:border-blue-400'
                      }`}
                    >
                      {item.completed && <CheckCircleIcon className="w-3 h-3" />}
                    </button>
                    
                    {editingChecklistId === item.id ? (
                      <input
                        type="text"
                        defaultValue={item.text}
                        className="flex-1 bg-white border border-blue-300 rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                        autoFocus
                        onBlur={(e) => {
                          updateChecklistItem(item.id, e.target.value)
                          setEditingChecklistId(null)
                        }}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            updateChecklistItem(item.id, e.currentTarget.value)
                            setEditingChecklistId(null)
                          }
                          if (e.key === 'Escape') {
                            setEditingChecklistId(null)
                          }
                        }}
                      />
                    ) : (
                      <span 
                        className={`flex-1 cursor-pointer ${
                          item.completed ? 'line-through text-gray-500' : 'text-gray-900'
                        }`}
                        onClick={() => setEditingChecklistId(item.id)}
                      >
                        {item.text}
                      </span>
                    )}
                    
                    {/* 편집/삭제 버튼 */}
                    <div className="opacity-0 group-hover:opacity-100 flex items-center gap-1 transition-opacity">
                      <button
                        onClick={() => setEditingChecklistId(item.id)}
                        className="w-6 h-6 flex items-center justify-center text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors"
                        title="편집"
                      >
                        <PencilIcon className="w-3 h-3" />
                      </button>
                      <button
                        onClick={() => deleteChecklistItem(item.id)}
                        className="w-6 h-6 flex items-center justify-center text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors"
                        title="삭제"
                      >
                        <TrashIcon className="w-3 h-3" />
                      </button>
                    </div>
                  </div>
                ))}
                
                {/* 새 체크리스트 아이템 추가 */}
                <div className="flex items-center gap-3 p-2">
                  <div className="w-5 h-5 rounded border-2 border-gray-300" />
                  <input
                    type="text"
                    placeholder="새 체크리스트 아이템 추가..."
                    className="flex-1 bg-transparent border-none outline-none text-gray-900 placeholder-gray-400"
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && e.currentTarget.value.trim()) {
                        addChecklistItem(e.currentTarget.value)
                        e.currentTarget.value = ''
                      }
                    }}
                  />
                </div>
              </div>
            </div>

            {/* 관련 업무 */}
            <div>
              <div className="flex items-center justify-between mb-3">
                <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">
                  <LinkIcon className="w-5 h-5" />
                  관련 업무
                  {localTask.relationships.length > 0 && (
                    <span className="text-sm text-gray-500">({localTask.relationships.length})</span>
                  )}
                </h3>
                <button
                  onClick={() => setShowTaskSearch(true)}
                  className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors"
                >
                  <PlusIcon className="w-4 h-4" />
                  관계 추가
                </button>
              </div>
              
              {localTask.relationships.length > 0 ? (
                <div className="space-y-2">
                  {localTask.relationships.map((relationship) => {
                    const getRelationIcon = (type: string) => {
                      switch (type) {
                        case 'blocks':
                          return <ArrowRightIcon className="w-4 h-4 text-red-500" />
                        case 'blocked_by':
                          return <ArrowLeftIcon className="w-4 h-4 text-red-500" />
                        case 'related':
                          return <ArrowsRightLeftIcon className="w-4 h-4 text-blue-500" />
                        default:
                          return <LinkIcon className="w-4 h-4 text-gray-500" />
                      }
                    }

                    const getRelationLabel = (type: string) => {
                      switch (type) {
                        case 'blocks':
                          return '차단함'
                        case 'blocked_by':
                          return '차단됨'
                        case 'related':
                          return '관련됨'
                        case 'parent':
                          return '상위 업무'
                        case 'child':
                          return '하위 업무'
                        default:
                          return '관련'
                      }
                    }

                    return (
                      <div key={relationship.id} className="group flex items-center gap-3 p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors">
                        {getRelationIcon(relationship.type)}
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            <span className="text-xs font-medium text-gray-600 bg-white px-2 py-1 rounded-full">
                              {getRelationLabel(relationship.type)}
                            </span>
                            <span className="text-sm font-medium text-gray-900">
                              {relationship.targetTask?.title || `업무 #${relationship.targetTaskId}`}
                            </span>
                          </div>
                        </div>
                        <button
                          onClick={() => removeTaskRelationship(relationship.id)}
                          className="opacity-0 group-hover:opacity-100 w-6 h-6 flex items-center justify-center text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-all"
                          title="관계 제거"
                        >
                          <XMarkIcon className="w-4 h-4" />
                        </button>
                      </div>
                    )
                  })}
                </div>
              ) : (
                <div className="text-center py-6 text-gray-500">
                  <LinkIcon className="w-8 h-8 mx-auto mb-2 text-gray-300" />
                  <p className="text-sm">관련 업무가 없습니다.</p>
                  <button
                    onClick={() => setShowTaskSearch(true)}
                    className="text-sm text-blue-600 hover:text-blue-700 font-medium mt-1"
                  >
                    관계 추가하기
                  </button>
                </div>
              )}

              {/* 업무 검색 모달 */}
              {showTaskSearch && (
                <div className="fixed inset-0 z-50 bg-black bg-opacity-25 flex items-center justify-center p-4">
                  <div className="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[70vh] overflow-hidden">
                    {/* 검색 헤더 */}
                    <div className="p-4 border-b border-gray-200">
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="text-lg font-semibold text-gray-900">업무 관계 추가</h4>
                        <button
                          onClick={() => {
                            setShowTaskSearch(false)
                            setTaskSearchQuery('')
                          }}
                          className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors"
                        >
                          <XMarkIcon className="w-5 h-5" />
                        </button>
                      </div>
                      
                      {/* 검색 입력 */}
                      <div className="relative">
                        <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
                        <input
                          type="text"
                          value={taskSearchQuery}
                          onChange={(e) => setTaskSearchQuery(e.target.value)}
                          placeholder="업무 제목으로 검색..."
                          className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                          autoFocus
                        />
                      </div>
                    </div>

                    {/* 업무 목록 */}
                    <div className="max-h-80 overflow-y-auto">
                      {filteredTasks.length > 0 ? (
                        <div className="p-2">
                          {filteredTasks.map((task) => (
                            <div
                              key={task.id}
                              className="p-3 hover:bg-gray-50 rounded-lg cursor-pointer transition-colors"
                            >
                              <div className="font-medium text-gray-900 mb-2">{task.title}</div>
                              
                              {/* 관계 타입 선택 */}
                              <div className="flex gap-2">
                                <button
                                  onClick={() => addTaskRelationship(task.id, 'blocks')}
                                  className="flex items-center gap-1 px-2 py-1 text-xs font-medium text-red-600 bg-red-50 hover:bg-red-100 rounded transition-colors"
                                >
                                  <ArrowRightIcon className="w-3 h-3" />
                                  차단함
                                </button>
                                <button
                                  onClick={() => addTaskRelationship(task.id, 'blocked_by')}
                                  className="flex items-center gap-1 px-2 py-1 text-xs font-medium text-red-600 bg-red-50 hover:bg-red-100 rounded transition-colors"
                                >
                                  <ArrowLeftIcon className="w-3 h-3" />
                                  차단됨
                                </button>
                                <button
                                  onClick={() => addTaskRelationship(task.id, 'related')}
                                  className="flex items-center gap-1 px-2 py-1 text-xs font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded transition-colors"
                                >
                                  <ArrowsRightLeftIcon className="w-3 h-3" />
                                  관련됨
                                </button>
                              </div>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div className="p-8 text-center text-gray-500">
                          <MagnifyingGlassIcon className="w-8 h-8 mx-auto mb-2 text-gray-300" />
                          <p className="text-sm">
                            {taskSearchQuery ? '검색 결과가 없습니다.' : '업무를 검색해보세요.'}
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* 위키 레퍼런스 */}
            <div>
              <div className="flex items-center justify-between mb-3">
                <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">
                  <DocumentTextIcon className="w-5 h-5" />
                  위키 레퍼런스
                  {localTask.wikiReferences.length > 0 && (
                    <span className="text-sm text-gray-500">({localTask.wikiReferences.length})</span>
                  )}
                </h3>
                <button
                  onClick={() => setShowWikiForm(true)}
                  className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors"
                >
                  <PlusIcon className="w-4 h-4" />
                  위키 추가
                </button>
              </div>
              
              {localTask.wikiReferences.length > 0 ? (
                <div className="space-y-2">
                  {localTask.wikiReferences.map((wiki) => {
                    const DocumentIcon = getDocumentIcon(wiki.url)
                    const documentColor = getDocumentColor(wiki.url)
                    
                    return (
                      <div key={wiki.id} className="group flex items-center gap-3 p-3 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors">
                        <DocumentIcon className={`w-5 h-5 ${documentColor} flex-shrink-0`} />
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            <h4 className="text-sm font-medium text-blue-900">{wiki.title}</h4>
                            <LinkIcon className="w-3 h-3 text-blue-600" />
                          </div>
                          {wiki.description && (
                            <p className="text-xs text-blue-700 mt-1">{wiki.description}</p>
                          )}
                          <p className="text-xs text-blue-600 mt-1 font-mono truncate">{wiki.url}</p>
                        </div>
                        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button
                          onClick={() => window.open(wiki.url, '_blank')}
                          className="w-6 h-6 flex items-center justify-center text-blue-600 hover:text-blue-700 hover:bg-blue-200 rounded transition-all"
                          title="위키 열기"
                        >
                          <ArrowTopRightOnSquareIcon className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => startEditingWiki(wiki)}
                          className="w-6 h-6 flex items-center justify-center text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-all"
                          title="위키 편집"
                        >
                          <PencilIcon className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => removeWikiReference(wiki.id)}
                          className="w-6 h-6 flex items-center justify-center text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-all"
                          title="위키 제거"
                        >
                          <XMarkIcon className="w-4 h-4" />
                        </button>
                        </div>
                      </div>
                    )
                  })}
                </div>
              ) : (
                <div className="text-center py-6 text-gray-500">
                  <DocumentTextIcon className="w-8 h-8 mx-auto mb-2 text-gray-300" />
                  <p className="text-sm">연결된 위키 문서가 없습니다.</p>
                  <button
                    onClick={() => setShowWikiForm(true)}
                    className="text-sm text-blue-600 hover:text-blue-700 font-medium mt-1"
                  >
                    위키 추가하기
                  </button>
                </div>
              )}

              {/* 위키 추가 폼 */}
              {showWikiForm && (
                <div className="fixed inset-0 z-50 bg-black bg-opacity-25 flex items-center justify-center p-4">
                  <div className="bg-white rounded-lg shadow-xl max-w-md w-full">
                    {/* 폼 헤더 */}
                    <div className="p-4 border-b border-gray-200">
                      <div className="flex items-center justify-between">
                        <h4 className="text-lg font-semibold text-gray-900">
                          {editingWikiId ? '위키 레퍼런스 편집' : '위키 레퍼런스 추가'}
                        </h4>
                        <button
                          onClick={() => {
                            setShowWikiForm(false)
                            setNewWikiTitle('')
                            setNewWikiUrl('')
                            setNewWikiDescription('')
                            setUrlValidation(null)
                            setEditingWikiId(null)
                          }}
                          className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors"
                        >
                          <XMarkIcon className="w-5 h-5" />
                        </button>
                      </div>
                    </div>

                    {/* 폼 내용 */}
                    <div className="p-4 space-y-4">
                      <div>
                        <label htmlFor="wiki-title" className="block text-sm font-medium text-gray-700 mb-1">
                          제목 *
                        </label>
                        <input
                          id="wiki-title"
                          type="text"
                          value={newWikiTitle}
                          onChange={(e) => setNewWikiTitle(e.target.value)}
                          placeholder="위키 문서 제목"
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        />
                      </div>

                      <div>
                        <label htmlFor="wiki-url" className="block text-sm font-medium text-gray-700 mb-1">
                          URL *
                        </label>
                        <div className="relative">
                          <input
                            id="wiki-url"
                            type="url"
                            value={newWikiUrl}
                            onChange={(e) => handleUrlChange(e.target.value)}
                            placeholder="https://wiki.example.com/document"
                            className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
                              urlValidation 
                                ? urlValidation.isValid 
                                  ? 'border-green-300 bg-green-50' 
                                  : 'border-red-300 bg-red-50'
                                : 'border-gray-300'
                            }`}
                          />
                          {urlValidation && (
                            <div className="absolute right-2 top-1/2 transform -translate-y-1/2">
                              {urlValidation.isValid ? (
                                <CheckCircleIcon className="w-5 h-5 text-green-500" />
                              ) : (
                                <XMarkIcon className="w-5 h-5 text-red-500" />
                              )}
                            </div>
                          )}
                        </div>
                        {urlValidation && (
                          <p className={`text-xs mt-1 ${
                            urlValidation.isValid ? 'text-green-600' : 'text-red-600'
                          }`}>
                            {urlValidation.message}
                          </p>
                        )}
                        
                        {/* URL 미리보기 */}
                        {newWikiUrl && urlValidation?.isValid && (
                          <div className="mt-2 p-2 bg-blue-50 rounded-md border border-blue-200">
                            <div className="flex items-center gap-2 text-sm">
                              <LinkIcon className="w-4 h-4 text-blue-600" />
                              <span className="text-blue-900 font-medium">미리보기:</span>
                              <a 
                                href={newWikiUrl} 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="text-blue-600 hover:text-blue-700 underline truncate flex-1"
                              >
                                {newWikiUrl}
                              </a>
                              <button
                                type="button"
                                onClick={() => window.open(newWikiUrl, '_blank')}
                                className="p-1 text-blue-600 hover:text-blue-700 hover:bg-blue-100 rounded"
                                title="새 탭에서 열기"
                              >
                                <ArrowTopRightOnSquareIcon className="w-4 h-4" />
                              </button>
                            </div>
                          </div>
                        )}
                      </div>

                      <div>
                        <label htmlFor="wiki-description" className="block text-sm font-medium text-gray-700 mb-1">
                          설명 (선택)
                        </label>
                        <textarea
                          id="wiki-description"
                          value={newWikiDescription}
                          onChange={(e) => setNewWikiDescription(e.target.value)}
                          placeholder="위키 문서에 대한 간단한 설명"
                          rows={2}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none"
                        />
                      </div>
                    </div>

                    {/* 폼 푸터 */}
                    <div className="flex items-center justify-end gap-3 p-4 border-t border-gray-200">
                      <button
                        onClick={() => {
                          setShowWikiForm(false)
                          setNewWikiTitle('')
                          setNewWikiUrl('')
                          setNewWikiDescription('')
                          setUrlValidation(null)
                          setEditingWikiId(null)
                        }}
                        className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                      >
                        취소
                      </button>
                      <button
                        onClick={addWikiReference}
                        disabled={!newWikiTitle.trim() || !newWikiUrl.trim() || !urlValidation?.isValid}
                        className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                      >
                        {editingWikiId ? '수정' : '추가'}
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* 푸터 */}
        <div className="flex items-center justify-between p-4 border-t border-gray-200 bg-gray-50">
          <div className="text-sm text-gray-500">
            생성일: {new Date(localTask.createdAt).toLocaleDateString('ko-KR')}
            {localTask.updatedAt && localTask.updatedAt !== localTask.createdAt && (
              <span className="ml-4">
                수정일: {new Date(localTask.updatedAt).toLocaleDateString('ko-KR')}
              </span>
            )}
          </div>
          
          <div className="flex items-center gap-3">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
            >
              취소
            </button>
            <button
              onClick={handleSave}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-md hover:bg-blue-700 transition-colors"
            >
              저장
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/TaskFilters.tsx">
'use client';

import React from 'react';
import { Filter, Calendar, CheckCircle, List } from 'lucide-react';
import type { SmartFilter } from '@/types/task.types';

interface TaskFiltersProps {
  currentFilter: SmartFilter | 'all';
  onFilterChange: (filter: SmartFilter) => void;
  taskCounts?: {
    today: number;
    completed: number;
    all: number;
  };
}

const filterConfig = {
  today: {
    label: '오늘',
    icon: Calendar,
    description: '오늘 마감이거나 진행 중인 태스크',
    color: 'text-orange-600',
    bgColor: 'bg-orange-100',
    hoverBgColor: 'hover:bg-orange-50',
    activeBgColor: 'bg-orange-100',
  },
  completed: {
    label: '완료됨',
    icon: CheckCircle,
    description: '완료된 태스크',
    color: 'text-green-600',
    bgColor: 'bg-green-100',
    hoverBgColor: 'hover:bg-green-50',
    activeBgColor: 'bg-green-100',
  },
  all: {
    label: '전체',
    icon: List,
    description: '모든 태스크',
    color: 'text-gray-600',
    bgColor: 'bg-gray-100',
    hoverBgColor: 'hover:bg-gray-50',
    activeBgColor: 'bg-gray-100',
  },
};

export default function TaskFilters({
  currentFilter = 'all',
  onFilterChange,
  taskCounts
}: TaskFiltersProps) {
  const handleFilterClick = (filter: SmartFilter) => {
    onFilterChange(filter);
  };

  return (
    <div className="flex flex-col sm:flex-row gap-2 p-4 bg-white rounded-lg border border-gray-200">
      <div className="flex items-center gap-2 text-sm font-medium text-gray-700 mb-2 sm:mb-0">
        <Filter className="w-4 h-4" />
        <span className="hidden sm:inline">필터:</span>
      </div>
      
      <div className="flex flex-wrap gap-2">
        {Object.entries(filterConfig).map(([filterKey, config]) => {
          const isActive = currentFilter === filterKey;
          const IconComponent = config.icon;
          const count = taskCounts?.[filterKey as keyof typeof taskCounts];
          
          return (
            <button
              key={filterKey}
              onClick={() => handleFilterClick(filterKey as SmartFilter)}
              className={`
                inline-flex items-center gap-2 px-3 py-2 text-sm font-medium rounded-lg
                border transition-all duration-200
                ${isActive 
                  ? `${config.activeBgColor} ${config.color} border-current shadow-sm` 
                  : `bg-white text-gray-600 border-gray-200 ${config.hoverBgColor} hover:border-gray-300`
                }
              `}
              title={config.description}
            >
              <IconComponent className="w-4 h-4" />
              <span>{config.label}</span>
              {count !== undefined && (
                <span className={`
                  inline-flex items-center justify-center w-5 h-5 text-xs font-semibold rounded-full
                  ${isActive 
                    ? 'bg-white text-current' 
                    : 'bg-gray-100 text-gray-600'
                  }
                `}>
                  {count}
                </span>
              )}
            </button>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/tasks/TaskList.tsx">
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { 
  Calendar, 
  Clock, 
  User, 
  Folder,
  MoreHorizontal,
  Edit,
  Trash2,
  Eye
} from 'lucide-react';
import TaskStatusBadge from './TaskStatusBadge';
import TaskPriorityBadge from './TaskPriorityBadge';
import TaskStatusSelector from './TaskStatusSelector';
import { Task, TaskStatus } from '@/types/task.types';

interface TaskListProps {
  tasks: Task[];
  onStatusChange?: (taskId: string, status: TaskStatus) => void;
  onTaskEdit?: (task: Task) => void;
  onTaskDelete?: (task: Task) => void;
  isLoading?: boolean;
  emptyMessage?: string;
  showProject?: boolean;
  showAssignee?: boolean;
}

export default function TaskList({
  tasks,
  onStatusChange,
  onTaskEdit,
  onTaskDelete,
  isLoading = false,
  emptyMessage = '태스크가 없습니다.',
  showProject = true,
  showAssignee = true
}: TaskListProps) {
  const [expandedTask, setExpandedTask] = useState<string | null>(null);

  const formatDate = (dateString: string | null) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR', {
      month: 'short',
      day: 'numeric'
    });
  };

  const isOverdue = (dueDate: string | null) => {
    if (!dueDate) return false;
    return new Date(dueDate) < new Date();
  };

  const handleActionClick = (e: React.MouseEvent, action: () => void) => {
    e.preventDefault();
    e.stopPropagation();
    action();
  };

  if (isLoading) {
    return (
      <div className="space-y-3">
        {[...Array(5)].map((_, index) => (
          <div key={index} className="bg-white rounded-lg border border-gray-200 p-4">
            <div className="animate-pulse">
              <div className="h-4 bg-gray-200 rounded w-3/4 mb-3"></div>
              <div className="flex space-x-4">
                <div className="h-6 bg-gray-200 rounded w-16"></div>
                <div className="h-6 bg-gray-200 rounded w-20"></div>
                <div className="h-6 bg-gray-200 rounded w-24"></div>
              </div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <div className="text-center py-12">
        <div className="text-gray-400 text-6xl mb-4">📋</div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">태스크 없음</h3>
        <p className="text-gray-500">{emptyMessage}</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {tasks.map((task) => (
        <div
          key={task.id}
          className="bg-white rounded-lg border border-gray-200 hover:border-gray-300 transition-colors"
        >
          <div className="p-4">
            {/* 태스크 헤더 */}
            <div className="flex items-start justify-between mb-3">
              <div className="flex-1 min-w-0">
                <Link 
                  href={`/tasks/${task.id}`}
                  className="block group"
                >
                  <h3 className="text-lg font-medium text-gray-900 group-hover:text-blue-600 transition-colors truncate">
                    {task.title}
                  </h3>
                  {task.description && (
                    <p className="text-sm text-gray-600 mt-1 line-clamp-2">
                      {task.description}
                    </p>
                  )}
                </Link>
              </div>

              {/* 액션 메뉴 */}
              <div className="flex items-center space-x-2 ml-4">
                <div className="relative">
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      setExpandedTask(expandedTask === task.id ? null : task.id);
                    }}
                    className="p-2 text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"
                  >
                    <MoreHorizontal className="w-4 h-4" />
                  </button>

                  {expandedTask === task.id && (
                    <>
                      <div
                        className="fixed inset-0 z-10"
                        onClick={() => setExpandedTask(null)}
                      />
                      <div className="absolute right-0 z-20 mt-1 w-40 bg-white rounded-lg shadow-lg border border-gray-200 py-1">
                        <Link
                          href={`/tasks/${task.id}`}
                          className="flex items-center px-3 py-2 text-sm text-gray-700 hover:bg-gray-50"
                        >
                          <Eye className="w-4 h-4 mr-2" />
                          상세 보기
                        </Link>
                        {onTaskEdit && (
                          <button
                            onClick={(e) => handleActionClick(e, () => onTaskEdit(task))}
                            className="w-full flex items-center px-3 py-2 text-sm text-gray-700 hover:bg-gray-50"
                          >
                            <Edit className="w-4 h-4 mr-2" />
                            수정
                          </button>
                        )}
                        {onTaskDelete && (
                          <button
                            onClick={(e) => handleActionClick(e, () => onTaskDelete(task))}
                            className="w-full flex items-center px-3 py-2 text-sm text-red-600 hover:bg-red-50"
                          >
                            <Trash2 className="w-4 h-4 mr-2" />
                            삭제
                          </button>
                        )}
                      </div>
                    </>
                  )}
                </div>
              </div>
            </div>

            {/* 태스크 메타데이터 */}
            <div className="flex items-center flex-wrap gap-3">
              {/* 상태 */}
              {onStatusChange ? (
                <TaskStatusSelector
                  currentStatus={task.status}
                  onStatusChange={(status) => onStatusChange(task.id, status)}
                  size="sm"
                />
              ) : (
                <TaskStatusBadge status={task.status} size="sm" />
              )}

              {/* 우선순위 */}
              <TaskPriorityBadge priority={task.priority} size="sm" />

              {/* 프로젝트 */}
              {showProject && task.project && (
                <div className="flex items-center text-sm text-gray-500">
                  <Folder className="w-4 h-4 mr-1" />
                  <span className="truncate max-w-32">{task.project.name}</span>
                </div>
              )}

              {/* 담당자 */}
              {showAssignee && task.assignee && (
                <div className="flex items-center text-sm text-gray-500">
                  <User className="w-4 h-4 mr-1" />
                  <span className="truncate max-w-24">
                    {task.assignee.firstName} {task.assignee.lastName}
                  </span>
                </div>
              )}

              {/* 마감일 */}
              {task.dueDate && (
                <div className={`flex items-center text-sm ${
                  isOverdue(task.dueDate) ? 'text-red-600' : 'text-gray-500'
                }`}>
                  <Calendar className="w-4 h-4 mr-1" />
                  <span>{formatDate(task.dueDate)}</span>
                  {isOverdue(task.dueDate) && (
                    <span className="ml-1 text-xs">(지연)</span>
                  )}
                </div>
              )}

              {/* 예상 시간 */}
              {task.estimatedHours && task.estimatedHours > 0 && (
                <div className="flex items-center text-sm text-gray-500">
                  <Clock className="w-4 h-4 mr-1" />
                  <span>{task.estimatedHours}h</span>
                </div>
              )}

              {/* 진행률 */}
              {task.progress > 0 && (
                <div className="flex items-center text-sm text-gray-500">
                  <div className="w-12 bg-gray-200 rounded-full h-2 mr-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${task.progress}%` }}
                    ></div>
                  </div>
                  <span>{task.progress}%</span>
                </div>
              )}
            </div>

            {/* 태그 */}
            {task.tags && task.tags.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-3">
                {task.tags.slice(0, 3).map((tag, index) => (
                  <span
                    key={index}
                    className="inline-block px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full"
                  >
                    {tag}
                  </span>
                ))}
                {task.tags.length > 3 && (
                  <span className="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded-full">
                    +{task.tags.length - 3}
                  </span>
                )}
              </div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/components/ui/AdvancedFilterPanel.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { 
  XMarkIcon, 
  CalendarDaysIcon,
  ClockIcon,
  CheckCircleIcon,
  FlagIcon,
  RectangleStackIcon
} from '@heroicons/react/24/outline'
import { TaskStatus, TaskPriority } from '@/types/task.types'

export interface AdvancedFilters {
  // 마감일 필터
  dueDate?: 'overdue' | 'today' | 'this-week' | 'no-due' | 'custom'
  dueDateRange?: { start: string; end: string }
  
  // 상태 필터
  status?: TaskStatus[]
  
  // 소속 필터 
  projectIds?: string[]
  goalIds?: string[]
}

interface AdvancedFilterPanelProps {
  isOpen: boolean
  onClose: () => void
  filters: AdvancedFilters
  onFiltersChange: (filters: AdvancedFilters) => void
  availableProjects?: Array<{ id: string; name: string }>
  availableGoals?: Array<{ id: string; name: string }>
}

export default function AdvancedFilterPanel({
  isOpen,
  onClose,
  filters,
  onFiltersChange,
  availableProjects = [],
  availableGoals = []
}: AdvancedFilterPanelProps) {
  const panelRef = useRef<HTMLDivElement>(null)
  const [localFilters, setLocalFilters] = useState<AdvancedFilters>(filters)

  // 패널 외부 클릭 감지
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isOpen && panelRef.current && !panelRef.current.contains(event.target as Node)) {
        onClose()
      }
    }

    if (isOpen) {
      setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside)
      }, 100)
      
      return () => {
        document.removeEventListener('mousedown', handleClickOutside)
      }
    }
  }, [isOpen, onClose])

  // 로컬 필터 업데이트
  const updateLocalFilters = (updates: Partial<AdvancedFilters>) => {
    const newFilters = { ...localFilters, ...updates }
    setLocalFilters(newFilters)
    onFiltersChange(newFilters)
  }

  // 마감일 필터 옵션들
  const dueDateOptions = [
    { key: 'overdue', label: '기한 초과', icon: ClockIcon, color: 'text-red-600' },
    { key: 'today', label: '오늘 마감', icon: CalendarDaysIcon, color: 'text-blue-600' },
    { key: 'this-week', label: '이번 주 내 마감', icon: CalendarDaysIcon, color: 'text-blue-500' },
    { key: 'no-due', label: '마감일 없음', icon: CalendarDaysIcon, color: 'text-gray-500' }
  ]

  // 상태 필터 옵션들
  const statusOptions = [
    { key: TaskStatus.TODO, label: '할 일', icon: CheckCircleIcon, color: 'text-gray-600' },
    { key: TaskStatus.IN_PROGRESS, label: '진행 중', icon: ClockIcon, color: 'text-blue-600' },
    { key: TaskStatus.DONE, label: '완료', icon: CheckCircleIcon, color: 'text-green-600' },
    { key: TaskStatus.IN_REVIEW, label: '검토 중', icon: FlagIcon, color: 'text-purple-600' },
    { key: TaskStatus.DEFERRED, label: '보류', icon: ClockIcon, color: 'text-yellow-600' }
  ]

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 bg-black bg-opacity-25 flex items-start justify-center pt-20">
      <div 
        ref={panelRef}
        className="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 max-h-[80vh] overflow-y-auto"
      >
        {/* 헤더 */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <h2 className="text-lg font-semibold text-gray-900">상세 필터</h2>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors"
          >
            <XMarkIcon className="w-5 h-5" />
          </button>
        </div>

        {/* 마감일 필터 */}
        <div className="p-4 border-b border-gray-100">
          <h3 className="text-sm font-medium text-gray-900 mb-3 flex items-center gap-2">
            <CalendarDaysIcon className="w-4 h-4" />
            마감일
          </h3>
          <div className="space-y-2">
            {dueDateOptions.map((option) => {
              const Icon = option.icon
              return (
                <button
                  key={option.key}
                  onClick={() => updateLocalFilters({ 
                    dueDate: localFilters.dueDate === option.key ? undefined : option.key as any 
                  })}
                  className={`w-full flex items-center gap-3 p-2 rounded-lg text-left transition-colors ${
                    localFilters.dueDate === option.key
                      ? 'bg-blue-50 border border-blue-200'
                      : 'hover:bg-gray-50'
                  }`}
                >
                  <Icon className={`w-4 h-4 ${option.color}`} />
                  <span className="text-sm text-gray-700">{option.label}</span>
                </button>
              )
            })}
          </div>
        </div>

        {/* 상태 필터 */}
        <div className="p-4 border-b border-gray-100">
          <h3 className="text-sm font-medium text-gray-900 mb-3 flex items-center gap-2">
            <CheckCircleIcon className="w-4 h-4" />
            상태
          </h3>
          <div className="space-y-2">
            {statusOptions.map((option) => {
              const Icon = option.icon
              const isSelected = localFilters.status?.includes(option.key) || false
              
              return (
                <button
                  key={option.key}
                  onClick={() => {
                    const currentStatus = localFilters.status || []
                    const newStatus = isSelected
                      ? currentStatus.filter(s => s !== option.key)
                      : [...currentStatus, option.key]
                    
                    updateLocalFilters({ 
                      status: newStatus.length > 0 ? newStatus : undefined 
                    })
                  }}
                  className={`w-full flex items-center gap-3 p-2 rounded-lg text-left transition-colors ${
                    isSelected
                      ? 'bg-blue-50 border border-blue-200'
                      : 'hover:bg-gray-50'
                  }`}
                >
                  <Icon className={`w-4 h-4 ${option.color}`} />
                  <span className="text-sm text-gray-700">{option.label}</span>
                  {isSelected && (
                    <div className="ml-auto w-4 h-4 bg-blue-600 rounded-full flex items-center justify-center">
                      <div className="w-1.5 h-1.5 bg-white rounded-full" />
                    </div>
                  )}
                </button>
              )
            })}
          </div>
        </div>

        {/* 소속 필터 */}
        <div className="p-4">
          <h3 className="text-sm font-medium text-gray-900 mb-3 flex items-center gap-2">
            <RectangleStackIcon className="w-4 h-4" />
            소속
          </h3>
          
          {/* 프로젝트 */}
          {availableProjects.length > 0 && (
            <div className="mb-4">
              <h4 className="text-xs font-medium text-gray-600 mb-2">프로젝트</h4>
              <div className="space-y-1">
                {availableProjects.map((project) => {
                  const isSelected = localFilters.projectIds?.includes(project.id) || false
                  
                  return (
                    <button
                      key={project.id}
                      onClick={() => {
                        const currentProjects = localFilters.projectIds || []
                        const newProjects = isSelected
                          ? currentProjects.filter(p => p !== project.id)
                          : [...currentProjects, project.id]
                        
                        updateLocalFilters({ 
                          projectIds: newProjects.length > 0 ? newProjects : undefined 
                        })
                      }}
                      className={`w-full flex items-center gap-3 p-2 rounded-lg text-left transition-colors ${
                        isSelected
                          ? 'bg-blue-50 border border-blue-200'
                          : 'hover:bg-gray-50'
                      }`}
                    >
                      <div className="w-3 h-3 bg-green-500 rounded-full flex-shrink-0" />
                      <span className="text-sm text-gray-700 truncate">{project.name}</span>
                      {isSelected && (
                        <div className="ml-auto w-4 h-4 bg-blue-600 rounded-full flex items-center justify-center">
                          <div className="w-1.5 h-1.5 bg-white rounded-full" />
                        </div>
                      )}
                    </button>
                  )
                })}
              </div>
            </div>
          )}

          {/* 목표 */}
          {availableGoals.length > 0 && (
            <div>
              <h4 className="text-xs font-medium text-gray-600 mb-2">목표</h4>
              <div className="space-y-1">
                {availableGoals.map((goal) => {
                  const isSelected = localFilters.goalIds?.includes(goal.id) || false
                  
                  return (
                    <button
                      key={goal.id}
                      onClick={() => {
                        const currentGoals = localFilters.goalIds || []
                        const newGoals = isSelected
                          ? currentGoals.filter(g => g !== goal.id)
                          : [...currentGoals, goal.id]
                        
                        updateLocalFilters({ 
                          goalIds: newGoals.length > 0 ? newGoals : undefined 
                        })
                      }}
                      className={`w-full flex items-center gap-3 p-2 rounded-lg text-left transition-colors ${
                        isSelected
                          ? 'bg-blue-50 border border-blue-200'
                          : 'hover:bg-gray-50'
                      }`}
                    >
                      <FlagIcon className="w-4 h-4 text-blue-500 flex-shrink-0" />
                      <span className="text-sm text-gray-700 truncate">{goal.name}</span>
                      {isSelected && (
                        <div className="ml-auto w-4 h-4 bg-blue-600 rounded-full flex items-center justify-center">
                          <div className="w-1.5 h-1.5 bg-white rounded-full" />
                        </div>
                      )}
                    </button>
                  )
                })}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/Button.tsx">
import React from 'react';
import { cn } from '@/lib/utils';

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  loading?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', loading = false, disabled, children, ...props }, ref) => {
    const baseClasses = 'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50';
    
    const variants = {
      default: 'bg-blue-600 text-white hover:bg-blue-700',
      destructive: 'bg-red-600 text-white hover:bg-red-700',
      outline: 'border border-gray-300 bg-background text-gray-900 hover:bg-gray-50',
      secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200',
      ghost: 'text-gray-900 hover:bg-gray-100',
      link: 'text-blue-600 underline-offset-4 hover:underline'
    };

    const sizes = {
      default: 'h-10 px-4 py-2',
      sm: 'h-9 rounded-md px-3',
      lg: 'h-11 rounded-md px-8',
      icon: 'h-10 w-10'
    };

    return (
      <button
        className={cn(
          baseClasses,
          variants[variant],
          sizes[size],
          className
        )}
        ref={ref}
        disabled={disabled || loading}
        {...props}
      >
        {loading ? (
          <div className="flex items-center space-x-2">
            <div className="w-4 h-4 border-2 border-current border-r-transparent rounded-full animate-spin" />
            <span>로딩중...</span>
          </div>
        ) : (
          children
        )}
      </button>
    );
  }
);

Button.displayName = 'Button';

export { Button };
</file>

<file path="frontend/src/components/ui/CalendarToggleFAB.tsx">
'use client'

import { CalendarIcon, XMarkIcon } from '@heroicons/react/24/outline'

interface CalendarToggleFABProps {
  isCalendarExpanded: boolean
  onToggle: () => void
}

export default function CalendarToggleFAB({ 
  isCalendarExpanded, 
  onToggle 
}: CalendarToggleFABProps) {
  return (
    <button
      onClick={onToggle}
      className={`
        w-14 h-14 
        bg-gray-600 hover:bg-gray-700 
        text-white 
        rounded-full 
        shadow-lg hover:shadow-xl
        transition-all duration-200
        flex items-center justify-center
        ${isCalendarExpanded ? 'rotate-180' : ''}
      `}
      title={isCalendarExpanded ? "캘린더 닫기" : "캘린더 열기"}
    >
      {isCalendarExpanded ? (
        <XMarkIcon className="w-6 h-6" />
      ) : (
        <CalendarIcon className="w-6 h-6" />
      )}
    </button>
  )
}
</file>

<file path="frontend/src/components/ui/LoginBanner.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { isAuthenticated } from '@/lib/auth'

export default function LoginBanner() {
  const router = useRouter()
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  const handleGoogleLogin = () => {
    router.push('/auth/login')
  }

  // 로그인된 상태면 표시하지 않음
  if (isLoggedIn) {
    return null
  }

  return (
    <div className="fixed top-20 z-30 hidden xl:block" style={{ left: 'calc(50% + 360px + 40px)' }}>
      <div className="bg-white border border-gray-200 rounded-xl shadow-lg p-6 w-72">
        <div className="text-center">
          <div className="mb-4">
            <div className="w-12 h-12 bg-gradient-to-r from-blue-500 to-purple-500 rounded-full flex items-center justify-center mx-auto mb-3">
              <span className="text-white font-bold text-xl">W</span>
            </div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">워클리와 함께 시작하세요</h3>
            <p className="text-sm text-gray-600 mb-4">업무를 정리하고, 목표를 달성하며, 역량을 성장시키세요</p>
          </div>
          <button 
            onClick={handleGoogleLogin}
            className="w-full flex items-center justify-center gap-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-xl px-4 py-3 font-semibold hover:from-blue-700 hover:to-purple-700 transition-colors shadow-md"
          >
            <svg className="w-5 h-5" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Google로 시작하기
          </button>
          <div className="mt-4 text-xs text-gray-500">
            <p>• 무료로 시작</p>
            <p>• 즉시 사용 가능</p>
            <p>• 데이터 안전 보장</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/MobileFilterTabs.tsx">
'use client'

import { ReactNode, useRef, useEffect } from 'react'

interface FilterOption {
  key: string
  label: string
  count?: number
  icon?: ReactNode
}

interface MobileFilterTabsProps {
  options: FilterOption[]
  activeFilter: string
  onFilterChange: (filter: string) => void
  className?: string
  variant?: 'chips' | 'tabs' | 'cards'
}

/**
 * 향상된 모바일 필터 컴포넌트
 * - 스크롤 가능한 무한 확장성
 * - 모던한 디자인 변형 지원
 * - 자동 중앙 정렬 및 스크롤
 */
export default function MobileFilterTabs({ 
  options, 
  activeFilter, 
  onFilterChange,
  className = '',
  variant = 'chips'
}: MobileFilterTabsProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null)

  // 활성 필터로 자동 스크롤
  useEffect(() => {
    if (scrollContainerRef.current) {
      const activeElement = scrollContainerRef.current.querySelector(`[data-filter="${activeFilter}"]`)
      if (activeElement) {
        activeElement.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center'
        })
      }
    }
  }, [activeFilter])

  if (variant === 'chips') {
    return (
      <div className={`relative bg-gradient-to-r from-gray-50 to-white px-4 py-3 ${className}`}>
        {/* 그라디언트 페이드 효과 */}
        <div className="absolute left-0 top-0 bottom-0 w-4 bg-gradient-to-r from-gray-50 to-transparent pointer-events-none z-10" />
        <div className="absolute right-0 top-0 bottom-0 w-4 bg-gradient-to-l from-white to-transparent pointer-events-none z-10" />
        
        <div 
          ref={scrollContainerRef}
          className="flex space-x-2 overflow-x-auto scrollbar-hide pb-1"
          style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
        >
          {options.map((option) => (
            <button
              key={option.key}
              data-filter={option.key}
              onClick={() => onFilterChange(option.key)}
              className={`
                flex-shrink-0
                px-4 py-2
                text-sm font-medium
                rounded-full
                transition-all duration-300
                flex items-center gap-2
                min-w-max
                transform hover:scale-105
                ${
                  activeFilter === option.key
                    ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg shadow-blue-500/25'
                    : 'bg-white text-gray-600 hover:text-gray-900 hover:bg-gray-50 border border-gray-200 hover:border-gray-300 hover:shadow-md'
                }
              `}
            >
              {option.icon && (
                <span className="w-4 h-4 flex items-center justify-center">
                  {option.icon}
                </span>
              )}
              <span className="whitespace-nowrap">{option.label}</span>
              {option.count !== undefined && option.count > 0 && (
                <span 
                  className={`
                    text-xs 
                    min-w-[20px] 
                    h-5
                    rounded-full 
                    flex 
                    items-center 
                    justify-center 
                    font-semibold
                    ${
                      activeFilter === option.key 
                        ? 'bg-white/20 text-white' 
                        : 'bg-gray-100 text-gray-600'
                    }
                  `}
                >
                  {option.count > 99 ? '99+' : option.count}
                </span>
              )}
            </button>
          ))}
        </div>
      </div>
    )
  }

  if (variant === 'cards') {
    return (
      <div className={`bg-gray-50 p-4 ${className}`}>
        <div 
          ref={scrollContainerRef}
          className="flex space-x-3 overflow-x-auto scrollbar-hide pb-2"
          style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
        >
          {options.map((option) => (
            <button
              key={option.key}
              data-filter={option.key}
              onClick={() => onFilterChange(option.key)}
              className={`
                flex-shrink-0 
                min-w-[120px]
                p-4
                rounded-xl
                transition-all duration-300
                transform hover:scale-105
                ${
                  activeFilter === option.key
                    ? 'bg-gradient-to-br from-blue-600 to-purple-600 text-white shadow-xl shadow-blue-500/30'
                    : 'bg-white text-gray-700 hover:text-gray-900 shadow-md hover:shadow-lg border border-gray-200'
                }
              `}
            >
              <div className="text-center space-y-2">
                {option.icon && (
                  <div className="flex justify-center">
                    <span className="w-6 h-6 flex items-center justify-center">
                      {option.icon}
                    </span>
                  </div>
                )}
                <div className="text-sm font-medium">{option.label}</div>
                {option.count !== undefined && (
                  <div 
                    className={`
                      text-xs font-semibold
                      ${
                        activeFilter === option.key 
                          ? 'text-white/80' 
                          : 'text-gray-500'
                      }
                    `}
                  >
                    {option.count}개
                  </div>
                )}
              </div>
            </button>
          ))}
        </div>
      </div>
    )
  }

  // 기본 tabs 변형 (개선된 버전)
  return (
    <div className={`bg-white border-b border-gray-200 ${className}`}>
      <div 
        ref={scrollContainerRef}
        className="flex overflow-x-auto scrollbar-hide"
        style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
      >
        {options.map((option) => (
          <button
            key={option.key}
            data-filter={option.key}
            onClick={() => onFilterChange(option.key)}
            className={`
              flex-shrink-0
              px-6 py-4
              text-sm font-medium
              transition-all duration-300
              flex items-center gap-2
              border-b-2
              min-w-max
              relative
              ${
                activeFilter === option.key
                  ? 'text-blue-600 border-blue-600 bg-blue-50/50'
                  : 'text-gray-600 hover:text-gray-900 border-transparent hover:border-gray-300'
              }
            `}
          >
            {option.icon && (
              <span className="w-4 h-4 flex items-center justify-center">
                {option.icon}
              </span>
            )}
            <span className="whitespace-nowrap">{option.label}</span>
            {option.count !== undefined && option.count > 0 && (
              <span 
                className={`
                  text-xs 
                  min-w-[20px] 
                  h-5
                  rounded-full 
                  flex 
                  items-center 
                  justify-center 
                  font-semibold
                  ${
                    activeFilter === option.key 
                      ? 'bg-blue-100 text-blue-700' 
                      : 'bg-gray-100 text-gray-600'
                  }
                `}
              >
                {option.count > 99 ? '99+' : option.count}
              </span>
            )}
          </button>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/QuickAddInput.tsx">
'use client'

import { useState, KeyboardEvent } from 'react'
import { PlusIcon } from '@heroicons/react/24/outline'

interface QuickAddInputProps {
  placeholder?: string
  onTaskCreate: (title: string) => void
  className?: string
}

export default function QuickAddInput({ 
  placeholder = "무엇을 해야 하나요?", 
  onTaskCreate,
  className = ""
}: QuickAddInputProps) {
  const [inputValue, setInputValue] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  const handleKeyPress = async (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && inputValue.trim()) {
      e.preventDefault()
      setIsLoading(true)
      
      try {
        // PRD 명세: Enter 입력 시 새 업무가 리스트 최상단에 생성
        await onTaskCreate(inputValue.trim())
        setInputValue('') // 입력창 초기화
      } catch (error) {
        console.error('업무 생성 실패:', error)
      } finally {
        setIsLoading(false)
      }
    }
  }

  const handleButtonClick = async () => {
    if (!inputValue.trim()) return
    
    setIsLoading(true)
    try {
      await onTaskCreate(inputValue.trim())
      setInputValue('')
    } catch (error) {
      console.error('업무 생성 실패:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className={`workly-card ${className}`}>
      <div className="flex items-center space-x-3">
        <div className="flex-1 relative">
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={placeholder}
            disabled={isLoading}
            className="w-full px-4 py-3 text-base border border-gray-200 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent placeholder-gray-500 disabled:bg-gray-50 disabled:cursor-not-allowed"
          />
          {isLoading && (
            <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            </div>
          )}
        </div>
        <button
          onClick={handleButtonClick}
          disabled={!inputValue.trim() || isLoading}
          className="workly-button flex items-center justify-center w-12 h-12 disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          <PlusIcon className="w-5 h-5" />
        </button>
      </div>
      
      {/* 힌트 텍스트 */}
      <p className="workly-caption mt-2 ml-1">
        Enter 키를 누르거나 + 버튼을 클릭하여 업무를 추가하세요
      </p>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/SearchBar.tsx">
'use client'

import { Search, X } from 'lucide-react'

interface SearchBarProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  className?: string
  showClearButton?: boolean
}

/**
 * 깔끔한 검색바 컴포넌트
 * - 아이콘이 포함된 입력 필드
 * - 클리어 버튼 옵션
 * - 깔끔한 디자인
 */
export default function SearchBar({
  value,
  onChange,
  placeholder = "검색...",
  className = "",
  showClearButton = true
}: SearchBarProps) {
  const handleClear = () => {
    onChange('')
  }

  return (
    <div className={`relative ${className}`}>
      <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
      <input
        type="text"
        placeholder={placeholder}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="
          w-full 
          pl-10 
          pr-10 
          py-3 
          border 
          border-gray-200 
          rounded-lg 
          focus:ring-2 
          focus:ring-blue-500 
          focus:border-transparent 
          bg-white 
          text-sm
          placeholder:text-gray-400
          transition-colors
        "
      />
      {showClearButton && value && (
        <button
          onClick={handleClear}
          className="
            absolute 
            right-3 
            top-1/2 
            transform 
            -translate-y-1/2 
            text-gray-400 
            hover:text-gray-600 
            transition-colors
            p-1
            rounded-full
            hover:bg-gray-100
          "
          aria-label="검색 지우기"
        >
          <X className="w-3 h-3" />
        </button>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/Textarea.tsx">
import React from 'react';
import { cn } from '@/lib/utils';

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  error?: string;
  label?: string;
  helperText?: string;
}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, error, label, helperText, id, ...props }, ref) => {
    const textareaId = id || `textarea-${Math.random().toString(36).substr(2, 9)}`;

    return (
      <div className="w-full">
        {label && (
          <label 
            htmlFor={textareaId}
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            {label}
            {props.required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        <textarea
          id={textareaId}
          className={cn(
            'flex min-h-[80px] w-full rounded-md border border-gray-300 bg-background px-3 py-2 text-sm ring-offset-background',
            'placeholder:text-gray-400',
            'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2',
            'disabled:cursor-not-allowed disabled:opacity-50',
            'resize-none',
            error && 'border-red-500 focus-visible:ring-red-500',
            className
          )}
          ref={ref}
          {...props}
        />
        {error && (
          <p className="mt-1 text-sm text-red-600">{error}</p>
        )}
        {helperText && !error && (
          <p className="mt-1 text-sm text-gray-500">{helperText}</p>
        )}
      </div>
    );
  }
);

Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="frontend/src/components/ui/TriageWizardModal.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { 
  XMarkIcon, 
  TrashIcon, 
  CalendarIcon,
  FolderIcon,
  FlagIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  CheckCircleIcon
} from '@heroicons/react/24/outline'
import { WorklyTask } from '@/shared/types/workly-core.types'
import { TaskStatus } from '@/types/task.types'

interface TriageWizardModalProps {
  isOpen: boolean
  onClose: () => void
  tasks: WorklyTask[] // 미분류 업무들
  onTaskUpdate: (taskId: string, updates: Partial<WorklyTask>) => void
  onTaskDelete: (taskId: string) => void
}

interface DragTarget {
  type: 'delete' | 'schedule' | 'project'
  label: string
  icon: React.ReactNode
  action: string
}

export default function TriageWizardModal({
  isOpen,
  onClose,
  tasks,
  onTaskUpdate,
  onTaskDelete
}: TriageWizardModalProps) {
  const [currentTaskIndex, setCurrentTaskIndex] = useState(0)
  const [isDragging, setIsDragging] = useState(false)
  const [draggedOver, setDraggedOver] = useState<string | null>(null)
  const [swipeStartX, setSwipeStartX] = useState<number | null>(null)
  const [swipeDistance, setSwipeDistance] = useState(0)
  const cardRef = useRef<HTMLDivElement>(null)

  // PRD 명세: 미분류 업무만 표시 (프로젝트/목표 소속 없음)
  const untriagedTasks = tasks.filter(task => 
    !task.projectId && !task.goalId && task.status !== TaskStatus.DONE
  )
  
  // 디버깅: 미분류 업무가 없으면 전체 업무 중 완료되지 않은 것들을 보여줌
  const availableTasks = untriagedTasks.length > 0 ? untriagedTasks : 
    tasks.filter(task => task.status !== TaskStatus.DONE)

  console.log('TriageWizardModal - 전체 업무:', tasks.length)
  console.log('TriageWizardModal - 미분류 업무:', untriagedTasks.length)
  console.log('TriageWizardModal - 사용할 업무:', availableTasks.length)

  const currentTask = availableTasks[currentTaskIndex]
  const hasNextTask = currentTaskIndex < availableTasks.length - 1
  const hasPrevTask = currentTaskIndex > 0
  const completedCount = currentTaskIndex

  // 드래그 타겟 정의
  const dragTargets: DragTarget[] = [
    {
      type: 'delete',
      label: '삭제 (30일간 휴지통 보관)',
      icon: <TrashIcon className="w-6 h-6" />,
      action: 'delete'
    },
    {
      type: 'schedule',
      label: '날짜 지정',
      icon: <CalendarIcon className="w-6 h-6" />,
      action: 'schedule'
    },
    {
      type: 'project',
      label: '프로젝트에 추가',
      icon: <FolderIcon className="w-6 h-6" />,
      action: 'project'
    }
  ]

  // 모달이 열릴 때 첫 번째 업무로 초기화
  useEffect(() => {
    if (isOpen) {
      setCurrentTaskIndex(0)
      setSwipeDistance(0)
    }
  }, [isOpen])

  // 빈 업무 목록이면 모달 닫기
  useEffect(() => {
    if (isOpen && availableTasks.length === 0) {
      onClose()
    }
  }, [availableTasks.length, isOpen, onClose])

  if (!isOpen || !currentTask) return null

  // 스와이프 시작
  const handleTouchStart = (e: React.TouchEvent) => {
    setSwipeStartX(e.touches[0].clientX)
    setSwipeDistance(0)
  }

  // 스와이프 중
  const handleTouchMove = (e: React.TouchEvent) => {
    if (swipeStartX === null) return
    
    const currentX = e.touches[0].clientX
    const distance = currentX - swipeStartX
    
    // 왼쪽 스와이프만 처리 (삭제)
    if (distance < 0) {
      setSwipeDistance(Math.max(distance, -150)) // 최대 150px
    }
  }

  // 스와이프 끝
  const handleTouchEnd = () => {
    if (swipeDistance < -100) {
      // PRD 명세: 스와이프(왼쪽)으로 삭제
      handleDeleteTask()
    } else {
      setSwipeDistance(0)
    }
    setSwipeStartX(null)
  }

  // 드래그 시작
  const handleDragStart = (e: React.DragEvent) => {
    setIsDragging(true)
    e.dataTransfer.setData('text/plain', currentTask.id)
  }

  // 드래그 끝
  const handleDragEnd = () => {
    setIsDragging(false)
    setDraggedOver(null)
  }

  // 드롭 타겟 위로 드래그
  const handleDragOver = (e: React.DragEvent, targetType: string) => {
    e.preventDefault()
    setDraggedOver(targetType)
  }

  // 드롭 타겟에서 나감
  const handleDragLeave = () => {
    setDraggedOver(null)
  }

  // 드롭 처리
  const handleDrop = (e: React.DragEvent, target: DragTarget) => {
    e.preventDefault()
    const taskId = e.dataTransfer.getData('text/plain')
    
    if (taskId === currentTask.id) {
      switch (target.type) {
        case 'delete':
          handleDeleteTask()
          break
        case 'schedule':
          handleScheduleTask()
          break
        case 'project':
          handleAssignToProject()
          break
      }
    }
    
    setDraggedOver(null)
    setIsDragging(false)
  }

  // 업무 삭제 (30일간 휴지통)
  const handleDeleteTask = () => {
    onTaskDelete(currentTask.id)
    moveToNextTask()
  }

  // 날짜 지정 (임시로 3일 후로 설정 - 실제로는 캘린더 위젯 필요)
  const handleScheduleTask = () => {
    const dueDate = new Date()
    dueDate.setDate(dueDate.getDate() + 3)
    
    onTaskUpdate(currentTask.id, {
      dueDate: dueDate.toISOString(),
      scheduledDate: dueDate.toISOString()
    })
    moveToNextTask()
  }

  // 프로젝트 할당 (임시로 기본 프로젝트 - 실제로는 프로젝트 선택 필요)
  const handleAssignToProject = () => {
    onTaskUpdate(currentTask.id, {
      projectId: 'proj-1' // 임시 프로젝트 ID
    })
    moveToNextTask()
  }

  // 다음 업무로 이동
  const moveToNextTask = () => {
    if (hasNextTask) {
      setCurrentTaskIndex(prev => prev + 1)
    } else {
      onClose() // 모든 업무 처리 완료
    }
    setSwipeDistance(0)
  }

  // 이전 업무로 이동
  const moveToPrevTask = () => {
    if (hasPrevTask) {
      setCurrentTaskIndex(prev => prev - 1)
    }
    setSwipeDistance(0)
  }

  // 건너뛰기
  const handleSkip = () => {
    moveToNextTask()
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-md mx-auto">
        {/* 헤더 */}
        <div className="flex items-center justify-between p-6 border-b border-gray-100">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
              <span className="text-xl">🪄</span>
            </div>
            <div>
              <h2 className="workly-card-title">정리 마법사</h2>
              <p className="workly-caption">
                {completedCount}/{availableTasks.length} 완료
              </p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-full hover:bg-gray-100 transition-colors"
          >
            <XMarkIcon className="w-5 h-5" />
          </button>
        </div>

        {/* 진행률 바 */}
        <div className="px-6 py-3 bg-gray-50">
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${(completedCount / availableTasks.length) * 100}%` }}
            />
          </div>
        </div>

        {/* 업무 카드 */}
        <div className="p-6">
          <div
            ref={cardRef}
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            className={`
              workly-card cursor-move select-none transition-all duration-200
              ${isDragging ? 'opacity-50 scale-95' : ''}
              ${swipeDistance < 0 ? 'bg-red-50' : ''}
            `}
            style={{
              transform: `translateX(${swipeDistance}px)`,
            }}
          >
            <div className="flex items-start gap-3 mb-3">
              <div className="w-6 h-6 flex-shrink-0 bg-blue-100 rounded-full flex items-center justify-center">
                <FlagIcon className="w-4 h-4 text-blue-600" />
              </div>
              <div className="flex-1 min-w-0">
                <h3 className="workly-card-title mb-1">{currentTask.title}</h3>
                {currentTask.description && (
                  <p className="workly-caption text-gray-600 line-clamp-2">
                    {currentTask.description}
                  </p>
                )}
              </div>
            </div>
            
            {/* 태그들 */}
            <div className="flex flex-wrap gap-1 mb-3">
              {currentTask.tags.map((tag, index) => (
                <span
                  key={index}
                  className="inline-block px-2 py-1 text-xs text-gray-600 bg-gray-100 rounded-full"
                >
                  {tag}
                </span>
              ))}
            </div>

            {/* 힌트 텍스트 */}
            <div className="text-center text-xs text-gray-500 border-t border-gray-100 pt-3">
              <p>← 스와이프하여 삭제 또는 드래그하여 정리</p>
            </div>
          </div>

          {/* 삭제 표시 (스와이프 시) */}
          {swipeDistance < -50 && (
            <div className="absolute right-8 top-1/2 transform -translate-y-1/2 text-red-500">
              <TrashIcon className="w-8 h-8" />
              <p className="text-xs mt-1">삭제</p>
            </div>
          )}
        </div>

        {/* 드래그 타겟들 */}
        <div className="px-6 pb-4">
          <div className="grid grid-cols-3 gap-3">
            {dragTargets.map((target) => (
              <div
                key={target.type}
                onDragOver={(e) => handleDragOver(e, target.type)}
                onDragLeave={handleDragLeave}
                onDrop={(e) => handleDrop(e, target)}
                className={`
                  p-4 border-2 border-dashed rounded-lg text-center transition-all
                  ${draggedOver === target.type
                    ? target.type === 'delete'
                      ? 'border-red-300 bg-red-50 text-red-600'
                      : target.type === 'schedule'
                      ? 'border-blue-300 bg-blue-50 text-blue-600'
                      : 'border-green-300 bg-green-50 text-green-600'
                    : 'border-gray-200 text-gray-500'
                  }
                `}
              >
                <div className="flex flex-col items-center gap-2">
                  {target.icon}
                  <span className="text-xs font-medium">{target.label}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* 액션 버튼들 */}
        <div className="flex items-center justify-between p-6 bg-gray-50 rounded-b-xl">
          <button
            onClick={moveToPrevTask}
            disabled={!hasPrevTask}
            className="flex items-center gap-2 px-4 py-2 text-sm text-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed hover:text-gray-800 transition-colors"
          >
            <ArrowLeftIcon className="w-4 h-4" />
            이전
          </button>

          <button
            onClick={handleSkip}
            className="px-4 py-2 text-sm text-gray-600 hover:text-gray-800 transition-colors"
          >
            건너뛰기
          </button>

          <button
            onClick={moveToNextTask}
            disabled={!hasNextTask}
            className="flex items-center gap-2 px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
          >
            다음
            <ArrowRightIcon className="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/WorklyFloatingActionButton.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { usePathname } from 'next/navigation'
import { SparklesIcon } from '@heroicons/react/24/outline'
import TriageWizardModal from '@/components/ui/TriageWizardModal'
import { WorklyTask } from '@/shared/types/workly-core.types'

interface WorklyFloatingActionButtonProps {
  tasks?: WorklyTask[] // 정리 마법사를 위한 업무 목록
  onTaskUpdate?: (taskId: string, updates: Partial<WorklyTask>) => void
  onTaskDelete?: (taskId: string) => void
  showOnDesktop?: boolean  // 워클리 정책: 데스크톱에서만 표시
  showOnMobile?: boolean   // 모바일에서는 기본적으로 숨김
}

export default function WorklyFloatingActionButton({
  tasks = [],
  onTaskUpdate,
  onTaskDelete,
  showOnDesktop = true,
  showOnMobile = false
}: WorklyFloatingActionButtonProps) {
  const pathname = usePathname()
  const [isTriageWizardOpen, setIsTriageWizardOpen] = useState(false)

  // PRD 명세: 미분류 업무 20개 초과 시 지능적 유도
  const untriagedTasks = tasks.filter(task => !task.projectId && !task.goalId)
  const shouldShowTriagePrompt = untriagedTasks.length >= 20
  
  // 디버깅: 테스트를 위해 업무가 있으면 항상 FAB 표시
  const hasTasksToTriage = tasks.length > 0

  console.log('WorklyFloatingActionButton - 전체 업무:', tasks.length)
  console.log('WorklyFloatingActionButton - 미분류 업무:', untriagedTasks.length)
  console.log('WorklyFloatingActionButton - FAB 표시 여부:', hasTasksToTriage)

  const handleOpenTriageWizard = () => {
    console.log('정리 마법사 열기 클릭!')
    console.log('전체 업무:', tasks.length)
    console.log('미분류 업무:', untriagedTasks.length)
    setIsTriageWizardOpen(true)
  }

  const handleCloseTriageWizard = () => {
    setIsTriageWizardOpen(false)
  }

  return (
    <>
      {/* 데스크톱 버전 - 정리 마법사 FAB */}
      {showOnDesktop && (
        <div className="hidden md:block fixed bottom-6 right-6 z-40">
          {/* 정리 마법사 버튼 */}
          <button
            onClick={handleOpenTriageWizard}
            className={`
              w-16 h-16 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full 
              flex items-center justify-center shadow-xl hover:shadow-2xl transition-all duration-300 
              hover:scale-110 active:scale-95
              ${shouldShowTriagePrompt ? 'animate-pulse ring-4 ring-blue-200' : ''}
            `}
            aria-label="정리 마법사 열기"
          >
            <SparklesIcon className="w-7 h-7" />
          </button>

          {/* 지능적 유도 알림 */}
          {shouldShowTriagePrompt && (
            <div className="absolute -top-16 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg text-xs whitespace-nowrap animate-bounce">
              <div className="text-center">
                <div className="font-semibold">정리가 필요해요!</div>
                <div>미분류 업무 {untriagedTasks.length}개</div>
              </div>
              {/* 화살표 */}
              <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-blue-600"></div>
            </div>
          )}
        </div>
      )}

      {/* 모바일 버전 - 정리 마법사 FAB */}
      {showOnMobile && hasTasksToTriage && (
        <div className="md:hidden fixed bottom-20 right-6 z-40">
          <button
            onClick={handleOpenTriageWizard}
            className={`
              w-14 h-14 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full 
              flex items-center justify-center shadow-lg transition-all duration-300
              ${shouldShowTriagePrompt ? 'animate-pulse ring-2 ring-blue-200' : ''}
            `}
            aria-label="정리 마법사"
          >
            <SparklesIcon className="w-6 h-6" />
          </button>
        </div>
      )}

      {/* 정리 마법사 모달 */}
      <TriageWizardModal
        isOpen={isTriageWizardOpen}
        onClose={handleCloseTriageWizard}
        tasks={tasks}
        onTaskUpdate={onTaskUpdate || (() => {})}
        onTaskDelete={onTaskDelete || (() => {})}
      />
    </>
  )
}
</file>

<file path="frontend/src/components/ui/WorklyMDXEditor.tsx">
'use client'

import { forwardRef } from 'react'
import { 
  MDXEditor,
  headingsPlugin,
  listsPlugin,
  quotePlugin,
  thematicBreakPlugin,
  markdownShortcutPlugin,
  linkPlugin,
  linkDialogPlugin,
  imagePlugin,
  tablePlugin,
  codeBlockPlugin,
  codeMirrorPlugin,
  toolbarPlugin,
  UndoRedo,
  BoldItalicUnderlineToggles,
  BlockTypeSelect,
  CreateLink,
  InsertImage,
  InsertTable,
  InsertThematicBreak,
  ListsToggle,
  Separator,
  type MDXEditorMethods
} from '@mdxeditor/editor'

interface WorklyMDXEditorProps {
  markdown: string
  onChange: (markdown: string) => void
  placeholder?: string
  className?: string
}

const WorklyMDXEditor = forwardRef<MDXEditorMethods, WorklyMDXEditorProps>(
  ({ markdown, onChange, placeholder = "내용을 입력하세요...", className = "" }, ref) => {
    return (
      <div className={`border border-gray-200 rounded-lg overflow-hidden ${className}`}>
        <MDXEditor
          ref={ref}
          markdown={markdown}
          onChange={onChange}
          placeholder={placeholder}
          plugins={[
            // 기본 텍스트 서식
            headingsPlugin(),
            listsPlugin(),
            quotePlugin(),
            thematicBreakPlugin(),
            markdownShortcutPlugin(),
            
            // 링크 및 이미지
            linkPlugin(),
            linkDialogPlugin(),
            imagePlugin({
              imageUploadHandler: async () => {
                // 이미지 업로드 처리 로직 (향후 구현)
                return Promise.resolve('https://via.placeholder.com/300x200')
              }
            }),
            
            // 테이블 및 코드
            tablePlugin(),
            codeBlockPlugin({ defaultCodeBlockLanguage: 'javascript' }),
            codeMirrorPlugin({
              codeBlockLanguages: {
                js: 'JavaScript',
                jsx: 'JSX',
                ts: 'TypeScript',
                tsx: 'TSX',
                css: 'CSS',
                html: 'HTML',
                json: 'JSON',
                md: 'Markdown',
                bash: 'Bash',
                python: 'Python',
                sql: 'SQL'
              }
            }),
            
            // 툴바
            toolbarPlugin({
              toolbarContents: () => (
                <>
                  <UndoRedo />
                  <Separator />
                  <BoldItalicUnderlineToggles />
                  <Separator />
                  <BlockTypeSelect />
                  <Separator />
                  <ListsToggle />
                  <Separator />
                  <CreateLink />
                  <InsertImage />
                  <Separator />
                  <InsertTable />
                  <InsertThematicBreak />
                </>
              )
            })
          ]}
          contentEditableClassName="prose max-w-none p-4 focus:outline-none min-h-[200px]"
        />
      </div>
    )
  }
)

WorklyMDXEditor.displayName = 'WorklyMDXEditor'

export default WorklyMDXEditor
</file>

<file path="frontend/src/components/workflow/ExecuteWorkflowDashboard.tsx">
'use client'

import { useState, useEffect } from 'react'
import { 
  PlayIcon,
  ClockIcon,
  CheckCircleIcon,
  ChartBarIcon,
  CalendarDaysIcon,
  BoltIcon,
  FireIcon
} from '@heroicons/react/24/outline'
import { Task, TaskStatus, TaskPriority } from '@/types/task.types'

// 목업 오늘의 업무 데이터
const mockTodayTasks: Task[] = [
  {
    id: '1',
    title: '사용자 피드백 정리 및 분석',
    description: '베타 테스트 사용자 피드백을 분석하고 개선 방향 수립',
    status: TaskStatus.IN_PROGRESS,
    priority: TaskPriority.HIGH,
    projectId: 'proj-1',
    project: { id: 'proj-1', name: '워클리 플랫폼 개선', color: '#3B82F6' },
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date().toISOString(),
    estimatedHours: 4,
    actualHours: 2.5,
    completionRate: 60,
    tags: ['분석', '피드백', 'UX'],
    createdAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '2',
    title: 'API 성능 최적화',
    description: '사용자 대시보드 API 응답 시간 개선',
    status: TaskStatus.TODO,
    priority: TaskPriority.MEDIUM,
    projectId: 'proj-2',
    project: { id: 'proj-2', name: '백엔드 최적화', color: '#10B981' },
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date().toISOString(),
    estimatedHours: 3,
    actualHours: 0,
    completionRate: 0,
    tags: ['성능', 'API', '최적화'],
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString()
  },
  {
    id: '3',
    title: '팀 회의 준비',
    description: '주간 스프린트 회의 아젠다 작성',
    status: TaskStatus.COMPLETED,
    priority: TaskPriority.LOW,
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    completedAt: new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString(),
    estimatedHours: 1,
    actualHours: 0.5,
    completionRate: 100,
    tags: ['회의', '계획'],
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString()
  }
]

interface ExecuteWorkflowDashboardProps {
  className?: string
}

export default function ExecuteWorkflowDashboard({ className = '' }: ExecuteWorkflowDashboardProps) {
  const [tasks, setTasks] = useState<Task[]>(mockTodayTasks)
  const [focusMode, setFocusMode] = useState(false)
  const [timeSpent, setTimeSpent] = useState(0) // 분 단위
  const [currentFocusTask, setCurrentFocusTask] = useState<Task | null>(null)

  // 통계 계산
  const todayStats = {
    total: tasks.length,
    completed: tasks.filter(t => t.status === TaskStatus.COMPLETED).length,
    inProgress: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length,
    todo: tasks.filter(t => t.status === TaskStatus.TODO).length,
    totalEstimated: tasks.reduce((acc, task) => acc + (task.estimatedHours || 0), 0),
    totalActual: tasks.reduce((acc, task) => acc + (task.actualHours || 0), 0),
    completionRate: Math.round(
      (tasks.filter(t => t.status === TaskStatus.COMPLETED).length / tasks.length) * 100
    )
  }

  // 집중 모드 시간 추적
  useEffect(() => {
    let interval: NodeJS.Timeout | null = null
    
    if (focusMode && currentFocusTask) {
      interval = setInterval(() => {
        setTimeSpent(prev => prev + 1)
      }, 60000) // 1분마다 업데이트
    }
    
    return () => {
      if (interval) clearInterval(interval)
    }
  }, [focusMode, currentFocusTask])

  const handleStartFocus = (task: Task) => {
    setCurrentFocusTask(task)
    setFocusMode(true)
    setTimeSpent(0)
  }

  const handleStopFocus = () => {
    setFocusMode(false)
    setCurrentFocusTask(null)
    // 실제로는 시간 기록을 저장
  }

  const handleTaskStatusChange = (taskId: string, newStatus: TaskStatus) => {
    setTasks(prev => prev.map(task => 
      task.id === taskId 
        ? { 
            ...task, 
            status: newStatus,
            completedAt: newStatus === TaskStatus.COMPLETED ? new Date().toISOString() : undefined,
            updatedAt: new Date().toISOString()
          }
        : task
    ))
  }

  const getPriorityColor = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.URGENT: return 'text-red-600 bg-red-100'
      case TaskPriority.HIGH: return 'text-blue-600 bg-blue-100'
      case TaskPriority.MEDIUM: return 'text-blue-600 bg-blue-100'
      case TaskPriority.LOW: return 'text-gray-600 bg-gray-100'
      default: return 'text-gray-600 bg-gray-100'
    }
  }

  const getStatusColor = (status: TaskStatus) => {
    switch (status) {
      case TaskStatus.TODO: return 'text-gray-600 bg-gray-100'
      case TaskStatus.IN_PROGRESS: return 'text-blue-600 bg-blue-100'
      case TaskStatus.COMPLETED: return 'text-green-600 bg-green-100'
      case TaskStatus.ON_HOLD: return 'text-yellow-600 bg-yellow-100'
      default: return 'text-gray-600 bg-gray-100'
    }
  }

  return (
    <div className={`space-y-6 ${className}`}>
      {/* 집중 모드 배너 */}
      {focusMode && currentFocusTask && (
        <div className="bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <div className="w-10 h-10 rounded-full bg-white bg-opacity-20 flex items-center justify-center">
                <BoltIcon className="w-5 h-5" />
              </div>
              <div>
                <h3 className="font-semibold">집중 모드 활성</h3>
                <p className="text-sm opacity-90">{currentFocusTask.title}</p>
              </div>
            </div>
            <div className="text-right">
              <div className="text-2xl font-bold">{Math.floor(timeSpent / 60)}:{(timeSpent % 60).toString().padStart(2, '0')}</div>
              <button
                onClick={handleStopFocus}
                className="text-sm px-3 py-1 bg-white bg-opacity-20 rounded-lg hover:bg-opacity-30 mt-1"
              >
                종료
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 오늘의 통계 */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div className="bg-white rounded-lg p-4 border">
          <div className="flex items-center space-x-2">
            <ChartBarIcon className="w-5 h-5 text-blue-600" />
            <span className="text-sm text-gray-600">완료율</span>
          </div>
          <div className="text-2xl font-bold text-gray-900 mt-1">{todayStats.completionRate}%</div>
        </div>
        
        <div className="bg-white rounded-lg p-4 border">
          <div className="flex items-center space-x-2">
            <CheckCircleIcon className="w-5 h-5 text-green-600" />
            <span className="text-sm text-gray-600">완료</span>
          </div>
          <div className="text-2xl font-bold text-gray-900 mt-1">{todayStats.completed}/{todayStats.total}</div>
        </div>
        
        <div className="bg-white rounded-lg p-4 border">
          <div className="flex items-center space-x-2">
            <ClockIcon className="w-5 h-5 text-amber-600" />
            <span className="text-sm text-gray-600">예상 시간</span>
          </div>
          <div className="text-2xl font-bold text-gray-900 mt-1">{todayStats.totalEstimated}h</div>
        </div>
        
        <div className="bg-white rounded-lg p-4 border">
          <div className="flex items-center space-x-2">
            <FireIcon className="w-5 h-5 text-red-600" />
            <span className="text-sm text-gray-600">실제 시간</span>
          </div>
          <div className="text-2xl font-bold text-gray-900 mt-1">{todayStats.totalActual}h</div>
        </div>
      </div>

      {/* 오늘의 업무 목록 */}
      <div className="bg-white rounded-lg border">
        <div className="p-4 border-b">
          <div className="flex items-center space-x-2">
            <CalendarDaysIcon className="w-5 h-5 text-blue-600" />
            <h2 className="text-lg font-semibold text-gray-900">오늘의 업무</h2>
            <span className="text-sm text-gray-500">
              {new Date().toLocaleDateString('ko-KR', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                weekday: 'long'
              })}
            </span>
          </div>
        </div>
        
        <div className="divide-y">
          {tasks.map((task) => (
            <div key={task.id} className="p-4 hover:bg-gray-50">
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <div className="flex items-center space-x-2 mb-2">
                    <h3 className="font-medium text-gray-900">{task.title}</h3>
                    <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getPriorityColor(task.priority)}`}>
                      {task.priority.toUpperCase()}
                    </span>
                    <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(task.status)}`}>
                      {task.status === TaskStatus.TODO ? '대기' :
                       task.status === TaskStatus.IN_PROGRESS ? '진행중' :
                       task.status === TaskStatus.COMPLETED ? '완료' : '보류'}
                    </span>
                  </div>
                  
                  {task.description && (
                    <p className="text-sm text-gray-600 mb-2">{task.description}</p>
                  )}
                  
                  <div className="flex items-center space-x-4 text-sm text-gray-500">
                    {task.project && (
                      <div className="flex items-center space-x-1">
                        <div 
                          className="w-3 h-3 rounded-full"
                          style={{ backgroundColor: task.project.color }}
                        />
                        <span>{task.project.name}</span>
                      </div>
                    )}
                    <span>{task.estimatedHours}h 예상</span>
                    {task.actualHours > 0 && (
                      <span>{task.actualHours}h 소요</span>
                    )}
                  </div>
                  
                  {task.tags.length > 0 && (
                    <div className="flex flex-wrap gap-1 mt-2">
                      {task.tags.map((tag, index) => (
                        <span
                          key={index}
                          className="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded-full"
                        >
                          {tag}
                        </span>
                      ))}
                    </div>
                  )}
                </div>
                
                <div className="flex items-center space-x-2 ml-4">
                  {task.status !== TaskStatus.COMPLETED && (
                    <button
                      onClick={() => handleStartFocus(task)}
                      disabled={focusMode}
                      className="p-2 text-purple-600 hover:bg-purple-50 rounded-lg disabled:opacity-50"
                      title="집중 모드 시작"
                    >
                      <PlayIcon className="w-4 h-4" />
                    </button>
                  )}
                  
                  <select
                    value={task.status}
                    onChange={(e) => handleTaskStatusChange(task.id, e.target.value as TaskStatus)}
                    className="text-sm border border-gray-300 rounded px-2 py-1"
                  >
                    <option value={TaskStatus.TODO}>대기</option>
                    <option value={TaskStatus.IN_PROGRESS}>진행중</option>
                    <option value={TaskStatus.COMPLETED}>완료</option>
                    <option value={TaskStatus.ON_HOLD}>보류</option>
                  </select>
                </div>
              </div>
              
              {/* 진행률 바 */}
              {task.completionRate > 0 && (
                <div className="mt-3">
                  <div className="flex items-center justify-between text-sm mb-1">
                    <span className="text-gray-600">진행률</span>
                    <span className="font-medium">{task.completionRate}%</span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="h-2 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 transition-all duration-300"
                      style={{ width: `${task.completionRate}%` }}
                    />
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>
        
        {tasks.length === 0 && (
          <div className="p-8 text-center">
            <CalendarDaysIcon className="w-16 h-16 text-gray-400 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-gray-600 mb-1">오늘 할 일이 없습니다</h3>
            <p className="text-gray-500 text-sm">수집함에서 새로운 업무를 계획해보세요!</p>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/workflow/PlanWorkflowModal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { 
  ArrowRightIcon,
  CheckCircleIcon,
  FolderPlusIcon,
  FlagIcon,
  ClipboardDocumentIcon,
  XMarkIcon,
  CalendarIcon
} from '@heroicons/react/24/outline'
import { InboxItem, InboxItemStatus } from '@/shared/types/inbox.types'

interface PlanWorkflowModalProps {
  isOpen: boolean
  onClose: () => void
  inboxItem: InboxItem
  onProcessComplete: (processedItem: InboxItem) => void
}

// 처리 유형 옵션
const processOptions = [
  {
    type: 'task',
    label: '업무로 전환',
    icon: ClipboardDocumentIcon,
    color: 'blue',
    description: '즉시 실행 가능한 단일 업무'
  },
  {
    type: 'project',
    label: '프로젝트로 전환',
    icon: FolderPlusIcon,
    color: 'green',
    description: '여러 업무로 구성된 프로젝트'
  },
  {
    type: 'goal',
    label: '목표로 전환',
    icon: FlagIcon,
    color: 'purple',
    description: '장기적인 목표나 비전'
  },
  {
    type: 'defer',
    label: '미루기',
    icon: CalendarIcon,
    color: 'yellow',
    description: '나중에 다시 검토'
  }
]

export default function PlanWorkflowModal({
  isOpen,
  onClose,
  inboxItem,
  onProcessComplete
}: PlanWorkflowModalProps) {
  const [selectedOption, setSelectedOption] = useState<string>('')
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [priority, setPriority] = useState<'low' | 'medium' | 'high' | 'urgent'>('medium')
  const [scheduledDate, setScheduledDate] = useState('')
  const [isProcessing, setIsProcessing] = useState(false)

  useEffect(() => {
    if (isOpen && inboxItem) {
      setTitle(inboxItem.title)
      setDescription(inboxItem.content || '')
      setSelectedOption('')
      setPriority('medium')
      setScheduledDate('')
    }
  }, [isOpen, inboxItem])

  const handleProcess = async () => {
    if (!selectedOption || !title.trim()) return

    setIsProcessing(true)

    try {
      // 실제로는 API 호출
      await new Promise(resolve => setTimeout(resolve, 1000))

      const processedItem: InboxItem = {
        ...inboxItem,
        status: selectedOption === 'defer' ? InboxItemStatus.DEFERRED : InboxItemStatus.ORGANIZED,
        processedInto: selectedOption === 'defer' ? undefined : {
          type: selectedOption as 'task' | 'project' | 'goal',
          id: `new-${selectedOption}-${Date.now()}`,
          title: title
        },
        processedAt: new Date().toISOString(),
        scheduledFor: scheduledDate ? new Date(scheduledDate).toISOString() : undefined,
        updatedAt: new Date().toISOString()
      }

      onProcessComplete(processedItem)
      onClose()
    } catch (error) {
      console.error('처리 중 오류:', error)
    } finally {
      setIsProcessing(false)
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="bg-white rounded-lg max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
        {/* 헤더 */}
        <div className="flex items-center justify-between p-6 border-b">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 rounded-lg bg-amber-100 flex items-center justify-center">
              <ArrowRightIcon className="w-5 h-5 text-amber-600" />
            </div>
            <div>
              <h2 className="text-lg font-semibold text-gray-900">항목 계획하기</h2>
              <p className="text-sm text-gray-500">수집된 항목을 적절한 형태로 변환합니다</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-gray-100 rounded-lg"
          >
            <XMarkIcon className="w-5 h-5" />
          </button>
        </div>

        {/* 원본 항목 정보 */}
        <div className="p-6 bg-gray-50 border-b">
          <h3 className="font-medium text-gray-900 mb-2">원본 항목</h3>
          <div className="bg-white rounded-lg p-4 border">
            <h4 className="font-medium text-gray-900 mb-1">{inboxItem.title}</h4>
            {inboxItem.content && (
              <p className="text-sm text-gray-600">{inboxItem.content}</p>
            )}
            <div className="flex items-center space-x-4 mt-3 text-xs text-gray-500">
              <span>{new Date(inboxItem.createdAt).toLocaleDateString('ko-KR')}</span>
              <span className="capitalize">{inboxItem.source.replace('_', ' ')}</span>
              {inboxItem.tags.length > 0 && (
                <span>{inboxItem.tags.join(', ')}</span>
              )}
            </div>
          </div>
        </div>

        {/* 처리 옵션 선택 */}
        <div className="p-6 border-b">
          <h3 className="font-medium text-gray-900 mb-4">처리 방법 선택</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {processOptions.map((option) => {
              const Icon = option.icon
              const isSelected = selectedOption === option.type
              
              return (
                <button
                  key={option.type}
                  onClick={() => setSelectedOption(option.type)}
                  className={`p-4 rounded-lg border-2 text-left transition-all ${
                    isSelected
                      ? 'border-blue-500 bg-blue-50'
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <div className="flex items-start space-x-3">
                    <div className={`w-8 h-8 rounded-lg flex items-center justify-center ${
                      option.color === 'blue' ? 'bg-blue-100 text-blue-600' :
                      option.color === 'green' ? 'bg-green-100 text-green-600' :
                      option.color === 'purple' ? 'bg-purple-100 text-purple-600' :
                      'bg-yellow-100 text-yellow-600'
                    }`}>
                      <Icon className="w-4 h-4" />
                    </div>
                    <div>
                      <h4 className="font-medium text-gray-900">{option.label}</h4>
                      <p className="text-sm text-gray-500 mt-1">{option.description}</p>
                    </div>
                  </div>
                </button>
              )
            })}
          </div>
        </div>

        {/* 세부 정보 입력 */}
        {selectedOption && selectedOption !== 'defer' && (
          <div className="p-6 border-b space-y-4">
            <h3 className="font-medium text-gray-900">세부 정보</h3>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                제목
              </label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="명확한 제목을 입력하세요"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                설명
              </label>
              <textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                rows={3}
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                placeholder="자세한 설명을 입력하세요"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                우선순위
              </label>
              <select
                value={priority}
                onChange={(e) => setPriority(e.target.value as any)}
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              >
                <option value="low">낮음</option>
                <option value="medium">보통</option>
                <option value="high">높음</option>
                <option value="urgent">긴급</option>
              </select>
            </div>
          </div>
        )}

        {/* 미루기 옵션 */}
        {selectedOption === 'defer' && (
          <div className="p-6 border-b">
            <h3 className="font-medium text-gray-900 mb-4">언제 다시 검토할까요?</h3>
            <input
              type="date"
              value={scheduledDate}
              onChange={(e) => setScheduledDate(e.target.value)}
              min={new Date().toISOString().split('T')[0]}
              className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
        )}

        {/* 액션 버튼 */}
        <div className="flex justify-end space-x-3 p-6">
          <button
            onClick={onClose}
            disabled={isProcessing}
            className="px-4 py-2 text-gray-600 hover:text-gray-800 disabled:opacity-50"
          >
            취소
          </button>
          <button
            onClick={handleProcess}
            disabled={!selectedOption || isProcessing || (selectedOption !== 'defer' && !title.trim())}
            className="flex items-center space-x-2 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isProcessing ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                <span>처리 중...</span>
              </>
            ) : (
              <>
                <CheckCircleIcon className="w-4 h-4" />
                <span>처리 완료</span>
              </>
            )}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/workflow/ReviewWorkflowDashboard.tsx">
'use client'

import { useState, useEffect } from 'react'
import { 
  ChartBarIcon,
  ClockIcon,
  ArrowTrendingUpIcon,
  ArrowTrendingDownIcon,
  CalendarIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  LightBulbIcon
} from '@heroicons/react/24/outline'

// 목업 주간 리뷰 데이터
interface WeeklyReview {
  weekRange: string
  totalTasks: number
  completedTasks: number
  totalHours: number
  focusTime: number
  completionRate: number
  productivity: number
  goals: {
    id: string
    title: string
    progress: number
    target: number
    status: 'on_track' | 'behind' | 'ahead'
  }[]
  insights: {
    type: 'positive' | 'warning' | 'suggestion'
    title: string
    description: string
  }[]
  topCategories: {
    category: string
    hours: number
    tasks: number
  }[]
}

const mockWeeklyReview: WeeklyReview = {
  weekRange: '1월 22일 - 1월 28일',
  totalTasks: 18,
  completedTasks: 14,
  totalHours: 32.5,
  focusTime: 18.2,
  completionRate: 78,
  productivity: 85,
  goals: [
    {
      id: '1',
      title: '워클리 플랫폼 완성',
      progress: 75,
      target: 80,
      status: 'behind'
    },
    {
      id: '2',
      title: '개인 역량 강화',
      progress: 48,
      target: 45,
      status: 'ahead'
    }
  ],
  insights: [
    {
      type: 'positive',
      title: '집중 시간 증가',
      description: '이번 주 집중 모드 사용 시간이 지난 주 대비 25% 증가했습니다.'
    },
    {
      type: 'warning',
      title: '마감일 지연 업무',
      description: '3개의 업무가 예정된 마감일을 넘겼습니다. 우선순위를 재검토해보세요.'
    },
    {
      type: 'suggestion',
      title: '오후 생산성 향상 필요',
      description: '오후 시간대 업무 완료율이 60%로 낮습니다. 오후 루틴을 개선해보세요.'
    }
  ],
  topCategories: [
    { category: '개발', hours: 15.5, tasks: 8 },
    { category: '회의', hours: 6.2, tasks: 4 },
    { category: '분석', hours: 4.8, tasks: 3 },
    { category: '문서작업', hours: 3.5, tasks: 2 },
    { category: '학습', hours: 2.5, tasks: 1 }
  ]
}

interface ReviewWorkflowDashboardProps {
  className?: string
}

export default function ReviewWorkflowDashboard({ className = '' }: ReviewWorkflowDashboardProps) {
  const [reviewData, setReviewData] = useState<WeeklyReview>(mockWeeklyReview)
  const [selectedPeriod, setSelectedPeriod] = useState('this_week')
  const [isLoading, setIsLoading] = useState(false)

  const loadReviewData = async (period: string) => {
    setIsLoading(true)
    // 실제로는 API 호출
    await new Promise(resolve => setTimeout(resolve, 1000))
    setIsLoading(false)
  }

  useEffect(() => {
    loadReviewData(selectedPeriod)
  }, [selectedPeriod])

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'ahead': return 'text-green-600 bg-green-100'
      case 'on_track': return 'text-blue-600 bg-blue-100'
      case 'behind': return 'text-red-600 bg-red-100'
      default: return 'text-gray-600 bg-gray-100'
    }
  }

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'ahead': return '앞서고 있음'
      case 'on_track': return '순조롭게 진행'
      case 'behind': return '지연됨'
      default: return '알 수 없음'
    }
  }

  const getInsightIcon = (type: string) => {
    switch (type) {
      case 'positive': return <ArrowTrendingUpIcon className="w-5 h-5 text-green-600" />
      case 'warning': return <ExclamationTriangleIcon className="w-5 h-5 text-red-600" />
      case 'suggestion': return <LightBulbIcon className="w-5 h-5 text-amber-600" />
      default: return <ChartBarIcon className="w-5 h-5 text-gray-600" />
    }
  }

  const getInsightBgColor = (type: string) => {
    switch (type) {
      case 'positive': return 'bg-green-50 border-green-200'
      case 'warning': return 'bg-red-50 border-red-200'
      case 'suggestion': return 'bg-amber-50 border-amber-200'
      default: return 'bg-gray-50 border-gray-200'
    }
  }

  return (
    <div className={`space-y-6 ${className}`}>
      {/* 헤더 */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">주간 리뷰</h1>
          <p className="text-gray-600 mt-1">{reviewData.weekRange}</p>
        </div>
        <select
          value={selectedPeriod}
          onChange={(e) => setSelectedPeriod(e.target.value)}
          className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        >
          <option value="this_week">이번 주</option>
          <option value="last_week">지난 주</option>
          <option value="this_month">이번 달</option>
          <option value="last_month">지난 달</option>
        </select>
      </div>

      {isLoading ? (
        <div className="flex justify-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      ) : (
        <>
          {/* 주요 지표 */}
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div className="bg-white rounded-lg p-6 border">
              <div className="flex items-center space-x-2 mb-2">
                <CheckCircleIcon className="w-5 h-5 text-green-600" />
                <span className="text-sm text-gray-600">완료율</span>
              </div>
              <div className="text-3xl font-bold text-gray-900">{reviewData.completionRate}%</div>
              <p className="text-sm text-gray-500 mt-1">
                {reviewData.completedTasks}/{reviewData.totalTasks} 업무
              </p>
            </div>

            <div className="bg-white rounded-lg p-6 border">
              <div className="flex items-center space-x-2 mb-2">
                <ClockIcon className="w-5 h-5 text-blue-600" />
                <span className="text-sm text-gray-600">총 작업 시간</span>
              </div>
              <div className="text-3xl font-bold text-gray-900">{reviewData.totalHours}h</div>
              <p className="text-sm text-gray-500 mt-1">
                집중 시간: {reviewData.focusTime}h
              </p>
            </div>

            <div className="bg-white rounded-lg p-6 border">
              <div className="flex items-center space-x-2 mb-2">
                <ArrowTrendingUpIcon className="w-5 h-5 text-purple-600" />
                <span className="text-sm text-gray-600">생산성 지수</span>
              </div>
              <div className="text-3xl font-bold text-gray-900">{reviewData.productivity}</div>
              <p className="text-sm text-gray-500 mt-1">
                지난 주 대비 +5
              </p>
            </div>

            <div className="bg-white rounded-lg p-6 border">
              <div className="flex items-center space-x-2 mb-2">
                <CalendarIcon className="w-5 h-5 text-amber-600" />
                <span className="text-sm text-gray-600">평균 일일 시간</span>
              </div>
              <div className="text-3xl font-bold text-gray-900">{(reviewData.totalHours / 7).toFixed(1)}h</div>
              <p className="text-sm text-gray-500 mt-1">
                목표: 6h/일
              </p>
            </div>
          </div>

          {/* 목표 진행 상황 */}
          <div className="bg-white rounded-lg border">
            <div className="p-6 border-b">
              <h2 className="text-lg font-semibold text-gray-900">목표 진행 상황</h2>
            </div>
            <div className="p-6 space-y-4">
              {reviewData.goals.map((goal) => (
                <div key={goal.id} className="border rounded-lg p-4">
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="font-medium text-gray-900">{goal.title}</h3>
                    <span className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(goal.status)}`}>
                      {getStatusLabel(goal.status)}
                    </span>
                  </div>
                  <div className="flex items-center justify-between text-sm mb-2">
                    <span className="text-gray-600">진행률</span>
                    <span className="font-medium">{goal.progress}% / {goal.target}%</span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full transition-all duration-300 ${
                        goal.status === 'ahead' ? 'bg-green-500' :
                        goal.status === 'on_track' ? 'bg-blue-500' :
                        'bg-red-500'
                      }`}
                      style={{ width: `${(goal.progress / goal.target) * 100}%` }}
                    />
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* 인사이트 */}
          <div className="bg-white rounded-lg border">
            <div className="p-6 border-b">
              <h2 className="text-lg font-semibold text-gray-900">주간 인사이트</h2>
            </div>
            <div className="p-6 space-y-4">
              {reviewData.insights.map((insight, index) => (
                <div key={index} className={`border rounded-lg p-4 ${getInsightBgColor(insight.type)}`}>
                  <div className="flex items-start space-x-3">
                    {getInsightIcon(insight.type)}
                    <div>
                      <h3 className="font-medium text-gray-900 mb-1">{insight.title}</h3>
                      <p className="text-sm text-gray-600">{insight.description}</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* 카테고리별 시간 분석 */}
          <div className="bg-white rounded-lg border">
            <div className="p-6 border-b">
              <h2 className="text-lg font-semibold text-gray-900">카테고리별 시간 분석</h2>
            </div>
            <div className="p-6">
              <div className="space-y-4">
                {reviewData.topCategories.map((category, index) => (
                  <div key={category.category} className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      <div className="w-8 h-8 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 flex items-center justify-center text-white text-sm font-medium">
                        {index + 1}
                      </div>
                      <div>
                        <h3 className="font-medium text-gray-900">{category.category}</h3>
                        <p className="text-sm text-gray-500">{category.tasks}개 업무</p>
                      </div>
                    </div>
                    <div className="text-right">
                      <div className="font-medium text-gray-900">{category.hours}h</div>
                      <div className="text-sm text-gray-500">
                        {Math.round((category.hours / reviewData.totalHours) * 100)}%
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* 다음 주 계획 */}
          <div className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border border-blue-200">
            <div className="p-6">
              <h2 className="text-lg font-semibold text-gray-900 mb-4">다음 주 개선 계획</h2>
              <div className="space-y-3">
                <div className="flex items-start space-x-3">
                  <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-sm font-medium">
                    1
                  </div>
                  <p className="text-sm text-gray-700">
                    오후 시간대 생산성 향상을 위해 15분 휴식 후 집중 모드 활용
                  </p>
                </div>
                <div className="flex items-start space-x-3">
                  <div className="w-6 h-6 rounded-full bg-purple-500 flex items-center justify-center text-white text-sm font-medium">
                    2
                  </div>
                  <p className="text-sm text-gray-700">
                    마감일 지연 방지를 위해 업무 우선순위 매일 아침 재검토
                  </p>
                </div>
                <div className="flex items-start space-x-3">
                  <div className="w-6 h-6 rounded-full bg-green-500 flex items-center justify-center text-white text-sm font-medium">
                    3
                  </div>
                  <p className="text-sm text-gray-700">
                    목표 달성률 향상을 위해 주간 중간 점검 스케줄 추가
                  </p>
                </div>
              </div>
            </div>
          </div>
        </>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/hooks/useDeviceType.ts">
'use client'

import { useState, useEffect } from 'react'

export type DeviceType = 'mobile' | 'tablet' | 'desktop'

export function useDeviceType(): DeviceType {
  const [deviceType, setDeviceType] = useState<DeviceType>('desktop')

  useEffect(() => {
    const checkDeviceType = () => {
      // 터치 지원 여부 확인
      const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0

      if (!hasTouchScreen) {
        setDeviceType('desktop')
        return
      }

      // 화면 크기로 모바일/태블릿 구분
      const width = window.innerWidth
      const height = window.innerHeight
      const minDimension = Math.min(width, height)
      const maxDimension = Math.max(width, height)

      // 모바일: 작은 쪽이 480px 미만
      if (minDimension < 480) {
        setDeviceType('mobile')
      }
      // 태블릿: 작은 쪽이 480px 이상, 큰 쪽이 1024px 미만
      else if (maxDimension < 1024) {
        setDeviceType('tablet')
      }
      // 데스크톱: 그 외 (터치 지원 데스크톱 포함)
      else {
        setDeviceType('desktop')
      }
    }

    // 초기 감지
    checkDeviceType()

    // 리사이즈 이벤트 리스너
    window.addEventListener('resize', checkDeviceType)
    
    return () => {
      window.removeEventListener('resize', checkDeviceType)
    }
  }, [])

  return deviceType
}

export function useIsMobile(): boolean {
  const deviceType = useDeviceType()
  return deviceType === 'mobile'
}

export function useIsTouch(): boolean {
  const deviceType = useDeviceType()
  return deviceType === 'mobile' || deviceType === 'tablet'
}
</file>

<file path="frontend/src/hooks/useScrollVisibility.ts">
'use client'

import { useEffect, useRef, useCallback } from 'react'

interface UseScrollVisibilityOptions {
  hideDelay?: number
  showOnHover?: boolean
}

export function useScrollVisibility(options: UseScrollVisibilityOptions = {}) {
  const { hideDelay = 1000, showOnHover = true } = options
  const elementRef = useRef<HTMLElement>(null)
  const timeoutRef = useRef<NodeJS.Timeout>()

  const showScrollbar = useCallback(() => {
    if (elementRef.current) {
      elementRef.current.classList.add('scrolling')
    }
  }, [])

  const hideScrollbar = useCallback(() => {
    if (elementRef.current) {
      elementRef.current.classList.remove('scrolling')
    }
  }, [])

  const handleScroll = useCallback(() => {
    showScrollbar()
    
    // 기존 타이머 정리
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }
    
    // 새 타이머 설정
    timeoutRef.current = setTimeout(() => {
      hideScrollbar()
    }, hideDelay)
  }, [showScrollbar, hideScrollbar, hideDelay])

  const handleMouseEnter = useCallback(() => {
    if (showOnHover) {
      showScrollbar()
    }
  }, [showScrollbar, showOnHover])

  const handleMouseLeave = useCallback(() => {
    if (showOnHover) {
      // 스크롤 중이 아닐 때만 숨김
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
      timeoutRef.current = setTimeout(() => {
        hideScrollbar()
      }, 300)
    }
  }, [hideScrollbar, showOnHover])

  useEffect(() => {
    const element = elementRef.current
    if (!element) return

    element.addEventListener('scroll', handleScroll, { passive: true })
    
    if (showOnHover) {
      element.addEventListener('mouseenter', handleMouseEnter)
      element.addEventListener('mouseleave', handleMouseLeave)
    }

    return () => {
      element.removeEventListener('scroll', handleScroll)
      if (showOnHover) {
        element.removeEventListener('mouseenter', handleMouseEnter)
        element.removeEventListener('mouseleave', handleMouseLeave)
      }
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [handleScroll, handleMouseEnter, handleMouseLeave, showOnHover])

  return { elementRef, showScrollbar, hideScrollbar }
}
</file>

<file path="frontend/src/lib/api/admin-api.ts">
/**
 * 어드민 패널 API 클라이언트
 * 관리자 전용 API 호출을 담당하는 모듈
 */

import { ApiResponse } from '@workly/shared';

// 기본 API 설정
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
const ADMIN_API_PREFIX = '/api/admin';

// 에러 타입 정의
export class AdminApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message);
    this.name = 'AdminApiError';
  }
}

// API 응답 타입
interface AdminApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// HTTP 메서드 타입
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

/**
 * API 요청을 보내는 기본 함수
 */
async function apiRequest<T = any>(
  endpoint: string,
  options: {
    method?: HttpMethod;
    data?: any;
    params?: Record<string, string | number>;
    headers?: Record<string, string>;
  } = {}
): Promise<AdminApiResponse<T>> {
  const {
    method = 'GET',
    data,
    params,
    headers: customHeaders = {},
  } = options;

  // URL 구성
  const url = new URL(`${API_BASE_URL}${ADMIN_API_PREFIX}${endpoint}`);
  
  // 쿼리 파라미터 추가
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.append(key, String(value));
    });
  }

  // 헤더 설정
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...customHeaders,
  };

  // 인증 토큰 추가 (localStorage에서 가져옴)
  const token = localStorage.getItem('access_token');
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }

  // 요청 옵션 구성
  const requestOptions: RequestInit = {
    method,
    headers,
    credentials: 'include',
  };

  // POST, PUT, PATCH 요청인 경우 body 추가
  if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
    requestOptions.body = JSON.stringify(data);
  }

  try {
    const response = await fetch(url.toString(), requestOptions);
    
    // 응답이 JSON이 아닐 수 있으므로 체크
    const contentType = response.headers.get('content-type');
    let responseData;

    if (contentType && contentType.includes('application/json')) {
      responseData = await response.json();
    } else {
      responseData = { success: false, error: await response.text() };
    }

    // HTTP 에러 상태 체크
    if (!response.ok) {
      throw new AdminApiError(
        responseData?.error || responseData?.message || `HTTP ${response.status}`,
        response.status,
        responseData?.code
      );
    }

    return responseData;
  } catch (error) {
    if (error instanceof AdminApiError) {
      throw error;
    }

    // 네트워크 에러 등 기타 에러
    throw new AdminApiError(
      error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다',
      0
    );
  }
}

// =============================================================================
// 대시보드 API
// =============================================================================

export const dashboardApi = {
  /**
   * 대시보드 통계 및 정보 조회
   */
  async getDashboard() {
    return apiRequest('/dashboard');
  },

  /**
   * 관리자 프로필 조회
   */
  async getProfile() {
    return apiRequest('/profile');
  },
};

// =============================================================================
// 사용자 관리 API
// =============================================================================

export interface UserFilters {
  page?: number;
  limit?: number;
  search?: string;
  role?: string;
  status?: string;
}

export interface UpdateUserRoleRequest {
  role: string;
  permissions: string[];
}

export const usersApi = {
  /**
   * 사용자 목록 조회
   */
  async getUsers(filters: UserFilters = {}) {
    return apiRequest('/users', {
      params: filters as Record<string, string | number>,
    });
  },

  /**
   * 특정 사용자 조회
   */
  async getUser(userId: string) {
    return apiRequest(`/users/${userId}`);
  },

  /**
   * 사용자 역할 및 권한 변경
   */
  async updateUserRole(userId: string, data: UpdateUserRoleRequest) {
    return apiRequest(`/users/${userId}/role`, {
      method: 'PUT',
      data,
    });
  },

  /**
   * 사용자 삭제
   */
  async deleteUser(userId: string) {
    return apiRequest(`/users/${userId}`, {
      method: 'DELETE',
    });
  },
};

// =============================================================================
// 프로젝트 관리 API
// =============================================================================

export interface ProjectFilters {
  page?: number;
  limit?: number;
  search?: string;
  status?: string;
}

export const projectsApi = {
  /**
   * 프로젝트 목록 조회
   */
  async getProjects(filters: ProjectFilters = {}) {
    return apiRequest('/projects', {
      params: filters as Record<string, string | number>,
    });
  },

  /**
   * 특정 프로젝트 조회
   */
  async getProject(projectId: string) {
    return apiRequest(`/projects/${projectId}`);
  },

  /**
   * 프로젝트 삭제
   */
  async deleteProject(projectId: string) {
    return apiRequest(`/projects/${projectId}`, {
      method: 'DELETE',
    });
  },
};

// =============================================================================
// 감사 로그 API
// =============================================================================

export interface AuditLogFilters {
  page?: number;
  limit?: number;
  adminId?: string;
  action?: string;
  targetType?: string;
  startDate?: string;
  endDate?: string;
  success?: boolean;
}

export const auditLogsApi = {
  /**
   * 감사 로그 목록 조회
   */
  async getAuditLogs(filters: AuditLogFilters = {}) {
    const params: Record<string, string | number> = {};
    
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== '') {
        params[key] = String(value);
      }
    });

    return apiRequest('/audit-logs', { params });
  },

  /**
   * 최근 감사 로그 조회
   */
  async getRecentAuditLogs(adminId?: string, hours: number = 24) {
    const params: Record<string, string | number> = { hours };
    if (adminId) {
      params.adminId = adminId;
    }

    return apiRequest('/audit-logs/recent', { params });
  },
};

// =============================================================================
// 시스템 설정 API
// =============================================================================

export interface SystemSettingsUpdateRequest {
  maintenanceMode?: boolean;
  registrationEnabled?: boolean;
  maxUsersPerProject?: number;
  maxProjectsPerUser?: number;
  emailNotifications?: boolean;
  [key: string]: any;
}

export const settingsApi = {
  /**
   * 시스템 설정 조회
   */
  async getSettings() {
    return apiRequest('/settings');
  },

  /**
   * 시스템 설정 업데이트
   */
  async updateSettings(data: SystemSettingsUpdateRequest) {
    return apiRequest('/settings', {
      method: 'PUT',
      data,
    });
  },
};

// =============================================================================
// 통합 어드민 API 객체
// =============================================================================

export const adminApi = {
  dashboard: dashboardApi,
  users: usersApi,
  projects: projectsApi,
  auditLogs: auditLogsApi,
  settings: settingsApi,
};

// 기본 내보내기
export default adminApi;
</file>

<file path="frontend/src/lib/api/tasks.ts">
/**
 * Task API 클라이언트
 */

import { api } from '../api';
import type {
  Task,
  CreateTaskDto,
  UpdateTaskDto,
  TaskQueryDto,
  PaginatedResponse,
  GTDContext,
  SmartFilter,
  TaskStatus,
  TaskPriority,
} from '../../types/task.types';

/**
 * 태스크 생성
 */
export const createTask = async (data: CreateTaskDto): Promise<Task> => {
  return api.post<Task>('/tasks', data);
};

/**
 * 태스크 목록 조회 (필터링, 정렬, 페이징 지원)
 */
export const getTasks = async (query?: TaskQueryDto): Promise<PaginatedResponse<Task>> => {
  const params = new URLSearchParams();
  
  if (query) {
    Object.entries(query).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        if (Array.isArray(value)) {
          value.forEach(v => params.append(key, v.toString()));
        } else {
          params.append(key, value.toString());
        }
      }
    });
  }

  const queryString = params.toString();
  const endpoint = queryString ? `/tasks?${queryString}` : '/tasks';
  
  return api.get<PaginatedResponse<Task>>(endpoint);
};

/**
 * 특정 태스크 조회
 */
export const getTask = async (id: string): Promise<Task> => {
  return api.get<Task>(`/tasks/${id}`);
};

/**
 * 태스크 수정
 */
export const updateTask = async (id: string, data: UpdateTaskDto): Promise<Task> => {
  return api.put<Task>(`/tasks/${id}`, data);
};

/**
 * 태스크 삭제
 */
export const deleteTask = async (id: string): Promise<void> => {
  return api.delete<void>(`/tasks/${id}`);
};

/**
 * 태스크 상태 변경
 */
export const updateTaskStatus = async (id: string, status: TaskStatus): Promise<Task> => {
  return api.put<Task>(`/tasks/${id}/status?status=${status}`);
};

/**
 * 태스크 우선순위 변경
 */
export const updateTaskPriority = async (id: string, priority: TaskPriority): Promise<Task> => {
  return api.put<Task>(`/tasks/${id}/priority?priority=${priority}`);
};

/**
 * 태스크 진행률 업데이트
 */
export const updateTaskProgress = async (id: string, progress: number): Promise<Task> => {
  return api.put<Task>(`/tasks/${id}/progress?progress=${progress}`);
};

/**
 * 내 태스크 조회 (GTD 컨텍스트별)
 */
export const getMyTasks = async (context?: GTDContext): Promise<Task[]> => {
  const endpoint = context ? `/tasks/my/${context}` : '/tasks/my';
  return api.get<Task[]>(endpoint);
};

/**
 * GTD 스마트 필터 기반 태스크 조회
 */
export const getSmartFilteredTasks = async (filter: SmartFilter): Promise<Task[]> => {
  return api.get<Task[]>(`/tasks/filter/${filter}`);
};

/**
 * 오늘 할 일 조회
 */
export const getTodayTasks = async (): Promise<Task[]> => {
  return getSmartFilteredTasks('today');
};

/**
 * 완료된 태스크 조회
 */
export const getCompletedTasks = async (): Promise<Task[]> => {
  return getSmartFilteredTasks('completed');
};

/**
 * 모든 태스크 조회
 */
export const getAllTasks = async (): Promise<Task[]> => {
  return getSmartFilteredTasks('all');
};

/**
 * 태스크 완료 처리
 */
export const completeTask = async (id: string): Promise<Task> => {
  return updateTaskStatus(id, TaskStatus.DONE);
};

/**
 * 태스크 시작
 */
export const startTask = async (id: string): Promise<Task> => {
  return updateTaskStatus(id, TaskStatus.IN_PROGRESS);
};

/**
 * 태스크 차단
 */
export const blockTask = async (id: string): Promise<Task> => {
  return updateTaskStatus(id, TaskStatus.BLOCKED);
};

/**
 * 태스크 취소
 */
export const cancelTask = async (id: string): Promise<Task> => {
  return updateTaskStatus(id, TaskStatus.CANCELLED);
};

/**
 * 태스크 검토 요청
 */
export const requestTaskReview = async (id: string): Promise<Task> => {
  return updateTaskStatus(id, TaskStatus.IN_REVIEW);
};

/**
 * 태스크 할당
 */
export const assignTask = async (id: string, assigneeId: string): Promise<Task> => {
  return updateTask(id, { assigneeId } as UpdateTaskDto);
};

/**
 * 태스크 할당 해제
 */
export const unassignTask = async (id: string): Promise<Task> => {
  return updateTask(id, { assigneeId: undefined } as UpdateTaskDto);
};

/**
 * 태스크 마감일 설정
 */
export const setTaskDueDate = async (id: string, dueDate: string): Promise<Task> => {
  return updateTask(id, { dueDate });
};

/**
 * 태스크 마감일 제거
 */
export const clearTaskDueDate = async (id: string): Promise<Task> => {
  return updateTask(id, { dueDate: undefined });
};

/**
 * 태스크 태그 추가
 */
export const addTaskTag = async (id: string, tag: string): Promise<Task> => {
  const task = await getTask(id);
  const newTags = [...(task.tags || []), tag];
  return updateTask(id, { tags: newTags });
};

/**
 * 태스크 태그 제거
 */
export const removeTaskTag = async (id: string, tag: string): Promise<Task> => {
  const task = await getTask(id);
  const newTags = (task.tags || []).filter(t => t !== tag);
  return updateTask(id, { tags: newTags });
};

/**
 * 서브태스크 생성
 */
export const createSubtask = async (parentTaskId: string, data: Omit<CreateTaskDto, 'parentTaskId'>): Promise<Task> => {
  return createTask({ ...data, parentTaskId });
};

/**
 * 부모 태스크의 서브태스크 조회
 */
export const getSubtasks = async (parentTaskId: string): Promise<Task[]> => {
  return api.get<Task[]>(`/tasks?parentTaskId=${parentTaskId}&includeSubtasks=true`);
};

/**
 * 프로젝트의 태스크 조회
 */
export const getProjectTasks = async (projectId: string, query?: Omit<TaskQueryDto, 'projectId'>): Promise<PaginatedResponse<Task>> => {
  return getTasks({ ...query, projectId });
};

/**
 * 담당자의 태스크 조회
 */
export const getAssigneeTasks = async (assigneeId: string, query?: Omit<TaskQueryDto, 'assigneeId'>): Promise<PaginatedResponse<Task>> => {
  return getTasks({ ...query, assigneeId });
};

/**
 * 태스크 검색
 */
export const searchTasks = async (searchTerm: string, filters?: Partial<TaskQueryDto>): Promise<PaginatedResponse<Task>> => {
  return getTasks({ ...filters, search: searchTerm });
};

/**
 * 연체된 태스크 조회
 */
export const getOverdueTasks = async (): Promise<Task[]> => {
  const today = new Date();
  const response = await getTasks({
    sortBy: 'dueDate',
    sortOrder: 'ASC',
    limit: 100 // 충분히 큰 수로 설정
  });
  
  return response.items.filter(task => {
    if (!task.dueDate || task.status === TaskStatus.DONE) return false;
    return new Date(task.dueDate) < today;
  });
};

/**
 * 곧 마감되는 태스크 조회 (24시간 이내)
 */
export const getUpcomingTasks = async (): Promise<Task[]> => {
  const now = new Date();
  const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
  
  const response = await getTasks({
    sortBy: 'dueDate',
    sortOrder: 'ASC',
    limit: 100
  });
  
  return response.items.filter(task => {
    if (!task.dueDate || task.status === TaskStatus.DONE) return false;
    const dueDate = new Date(task.dueDate);
    return dueDate >= now && dueDate <= tomorrow;
  });
};

/**
 * 태스크 통계 조회
 */
export const getTaskStats = async (filters?: Partial<TaskQueryDto>) => {
  const response = await getTasks({ ...filters, limit: 1000 }); // 통계를 위해 큰 수로 설정
  const tasks = response.items;
  
  const today = new Date();
  
  return {
    total: tasks.length,
    todo: tasks.filter(t => t.status === TaskStatus.TODO).length,
    inProgress: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length,
    done: tasks.filter(t => t.status === TaskStatus.DONE).length,
    blocked: tasks.filter(t => t.status === TaskStatus.BLOCKED).length,
    overdue: tasks.filter(t => {
      if (!t.dueDate || t.status === TaskStatus.DONE) return false;
      return new Date(t.dueDate) < today;
    }).length,
  };
};
</file>

<file path="frontend/src/lib/api/workly-api.ts">
/**
 * 워클리 CPER 워크플로우 API 클라이언트
 * 실제 백엔드와 연동을 위한 API 인터페이스
 */

import { 
  WorklyTask, 
  HierarchyChoice, 
  CPERWorkflowData,
  TodayTasksOptimized,
  HierarchyAnalytics 
} from '@/shared/types/workly-core.types'
import { 
  InboxItem, 
  CreateInboxItemDto, 
  UpdateInboxItemDto,
  InboxQueryDto 
} from '@/shared/types/inbox.types'
import { Goal, CreateGoalDto, UpdateGoalDto } from '@/shared/types/goal.types'
import { Project, CreateProjectDto, UpdateProjectDto } from '@/types/project.types'

// API 기본 설정
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api'
const API_VERSION = 'v1'

class WorklyApiClient {
  private baseUrl: string
  private headers: HeadersInit

  constructor() {
    this.baseUrl = `${API_BASE_URL}/${API_VERSION}`
    this.headers = {
      'Content-Type': 'application/json',
    }
  }

  // 인증 토큰 설정
  setAuthToken(token: string) {
    this.headers = {
      ...this.headers,
      'Authorization': `Bearer ${token}`
    }
  }

  // HTTP 요청 헬퍼
  private async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`
    
    const config: RequestInit = {
      headers: this.headers,
      ...options
    }

    try {
      const response = await fetch(url, config)
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.status} ${response.statusText}`)
      }

      return await response.json()
    } catch (error) {
      console.error(`API 요청 실패: ${endpoint}`, error)
      throw error
    }
  }

  // GET 요청
  private get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' })
  }

  // POST 요청
  private post<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined
    })
  }

  // PUT 요청
  private put<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined
    })
  }

  // DELETE 요청
  private delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'DELETE' })
  }

  // PATCH 요청
  private patch<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined
    })
  }

  // =============================================================================
  // CPER 워크플로우 API
  // =============================================================================

  /**
   * 1단계: Capture - 수집함 관련 API
   */
  inbox = {
    // 빠른 수집
    quickCapture: (content: string): Promise<InboxItem> => {
      return this.post('/inbox/quick-capture', { content })
    },

    // 구조화된 수집
    create: (data: CreateInboxItemDto): Promise<InboxItem> => {
      return this.post('/inbox', data)
    },

    // 수집함 목록 조회
    list: (query?: InboxQueryDto): Promise<InboxItem[]> => {
      const params = query ? `?${new URLSearchParams(query as any).toString()}` : ''
      return this.get(`/inbox${params}`)
    },

    // 수집함 아이템 상세 조회
    getById: (id: string): Promise<InboxItem> => {
      return this.get(`/inbox/${id}`)
    },

    // 수집함 아이템 업데이트
    update: (id: string, data: UpdateInboxItemDto): Promise<InboxItem> => {
      return this.put(`/inbox/${id}`, data)
    },

    // 수집함 아이템 삭제
    delete: (id: string): Promise<void> => {
      return this.delete(`/inbox/${id}`)
    },

    // 일괄 처리
    batchProcess: (itemIds: string[], action: string, data?: any): Promise<void> => {
      return this.post('/inbox/batch-process', { itemIds, action, data })
    }
  }

  /**
   * 2단계: Plan - 계획 및 변환 API
   */
  planning = {
    // 수집함 아이템을 업무로 변환
    convertToTask: (inboxId: string, hierarchyChoice: HierarchyChoice): Promise<WorklyTask> => {
      return this.post(`/inbox/${inboxId}/convert-to-task`, { hierarchyChoice })
    },

    // 명확화 처리
    clarify: (inboxId: string, clarificationData: CPERWorkflowData['planningData']): Promise<InboxItem> => {
      return this.patch(`/inbox/${inboxId}/clarify`, clarificationData)
    },

    // 계층구조 변경
    changeHierarchy: (taskId: string, newHierarchy: HierarchyChoice): Promise<WorklyTask> => {
      return this.patch(`/tasks/${taskId}/hierarchy`, { hierarchyChoice: newHierarchy })
    },

    // 계층구조 분석
    analyzeHierarchy: (taskId: string): Promise<HierarchyAnalytics> => {
      return this.get(`/tasks/${taskId}/hierarchy-analysis`)
    }
  }

  /**
   * 3단계: Execute - 실행 관리 API
   */
  execution = {
    // 오늘 할 일 설정
    setTodayTasks: (taskIds: string[]): Promise<void> => {
      return this.post('/tasks/set-today', { taskIds })
    },

    // 집중 업무 설정
    setFocusedTask: (taskId: string): Promise<void> => {
      return this.post(`/tasks/${taskId}/set-focused`)
    },

    // 업무 시작
    startTask: (taskId: string): Promise<WorklyTask> => {
      return this.post(`/tasks/${taskId}/start`)
    },

    // 진행 상황 업데이트
    updateProgress: (taskId: string, progressNote: string, progressPercentage?: number): Promise<WorklyTask> => {
      return this.patch(`/tasks/${taskId}/progress`, { progressNote, progressPercentage })
    },

    // 업무 완료
    completeTask: (taskId: string): Promise<WorklyTask> => {
      return this.post(`/tasks/${taskId}/complete`)
    },

    // 오늘 할 일 최적화된 조회
    getTodayTasksOptimized: (): Promise<TodayTasksOptimized> => {
      return this.get('/tasks/today-optimized')
    }
  }

  /**
   * 4단계: Review - 검토 및 분석 API
   */
  review = {
    // 리뷰 데이터 추가
    addReview: (taskId: string, reviewData: CPERWorkflowData['reviewData']): Promise<WorklyTask> => {
      return this.post(`/tasks/${taskId}/review`, reviewData)
    },

    // 업무 인사이트 조회
    getTaskInsights: (taskId: string): Promise<HierarchyAnalytics> => {
      return this.get(`/tasks/${taskId}/insights`)
    },

    // 주간 리뷰 데이터
    getWeeklyReview: (startDate: string, endDate: string): Promise<any> => {
      return this.get(`/review/weekly?start=${startDate}&end=${endDate}`)
    },

    // 월간 리뷰 데이터
    getMonthlyReview: (year: number, month: number): Promise<any> => {
      return this.get(`/review/monthly?year=${year}&month=${month}`)
    }
  }

  // =============================================================================
  // 기본 엔티티 관리 API
  // =============================================================================

  /**
   * 업무(Tasks) API
   */
  tasks = {
    // 업무 목록 조회
    list: (query?: any): Promise<WorklyTask[]> => {
      const params = query ? `?${new URLSearchParams(query).toString()}` : ''
      return this.get(`/tasks${params}`)
    },

    // 업무 상세 조회
    getById: (id: string): Promise<WorklyTask> => {
      return this.get(`/tasks/${id}`)
    },

    // 업무 생성
    create: (data: any): Promise<WorklyTask> => {
      return this.post('/tasks', data)
    },

    // 업무 업데이트
    update: (id: string, data: any): Promise<WorklyTask> => {
      return this.put(`/tasks/${id}`, data)
    },

    // 업무 상세 정보 업데이트 (Notion 스타일 모달용)
    updateDetail: (id: string, data: any): Promise<WorklyTask> => {
      return this.patch(`/tasks/${id}/detail`, data)
    },

    // 업무 삭제
    delete: (id: string): Promise<void> => {
      return this.delete(`/tasks/${id}`)
    },

    // 업무 상태 변경
    updateStatus: (id: string, status: string): Promise<WorklyTask> => {
      return this.patch(`/tasks/${id}/status`, { status })
    }
  }

  /**
   * 프로젝트(Projects) API
   */
  projects = {
    // 프로젝트 목록 조회
    list: (query?: any): Promise<Project[]> => {
      const params = query ? `?${new URLSearchParams(query).toString()}` : ''
      return this.get(`/projects${params}`)
    },

    // 프로젝트 상세 조회
    getById: (id: string): Promise<Project> => {
      return this.get(`/projects/${id}`)
    },

    // 프로젝트 생성
    create: (data: CreateProjectDto): Promise<Project> => {
      return this.post('/projects', data)
    },

    // 프로젝트 업데이트
    update: (id: string, data: UpdateProjectDto): Promise<Project> => {
      return this.put(`/projects/${id}`, data)
    },

    // 프로젝트 삭제
    delete: (id: string): Promise<void> => {
      return this.delete(`/projects/${id}`)
    },

    // 프로젝트 멤버 관리
    addMember: (id: string, userId: string, role: string): Promise<void> => {
      return this.post(`/projects/${id}/members`, { userId, role })
    },

    removeMember: (id: string, userId: string): Promise<void> => {
      return this.delete(`/projects/${id}/members/${userId}`)
    }
  }

  /**
   * 목표(Goals) API
   */
  goals = {
    // 목표 목록 조회
    list: (query?: any): Promise<Goal[]> => {
      const params = query ? `?${new URLSearchParams(query).toString()}` : ''
      return this.get(`/goals${params}`)
    },

    // 목표 상세 조회
    getById: (id: string): Promise<Goal> => {
      return this.get(`/goals/${id}`)
    },

    // 목표 생성
    create: (data: CreateGoalDto): Promise<Goal> => {
      return this.post('/goals', data)
    },

    // 목표 업데이트
    update: (id: string, data: UpdateGoalDto): Promise<Goal> => {
      return this.put(`/goals/${id}`, data)
    },

    // 목표 삭제
    delete: (id: string): Promise<void> => {
      return this.delete(`/goals/${id}`)
    },

    // 목표 진행률 업데이트
    updateProgress: (id: string, progress: number): Promise<Goal> => {
      return this.patch(`/goals/${id}/progress`, { progress })
    }
  }

  // =============================================================================
  // 대시보드 및 분석 API
  // =============================================================================

  /**
   * 대시보드 API
   */
  dashboard = {
    // 홈 대시보드 데이터
    getHomeDashboard: (): Promise<any> => {
      return this.get('/dashboard/home')
    },

    // 프로젝트 대시보드 데이터
    getProjectDashboard: (projectId: string): Promise<any> => {
      return this.get(`/dashboard/project/${projectId}`)
    },

    // 목표 대시보드 데이터
    getGoalDashboard: (goalId: string): Promise<any> => {
      return this.get(`/dashboard/goal/${goalId}`)
    },

    // 개인 생산성 분석
    getProductivityAnalysis: (period: 'week' | 'month' | 'quarter'): Promise<any> => {
      return this.get(`/dashboard/productivity?period=${period}`)
    }
  }

  /**
   * 검색 API
   */
  search = {
    // 통합 검색
    global: (query: string, filters?: any): Promise<any> => {
      const params = new URLSearchParams({ q: query, ...filters })
      return this.get(`/search?${params.toString()}`)
    },

    // 업무 검색
    tasks: (query: string): Promise<WorklyTask[]> => {
      return this.get(`/search/tasks?q=${encodeURIComponent(query)}`)
    },

    // 프로젝트 검색
    projects: (query: string): Promise<Project[]> => {
      return this.get(`/search/projects?q=${encodeURIComponent(query)}`)
    },

    // 목표 검색
    goals: (query: string): Promise<Goal[]> => {
      return this.get(`/search/goals?q=${encodeURIComponent(query)}`)
    }
  }

  // =============================================================================
  // 사용자 및 설정 API
  // =============================================================================

  /**
   * 사용자 API
   */
  user = {
    // 현재 사용자 프로필
    getProfile: (): Promise<any> => {
      return this.get('/user/profile')
    },

    // 프로필 업데이트
    updateProfile: (data: any): Promise<any> => {
      return this.put('/user/profile', data)
    },

    // 사용자 설정
    getSettings: (): Promise<any> => {
      return this.get('/user/settings')
    },

    updateSettings: (data: any): Promise<any> => {
      return this.put('/user/settings', data)
    }
  }

  /**
   * 인증 API
   */
  auth = {
    // 로그인
    login: (email: string, password: string): Promise<{ token: string; user: any }> => {
      return this.post('/auth/login', { email, password })
    },

    // Google OAuth 로그인
    googleLogin: (idToken: string): Promise<{ token: string; user: any }> => {
      return this.post('/auth/google', { idToken })
    },

    // 로그아웃
    logout: (): Promise<void> => {
      return this.post('/auth/logout')
    },

    // 토큰 갱신
    refreshToken: (refreshToken: string): Promise<{ token: string }> => {
      return this.post('/auth/refresh', { refreshToken })
    },

    // 회원가입
    register: (data: any): Promise<{ token: string; user: any }> => {
      return this.post('/auth/register', data)
    }
  }
}

// 싱글톤 인스턴스 생성
export const worklyApi = new WorklyApiClient()

// 기본 export
export default worklyApi

// 타입 export
export type { 
  WorklyTask, 
  InboxItem, 
  Project, 
  Goal, 
  HierarchyChoice,
  CPERWorkflowData,
  TodayTasksOptimized,
  HierarchyAnalytics 
}
</file>

<file path="frontend/src/lib/hooks/useAdminApi.ts">
/**
 * 어드민 API를 위한 React 훅들
 * SWR을 활용한 데이터 페칭 및 상태 관리
 */

import { useState, useCallback } from 'react';
import useSWR, { mutate } from 'swr';
import { 
  adminApi, 
  AdminApiError, 
  UserFilters, 
  ProjectFilters, 
  AuditLogFilters,
  UpdateUserRoleRequest,
  SystemSettingsUpdateRequest,
} from '../api/admin-api';

// =============================================================================
// 기본 훅
// =============================================================================

/**
 * API 요청 상태 타입
 */
interface ApiState {
  loading: boolean;
  error: string | null;
}

/**
 * API 요청 상태를 관리하는 기본 훅
 */
export function useApiState(): [ApiState, (loading: boolean, error?: string | null) => void] {
  const [state, setState] = useState<ApiState>({ loading: false, error: null });

  const setApiState = useCallback((loading: boolean, error: string | null = null) => {
    setState({ loading, error });
  }, []);

  return [state, setApiState];
}

/**
 * 에러 처리 유틸리티
 */
export function handleApiError(error: unknown): string {
  if (error instanceof AdminApiError) {
    return error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return '알 수 없는 오류가 발생했습니다';
}

// =============================================================================
// 대시보드 훅
// =============================================================================

/**
 * 어드민 대시보드 데이터 훅
 */
export function useAdminDashboard() {
  const { data, error, isLoading, mutate } = useSWR(
    '/admin/dashboard',
    () => adminApi.dashboard.getDashboard()
  );

  return {
    dashboard: data?.data,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 관리자 프로필 훅
 */
export function useAdminProfile() {
  const { data, error, isLoading, mutate } = useSWR(
    '/admin/profile',
    () => adminApi.dashboard.getProfile()
  );

  return {
    profile: data?.data,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

// =============================================================================
// 사용자 관리 훅
// =============================================================================

/**
 * 사용자 목록 훅
 */
export function useUsers(filters: UserFilters = {}) {
  const key = `/admin/users?${new URLSearchParams(
    Object.entries(filters).reduce((acc, [key, value]) => {
      if (value !== undefined && value !== '') {
        acc[key] = String(value);
      }
      return acc;
    }, {} as Record<string, string>)
  )}`;

  const { data, error, isLoading, mutate } = useSWR(
    key,
    () => adminApi.users.getUsers(filters)
  );

  return {
    users: data?.data || [],
    pagination: data?.pagination,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 특정 사용자 훅
 */
export function useUser(userId: string) {
  const { data, error, isLoading, mutate } = useSWR(
    userId ? `/admin/users/${userId}` : null,
    () => adminApi.users.getUser(userId)
  );

  return {
    user: data?.data,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 사용자 관리 액션 훅
 */
export function useUserActions() {
  const [state, setApiState] = useApiState();

  const updateUserRole = useCallback(async (userId: string, data: UpdateUserRoleRequest) => {
    setApiState(true);
    try {
      const result = await adminApi.users.updateUserRole(userId, data);
      
      // 관련 캐시 무효화
      await mutate(`/admin/users/${userId}`);
      await mutate((key) => typeof key === 'string' && key.startsWith('/admin/users?'));
      
      setApiState(false);
      return result;
    } catch (error) {
      setApiState(false, handleApiError(error));
      throw error;
    }
  }, [setApiState]);

  const deleteUser = useCallback(async (userId: string) => {
    setApiState(true);
    try {
      const result = await adminApi.users.deleteUser(userId);
      
      // 관련 캐시 무효화
      await mutate((key) => typeof key === 'string' && key.startsWith('/admin/users'));
      
      setApiState(false);
      return result;
    } catch (error) {
      setApiState(false, handleApiError(error));
      throw error;
    }
  }, [setApiState]);

  return {
    updateUserRole,
    deleteUser,
    loading: state.loading,
    error: state.error,
  };
}

// =============================================================================
// 프로젝트 관리 훅
// =============================================================================

/**
 * 프로젝트 목록 훅
 */
export function useProjects(filters: ProjectFilters = {}) {
  const key = `/admin/projects?${new URLSearchParams(
    Object.entries(filters).reduce((acc, [key, value]) => {
      if (value !== undefined && value !== '') {
        acc[key] = String(value);
      }
      return acc;
    }, {} as Record<string, string>)
  )}`;

  const { data, error, isLoading, mutate } = useSWR(
    key,
    () => adminApi.projects.getProjects(filters)
  );

  return {
    projects: data?.data || [],
    pagination: data?.pagination,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 특정 프로젝트 훅
 */
export function useProject(projectId: string) {
  const { data, error, isLoading, mutate } = useSWR(
    projectId ? `/admin/projects/${projectId}` : null,
    () => adminApi.projects.getProject(projectId)
  );

  return {
    project: data?.data,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 프로젝트 관리 액션 훅
 */
export function useProjectActions() {
  const [state, setApiState] = useApiState();

  const deleteProject = useCallback(async (projectId: string) => {
    setApiState(true);
    try {
      const result = await adminApi.projects.deleteProject(projectId);
      
      // 관련 캐시 무효화
      await mutate((key) => typeof key === 'string' && key.startsWith('/admin/projects'));
      
      setApiState(false);
      return result;
    } catch (error) {
      setApiState(false, handleApiError(error));
      throw error;
    }
  }, [setApiState]);

  return {
    deleteProject,
    loading: state.loading,
    error: state.error,
  };
}

// =============================================================================
// 감사 로그 훅
// =============================================================================

/**
 * 감사 로그 목록 훅
 */
export function useAuditLogs(filters: AuditLogFilters = {}) {
  const key = `/admin/audit-logs?${new URLSearchParams(
    Object.entries(filters).reduce((acc, [key, value]) => {
      if (value !== undefined && value !== '') {
        acc[key] = String(value);
      }
      return acc;
    }, {} as Record<string, string>)
  )}`;

  const { data, error, isLoading, mutate } = useSWR(
    key,
    () => adminApi.auditLogs.getAuditLogs(filters)
  );

  return {
    auditLogs: data?.data || [],
    pagination: data?.pagination,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 최근 감사 로그 훅
 */
export function useRecentAuditLogs(adminId?: string, hours: number = 24) {
  const key = `/admin/audit-logs/recent?${new URLSearchParams({
    ...(adminId && { adminId }),
    hours: String(hours),
  })}`;

  const { data, error, isLoading, mutate } = useSWR(
    key,
    () => adminApi.auditLogs.getRecentAuditLogs(adminId, hours)
  );

  return {
    recentLogs: data?.data || [],
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

// =============================================================================
// 시스템 설정 훅
// =============================================================================

/**
 * 시스템 설정 훅
 */
export function useSystemSettings() {
  const { data, error, isLoading, mutate } = useSWR(
    '/admin/settings',
    () => adminApi.settings.getSettings()
  );

  return {
    settings: data?.data,
    isLoading,
    error: error ? handleApiError(error) : null,
    refresh: mutate,
  };
}

/**
 * 시스템 설정 업데이트 훅
 */
export function useSystemSettingsActions() {
  const [state, setApiState] = useApiState();

  const updateSettings = useCallback(async (data: SystemSettingsUpdateRequest) => {
    setApiState(true);
    try {
      const result = await adminApi.settings.updateSettings(data);
      
      // 설정 캐시 무효화
      await mutate('/admin/settings');
      
      setApiState(false);
      return result;
    } catch (error) {
      setApiState(false, handleApiError(error));
      throw error;
    }
  }, [setApiState]);

  return {
    updateSettings,
    loading: state.loading,
    error: state.error,
  };
}

// =============================================================================
// 통합 훅 (선택적 사용)
// =============================================================================

/**
 * 모든 어드민 데이터를 한 번에 관리하는 통합 훅
 * 초기 로딩이나 전체 데이터 갱신이 필요할 때 사용
 */
export function useAdminData() {
  const dashboard = useAdminDashboard();
  const users = useUsers();
  const projects = useProjects();
  const auditLogs = useAuditLogs();
  const settings = useSystemSettings();

  const refreshAll = useCallback(async () => {
    await Promise.all([
      dashboard.refresh(),
      users.refresh(),
      projects.refresh(),
      auditLogs.refresh(),
      settings.refresh(),
    ]);
  }, [dashboard, users, projects, auditLogs, settings]);

  const isLoading = dashboard.isLoading || users.isLoading || projects.isLoading || 
                   auditLogs.isLoading || settings.isLoading;

  const hasError = !!(dashboard.error || users.error || projects.error || 
                     auditLogs.error || settings.error);

  return {
    dashboard: dashboard.dashboard,
    users: users.users,
    projects: projects.projects,
    auditLogs: auditLogs.auditLogs,
    settings: settings.settings,
    isLoading,
    hasError,
    refreshAll,
  };
}
</file>

<file path="frontend/src/lib/stores/authStore.ts">
import { create } from 'zustand'

// 사용자 타입 정의
export interface User {
  id: string
  name: string
  email: string
  adminRole?: 'super_admin' | 'admin' | 'moderator' | 'support'
  avatar?: string
  createdAt: string
  updatedAt: string
}

// Auth Store 상태 인터페이스
export interface AuthState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  token: string | null
  
  // Actions
  setUser: (user: User | null) => void
  setToken: (token: string | null) => void
  setLoading: (loading: boolean) => void
  checkAuth: () => Promise<void>
  login: (token: string, user: User) => void
  logout: () => void
}

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  token: null,

  setUser: (user: User | null) =>
    set((state) => ({ 
      ...state, 
      user, 
      isAuthenticated: !!user 
    })),

  setToken: (token: string | null) =>
    set((state) => ({ 
      ...state, 
      token 
    })),

  setLoading: (loading: boolean) =>
    set((state) => ({ 
      ...state, 
      isLoading: loading 
    })),

  checkAuth: async () => {
    try {
      set({ isLoading: true })
      
      // 개발 환경에서 임시 관리자 계정 활성화
      const isDevelopment = process.env.NODE_ENV === 'development' || 
                           typeof window !== 'undefined' && window.location.hostname === 'localhost';
      
      // 로컬 스토리지에서 토큰 확인
      let token = localStorage.getItem('token')
      
      // 개발 환경에서도 실제 로그인을 우선시하므로 자동 토큰 생성 제거
      // if (!token && isDevelopment) {
      //   token = 'dev-admin-token'
      //   localStorage.setItem('token', token)
      //   console.log('🔑 개발 환경: 임시 관리자 토큰이 생성되었습니다.')
      // }
      
      if (!token) {
        set({ 
          user: null, 
          isAuthenticated: false, 
          token: null, 
          isLoading: false 
        })
        return
      }

      // 실제 백엔드 API 호출로 사용자 정보 검증
      try {
        const response = await fetch('http://localhost:8000/api/v1/api/admin/profile', {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const apiResponse = await response.json();
          const userData = apiResponse.success ? apiResponse.data : apiResponse;
          
          // 백엔드 데이터를 프론트엔드 User 타입에 맞게 변환
          const user: User = {
            id: userData.id,
            name: userData.name,
            email: userData.email,
            adminRole: userData.role || userData.adminRole,
            avatar: userData.avatar,
            createdAt: userData.createdAt || new Date().toISOString(),
            updatedAt: userData.updatedAt || new Date().toISOString()
          };
          
          set({ 
            user, 
            isAuthenticated: true, 
            token, 
            isLoading: false 
          });
          
          if (isDevelopment) {
            console.log('🚀 실제 백엔드에서 사용자 정보를 가져왔습니다.', user);
          }
        } else {
          // API 호출 실패 시 임시 사용자 데이터 사용 (개발용)
          const mockUser: User = {
            id: '1',
            name: '워클리 관리자',
            email: 'admin@workly.com',
            adminRole: 'super_admin',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          }

          set({ 
            user: mockUser, 
            isAuthenticated: true, 
            token, 
            isLoading: false 
          });
          
          if (isDevelopment) {
            console.log('🔄 백엔드 API 연결 실패, 임시 관리자 데이터 사용:', mockUser);
          }
        }
      } catch (error) {
        console.error('백엔드 연결 오류:', error);
        
        // 에러 발생 시 임시 사용자 데이터 사용 (개발용)
        const mockUser: User = {
          id: '1',
          name: '워클리 관리자',
          email: 'admin@workly.com',
          adminRole: 'super_admin',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }

        set({ 
          user: mockUser, 
          isAuthenticated: true, 
          token, 
          isLoading: false 
        });
        
        if (isDevelopment) {
          console.log('🔄 백엔드 연결 에러, 임시 관리자 데이터 사용:', mockUser);
        }
      }
    } catch (error) {
      console.error('Auth check failed:', error)
      set({ 
        user: null, 
        isAuthenticated: false, 
        token: null, 
        isLoading: false 
      })
    }
  },

  login: (token: string, user: User) => {
    localStorage.setItem('token', token)
    set({ 
      token, 
      user, 
      isAuthenticated: true, 
      isLoading: false 
    })
  },

  logout: () => {
    localStorage.removeItem('token')
    set({ 
      user: null, 
      isAuthenticated: false, 
      token: null, 
      isLoading: false 
    })
  }
}))
</file>

<file path="frontend/src/lib/stores/calendarFilterStore.ts">
import { create } from 'zustand'

export interface CalendarFilterState {
  showNoDue: boolean
  showOverdue: boolean
  setShowNoDue: (show: boolean) => void
  setShowOverdue: (show: boolean) => void
  resetFilters: () => void
}

export const useCalendarFilterStore = create<CalendarFilterState>((set) => ({
  showNoDue: false,
  showOverdue: false,
  setShowNoDue: (show: boolean) =>
    set((state) => ({ ...state, showNoDue: show })),
  setShowOverdue: (show: boolean) =>
    set((state) => ({ ...state, showOverdue: show })),
  resetFilters: () =>
    set((state) => ({ ...state, showNoDue: false, showOverdue: false })),
}))
</file>

<file path="frontend/src/lib/auth.ts">
/**
 * 인증 관련 유틸리티와 타입 정의
 */

import { api } from './api';

// 사용자 타입
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar?: string;
  role: 'admin' | 'user';
  status: 'active' | 'inactive' | 'pending_verification';
  emailVerifiedAt?: string;
  lastLoginAt?: string;
  createdAt: string;
  updatedAt: string;
  profile: {
    displayName: string;
    bio: string;
    location: string;
    website: string;
    linkedinUrl: string;
    githubUrl: string;
  };
  preferences: {
    language: string;
    timezone: string;
    dateFormat: string;
    timeFormat: string;
    weekStartDay: number;
    notifications: {
      email: boolean;
      push: boolean;
      desktop: boolean;
      mentions: boolean;
      updates: boolean;
      marketing: boolean;
    };
    privacy: {
      profileVisibility: 'public' | 'team' | 'private';
      activityVisibility: 'public' | 'team' | 'private';
    };
  };
}

// 로그인 응답 타입
export interface LoginResponse {
  user: User;
  accessToken: string;
  refreshToken: string;
}

// 인증 응답 타입
export interface AuthResponse {
  message: string;
  user?: User;
}

// 로그인 DTO
export interface LoginDto {
  email: string;
  password: string;
  rememberMe?: boolean;
}

// 회원가입 DTO
export interface RegisterDto {
  email: string;
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
}

/**
 * 현재 로그인된 사용자 정보 가져오기
 */
export const getCurrentUser = (): User | null => {
  if (typeof window !== 'undefined') {
    const userStr = localStorage.getItem('user');
    if (userStr) {
      try {
        return JSON.parse(userStr) as User;
      } catch {
        return null;
      }
    }
  }
  return null;
};

/**
 * 로그인 상태 확인
 */
export const isAuthenticated = (): boolean => {
  if (typeof window !== 'undefined') {
    const accessToken = localStorage.getItem('accessToken');
    const user = getCurrentUser();
    return !!(accessToken && user);
  }
  return false;
};

/**
 * 토큰 저장
 */
export const saveTokens = (accessToken: string, refreshToken: string): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('refreshToken', refreshToken);
  }
};

/**
 * 사용자 정보 저장
 */
export const saveUser = (user: User): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('user', JSON.stringify(user));
  }
};

/**
 * 로그인
 */
export const login = async (loginData: LoginDto): Promise<LoginResponse> => {
  const response = await api.post<LoginResponse>('/auth/login', loginData, { requireAuth: false });
  
  // 토큰과 사용자 정보 저장
  saveTokens(response.accessToken, response.refreshToken);
  saveUser(response.user);
  
  return response;
};

/**
 * 회원가입
 */
export const register = async (registerData: RegisterDto): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>('/auth/register', registerData, { requireAuth: false });
  
  // 회원가입 시에는 사용자 정보만 저장 (이메일 인증 필요)
  if (response.user) {
    saveUser(response.user);
  }
  
  return response;
};

/**
 * 로그아웃
 */
export const logout = async (): Promise<void> => {
  try {
    // 백엔드에 로그아웃 요청
    await api.post('/auth/logout');
  } catch (error) {
    console.error('로그아웃 요청 오류:', error);
  } finally {
    // 로컬 데이터 정리
    api.logout();
  }
};

/**
 * 현재 사용자 프로필 새로고침
 */
export const refreshUserProfile = async (): Promise<User | null> => {
  try {
    const response = await api.get<{ user: User }>('/auth/profile');
    saveUser(response.user);
    return response.user;
  } catch (error) {
    console.error('사용자 프로필 새로고침 오류:', error);
    return null;
  }
};

/**
 * 비밀번호 변경
 */
export const changePassword = async (data: {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}): Promise<AuthResponse> => {
  return api.post<AuthResponse>('/auth/change-password', data);
};

/**
 * 비밀번호 재설정 요청
 */
export const forgotPassword = async (email: string): Promise<AuthResponse> => {
  return api.post<AuthResponse>('/auth/forgot-password', { email }, { requireAuth: false });
};

/**
 * 비밀번호 재설정
 */
export const resetPassword = async (data: {
  token: string;
  newPassword: string;
  confirmPassword: string;
}): Promise<AuthResponse> => {
  return api.post<AuthResponse>('/auth/reset-password', data, { requireAuth: false });
};

/**
 * 이메일 인증
 */
export const verifyEmail = async (token: string): Promise<AuthResponse> => {
  return api.post<AuthResponse>('/auth/verify-email', { token }, { requireAuth: false });
};

/**
 * 인증 이메일 재발송
 */
export const resendVerification = async (email: string): Promise<AuthResponse> => {
  return api.post<AuthResponse>('/auth/resend-verification', { email }, { requireAuth: false });
};
</file>

<file path="frontend/src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatDate(date: Date | string): string {
  const d = new Date(date);
  return new Intl.DateTimeFormat('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(d);
}

export function formatDateTime(date: Date | string): string {
  const d = new Date(date);
  return new Intl.DateTimeFormat('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(d);
}

export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const d = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - d.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return '방금 전';
  }

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes}분 전`;
  }

  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours}시간 전`;
  }

  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 7) {
    return `${diffInDays}일 전`;
  }

  const diffInWeeks = Math.floor(diffInDays / 7);
  if (diffInWeeks < 4) {
    return `${diffInWeeks}주 전`;
  }

  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths}개월 전`;
  }

  const diffInYears = Math.floor(diffInDays / 365);
  return `${diffInYears}년 전`;
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number,
  immediate?: boolean
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null;
  
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      if (!immediate) func(...args);
    };
    
    const callNow = immediate && !timeout;
    
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    
    if (callNow) func(...args);
  };
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  
  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

export function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

export function truncate(str: string, length: number): string {
  if (str.length <= length) return str;
  return str.slice(0, length) + '...';
}
</file>

<file path="frontend/src/styles/scrollbar-system.md">
# 워클리 스크롤바 시스템

## 개요

워클리는 간결한 UI를 위해 모든 스크롤바를 기본적으로 숨기고, 필요할 때만 표시하는 시스템을 구현했습니다.

## 동작 방식

### 1. 글로벌 스크롤바 숨김
- 모든 요소의 스크롤바가 기본적으로 숨겨집니다
- 브라우저 호환성: Chrome, Safari, Firefox, Edge

### 2. 선택적 표시
- 마우스 호버 시
- 포커스 시 (키보드 네비게이션)
- 실제 스크롤 중일 때 (1.5초 후 자동 숨김)

## 사용법

### 기본 사용
```tsx
<div className="overflow-y-auto scrollbar-on-hover">
  {/* 스크롤 가능한 콘텐츠 */}
</div>
```

### 고급 사용 (React Hook)
```tsx
import { useScrollVisibility } from '@/hooks/useScrollVisibility'

function MyComponent() {
  const { elementRef } = useScrollVisibility({
    hideDelay: 1500,
    showOnHover: true
  })

  return (
    <div ref={elementRef} className="overflow-y-auto scrollbar-on-hover">
      {/* 콘텐츠 */}
    </div>
  )
}
```

## 적용된 컴포넌트

- 채팅 메시지 영역
- 프로젝트 상세 사이드바
- 프로젝트 목록 모달
- 업무 생성 위저드
- 상태 선택 드롭다운

## 브라우저 지원

| 브라우저 | 버전 | 지원 상태 |
|---------|------|----------|
| Chrome  | 80+  | ✅ 완전 지원 |
| Safari  | 14+  | ✅ 완전 지원 |
| Firefox | 64+  | ✅ 완전 지원 |
| Edge    | 80+  | ✅ 완전 지원 |

## 커스터마이징

### CSS 변수로 스타일 조정
```css
.scrollbar-on-hover {
  --scrollbar-width: 6px;
  --scrollbar-color: rgba(156, 163, 175, 0.5);
  --scrollbar-hover-color: rgba(107, 114, 128, 0.7);
}
```

### 숨김 딜레이 조정
```tsx
const { elementRef } = useScrollVisibility({
  hideDelay: 2000, // 2초 후 숨김
  showOnHover: false // 호버 시 표시 비활성화
})
```

## 접근성

- 키보드 네비게이션 시 자동 표시
- 스크린 리더 호환성 유지
- 터치 디바이스에서 자연스러운 스크롤 경험

## 성능

- CSS transition을 통한 GPU 가속
- 불필요한 DOM 조작 최소화
- 메모리 누수 방지를 위한 이벤트 리스너 정리
</file>

<file path="frontend/src/types/api.types.ts">
// 사용자 관련 타입
export type UserRole = 'admin' | 'member';
export type UserStatus = 'active' | 'inactive' | 'pending_verification' | 'suspended';

export interface UserProfile {
  displayName: string;
  bio: string;
  location: string;
  website: string;
  linkedinUrl: string;
  githubUrl: string;
}

export interface UserNotificationSettings {
  email: boolean;
  push: boolean;
  desktop: boolean;
  mentions: boolean;
  updates: boolean;
  marketing: boolean;
}

export interface UserPrivacySettings {
  profileVisibility: 'public' | 'team' | 'private';
  activityVisibility: 'public' | 'team' | 'private';
}

export interface UserPreferences {
  language: string;
  timezone: string;
  dateFormat: string;
  timeFormat: '12h' | '24h';
  weekStartDay: number;
  notifications: UserNotificationSettings;
  privacy: UserPrivacySettings;
}

export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar?: string;
  role: UserRole;
  status: UserStatus;
  profile: UserProfile;
  preferences: UserPreferences;
  lastLoginAt?: string;
  emailVerifiedAt?: string;
  createdAt: string;
  updatedAt: string;
}

// 프로젝트 관련 타입
export type ProjectStatus = 'planning' | 'in_progress' | 'on_hold' | 'completed' | 'cancelled';
export type ProjectPriority = 'low' | 'medium' | 'high' | 'urgent';
export type ProjectVisibility = 'private' | 'team' | 'public';
export type ProjectMemberRole = 'admin' | 'member' | 'viewer';

export interface ProjectSettings {
  enableTimeTracking: boolean;
  enableComments: boolean;
  enableFileAttachments: boolean;
  workflowStages: string[];
  [key: string]: any;
}

export interface ProjectMember {
  id: string;
  user: User;
  role: ProjectMemberRole;
  permissions: string[];
  joinedAt: string;
}

export interface Project {
  id: string;
  title: string;
  description?: string;
  status: ProjectStatus;
  priority: ProjectPriority;
  startDate?: string;
  endDate?: string;
  progress: number;
  budget?: number;
  currency?: string;
  tags: string[];
  isArchived: boolean;
  isTemplate: boolean;
  templateId?: string;
  color?: string;
  icon?: string;
  visibility: ProjectVisibility;
  settings: ProjectSettings;
  ownerId: string;
  members: ProjectMember[];
  tasks?: Task[];
  createdAt: string;
  updatedAt: string;
}

// 태스크 관련 타입
export type TaskStatus = 'todo' | 'in_progress' | 'review' | 'done' | 'blocked' | 'cancelled';
export type TaskPriority = 'low' | 'medium' | 'high' | 'urgent';
export type TaskType = 'task' | 'bug' | 'feature' | 'epic' | 'story';

export interface TaskLabel {
  id: string;
  name: string;
  color: string;
  description?: string;
  projectId?: string;
  createdAt: string;
  updatedAt: string;
}

export interface TaskComment {
  id: string;
  content: string;
  author: User;
  parentId?: string;
  isInternal: boolean;
  isEdited: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface TaskDependency {
  id: string;
  dependentTask: Task;
  dependsOnTask: Task;
  type: 'blocks' | 'relates_to' | 'duplicates';
  createdAt: string;
}

export interface TimeEntry {
  id: string;
  description?: string;
  duration: number;
  startTime: string;
  endTime?: string;
  user: User;
  billable: boolean;
  approved: boolean;
  approvedBy?: string;
  approvedAt?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Task {
  id: string;
  title: string;
  description?: string;
  status: TaskStatus;
  priority: TaskPriority;
  type: TaskType;
  dueDate?: string;
  startDate?: string;
  completedAt?: string;
  project?: Project;
  assignee?: User;
  reporter: User;
  parentTask?: Task;
  subtasks?: Task[];
  estimatedHours?: number;
  actualHours: number;
  progress: number;
  workflowStageId?: string;
  tags: string[];
  customFields: Record<string, any>;
  labels?: TaskLabel[];
  comments?: TaskComment[];
  dependencies?: TaskDependency[];
  dependents?: TaskDependency[];
  watchers?: User[];
  timeEntries?: TimeEntry[];
  createdAt: string;
  updatedAt: string;
}

// API 응답 타입
export interface AuthResponse {
  message: string;
  user?: User;
}

export interface LoginResponse extends AuthResponse {
  accessToken: string;
  refreshToken: string;
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// API 요청 타입
export interface LoginRequest {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface RegisterRequest {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
}

export interface CreateTaskRequest {
  title: string;
  description?: string;
  projectId?: string;
  assigneeId?: string;
  parentTaskId?: string;
  priority?: TaskPriority;
  type?: TaskType;
  dueDate?: string;
  startDate?: string;
  estimatedHours?: number;
  tags?: string[];
  labelIds?: string[];
  customFields?: Record<string, any>;
}

export interface UpdateTaskRequest {
  title?: string;
  description?: string;
  status?: TaskStatus;
  priority?: TaskPriority;
  type?: TaskType;
  dueDate?: string;
  startDate?: string;
  estimatedHours?: number;
  progress?: number;
  tags?: string[];
  labelIds?: string[];
  customFields?: Record<string, any>;
}

export interface CreateProjectRequest {
  title: string;
  description?: string;
  priority?: ProjectPriority;
  startDate?: string;
  endDate?: string;
  budget?: number;
  currency?: string;
  tags?: string[];
  color?: string;
  icon?: string;
  visibility?: ProjectVisibility;
  settings?: Record<string, any>;
}
</file>

<file path="frontend/.eslintrc.js">
module.exports = {
  extends: [
    '../.eslintrc.js',
    'next/core-web-vitals',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:jsx-a11y/recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:storybook/recommended',
    'prettier',
  ],
  env: {
    browser: true,
    es2020: true,
    node: true,
  },
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  plugins: [
    'react',
    'react-hooks',
    'jsx-a11y',
    '@typescript-eslint',
  ],
  rules: {
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    'react/jsx-props-no-spreading': 'off',
    'react/jsx-filename-extension': [
      'warn',
      { extensions: ['.tsx', '.jsx'] },
    ],
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',
    'jsx-a11y/anchor-is-valid': 'off',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'import/prefer-default-export': 'off',
    'import/extensions': 'off',
    'no-console': 'warn',
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  overrides: [
    {
      files: ['**/*.stories.*'],
      rules: {
        'import/no-anonymous-default-export': 'off',
        '@typescript-eslint/no-explicit-any': 'off',
      },
    },
  ],
};
</file>

<file path="frontend/.eslintrc.json">
{
  "extends": ["next/core-web-vitals"]
}
</file>

<file path="frontend/.gitignore">
.vercel
</file>

<file path="frontend/jest.config.js">
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files
  dir: './',
});

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jsdom',
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@shared/(.*)$': '<rootDir>/../shared/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/app/layout.tsx',
    '!src/app/globals.css',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}',
    '<rootDir>/src/**/*.{test,spec}.{js,jsx,ts,tsx}',
  ],
  testPathIgnorePatterns: [
    '<rootDir>/.next/',
    '<rootDir>/node_modules/',
    '<rootDir>/e2e/',
  ],
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  transformIgnorePatterns: [
    '/node_modules/',
    '^.+\\.module\\.(css|sass|scss)$',
  ],
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig);
</file>

<file path="frontend/jest.setup.js">
import '@testing-library/jest-dom';

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  
  observe() {
    return null;
  }
  
  disconnect() {
    return null;
  }
  
  unobserve() {
    return null;
  }
};

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  
  observe() {
    return null;
  }
  
  disconnect() {
    return null;
  }
  
  unobserve() {
    return null;
  }
};

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // deprecated
    removeListener: jest.fn(), // deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock next/router
jest.mock('next/router', () => ({
  useRouter() {
    return {
      route: '/',
      pathname: '/',
      query: {},
      asPath: '/',
      push: jest.fn(),
      pop: jest.fn(),
      reload: jest.fn(),
      back: jest.fn(),
      prefetch: jest.fn().mockResolvedValue(undefined),
      beforePopState: jest.fn(),
      events: {
        on: jest.fn(),
        off: jest.fn(),
        emit: jest.fn(),
      },
      isFallback: false,
    };
  },
}));

// Mock next/navigation
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      refresh: jest.fn(),
    };
  },
  useSearchParams() {
    return new URLSearchParams();
  },
  usePathname() {
    return '/';
  },
}));
</file>

<file path="frontend/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
</file>

<file path="frontend/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Workly 브랜드 색상 (Threads 기반)
        background: '#FAFAFA',
        foreground: '#000000',
        card: '#FFFFFF',
        'card-foreground': '#000000',
        primary: '#000000',
        'primary-foreground': '#FFFFFF',
        secondary: '#F5F5F5',
        'secondary-foreground': '#000000',
        muted: '#F5F5F5',
        'muted-foreground': '#999999',
        accent: '#F5F5F5',
        'accent-foreground': '#000000',
        destructive: '#EF4444',
        'destructive-foreground': '#FFFFFF',
        border: '#D5D5D5',
        input: '#D5D5D5',
        ring: '#000000',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
      },
      spacing: {
        '18': '4.5rem', // 72px for navigation width
      },
    },
  },
  plugins: [],
}
export default config
</file>

<file path="instructions/20250725-01.md">
# 작업 지시서: UI/UX 개선

## 1. 네비게이션 메뉴 아이콘 변경
- 기존 3점 오버플로우 메뉴 아이콘을 3선 햄버거 메뉴 아이콘으로 교체합니다.

## 2. 오버플로우 메뉴 항목
- 햄버거 메뉴 내에 '로그인' 및 '설정' 항목을 포함합니다.
- 사용자가 로그인 상태일 경우, '로그인' 항목을 '로그아웃'으로 변경합니다.

## 3. 로그인 페이지 구현
- 로그인 페이지는 'Google로 시작하기' 버튼 하나만 있는 간결한 디자인으로 구성합니다.

## 4. 설정 페이지 구현
- 설정 페이지에는 다음 기능들을 포함합니다:
    - 언어 설정
    - 다크 모드 전환
    - 알림 설정

## 5. 홈 화면 헤더 인증 버튼 통합
- 홈 화면 상단 헤더 우측에 있는 인증 버튼을 'Google로 시작하기' 버튼 하나로 통합합니다.
- 모바일 환경에서는 해당 버튼을 간략하게 '로그인'으로만 표시합니다.

## 6. 모바일 네비게이션 조정
- 모바일 환경에서는 하단 네비게이션만 유지하고, 사이드 네비게이션은 제거합니다.

## 7. 헤더 스타일 조정
- 헤더의 높이를 60px로 설정합니다.
- 헤더의 테두리를 제거하여 깔끔한 디자인을 유지합니다.
</file>

<file path="instructions/20250725-02.md">
# CLAUDE에게 전달할 작업 지시서

## Phase 1 (즉시 시작 가능)

1.  **태스크 1: Monorepo & CI/CD**
    *   서브태스크 1.1: Monorepo 구조 설계 및 설정
    *   서브태스크 1.2: CI/CD 파이프라인 구축 (GitHub Actions)
    *   서브태스크 1.3: Linter 및 Formatter 설정
    *   서브태스크 1.4: 테스트 환경 구축
    *   서브태스크 1.5: 배포 스크립트 작성

2.  **태스크 3: 데이터 모델 설계**
    *   서브태스크 3.1: 사용자 모델 정의
    *   서브태스크 3.2: 프로젝트 및 태스크 모델 정의
    *   서브태스크 3.3: 관계형 데이터베이스 스키마 설계

3.  **태스크 5: UI/UX 기초**
    *   서브태스크 5.1: 기본 레이아웃 컴포넌트 개발
    *   서브태스크 5.2: 디자인 시스템 (Color, Typography) 정의
    *   서브태스크 5.3: Storybook을 이용한 컴포넌트 문서화

## Phase 2 (Phase 1 완료 후)

4.  **태스크 2: Google OAuth & JWT**
    *   서브태스크 2.1: Google OAuth 2.0 설정
    *   서브태스크 2.2: JWT 기반 인증 시스템 구현
    *   서브태스크 2.3: 로그인 및 회원가입 API 개발
    *   서브태스크 2.4: 인증 미들웨어 구현
    *   서브태스크 2.5: 소셜 로그인 버튼 UI 구현

5.  **태스크 7: GTD 업무 관리**
    *   서브태스크 7.1: 태스크 생성 및 수정 기능 구현
    *   서브태스크 7.2: 태스크 상태 관리 (Next, In Progress, Done)
    *   서브태스크 7.3: 태스크 우선순위 설정 기능
    *   서브태스크 7.4: 태스크 마감일 설정 및 알림
    *   서브태스크 7.5: GTD 필터링 및 정렬 기능

## Phase 3 (핵심 기능 완료 후)

6.  **나머지 협업 및 고급 기능들**
    *   태스크 4: 실시간 협업 기능
    *   태스크 6: AI 기반 자동화
    *   태스크 8: 알림 시스템
    *   태스크 9: 검색 기능
</file>

<file path="instructions/20250726-repomix.md">
네, 제공해주신 코드베이스 전체를 분석하고 구조적인 강점과 함께 리팩터링 제안을 드리겠습니다.

---

### 1. 프로젝트 개요

이 프로젝트는 **워클리(Workly)**라는 이름의 '게이미피케이션 기반 생산성 플랫폼'으로 보입니다. Monorepo 구조로 구성되어 있으며, 주요 기술 스택은 다음과 같습니다.

-   **Frontend**: Next.js (App Router), TypeScript, Tailwind CSS
-   **Backend**: NestJS, TypeScript, TypeORM, PostgreSQL
-   **Shared**: 프론트엔드와 백엔드 간 타입 및 상수 공유를 위한 별도 패키지
-   **DevOps**: Docker, Docker Compose, GitHub Actions를 이용한 CI/CD
-   **특징**: `.taskmaster`와 `.claude` 디렉토리를 통해 **AI 에이전트(Taskmaster)**를 활용하여 프로젝트 관리 및 개발을 자동화하는 매우 현대적이고 독특한 워크플로우를 채택하고 있습니다.

전반적으로 매우 체계적이고 잘 설계된 풀스택 애플리케이션입니다.

### 2. 코드베이스 구조 분석

#### 가. Monorepo 구조
- `frontend`, `backend`, `shared` 워크스페이스로 명확하게 분리되어 있습니다.
- 루트 `package.json`에서 모든 스크립트(`dev`, `build`, `lint`, `test`)를 관리하여 일관된 개발 경험을 제공합니다.
- 이는 코드 재사용성(특히 `shared` 패키지)을 높이고 프로젝트 관리를 용이하게 하는 모범적인 구조입니다.

#### 나. Backend (NestJS)
- **모듈화**: `auth`, `projects`, `tasks`, `users`, `websocket` 등 기능별로 모듈이 잘 분리되어 있습니다. 이는 NestJS의 철학을 잘 따르는 구조로, 유지보수와 확장이 용이합니다.
- **데이터베이스**: `database/entities`에 TypeORM 엔티티가, `database/migrations`에 마이그레이션 파일이 위치하여 데이터베이스 스키마 관리가 체계적입니다.
- **설정 관리**: `config` 디렉토리에서 `auth.config.ts`, `database.config.ts` 등으로 설정을 분리하여 관리하고 있습니다.
- **인증/인가**: Passport.js 기반의 `JwtStrategy`, `GoogleStrategy`와 `AuthGuard`, `RolesGuard`를 사용하여 견고한 인증/인가 시스템을 구축했습니다.

#### 다. Frontend (Next.js)
- **App Router**: Next.js 13+의 App Router를 사용하여 페이지 및 레이아웃을 구성하고 있습니다. 이는 최신 Next.js 개발 트렌드를 따르는 것입니다.
- **컴포넌트 구조**: `components/ui` (기본 UI), `components/tasks` (기능별), `components/layout` (레이아웃) 등으로 컴포넌트의 역할이 명확하게 분리되어 있습니다.
- **API 통신**: `lib/api.ts`에 중앙화된 API 클라이언트가 있으며, `lib/api/tasks.ts`처럼 기능별로 API 호출 함수를 분리하여 관리하고 있습니다.
- **상태 관리**: `zustand`를 사용할 것으로 보이나, 실제 스토어 파일은 제공된 코드에 없습니다. 경량 상태 관리를 지향하는 좋은 선택입니다.

#### 라. Shared 패키지
- `constants`와 `types`를 프론트엔드와 백엔드 간에 공유하는 것은 매우 훌륭한 설계입니다.
- 이를 통해 API의 '계약(contract)' 역할을 하는 타입을 한 곳에서 관리하여 양측의 불일치로 인한 버그를 원천적으로 방지할 수 있습니다.

#### 마. AI 기반 개발 워크플로우 (Taskmaster)
- `.taskmaster` 디렉토리에 `PRD.txt`, `tasks.json`, `reports` 등을 두어 AI 에이전트가 프로젝트를 이해하고 작업을 관리하는 기반을 마련했습니다.
- `.claude` 디렉토리에는 AI 에이전트(Claude)를 위한 명령어(slash commands)가 정의되어 있어, 개발 프로세스를 자동화하고 표준화하려는 시도가 돋보입니다.
- 이는 단순한 코드베이스를 넘어 **어떻게 개발할 것인가**에 대한 방법론까지 내재된 매우 진보적인 구조입니다.

---

### 3. 잘된 점 (Strengths)

-   **명확한 Monorepo 아키텍처**: 각 패키지(`frontend`, `backend`, `shared`)의 역할이 명확하고 상호 의존성 관리가 효율적입니다.
-   **최신 기술 스택 활용**: Next.js App Router, NestJS 등 검증된 최신 기술을 적극적으로 사용하고 있습니다.
-   **강력한 타입 시스템**: TypeScript와 `shared` 패키지를 통해 프론트엔드와 백엔드 간의 데이터 흐름을 안전하게 관리합니다.
-   **자동화된 개발 환경**: Docker, GitHub Actions CI/CD 파이프라인이 구축되어 있어 개발 및 배포 생산성이 높습니다.
-   **혁신적인 AI 개발 워크플로우**: Taskmaster AI를 도입하여 요구사항 분석부터 태스크 관리, 개발까지 체계적으로 자동화한 점은 이 프로젝트의 가장 큰 특징이자 강점입니다.

---

### 4. 개선 제안 및 리팩터링

전반적으로 매우 훌륭한 구조이지만, 몇 가지 영역에서 더 개선할 수 있는 부분이 보입니다.

#### 가. `shared` 패키지 및 타입 관리 (가장 중요)

-   **문제점**: 현재 `shared/types/api.types.ts` 파일과 `backend/src/shared/types/api.types.ts` 파일이 중복으로 존재합니다. 두 파일의 내용이 유사하지만 약간의 차이가 있어 혼란과 버그의 원인이 될 수 있습니다.
-   **리팩터링 제안**:
    1.  **타입 정의 단일화**: `shared` 워크스페이스를 **Single Source of Truth(신뢰할 수 있는 단일 소스)**로 만듭니다. `shared/types/api.types.ts`에 모든 공유 타입을 통합하고, `backend/src/shared` 디렉토리는 완전히 제거합니다.
    2.  **의존성 설정**: `backend`의 `package.json`에서 `@workly/shared`를 `dependency`로 추가하고, 백엔드 코드 전체에서 `import { ... } from '@workly/shared'` 구문을 사용하도록 수정합니다. 이렇게 하면 타입 정의가 항상 일치하게 됩니다.

#### 나. 백엔드 아키텍처 개선

-   **문제점**: TypeORM 엔티티(`*.entity.ts`) 파일 내에 비즈니스 로직(예: `File.entity.ts`의 `canDownload`, `ProjectMember.entity.ts`의 `hasPermission`)이 포함되어 있습니다. 이는 엔티티가 데이터 구조 이상의 책임을 갖게 하여 **Active Record 패턴**에 가까워집니다. NestJS는 **Data Mapper 패턴**을 지향하므로, 로직을 서비스 레이어로 옮기는 것이 좋습니다.
-   **리팩터링 제안**:
    1.  **비즈니스 로직을 서비스로 이전**: 엔티티는 데이터베이스 스키마와 관계를 정의하는 역할에만 충실하게 만듭니다.
    2.  예를 들어, `file.entity.ts`의 `canDownload(userId)` 메서드 대신, `FilesService`에 `canDownload(file: File, userId: string): boolean` 메서드를 만들어 권한 검사 로직을 구현합니다.
    3.  **장점**:
        -   **관심사 분리(SoC)**: 데이터 구조와 비즈니스 규칙이 명확하게 분리됩니다.
        -   **테스트 용이성**: 서비스 레이어에서 비즈니스 로직을 단위 테스트하기가 훨씬 쉬워집니다.
        -   **일관성**: 모든 비즈니스 규칙이 서비스 레이어에 모여있어 코드를 이해하고 유지보수하기 좋습니다.

-   **문제점**: `database.config.ts` 파일에 `getDatabaseConfig` 함수와 `dataSourceOptions` 상수가 거의 동일한 내용을 중복으로 정의하고 있습니다.
-   **리팩터링 제안**:
    1.  **설정 단일화**: `DataSourceOptions` 타입의 설정 객체를 하나만 만듭니다.
    2.  `getDatabaseConfig` 함수는 이 설정 객체를 그대로 반환하도록 하고, TypeORM CLI를 위한 `export default new DataSource(...)`도 이 객체를 사용하도록 수정합니다. 이렇게 하면 설정 변경 시 한 곳만 수정하면 됩니다.

#### 다. 프론트엔드 데이터 페칭(Data Fetching) 전략

-   **문제점**: `ProjectDetailPage.tsx`나 `ProjectsPage.tsx`와 같은 페이지 컴포넌트에서 `useEffect`와 `apiClient`를 사용하여 직접 데이터를 가져오고 상태를 관리하고 있습니다. 이는 로딩, 에러, 캐싱 처리를 매번 수동으로 해야 하는 번거로움이 있습니다.
-   **리팩터링 제안**:
    1.  **React Query (TanStack Query) 또는 SWR 도입**: 데이터 페칭, 캐싱, 동기화, 서버 상태 관리를 위한 라이브러리를 도입하는 것을 강력히 추천합니다.
    2.  **커스텀 훅(Custom Hook) 생성**: `useProjects`, `useProject(id)`와 같은 커스텀 훅을 만들어 데이터 페칭 로직을 컴포넌트로부터 완전히 분리합니다.

    ```typescript
    // 예시: useProjects.ts
    import { useQuery } from '@tanstack/react-query';
    import { apiClient } from '@/lib/api';
    import { PaginatedResponse, Project, ProjectQueryDto } from '@/types/project.types';

    const fetchProjects = async (query?: ProjectQueryDto): Promise<PaginatedResponse<Project>> => {
      // ... apiClient를 사용한 API 호출 로직 ...
    };

    export const useProjects = (query?: ProjectQueryDto) => {
      return useQuery({
        queryKey: ['projects', query], // 쿼리 키
        queryFn: () => fetchProjects(query),
        // staleTime, cacheTime 등 캐싱 옵션 설정
      });
    };
    ```

    3.  **장점**:
        -   **코드가 간결해짐**: 컴포넌트에서 `isLoading`, `error`, `data` 상태를 직접 관리할 필요가 없습니다.
        -   **자동 캐싱 및 재검증**: 데이터 일관성을 유지하고 불필요한 API 호출을 줄여 성능을 향상시킵니다.
        -   **서버 상태와 UI 상태의 분리**: 데이터 페칭 로직이 분리되어 컴포넌트는 UI 렌더링에만 집중할 수 있습니다.

#### 라. CI/CD 파이프라인 최적화
- **문제점**: 현재 `backend-ci.yml`과 `frontend-ci.yml`이 개별적으로 존재하고, `monorepo-ci.yml`은 변경된 경로를 감지하는 역할을 합니다. 하지만 `shared` 패키지가 변경될 경우 프론트엔드와 백엔드 워크플로우를 모두 트리거하는 로직이 더 명확해야 합니다. `monorepo-ci.yml`은 빌드/테스트를 직접 수행하지 않고 알림만 보내는 것으로 보입니다.
- **리팩터링 제안**:
    1. **단일 통합 워크플로우**: `monorepo-ci.yml`을 메인 CI 워크플로우로 사용하고, `dorny/paths-filter`의 `outputs`을 활용하여 필요한 작업(backend-test, frontend-test)을 조건부로 실행하는 것이 더 효율적일 수 있습니다.
    2. `shared` 변경 시, 백엔드와 프론트엔드 테스트/빌드 작업을 모두 실행하도록 `if` 조건을 설정합니다. (`if: needs.changes.outputs.backend == 'true' || needs.changes.outputs.shared == 'true'`)

### 5. 종합 결론

이 코드베이스는 최신 기술과 모범 사례를 적극적으로 도입한 매우 잘 만들어진 프로젝트입니다. 특히 AI 에이전트를 개발 프로세스에 통합한 점은 매우 인상적이며 미래 지향적입니다.

제안된 리팩터링은 주로 **코드 중복 제거, 관심사 분리 강화, 데이터 관리 전략 개선**에 초점을 맞추고 있습니다. 이러한 개선 사항들을 적용하면 프로젝트의 안정성과 유지보수성이 한 단계 더 높아져, 앞으로 더 복잡한 기능을 추가하고 확장해 나가는 데 튼튼한 기반이 될 것입니다.
</file>

<file path="instructions/20250727-01.md">
### 작업 지시서

*   **문서 ID**: `20250727-01.md`
*   **작성일**: 2025년 7월 27일
*   **요청자**: 오지훈
*   **담당자**: Gemini

### 1. 개요

프로젝트 상세 페이지의 사용자 경험(UX)을 개선하기 위해 기존 탭 기반 레이아웃을 채팅 중심의 2단 레이아웃으로 변경합니다. 사용자가 프로젝트의 핵심 소통 채널인 채팅에 집중하면서, 동시에 우측 사이드바를 통해 프로젝트의 주요 정보와 목표를 한눈에 파악할 수 있도록 하는 것을 목표로 합니다.

### 2. 작업 범위

*   `/Users/ohjiihoon/Documents/Workly/frontend/src/app/projects/[id]/page.tsx`
*   `/Users/ohjiihoon/Documents/Workly/frontend/src/components/projects/ProjectChatChannel.tsx`

### 3. 상세 작업 내용

#### 3.1. 메인 레이아웃 변경 (`page.tsx`)

1.  **2단 레이아웃 구조 적용**
    *   기존 `ProjectDetailView`의 탭 구조를 제거합니다.
    *   페이지 전체를 좌측 메인 콘텐츠(채팅)와 우측 사이드바로 구성된 2단 레이아웃으로 변경합니다. (예: `flex` 레이아웃 사용, 좌측 `flex-1`, 우측 `w-1/3` 또는 `w-[400px]` 고정 너비)

2.  **컴포넌트 재배치**
    *   **좌측 (메인 콘텐츠)**: `<ProjectChatChannel />` 컴포넌트를 항상 표시하도록 배치합니다.
    *   **우측 (사이드바)**:
        *   `<ProjectObjectiveManager />` (목표 관리) 컴포넌트를 배치합니다.
        *   기존 `ProjectDetailView`의 '프로젝트 정보' 탭에 있던 모든 내용을 사이드바의 별도 섹션으로 옮깁니다. (상세 내용은 3.3 참조)

#### 3.2. 채팅 헤더 수정 (`ProjectChatChannel.tsx`)

1.  **'뒤로가기' 버튼 추가**
    *   기존 `ProjectDetailView` 헤더에 있던 '뒤로가기' 버튼(`ArrowLeft` 아이콘)을 `ProjectChatChannel` 컴포넌트의 헤더 좌측으로 이동시킵니다.
    *   `useRouter` 훅을 사용하여 `router.back()` 기능을 구현합니다.

2.  **프로젝트 제목 및 편집 버튼 제거**
    *   `ProjectDetailView` 헤더에 있던 프로젝트 제목과 '편집' 버튼은 `ProjectChatChannel` 헤더에 필요 없으므로, '뒤로가기' 버튼만 추가합니다.

#### 3.3. 우측 사이드바 구성 (`page.tsx`)

1.  **'프로젝트 정보' 섹션 생성**
    *   기존 `ProjectDetailView`의 `activeTab === 'details'` 조건부 렌더링 안에 있던 모든 JSX(프로젝트 헤더 카드, 진행률, 정보, 태그, 액션 버튼 등)를 추출하여 우측 사이드바에 배치합니다.
    *   가독성을 위해 이 부분을 `ProjectInfoSidebar`와 같은 별도의 컴포넌트로 만드는 것을 권장합니다.

2.  **'편집' 버튼 재배치**
    *   기존 `ProjectDetailView` 헤더에 있던 '편집' 버튼을 우측 사이드바의 '프로젝트 정보' 섹션 상단으로 이동시킵니다.

3.  **'목표 관리' 섹션 배치**
    *   `<ProjectObjectiveManager />` 컴포넌트를 '프로젝트 정보' 섹션 위 또는 아래에 배치하여 사이드바 내에서 스크롤로 함께 볼 수 있도록 합니다.

### 4. 결과물

*   프로젝트 상세 페이지에 접속하면, 좌측에는 채팅창이, 우측에는 프로젝트 정보와 목표 관리 섹션이 있는 사이드바가 표시되어야 합니다.
*   채팅창 헤더의 '뒤로가기' 버튼이 정상적으로 동작해야 합니다.
*   기존의 '채팅', '목표 관리', '프로젝트 정보' 탭은 사라져야 합니다.
*   우측 사이드바는 스크롤이 가능해야 하며, 모든 정보가 정상적으로 표시되어야 합니다.
</file>

<file path="instructions/20250727-02.md">
### 작업 지시서

*   **문서 ID**: `20250727-02.md`
*   **작성일**: 2025년 7월 27일
*   **요청자**: 오지훈
*   **담당자**: Gemini

### 1. 개요

기존의 복합적인 방법론(GTD, OKR)을 대체하고, 워클리만의 독자적인 '워클리 고유 방법론'을 애플리케이션의 핵심 철학으로 도입합니다. 이를 위해 데이터 모델, API, UI/UX 전반에 걸쳐 '목표 → 프로젝트 → 업무'의 유연한 계층 구조와 '수집 → 계획 → 실행 → 검토(CPER)' 워크플로우를 적용하는 대규모 리팩토링을 진행합니다.

### 2. 핵심 원칙 및 정책

1.  **유연한 계층 구조**
    *   '목표 → 프로젝트 → 업무'는 권장 가이드라인일 뿐, **필수 강제 사항이 아닙니다.**
    *   **목표가 없는 프로젝트** 생성이 가능해야 합니다.
    *   **프로젝트가 없는 독립적인 업무** 생성이 가능해야 합니다.
    *   사용자는 업무를 먼저 만든 후, 나중에 해당 업무를 특정 프로젝트나 목표에 연결하는 '상향식(Bottom-up)' 구성이 가능해야 합니다.

2.  **네비게이션 구조 정의**
    *   애플리케이션의 핵심 네비게이션은 다음 5개 항목으로 구성합니다.
        1.  **업무 (Tasks)**
        2.  **프로젝트 (Projects)**
        3.  **수집함 (Inbox)**: 중앙에 위치하며, 시각적으로 강조된 디자인을 적용합니다.
        4.  **목표 (Goals)**
        5.  **프로필 (Profile)**

3.  **수집함(Inbox) 및 플로팅 액션 버튼(FAB) 정책**
    *   네비게이션의 '수집함'과 '플로팅 액션 버튼(FAB)'은 동일한 기능(빠른 항목 추가)을 수행합니다.
    *   **FAB는 데스크톱 환경에서만 표시**하여 접근 편의성을 높입니다.
    *   **모바일 환경에서는 FAB를 숨겨** 화면을 가리지 않고, 중앙의 '수집함' 버튼 사용을 유도합니다.

4.  **UI/UX 스타일 통일**
    *   '목표' 페이지는 복잡한 대시보드 형태가 아닌, 기존 '프로젝트'나 '업무' 목록과 같이 **간결한 카드 기반의 리스트 레이아웃**을 유지합니다.
    *   애플리케이션 전반의 디자인 통일성을 준수합니다.

### 3. 단계별 실행 계획

#### Phase 1: 기반 모델 및 API 재설계 (Foundation & API Redesign)

이 단계는 애플리케이션의 뼈대를 재구성하는 가장 중요한 과정입니다.

1.  **공통 타입 정의 (`/shared/types`)**
    *   기존 타입(`Objective`, `KeyResult` 등)을 새로운 모델에 맞게 재정의하거나 새로 만듭니다.
    *   `Goal.ts`: 목표 타입을 정의합니다. (id, title, description, progress 등)
    *   `Project.ts`: 프로젝트 타입을 수정합니다. `goalId` 필드를 **선택적(Optional/Nullable)**으로 변경합니다.
    *   `Task.ts`: 작업 타입을 수정합니다. `projectId` 필드를 **선택적(Optional/Nullable)**으로 변경합니다.
    *   `InboxItem.ts`: '수집함'에 들어올 항목의 타입을 정의합니다.

2.  **백엔드 (`/backend`)**
    *   **데이터베이스 스키마 변경**: `Goal` 테이블을 새로 생성하고, `Project` 테이블에 `goalId` 외래 키를 추가합니다. `Project`의 `goalId`와 `Task`의 `projectId`는 선택적 필드로 변경합니다.
    *   **API 엔드포인트 수정/추가**:
        *   `Goals API`: 목표(Goal)에 대한 CRUD API를 구현합니다.
        *   `Projects API`: 프로젝트 생성/수정 시 `goalId`를 필수로 받지 않도록 수정합니다.
        *   `Tasks API`: 기존 구조를 유지하되, 상위 프로젝트 및 목표와의 연결성을 항상 검증하도록 로직을 강화합니다. `projectId`를 필수로 받지 않도록 수정합니다.
        *   `Inbox API`: 수집함 항목을 생성하고 관리하는 API를 구현합니다.

3.  **프론트엔드 (`/frontend`)**
    *   애플리케이션 전반에서 사용되는 타입을 새로운 타입으로 교체합니다. 이 과정에서 발생하는 컴파일 오류를 해결하며 변경이 필요한 모든 컴포넌트를 식별합니다.

#### Phase 2: 핵심 UI/UX 재구축 (Core UI/UX Rebuild)

새로운 방법론에 맞춰 사용자가 상호작용하는 방식을 완전히 새로 설계합니다.

1.  **메인 네비게이션 변경**
    *   위에 정의된 5개의 항목으로 구성된 하단 네비게이션 바를 구현합니다.
    *   중앙의 '수집함(Inbox)' 버튼은 다른 버튼과 구별되는 크기, 색상, 아이콘 등으로 시각적 강조를 적용합니다.

2.  **화면 재설계**
    *   **게시판 페이지**: 게시판 페이지는 메인 메뉴의 페이지들과 성격이 달라 각각의 게시판을 따로 만들고, 데스크톱의 사이드 네비게이션, 모바일의 헤더에 있는 햄버거 메뉴 아이콘의 드롭다운 메뉴에 새로운 섹션을 나누어 게시판 링크를 추가합니다.
    *   **활동 페이지**: 활동 페이지는 중요도가 낮아, 프로필 페이지에 통합합니다.
    *   **목표 페이지**: 각 목표 카드는 목표 제목, 설명, 진행률 등 핵심 정보만 간결하게 표시합니다.
    *   **프로젝트 상세 페이지**: 우측 사이드바에 프로젝트 정보와 함께, 이 프로젝트가 속한 **상위 목표**를 명확하게 표시합니다.
    *   **용어 변경**: 애플리케이션 내 모든 'Objective', 'Key Result' 등의 용어를 '목표', '프로젝트', '업무'로 일괄 변경합니다.

#### Phase 3: 워크플로우 기능 구현 (Workflow Feature Implementation)

CPER 사이클을 실제로 동작하게 하는 기능들을 구현합니다.

1.  **수집 (Capture)**
    *   어느 화면에서나 접근 가능한 '글로벌 수집함 입력창' UI 컴포넌트를 개발하고, `Inbox API`와 연동합니다.
    *   화면 우측 하단에 위치하는 FAB 컴포넌트를 생성합니다. CSS 미디어 쿼리 등을 사용하여 **화면 너비가 특정 기준 이상일 때(데스크톱)만 표시**되도록 구현합니다. 클릭 시 '수집함' 기능(빠른 추가 모달 등)이 실행되도록 합니다.

2.  **계획 (Plan)**
    *   '수집함' 페이지에서 각 항목을 '프로젝트' 또는 '업무'로 전환하는 UI/UX를 구현합니다.
    *   업무(Task) 생성/수정 화면에 '프로젝트 연결' 항목을 추가합니다. 이 항목은 필수가 아니며, 사용자가 기존 프로젝트를 검색하여 연결하거나 비워둘 수 있습니다.
    *   프로젝트(Project) 생성/수정 화면에 '상위 목표 연결' 항목을 추가합니다. 이 또한 선택 사항입니다.

3.  **실행 (Execute)**
    *   '오늘 할 일' 페이지를 구현합니다. 마감일이 오늘이거나 사용자가 직접 추가한 업무들을 모아서 보여줍니다.
    *   목표 및 프로젝트 대시보드에 실시간 진행률 바(Progress Bar)를 적용합니다.

4.  **검토 (Review)**
    *   주간 성과(완료된 업무, 프로젝트 진행률 등)를 요약해서 보여주는 '주간 리포트' 페이지를 설계하고 구현합니다.
    *   백엔드는 리포트 생성을 위한 데이터 집계 API를 제공해야 합니다.

#### Phase 4: 문서화 및 최종 정리 (Documentation & Finalization)

1.  **내부 문서 업데이트**: `README.md`, `WorklyPlanning.md` 등 프로젝트 관련 문서를 새로운 워클리 고유 방법론에 맞게 모두 업데이트합니다.
2.  **코드 정리**: 기존 OKR/GTD 관련 로직과 컴포넌트 중 더 이상 사용되지 않는 코드를 모두 제거합니다.

### 4. 기대 효과

이 작업을 통해 워클리는 단순한 업무 관리 툴을 넘어, 사용자가 명확한 목표를 설정하고 달성해나가는 과정을 돕는 강력한 '목표 달성 플랫폼'으로 거듭날 것입니다.
</file>

<file path="instructions/20250727-03.md">
### 작업 지시서

*   **문서 ID**: `20250727-03.md`
*   **작성일**: 2025년 7월 27일
*   **요청자**: 오지훈
*   **담당자**: Gemini

### 1. 개요

점심시간으로 인해 중단되었던 `FilterManager` 적용 작업을 재개하고 마무리합니다. `FilterManager`가 애플리케이션 내에서 필터링 기능을 안정적으로 제공하고, 기존 코드와 원활하게 통합되도록 하는 것이 목표입니다.

### 2. 작업 범위

`FilterManager`와 관련된 모든 파일 및 통합 지점. (예상 경로: `/frontend/src/utils/FilterManager.ts` 또는 유사 경로, 그리고 이를 사용하는 컴포넌트들)

### 3. 상세 작업 내용

1.  **현재 작업 상태 파악**:
    *   `FilterManager` 관련 파일(예: `FilterManager.ts`, `useFilter.ts` 등)을 식별하고, 마지막으로 작업이 중단된 지점을 확인합니다.
    *   관련된 컴포넌트나 모듈에서 `FilterManager`가 어떻게 사용되고 있었는지 검토합니다.

2.  **미완료된 구현 사항 완료**:
    *   `FilterManager` 클래스/모듈의 남은 로직을 완성합니다. (예: 필터 상태 관리, 필터 적용 로직, 필터 초기화 등)
    *   필요한 경우, `FilterManager`가 의존하는 다른 유틸리티 함수나 헬퍼를 구현합니다.

3.  **통합 및 연결**:
    *   `FilterManager`를 사용할 예정이었던 UI 컴포넌트(예: 목록 페이지, 검색 바 등)에 `FilterManager`를 연결하고, 필터링 기능이 정상적으로 동작하도록 구현합니다.
    *   필터 상태가 UI에 올바르게 반영되고, UI 변경이 필터 상태에 영향을 주도록 양방향 바인딩을 확인합니다.

4.  **테스트 및 검증**:
    *   `FilterManager`가 예상대로 동작하는지 수동 테스트를 수행합니다.
    *   다양한 필터 조합과 엣지 케이스(예: 필터 없음, 모든 필터 적용)를 테스트하여 안정성을 확보합니다.
    *   가능하다면, `FilterManager`의 핵심 로직에 대한 단위 테스트를 작성하거나 기존 테스트를 보완합니다.

5.  **코드 정리 및 문서화**:
    *   불필요한 코드나 주석을 제거하고, 코드 컨벤션에 맞춰 정리합니다.
    *   `FilterManager`의 사용법이나 중요한 로직에 대한 주석을 추가하여 향후 유지보수를 용이하게 합니다.

### 4. 결과물

*   `FilterManager`의 구현이 완료되고, 애플리케이션 내에서 필터링 기능이 정상적으로 동작해야 합니다.
*   `FilterManager`가 적용된 UI 컴포넌트에서 필터링 기능이 안정적으로 작동해야 합니다.
*   관련 코드의 가독성과 유지보수성이 확보되어야 합니다.
</file>

<file path="instructions/20250728-01.md">
# 네비게이션 UI 수정 및 빌드 오류 해결

## 목표
이전에 진행하던 네비게이션 UI 개선 작업을 완료하고, 빌드 과정에서 발생하는 모든 오류를 해결하여 안정적인 실행 환경을 확보합니다.

## 세부 작업 내용
1.  **작업 재개:** 중단되었던 네비게이션 UI 수정 작업을 재개하여 마무리합니다.
2.  **빌드 오류 해결:** `npm run build` (또는 관련 빌드 명령어) 실행 시 발생하는 모든 컴파일 및 타입 에러를 해결합니다.
3.  **최종 검증:** 빌드가 성공적으로 완료된 후, 애플리케이션을 실행하여 네비게이션 기능이 정상적으로 작동하는지 최종 확인합니다.
</file>

<file path="instructions/20250728-02.md">
# UI/UX 개선 및 게시판 기능 복구

## 목표

현재 UI/UX의 중복 및 누락된 기능을 수정하고, 게시판 기능을 복구하여 사용자 경험을 개선합니다.

## 세부 작업 내용

1.  **설정 중복 문제 해결:**
    *   현재 프로필 페이지에 존재하는 '설정' 기능이 햄버거 메뉴 아이콘의 설정과 중복됩니다.
    *   이전 지시는 프로필 페이지에 '활동 기능'을 통합하라는 것이었으므로, 프로필 페이지의 중복된 '설정' 기능을 제거합니다. '활동 기능'을 프로필 페이지에 통합하도록 수정합니다.

2.  **게시판 기능 복구 및 링크 추가:**
    *   사라진 게시판 기능을 복구합니다.
    *   햄버거 메뉴 아이콘 내에 '게시판' 섹션을 생성하고, 각 게시판 섹션으로의 개별 링크를 추가합니다.

3.  **게시판 레이아웃 조정:**
    *   게시판은 기본 레이아웃과 다르게 게시판 본연의 기능에 적합한 별도의 레이아웃을 가질 수 있습니다. (필요시)
</file>

<file path="instructions/20250728-03.md">
# 긴급: 로그인 기능 복구 및 CLAUDE 작업 방식 개선

## 목표

CLAUDE의 임의적인 작업으로 인해 망가진 로그인 기능을 즉시 복구하고, 향후 CLAUDE의 작업 방식에서 발생하는 문제점(불충분한 소통, 임의 작업, 불완전한 작업 수행)을 재발 방지할 수 있는 방안을 마련합니다.

## 세부 작업 내용

1.  **로그인 기능 즉시 복구:**
    *   CLAUDE가 임의로 변경하여 작동하지 않는 로그인 페이지 및 관련 기능을 최우선으로 복구합니다.
    *   기존에 개발된 로그인 기능이 정상적으로 작동하도록 만듭니다.

2.  **CLAUDE 작업 방식 개선 및 재발 방지:**
    *   **충분한 소통 의무화:** CLAUDE가 작업을 수행하기 전, 반드시 대표님과 충분한 소통을 거쳐 작업 범위와 방식을 명확히 확인하도록 합니다. 임의적인 변경은 절대 금지합니다.
    *   **작업 범위 준수:** 지시받은 작업 범위 내에서만 수행하고, 지시하지 않은 부분은 절대 건드리지 않도록 합니다.
    *   **완전한 작업 수행:** 할당된 작업을 축소시키거나 불완전하게 수행하지 않고, 처음부터 끝까지 책임지고 완료하도록 합니다.
    *   **문제 발생 시 즉각 보고:** 작업 중 이해가 안 되거나 문제가 발생할 경우, 대답을 회피하지 않고 즉시 대표님께 보고하고 설명을 요청하도록 합니다.

## 중요 사항

*   현재 대표님의 스트레스가 극심하며, 불필요한 토큰 낭비와 시간 소모에 대한 불만이 매우 높습니다.
*   CLAUDE의 임의적인 작업 방식은 프로젝트 진행에 심각한 차질을 초래하고 있습니다.
*   이 지시서는 CLAUDE의 작업 방식에 대한 강력한 경고이자, 향후 작업의 기준이 될 것입니다.
</file>

<file path="instructions/20250728-04.md">
# UI/UX 개선 및 기능 구현

## 목표

현재 UI/UX의 불일치 및 중복 문제를 해결하고, '수집함' 기능을 대표님의 의도에 맞게 재정의하며, 전반적인 사용자 경험을 간결하고 일관되게 개선합니다.

## 세부 작업 내용

1.  **FAB (Floating Action Button) 및 '수집함' 기능 통합 및 간결화:**
    *   **문제점:**
        *   FAB은 모든 페이지의 추가 기능을 담당하는 간결한 UI로 기획되었으나, 현재 '수집함' 페이지에서만 '빠른 수집' 기능으로 제한되어 있습니다.
        *   네비게이션 중앙에 '수집함' 버튼이 FAB을 대체할 것으로 예상되었으나, '수집함'이 별도의 페이지로 구현되어 있어 혼란을 야기합니다.
        *   업무, 프로젝트, 목표 페이지에서는 여전히 기존의 '업무 추가', '프로젝트 추가', '목표 추가' 기능이 별도로 존재하여 UI가 섞여 있고 일관성이 부족합니다.
    *   **개선 방향 (간결한 UI 지향):**
        *   **'수집함'의 역할 재정의:** '수집함'은 단순히 아이디어를 담는 페이지가 아니라, 업무, 프로젝트, 목표 등 모든 종류의 항목을 추가할 수 있는 **핵심적인 '생성' 기능의 진입점**이 되어야 합니다.
        *   **'수집함' 형태 변경:** '수집함'은 별도의 페이지가 아닌, **모달(Modal) 형태**로 구현되어야 합니다.
        *   **FAB의 역할 통합:** 모든 페이지에서 FAB은 '수집함' 모달을 여는 단일한 역할을 수행하도록 변경합니다. FAB을 클릭하면 '수집함' 모달이 열려 모든 종류의 항목을 생성할 수 있도록 합니다.
        *   **기존 추가 기능 제거:** 업무, 프로젝트, 목표 페이지에 개별적으로 존재하는 '업무 추가', '프로젝트 추가', '목표 추가' 등의 중복된 UI/UX를 제거하고, FAB을 통한 '수집함' 모달 진입으로 통합합니다.

2.  **'Google로 시작하기' 카드 위치 및 간격 조정:**
    *   'Google로 시작하기' 카드의 간격을 현재보다 조금 더 오른쪽으로 이동시킵니다.
    *   해당 카드를 헤더 바로 아래에 위치하도록 조정합니다.

3.  **로그아웃 상태에서 필터 숨기기:**
    *   사용자가 로그아웃 상태일 때, 불필요한 필터 UI가 표시되지 않도록 숨깁니다.

4.  **'수집함'의 수집 이후 단계 구현 명확화:**
    *   '수집함'에 수집된 아이템들이 이후 어떤 워크플로우(예: 업무, 프로젝트, 목표로 전환)를 통해 처리되는지 명확히 정의하고 구현합니다.
    *   현재 '수집함'이 단순히 아이디어를 담는 공간이라면, 이를 실제 실행 가능한 항목으로 전환하는 UI/UX 흐름을 구체화합니다.
</file>

<file path="instructions/20250801-01.md">
# 작업 지시서: 업무 카드 UI/UX 개선 및 기능 추가

## 1. 개요

현재 데스크톱 환경에서 업무 카드에 마우스를 올렸을 때 나타나는 액션 버튼들의 사용자 경험이 자연스럽지 않고 디자인적으로도 개선이 필요합니다. 또한, '더보기' 메뉴가 다른 카드에 가려지는 버그가 있습니다.

본 작업의 목표는 데스크톱 환경에서 업무 카드의 UI를 더 직관적으로 개선하고, 드래그 앤 드롭을 통한 마감일 지정 기능을 추가하여 사용성을 극대화하는 것입니다.

## 2. 세부 요구사항

### 대상 컴포넌트
- `frontend/src/components/tasks/ResponsiveTaskCard.tsx`

### 2.1. 데스크톱 UI 변경 (모바일은 기존 스와이프 유지)

- **기존 호버 액션 버튼 제거**: 현재 마우스를 올렸을 때 나타나는 '날짜 설정', '삭제' 버튼을 제거합니다.
- **'더보기' 버튼 고정 배치**:
    - 카드 우측 마감일 표시 영역 옆에 '더보기(...)' 아이콘 버튼을 항상 보이도록 고정 배치합니다.
    - 이 버튼은 데스크톱 환경에서만 보이며, 모바일(터치) 환경에서는 보이지 않아야 합니다.
- **'더보기' 메뉴 항목 통합**:
    - '더보기' 버튼 클릭 시 나타나는 메뉴에 다음 항목들을 포함합니다.
        1.  **날짜 설정**
        2.  **위임**
        3.  **보류**
        4.  **프로젝트로 전환**
        5.  **삭제** (사용자 실수를 방지하기 위해 클릭 시 확인 절차를 추가하는 것을 권장합니다.)

### 2.2. 버그 수정

- **'더보기' 메뉴 Z-index 문제 해결**:
    - 현재 '더보기' 메뉴가 펼쳐졌을 때 아래에 있는 카드 컴포넌트 밑으로 가려지는 현상이 발생합니다.
    - 메뉴의 `z-index` 값을 충분히 높게 설정하여 항상 다른 모든 요소들 위에 표시되도록 수정합니다.

### 2.3. 신규 기능 개발 (데스크톱 전용)

- **드래그 앤 드롭으로 마감일 지정**:
    - 사용자가 데스크톱 환경에서 업무 카드를 드래그할 수 있도록 구현합니다.
    - 화면에 표시된 캘린더(달력)의 특정 날짜 위로 카드를 드롭하면, 해당 날짜가 업무의 '마감일'로 자동 설정되도록 개발합니다.
    - 이 기능은 데스크톱의 마우스 드래그 앤 드롭으로만 동작해야 하며, 기존의 모바일 스와이프 및 롱프레스 드래그 기능에 영향을 주지 않아야 합니다.

## 3. 참고 사항

- 모든 변경 사항은 `ResponsiveTaskCard.tsx` 컴포넌트를 중심으로 이루어져야 합니다.
- `isTouch` 상태를 활용하여 데스크톱과 모바일 환경의 UI/UX를 명확하게 분리해야 합니다.
- 모바일 환경의 기존 스와이프 액션(삭제, 위임, 보류 등)은 반드시 그대로 유지되어야 합니다.
</file>

<file path="instructions/20250801-02.md">
# 작업 지시서: 캘린더 뷰 및 필터 기능 개선, 디자인 가이드 준수 강조

## 1. 개요

현재 캘린더 뷰(`CollapsibleCalendar.tsx`) 내에 불필요한 '필터된 업무 표시 영역'이 존재하여 UI를 복잡하게 만들고 있습니다. 또한, 캘린더에서 적용한 필터가 메인 업무 목록과 연동되지 않아 사용자에게 혼란을 줍니다.

가장 심각한 문제는, **반복적으로 지시했음에도 불구하고 또다시 디자인 가이드를 위반하여 주황색을 사용한 점**입니다. 이는 프로젝트의 통일성을 심각하게 저해하는 행위입니다.

본 작업의 목표는 캘린더 뷰의 UI를 정리하고, 필터 로직을 통합하며, **디자인 가이드를 철저히 준수**하여 일관된 사용자 경험을 제공하는 것입니다.

## 2. 세부 요구사항

### 2.1. UI/UX 개선

-   **'필터된 업무 표시 영역' 완전 제거**:
    -   **대상 컴포넌트**: `frontend/src/components/tasks/CollapsibleCalendar.tsx`
    -   현재 캘린더 하단에 "마감일이 설정되지 않은 업무들입니다. 드래그해서 날짜를 지정해보세요." 텍스트와 함께 표시되는 영역 전체를 **즉시 삭제**합니다. 캘린더 뷰는 순수하게 달력의 기능만 제공해야 합니다.

-   **필터 로직 통합**:
    -   사용자가 캘린더 뷰 내에서 필터(예: 프로젝트별, 태그별 필터)를 적용했을 때, 해당 필터 조건이 **메인 업무 페이지의 목록에도 동일하게 즉시 적용**되어야 합니다.
    -   이를 위해 캘린더와 업무 목록 간의 상태 관리 로직을 재검토하고, 필터 상태가 상위 컴포넌트나 전역 상태 관리 시스템(Zustand, Redux 등)을 통해 공유되도록 구조를 개선하십시오.

### 2.2. 디자인 가이드 준수 (매우 중요)

-   **주황색 사용 즉시 중단 및 파란색으로 대체**:
    -   **몇 번을 강조했는지 모르겠습니다. 또다시 '오늘 마감' 등의 알림에 주황색(`text-orange-500`)을 사용했습니다. 이는 절대 용납할 수 없습니다.**
    -   프로젝트의 모든 마감일 관련 색상 로직은 `ResponsiveTaskCard.tsx`의 `getDueDateVisualization` 함수에서 구현된 **파란색 스케일(Primary Blue)을 반드시 따라야 합니다.**
    -   지금 즉시 `TaskCard.tsx`의 `getDueDateInfo` 함수를 포함하여 프로젝트 전체에서 주황색을 사용하는 모든 사례를 찾아내어, 지정된 파란색 시스템으로 전면 수정하십시오.

-   **디자인 시스템 숙지 및 준수**:
    -   **이것이 마지막 경고입니다.** 앞으로 단 한 번이라도 디자인 가이드를 위반하는 사례가 발견될 경우, 해당 작업물은 이유를 불문하고 반려될 것입니다.
    -   Workly의 브랜드 정체성은 **파란색**입니다. 모든 시각적 요소는 이 원칙을 중심으로 구현되어야 합니다.

## 3. 결론

UI 개선과 기능 통합도 중요하지만, **정해진 규칙과 디자인 시스템을 따르는 것은 협업의 가장 기본**입니다. 이번 지시를 통해 모든 개발자는 디자인 가이드 준수의 중요성을 다시 한번 명확히 인지하고, 코드 한 줄을 작성하더라도 전체적인 통일성을 해치지 않도록 각별히 주의하기 바랍니다.
</file>

<file path="instructions/20250801-03.md">
# 작업 지시서: 업무 페이지 핵심 필터 기능 구현

## 1. 개요

`WORKLY_PRD.md`에 명시된 핵심 기능임에도 불구하고, 현재 업무 페이지에는 사용자가 원하는 업무를 효율적으로 찾아볼 수 있는 필터 시스템이 부재합니다.

본 작업의 목표는 PRD에 정의된 4가지 핵심 기준(`담당자`, `마감일`, `상태`, `소속`)에 따라 업무를 필터링하는 기능을 구현하여, 사용자가 자신의 업무를 체계적으로 관리하고 집중할 수 있도록 돕는 것입니다.

## 2. 세부 요구사항

### 2.1. 필터 UI 위치 및 구성

-   **위치**: PRD 3.2.B 항에 따라, 필터 UI는 '업무' 페이지의 제목 바로 아래에 위치해야 합니다.
-   **UI 컴포넌트**:
    -   자주 사용하는 핵심 필터(예: '내 업무')는 PRD 2.5에 정의된 `Filter Chip` 컴포넌트를 사용하여 버튼 형태로 상시 노출합니다.
    -   나머지 상세 필터들은 '필터' 아이콘 버튼을 클릭했을 때 나타나는 패널 내에서 설정할 수 있도록 구성합니다.

### 2.2. 구현할 필터 종류

#### A. 담당자 필터 (Assignee Filter)

-   **기능**: 특정 사용자에게 할당된 업무를 기준으로 필터링합니다.
-   **세부 구현**:
    -   **'내 업무' 필터 칩**: 클릭 시 현재 로그인한 사용자에게 할당된 업무만 보여주는 기본 필터입니다.
    -   **상세 필터 패널**: 현재 참여 중인 프로젝트의 멤버 목록을 드롭다운으로 제공하여, 특정 담당자의 업무를 선택해서 볼 수 있도록 합니다.

#### B. 마감일 필터 (Due Date Filter)

-   **기능**: 업무의 마감일을 기준으로 필터링합니다.
-   **세부 구현**: 상세 필터 패널에서 다음 옵션을 제공합니다.
    -   기한 초과
    -   오늘 마감
    -   이번 주 내 마감
    -   마감일 없음
    -   (선택 사항) 사용자가 특정 날짜 범위를 직접 선택할 수 있는 캘린더 UI

#### C. 상태 필터 (Status Filter)

-   **기능**: 업무의 진행 상태(예: 할 일, 진행 중, 완료)에 따라 필터링합니다.
-   **세부 구현**: 상세 필터 패널에서 `To-do`, `In-progress`, `Done` 등 업무 상태를 선택할 수 있는 옵션을 제공합니다.

#### D. 소속 필터 (Context Filter)

-   **기능**: 업무가 속한 '프로젝트' 또는 '목표'를 기준으로 필터링합니다.
-   **세부 구현**: 상세 필터 패널에서 사용자가 참여하고 있는 프로젝트 및 목표 목록을 드롭다운으로 제공하여, 특정 컨텍스트에 해당하는 업무만 모아볼 수 있도록 합니다.

## 3. 기술적 고려사항

-   **복수 필터 적용**: 사용자가 여러 필터 조건(예: '내 업무' 중 '오늘 마감'인 것)을 동시에 적용할 수 있어야 합니다.
-   **상태 유지**: 필터 조건은 URL 쿼리 파라미터에 저장하여, 페이지를 새로고침하거나 링크를 공유하더라도 필터 상태가 유지되도록 구현하는 것을 권장합니다.
-   **성능 최적화**: 필터링은 클라이언트 사이드에서 처리하기보다, 백엔드 API에 필터 조건을 파라미터로 전송하여 서버로부터 필터링된 데이터를 받아오는 방식으로 구현해야 합니다.

## 4. 결론

필터 시스템은 PRD에 정의된 핵심 사용자 경험의 일부입니다. 이 기능이 구현되면 사용자는 방대한 업무 목록 속에서 길을 잃지 않고, 가장 중요하고 시급한 일에 집중할 수 있게 될 것입니다. 명세에 따라 정확하고 견고하게 구현해주시기 바랍니다.
</file>

<file path="instructions/20250801-04.md">
# 작업 지시서: 업무 상세 기능 개발

## 1. 개요

현재 Workly는 업무를 생성하고 목록으로 보는 기본 기능에 머물러 있습니다. 사용자가 업무의 구체적인 내용을 작성하고, 다른 업무와의 관계를 설정하며, 시간을 관리하는 등 세부적인 관리를 할 수 있는 '업무 상세' 기능의 개발이 시급합니다.

본 작업의 목표는 `WORKLY_PRD.md` 4.1.D 항에 명시된 바와 같이, 마크다운 에디터를 기반으로 한 업무 상세 화면의 핵심 기능들을 구현하는 것입니다.

## 2. 세부 요구사항

### 대상 화면
-   업무 카드 탭(클릭) 시 진입하는 **'업무 상세'** 화면

### 2.1. UI: 마크다운 에디터 도입

-   업무의 내용(content)을 작성하는 핵심 영역은 **마크다운(Markdown) 에디터**로 구현합니다.
-   사용자는 이를 통해 텍스트 서식, 링크, 이미지 첨부 등 풍부한 형식의 업무 내용을 작성할 수 있어야 합니다.
-   에디터는 직관적이어야 하며, 실시간으로 마크다운 미리보기를 제공하는 것을 권장합니다.

### 2.2. 핵심 기능 구현

#### A. 체크리스트 (하위 업무)

-   **기능**: 마크다운 에디터 내에서 사용자가 하위 체크리스트(`- [ ]`, `- [x]`)를 생성하고, 완료 상태를 직접 토글할 수 있어야 합니다.
-   **구현**: 단순 텍스트를 넘어, 체크박스가 실제로 상호작용 가능한 컴포넌트로 렌더링되어야 합니다. 체크리스트의 완료 상태는 업무의 전체 진행률에 반영될 수 있습니다.

#### B. 업무 관계 설정 (선행/후행)

-   **기능**: 다른 업무와의 의존 관계를 설정할 수 있는 기능을 구현합니다.
-   **UI**: '관계 추가' 또는 '의존성 설정'과 같은 버튼을 통해 다른 업무를 검색하고 연결할 수 있는 인터페이스를 제공해야 합니다.
-   **세부 구현**:
    -   **선행 업무**: 이 업무를 시작하기 전에 반드시 완료되어야 하는 업무를 지정합니다.
    -   **후행 업무**: 이 업무가 완료되어야만 시작할 수 있는 업무를 지정합니다.
    -   설정된 관계는 업무 상세 화면에 명확하게 표시되어야 합니다.

#### C. 위키 레퍼런스 첨부

-   **기능**: 업무 내용과 관련된 내부 위키(지식 베이스) 문서를 쉽게 참조하고 연결할 수 있는 기능을 제공합니다.
-   **구현**: 에디터 내에서 특정 키워드(예: `[[`)를 입력했을 때 위키 문서를 검색하고 첨부할 수 있는 자동 완성 기능을 구현하거나, 별도의 '위키 연결' 버튼을 통해 문서를 검색/첨부하는 방식을 고려할 수 있습니다.

#### D. 시간 추정 및 기록

-   **기능**: 업무에 소요될 시간을 계획하고, 실제 투입된 시간을 기록하는 기능을 구현합니다.
-   **UI**: 업무 상세 정보 영역에 '추정 시간'과 '기록된 시간'을 입력하고 확인할 수 있는 명확한 필드를 제공합니다.
-   **세부 구현**:
    -   **시간 추정**: 사용자가 예상 소요 시간을 시간 단위로 입력할 수 있습니다.
    -   **시간 기록**: 사용자가 실제 작업 시간을 기록할 수 있습니다. (예: 수동 입력 또는 시작/정지 타이머)

## 3. 데이터 모델 고려사항

-   `Task` 객체 모델에 다음 필드들이 추가되거나 수정되어야 합니다.
    -   `content` (String, Markdown)
    -   `dependencies` (Array of Objects: `{ type: 'precedes' | 'follows', taskId: String }`)
    -   `wikiReferences` (Array of Strings: `wikiPageId`)
    -   `estimatedHours` (Number)
    -   `loggedHours` (Number)

## 4. 결론

업무 상세 기능은 Workly를 단순한 할 일 목록 앱에서 강력한 업무 관리 도구로 발전시키는 핵심적인 단계입니다. PRD의 요구사항을 정확히 이해하고, 사용자가 업무의 모든 맥락을 한 곳에서 관리할 수 있도록 견고하게 구현해주시기 바랍니다.
</file>

<file path="instructions/20250801-05.md">
# 작업 지시서: 프론트엔드 Mock Data를 실제 백엔드 API 연동으로 전환

## 1. 개요

현재 프론트엔드는 UI 개발 속도와 편의를 위해 임시 목업(Mock) 데이터를 사용하고 있습니다. 이제 주요 UI 개발이 완료되었으므로, 실제 백엔드 API와 연동하여 실시간 데이터를 기반으로 동작하는 완전한 기능의 애플리케이션으로 전환해야 합니다.

이 작업은 Workly의 핵심 기능을 완성하고, 사용자가 자신의 실제 데이터를 보고 상호작용할 수 있게 만드는 매우 중요한 단계입니다.

## 2. 선행 조건

-   **중요**: 백엔드 서버는 대표님께서 항상 실행하고 있으므로, **개발자가 직접 서버를 실행하지 마십시오.**
-   프론트엔드 개발에 필요한 API 엔드포인트는 모두 정상적으로 동작하고 있는 상태입니다.
-   데이터베이스 또한 대표님께서 관리하고 있으므로, 연결 상태나 테스트 데이터 유무를 걱정할 필요 없습니다. 프론트엔드 개발에만 집중하십시오.

## 3. 세부 요구사항

### 3.1. 기존 Mock 데이터 완전 제거

-   프론트엔드 코드베이스 전체에서 하드코딩된 모든 목업 데이터 배열(예: `mockTasks`, `sampleProjects` 등)을 찾아 **모두 제거**합니다.
-   이 데이터들은 주로 컴포넌트의 초기 상태를 설정하거나, 개발 중 API 없이 UI를 확인하기 위한 목적으로 사용되었을 것입니다. 이제 그 역할은 끝났습니다.

### 3.2. API 클라이언트 로직 수정

-   **대상 파일**: `frontend/src/lib/api.ts` (또는 API 호출을 관리하는 다른 핵심 파일)
-   현재 목업 데이터를 반환하도록 되어 있는 함수들을, 실제 `fetch` 또는 `axios`를 사용한 **비동기 API 호출로 전면 수정**합니다.
-   API의 기본 URL은 환경 변수(`process.env.NEXT_PUBLIC_API_URL`)를 사용해야 합니다. (예: `http://localhost:3001/api`)
-   API 경로는 `shared/constants/api-endpoints.ts`에 정의된 엔드포인트 상수를 반드시 활용하여 일관성을 유지하십시오.

### 3.3. 데이터 Fetching 로직 교체

-   **대상**: 데이터를 필요로 하는 모든 페이지 및 컴포넌트 (예: `frontend/src/app/tasks/page.tsx`)
-   `useEffect`, `SWR`, `React Query` 등 현재 사용 중인 데이터 페칭 라이브러리/훅에서 목업 데이터를 불러오는 부분을, 위에서 수정한 **API 클라이언트 함수 호출로 교체**합니다.
-   API 호출 시 **로딩(loading) 및 에러(error) 상태를 사용자에게 명확히 피드백**해야 합니다. (예: 로딩 스피너, 에러 메시지 표시)

### 3.4. 데이터 타입 일치 확인

-   백엔드 API가 반환하는 데이터의 구조가 프론트엔드에서 사용하는 타입과 완벽하게 일치하는지 검증합니다.
-   모든 데이터 타입은 **`shared/types` 디렉토리의 파일을 단일 진실 공급원(Single Source of Truth)으로 삼아 동기화**되어야 합니다. 불일치 시, 백엔드 또는 프론트엔드의 타입을 수정하여 일관성을 확보하십시오.

### 3.5. 인증 처리

-   인증이 필요한 모든 API 엔드포인트 요청 헤더에 **인증 토큰(JWT 등)을 포함**시켜야 합니다.
-   `frontend/src/lib/auth.ts` 또는 유사 파일에 구현된 인증 관련 로직을 활용하여 토큰을 가져와 요청에 추가하십시오.

## 4. 검증

-   프론트엔드 애플리케이션을 실행하고, 각 페이지(업무, 프로젝트 등)에 백엔드 데이터베이스의 **실제 데이터가 정상적으로 표시되는지 확인**합니다.
-   데이터 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 등 **모든 CRUD 기능이 API를 통해 정상적으로 동작하는지 철저히 테스트**합니다.

## 5. 결론

이 작업이 완료되면, Workly는 비로소 살아있는 서비스가 됩니다. 정적인 UI에서 동적인 애플리케이션으로의 전환인 만큼, 한 치의 오차도 없이 견고하게 구현해주시기 바랍니다.
</file>

<file path="instructions/20250801-06.md">
# 작업 지시서: Task 13 최종 완료

**목표:** Taskmaster 서브태스크 13.7(백엔드)과 13.8(프론트엔드 통합)을 순차적으로 완료하여, 메인 태스크 13번 전체를 최종 완료합니다.
</file>

<file path="references/SuperClaude Guide.md">
# **SuperClaude 전문가 가이드: AI 기반 개발 워크플로우 마스터하기**

---

## **1부: SuperClaude 패러다임 \- AI 협업을 위한 새로운 철학**

AI 코딩 어시스턴트의 등장은 개발 환경에 혁신을 가져왔지만, 숙련된 개발자들은 이내 한계에 부딪혔습니다. 표준 AI 어시스턴트는 강력한 도구일 뿐, 진정한 개발 파트너가 되기에는 부족한 점이 많았습니다.1 이들은 장기적인 맥락을 기억하지 못하는 'AI 기억 상실' 문제를 겪고, 프로젝트의 특수성을 고려하지 않은 일반적인 조언을 제공하며, 기획, 아키텍처 설계, 테스트와 같은 핵심 엔지니어링 단계를 건너뛰는 경향이 있습니다.1 SuperClaude는 바로 이 지점에서 출발합니다. 이는 단순한 명령어 모음이 아니라, 강력하지만 일반적인 AI에 전문 소프트웨어 엔지니어링 원칙을 적용하여 진정한 협업 파트너로 변모시키는 철학적 프레임워크입니다.

### **1.1. 일반적인 어시스턴트에서 전문화된 파트너로**

SuperClaude는 Claude Code를 위한 '두뇌 업그레이드' 또는 경량의 '구성 프레임워크'로 작동합니다.1 추가적인 코드나 외부 도구 없이, 프로젝트에 특정 구성 파일을 추가하는 것만으로 AI를 전문적이고, 맥락을 인지하며, 체계적인 개발 파트너로 탈바꿈시킵니다.1 이는 개발자가 AI와 상호작용하는 방식을 근본적으로 바꾸어, 단순한 질의응답을 넘어선 체계적인 협업을 가능하게 합니다.

### **1.2. SuperClaude 철학의 세 가지 기둥**

SuperClaude의 효과는 세 가지 핵심 원칙에 기반합니다. 이 원칙들은 AI의 내재적 약점을 보완하고 개발 프로세스의 품질을 보장하기 위해 설계되었습니다.

#### **1.2.1. 기둥 1: 증거 기반 운영 (Evidence-Based Operation)**

이것은 SuperClaude의 가장 심오한 원칙으로, AI의 '환각(hallucination)' 현상, 즉 잘못된 정보를 사실인 것처럼 제시하는 문제를 해결하기 위해 고안되었습니다.1 이 프레임워크는 AI가 "이것이 더 낫다"와 같이 근거 없는 주장을 하는 것을 엄격히 금지합니다.4 대신, "아마도", "가능성이 있다", "일반적으로"와 같은 신중하고 확률적인 언어를 사용하도록 요구하며, 가장 중요하게는 공식 문서를 참조하여 자신의 주장을 증거로 뒷받침하도록 강제합니다.1 이는 종종 공식 라이브러리 문서를 자동으로 조회하는

Context7 MCP(Multi-Context Processor) 도구와의 통합을 통해 이루어집니다.1

#### **1.2.2. 기둥 2: 토큰 경제 (The Token Economy) \- 규모에 맞는 효율성**

이 기둥은 대규모 언어 모델(LLM)이 가진 장황함과 컨텍스트 창 제한 문제를 해결합니다. 이는 복잡한 대규모 프로젝트에서 큰 장애물이 됩니다.1 SuperClaude는 '초압축 모드(UltraCompressed Mode)'를 사용하여 이 문제를 해결합니다. 이 모드는 '→'(결과로 이어짐), 약어, 글머리 기호와 같은 기호를 활용하여 명확성을 잃지 않으면서 토큰 사용량을 최대 70%까지 획기적으로 줄입니다.1 이를 통해 더 큰 프로젝트 컨텍스트를 처리하고, 처리 속도를 높이며, API 호출 비용을 크게 절감할 수 있습니다.4 이와 더불어 '코드 경제(Code Economy)' 원칙은 AI가 기본적으로 군더더기 없고, 상용구(boilerplate)가 없으며, 주석이 없는 간결한 코드를 생성하도록 지시하여 순수한 기능성에 집중하게 합니다.1

#### **1.2.3. 기둥 3: 규칙 기반의 엄격함과 심각도 시스템 (The Severity System)**

SuperClaude는 소프트웨어 엔지니어링 모범 사례를 계층적인 규칙 시스템으로 체계화합니다.1 각 규칙은 1부터 10까지의 심각도 등급을 가집니다. \*\*CRITICAL \*\* 등급의 규칙은 협상의 여지가 없는 차단 요소로, "비밀 정보를 절대 커밋하지 말 것"과 같은 보안 규정이나 "공유 브랜치에 절대 강제 푸시하지 말 것"과 같은 Git 보호 장치를 포함합니다.1

**HIGH \[7-9\]** 등급의 규칙은 코드 품질 및 성능과 관련된 것으로, AI가 수정을 강력히 요구합니다. 반면 **MEDIUM \[4-6\]** 및 **LOW \[1-3\]** 등급의 규칙은 경고나 제안을 트리거하여, 개발자의 작업을 방해하지 않으면서 더 나은 방향으로 유도합니다.1

이러한 접근 방식은 프롬프트 엔지니어링의 진화를 보여줍니다. 개별 개발자들이 발견한 효과적인 프롬프트나 워크플로우는 공유하거나 유지보수하기 어렵습니다.2 SuperClaude는 이러한 비공식적인 모범 사례들을 명령어, 페르소나, 규칙이라는 형태로 공식화하여 배포 가능한 패키지로 만들었습니다.4 이는 단순한 '프롬프팅'에서 '프롬프트 엔지니어링'으로, 그리고 마침내 'AI 상호작용 프레임워크'를 구축하는 단계로의 발전을 의미합니다. 이는 개별 스크립트 작성에서 견고한 소프트웨어 라이브러리를 구축하는 과정과 유사합니다. SuperClaude는 전문가 수준의 AI 상호작용을 반복 가능하고 접근 가능하게 만드는 이러한 트렌드의 선구적인 사례입니다.

---

## **2부: 설치 및 환경 구성**

SuperClaude의 강력한 기능을 활용하기 위해서는 정확한 설치와 환경 구성이 선행되어야 합니다. 이 섹션에서는 플랫폼별 고려사항과 핵심 요소인 MCP 서버 설정을 포함한 포괄적인 설치 가이드를 제공합니다.

### **2.1. 전제 조건: 개발 환경 준비**

SuperClaude 설치 전에 몇 가지 필수 요소를 갖추어야 합니다.

* **Claude Code:** SuperClaude는 Claude Code를 위한 프레임워크이므로, 작동하는 Claude Code 설치가 가장 기본적인 요구사항입니다. 이는 보통 터미널 접근 권한이 포함된 유료 Claude Pro 또는 Max 구독을 필요로 합니다.6  
* **플랫폼 지원:** Linux와 macOS를 기본적으로 지원합니다. Windows 사용자의 경우, WSL(Windows Subsystem for Linux) 설치가 필수적입니다.3 WSL은 Windows 내에서 Linux 환경을 구동할 수 있게 해주는 가상화 계층으로, 설치 과정에서 약간의 지연이나 시스템 부하를 유발할 수 있습니다.8  
* **Python:** 설치 스크립트를 실행하기 위해 Python 3.7 이상 버전이 필요합니다.  
* **Git:** 저장소 복제뿐만 아니라, SuperClaude의 핵심 기능인 'Git 기반 메모리'를 사용하기 위해 필수적입니다.3

### **2.2. 설치 가이드: SuperClaude v3 설정하기**

* **1단계: 기존 버전 정리 (v2 사용자):** v3는 v2와 구조가 완전히 다르므로, 업그레이드하는 사용자는 반드시 기존 v2 제거 프로그램을 실행한 후, 관련 디렉토리(SuperClaude/, \~/.claude/shared/, \~/.claude/commands/)를 수동으로 삭제하여 충돌을 방지해야 합니다.10  
* **2단계: Python 패키지 설치 (권장):** 공식적으로 권장되는 방법은 PyPI를 통해 uv를 사용하는 것입니다. 터미널에 uv add SuperClaude 명령어를 입력하여 최신 안정 버전을 설치합니다.  
* **3단계: 설치 프로그램 실행:** 패키지 설치 후, Claude Code를 구성하기 위해 SuperClaude 설치 프로그램을 실행해야 합니다. python3 \-m SuperClaude install 또는 간단히 SuperClaude install 명령어를 사용합니다.  
* **설치 프로필:** 사용자는 필요에 따라 다양한 설치 프로필을 선택할 수 있습니다.  
  * \--interactive: 특정 구성 요소를 직접 선택하고 싶을 때 사용합니다.  
  * \--minimal: 핵심 프레임워크만 설치하는 최소한의 구성입니다.  
  * \--profile developer: 모든 도구를 포함하는 포괄적인 개발자용 설정입니다.

### **2.3. MCP 서버 통합: 잠재력 극대화**

MCP(Multi-Context Processors)는 SuperClaude에 확장된 기능을 제공하는 외부 서버 측 도구입니다.2 설치 프로그램이 이들을 자동으로 설정할 수 있습니다. 핵심적인 4개의 MCP는 다음과 같습니다.

* **Context7 (C7):** 문서 연구 도구입니다. '증거 기반 운영' 원칙의 핵심으로, 공식 라이브러리 문서와 디자인 패턴을 가져옵니다.1  
* **Sequential:** 심층 사고 도구입니다. 복잡하고 여러 단계에 걸친 문제 해결 과정을 AI가 수행하도록 돕습니다.1  
* **Magic:** UI 생성 도구입니다. React와 같은 프레임워크를 위한 최신 UI 컴포넌트를 생성할 수 있습니다.1  
* **Playwright / Puppeteer:** 브라우저 자동화 및 테스트 도구입니다. 작업 결과를 검증하고 엔드투엔드 테스트를 실행하는 데 사용됩니다.1

이러한 설치 과정은 SuperClaude의 특성을 명확히 보여줍니다. GitHub Copilot과 같이 IDE에 깊숙이 통합되어 클릭 한 번으로 설치되는 도구와 달리 13, SuperClaude는 여러 단계의 명령줄 기반 설정을 요구합니다. 특히 Windows 사용자의 WSL 요구사항은 추가적인 복잡성을 더합니다.8 이는 SuperClaude가 대중적인 접근성보다는 강력한 기능과 체계적인 워크플로우를 위해 초기 설정의 불편함을 감수할 의향이 있는 파워 유저를 대상으로 하는 도구임을 시사합니다. 향후 계획된 v4의 다른 CLI와의 호환성 지원은 이러한 진입 장벽을 낮추기 위한 전략적 움직임으로 보입니다.

---

## **3부: 명령어 무기고 \- SuperClaude 명령어 심층 분석**

이 섹션은 여러 자료에 흩어져 있는 정보를 통합하여 SuperClaude의 명령어에 대한 포괄적인 레퍼런스를 제공합니다. 명령어 수에 대한 혼동을 명확히 하고 실제 사용 예시를 제시합니다.

### **3.1. 명령어 구조 이해하기**

* **구문:** v3의 모든 명령어는 Claude Code의 기본 명령어와 구별하기 위해 /sc: 접두사를 사용합니다 (예: /sc:implement).10 이는 v2에서 사용되던  
  /user: 접두사와 달라진 주요 변경 사항입니다.1  
* **명령어 개수:** 여러 자료에서 17개, 18개, 19개의 명령어를 언급하지만 3, 최신 공식 v3 문서는 일관되게  
  **16개의 필수 명령어**를 명시하고 있습니다.10 이 보고서는 이 16개 명령어를 기준으로 합니다.  
* **플래그와 체이닝:** 명령어는 \--react, \--security와 같은 플래그를 통해 강력해지며, /sc:design 실행 후 /sc:implement를 사용하는 것처럼 논리적인 워크플로우로 연결될 수 있습니다.2

### **3.2. 주요 명령어 변경: /build vs. /sc:implement**

v2에서 v3로 업그레이드하는 사용자에게 가장 혼란을 주는 부분 중 하나입니다. v2에서는 /build 명령어가 일반적인 기능 구현에 사용되었습니다. v3에서는 이 기능이 /sc:implement로 이전되었습니다. 새로운 /sc:build 명령어는 이제 컴파일, 패키징, 빌드 프로세스 실행과 같이 좁은 범위의 작업에만 초점을 맞춥니다.10

* **마이그레이션 예시:** v2 명령어 v2 /build myFeature는 v3에서 v3 /sc:implement myFeature로 대체되어야 합니다.10

### **3.3. SuperClaude v3 명령어 레퍼런스 표**

이 표는 현재 접근이 어려운 공식 문서 대신 16, 명령어의 기능과 사용법을 한눈에 파악할 수 있는 핵심 자료입니다.

| 카테고리 | 명령어 | 기능 | 플래그를 포함한 사용 예시 |
| :---- | :---- | :---- | :---- |
| **개발** | /sc:implement | 새로운 기능, 함수, 컴포넌트를 구현하는 주 명령어. | /sc:implement a user login form \--persona-frontend \--react |
|  | /sc:build | 프로젝트를 컴파일, 패키징하거나 빌드 프로세스를 실행. | /sc:build \--prod |
|  | /sc:design | 기술 명세, UI/UX 디자인, 아키텍처 청사진을 생성. | /sc:design a REST API for user management \--ddd \--persona-architect |
| **분석** | /sc:analyze | 코드베이스에 대한 포괄적인 분석을 수행. | /sc:analyze the current file for security vulnerabilities \--security \--persona-security |
|  | /sc:troubleshoot | 이슈, 에러, 버그를 조사하고 디버깅. | /sc:troubleshoot the 'TypeError' in the main.js file \--persona-analyzer |
|  | /sc:explain | 코드 조각, 개념, 파일을 설명. | /sc:explain this regex pattern |
| **품질** | /sc:improve | 기존 코드의 품질, 성능, 가독성을 향상. | /sc:improve the database query for performance \--persona-performance |
|  | /sc:test | 테스트 스위트(단위, 통합, E2E)를 생성하거나 실행. | /sc:test the new checkout feature \--tdd |
|  | /sc:cleanup | 데드 코드, 미사용 의존성, 오래된 아티팩트를 제거. | /sc:cleanup the project |
| **유틸리티** | /sc:document | 코드나 프로젝트에 대한 문서를 자동으로 생성. | /sc:document the API endpoints |
|  | /sc:git | AI 기반 커밋 메시지 생성을 포함한 Git 작업을 수행. | /sc:git \--checkpoint "Before major refactor" |
|  | /sc:estimate | 주어진 작업에 대한 시간 또는 복잡도를 추정. | /sc:estimate the time to implement the new feature |
|  | /sc:task | 개발 작업을 관리하고 추적. | /sc:task create a list of sub-tasks for the auth feature |
|  | /sc:index | (추정) 컨텍스트를 위해 프로젝트 파일을 인덱싱. | /sc:index the entire repository |
|  | /sc:load | (추정) 특정 컨텍스트나 파일을 로드. | /sc:load the architecture.md file |
|  | /sc:spawn | (추정) 특정 작업을 위한 하위 에이전트를 생성. | /sc:spawn an agent to refactor the legacy module |

---

## **4부: 인지적 전문화 \- 9개의 페르소나 마스터하기**

이 섹션은 SuperClaude의 가장 혁신적인 기능인 페르소나 시스템을 상세히 다룹니다. 페르소나가 어떻게 '일반적인 AI' 문제를 해결하고, 온디맨드 전문가 팀처럼 기능하는지 설명합니다.

### **4.1. 페르소나의 힘: 단순한 프롬프트를 넘어서**

페르소나는 AI의 사고방식, 우선순위, 소통 스타일, 선호하는 도구까지 근본적으로 바꾸는 '인지적 원형(cognitive archetypes)'입니다.1 페르소나를 활성화하는 것은 단순히 외형적인 변화가 아니라, 완전히 다른 전문가와 대화하는 것과 같습니다.1 예를 들어,

security 페르소나의 주된 질문은 "무엇이 잘못될 수 있는가?"인 반면, mentor 페르소나의 목표는 정답을 바로 알려주는 것이 아니라 이해를 돕는 것입니다.1

### **4.2. 자동 페르소나 활성화**

SuperClaude는 사용자의 작업 맥락에 따라 지능적으로 페르소나를 활성화하여 상호작용을 자연스럽고 매끄럽게 만듭니다.1

* 예시 1:  
  * .tsx 파일을 편집하면 frontend 페르소나가 자동으로 활성화됩니다.  
  * "bug"나 "error" 같은 단어를 입력하면 analyzer 페르소나가 활성화됩니다.  
  * 이 기능은 마치 가장 적절한 순간에 최고의 전문가가 방으로 걸어 들어오는 것과 같은 경험을 제공합니다.

### **4.3. SuperClaude 페르소나 명단 표**

이 표는 9개의 전문 페르소나 각각의 고유한 초점과 전문 분야를 명확하게 안내하여, 사용자가 인지적 전문화의 힘을 최대한 활용할 수 있도록 돕습니다.

| 페르소나 | 아이콘 | 핵심 초점 / 사고방식 | 일반적인 사용 사례 / 샘플 프롬프트 |
| :---- | :---- | :---- | :---- |
| **architect** | 🏗️ | 거시적인 시스템 디자인, 확장성, 기술 부채 식별, 아키텍처 패턴. | /sc:design \--persona-architect "Design a microservices architecture for an e-commerce platform." |
| **frontend** | 🎨 | UI/UX 개선, React 모범 사례, 접근성(a11y), 최신 컴포넌트 디자인. | /sc:implement \--persona-frontend "Create an accessible and responsive login form using React and Tailwind." |
| **backend** | ⚙️ | API 신뢰성 및 확장, 데이터베이스 설계, 인프라, 서버 측 로직. | /sc:improve \--persona-backend "Optimize the database schema for write-heavy operations." |
| **security** | 🛡️ | 위협 모델링, 보안 코딩 관행, 취약점 분석, 입력 유효성 검사. | /sc:analyze \--persona-security "Perform a security audit of the authentication module." |
| **analyzer** | 🔍 | 심층 디버깅, 근본 원인 분석, 복잡한 문제 해결. | /sc:troubleshoot \--persona-analyzer "Find the source of the memory leak in the data processing script." |
| **qa** | 🧪 | 테스트 전략, 코드 커버리지, 버그 탐지, 견고한 테스트 케이스 생성. | /sc:test \--persona-qa "Write a comprehensive test plan for the new payment gateway integration." |
| **performance** | ⚡ | 속도 튜닝, 병목 현상 식별, 쿼리 최적화, 리소스 관리. | /sc:improve \--persona-performance "Identify and fix the performance bottlenecks on the main dashboard." |
| **refactorer** | ✨ | 코드 명확성 향상, 복잡도 감소, 기술 부채 정리. | /sc:improve \--persona-refactorer "Refactor this large function into smaller, more manageable units." |
| **mentor** | 🎓 | 가이드 기반 학습, 비유를 통한 복잡한 개념 설명, 코칭. 직접적인 답을 피함. | /sc:explain \--persona-mentor "Can you explain the concept of closures in JavaScript like I'm a beginner?" |

페르소나 시스템은 개발자의 역할을 근본적으로 변화시킵니다. 전통적인 코딩에서 개발자는 아키텍트, 코더, 테스터 등 모든 역할을 수행해야 했습니다. 기본 AI 어시스턴트는 단일하고 일반적인 조수 역할을 할 뿐입니다. 하지만 SuperClaude의 페르소나 시스템은 전문가로 구성된 '팀'을 제공합니다.5 이로 인해 개발자의 주된 임무는 모든 코드를 직접 작성하는 것에서 이 AI 에이전트 팀을 '지휘'하는 것으로 진화합니다. 개발자는 기술 리더나 관리자처럼

architect에게 설계를 지시하고, backend 페르소나에게 구현을 맡기며, qa 페르소나에게 테스트를 요청하게 됩니다. 향후 계획된 협업 기능(--collaborate \--persona-backend,frontend,security)은 이러한 변화를 더욱 가속화할 것입니다.19 따라서 SuperClaude와 같은 도구를 마스터한다는 것은 코딩 능력뿐만 아니라 AI 오케스트레이션 및 워크플로우 관리라는 새로운 기술을 습득하는 것을 의미합니다.

---

## **5부: 전략적 워크플로우 \- 단일 명령어에서 에이전트 시스템까지**

이 섹션은 명령어와 페르소나를 실제 개발 시나리오에 적용하는 실용적인 활용법을 제시합니다.

### **5.1. 풀스택 기능 개발 워크플로우: 단계별 예시**

이 워크플로우는 아이디어 구상부터 기능 완성까지, 명령어와 페르소나를 연결하여 사용하는 방법을 보여줍니다.2

* **1단계: 분석 및 설계 (/sc:design)**: 제품 요구사항 문서(PRD)에서 시작합니다. /sc:design \--persona-architect를 사용하여 상세한 기술 명세 파일을 생성합니다.  
* **2단계: 작업 분할 (/sc:task)**: 생성된 기술 명세 파일을 /sc:task에 입력하여 구체적인 구현 작업 목록을 만듭니다.  
* **3단계: 구현 (/sc:implement)**: 각 작업을 /sc:implement를 사용하여 해결합니다. 이때 API 엔드포인트에는 \--persona-backend를, UI에는 \--persona-frontend를 사용하는 등 적절한 페르소나를 활용합니다.  
* **4단계: 테스트 (/sc:test)**: /sc:test \--persona-qa를 사용하여 구현된 코드에 대한 단위 및 통합 테스트를 생성합니다.  
* **5단계: 문서화 및 커밋 (/sc:document, /sc:git)**: /sc:document로 문서를 만들고, /sc:git으로 의미 있는 커밋 메시지를 생성하여 작업을 마무리합니다.

### **5.2. analyzer 페르소나를 활용한 고급 디버깅**

버그가 발생했을 때, 사용자는 /sc:troubleshoot \--persona-analyzer "My app is crashing with a null pointer exception"과 같이 명령어를 호출할 수 있습니다. analyzer 페르소나는 심층 분석을 수행하여 로깅 지점을 제안하고, 스택 트레이스를 분석하며, 가능한 근본 원인을 설명합니다. 이는 마치 숙련된 디버깅 전문가와 협력하는 것과 같은 경험을 제공합니다.1

### **5.3. AI 기억 상실 극복: Git 기반 메모리**

이 기능은 장시간 이어지는 AI 대화의 가장 큰 문제 중 하나인 '기억 상실'을 해결하는 획기적인 방법입니다.1

* **사용법:** 대규모 리팩토링과 같이 위험 부담이 큰 변경 작업을 시작하기 전에, 개발자는 /sc:git \--checkpoint "message" 명령어를 실행합니다. 이는 대화와 코드의 전체 상태를 저장하는 체크포인트를 생성합니다.  
* **롤백:** 만약 리팩토링이 실패하거나 잘못된 방향으로 진행될 경우, 간단히 /sc:git \--rollback 명령어를 실행하면 프로젝트와 AI의 컨텍스트가 마지막으로 저장된 정상 상태로 즉시 복원됩니다. 이는 수 시간의 작업을 잃는 것을 방지해 줍니다.1

### **5.4. 미래의 워크플로우: 협업 및 다중 페르소나**

아직 완전히 구현되지는 않았지만, GitHub 이슈에서 논의된 페르소나 협업 기능은 SuperClaude의 미래 방향성을 보여줍니다.19

* **페르소나 체이닝 (--chain):** 한 페르소나의 출력이 다음 페르소나의 입력으로 자동으로 연결되는 순차적 워크플로우입니다 (예: architect → security → backend).  
* **다중 페르소나 협업 (--collaborate):** 여러 페르소나가 하나의 작업에 대해 동시에 협의하여 통합된 결과물을 도출하는 고급 모드입니다. 예를 들어, /sc:build \--collaborate \--persona-backend,security는 처음부터 기능적으로 올바르면서도 보안이 강화된 코드를 생성하게 됩니다.

---

## **6부: 더 넓은 생태계 \- 비용, 비교, 그리고 대안**

이 섹션은 SuperClaude 사용의 실제 비용을 분석하고, AI 코딩 도구 시장에서의 위치를 파악하여 사용자에게 중요한 맥락을 제공합니다.

### **6.1. 비용-편익 분석: 무료 프레임워크, 유료 서비스**

SuperClaude 자체는 무료 오픈소스(MIT 라이선스) 프레임워크입니다.4 하지만 이를 실행하기 위해서는 Claude Code 접근 권한이 필요하며, 이는 유료 Anthropic 구독을 통해 제공됩니다. 많은 사용자들이 이 점을 혼동하여 무료 도구임에도 왜 높은 비용에 대한 이야기가 나오는지 궁금해합니다.6 실제 비용은 기반이 되는 Claude 서비스에 대한 것입니다. SuperClaude의 진정한 가치는 이 유료 서비스를 토큰 감소를 통해

*더 효율적으로* 만들고, 구조화된 워크플로우를 통해 *더 효과적으로* 만들어 사용자의 구독료나 API 비용에 대한 투자 수익률(ROI)을 극대화하는 데 있습니다.

### **6.2. Claude 서비스 가격표 (2025년 7월 기준)**

이 표는 운영 비용을 명확히 하고 사용자가 예상 사용량에 기반한 합리적인 결정을 내릴 수 있도록 돕습니다.6

| 플랜/서비스 | 비용 | 주요 기능 및 제한 | 이상적인 사용자 |
| :---- | :---- | :---- | :---- |
| **Claude Pro** | 월 $20 | 무료 등급 대비 5배 사용량, Sonnet 및 Opus 모델 접근. | 전문가, 중간 사용량 사용자. |
| **Claude Max** | 월 $100-$200 | Pro 대비 5-20배 사용량, 우선 접근권. Claude Code 터미널 접근에 필요. | 헤비 유저, 기업. |
| **Claude Team** | 사용자당 월 $30 | 중앙 집중식 결제, 협업 기능 (최소 5명). | 비즈니스 팀. |
| **API: Haiku** | 입력 1백만 토큰당 $0.25 | 가장 빠르고 저렴한 모델. | 간단하고 대량의 작업. |
| **API: 3.5 Sonnet** | 입력 1백만 토큰당 $3.00 | 속도와 지능의 균형. | 일반적인 개발, 분석. |
| **API: Opus** | 입력 1백만 토큰당 $15.00 | 가장 강력하며 복잡한 추론에 사용. | 중요하고 복잡한 작업. |

### **6.3. 정면 대결: SuperClaude vs. GitHub Copilot**

AI 코드 지원의 두 가지 주요 패러다임을 비교하는 것은 많은 개발자들의 관심사입니다.13

| 측면 | SuperClaude (with Claude Code) | GitHub Copilot | 결론 및 추천 대상 |
| :---- | :---- | :---- | :---- |
| **핵심 철학** | **규율 및 추론:** 전문 파트너로서 엔지니어링 프로세스를 강제.1 | **속도 및 자동 완성:** 빠르고 '초능력적인' 페어 프로그래머처럼 코드 제안.13 | **SuperClaude:** 깊은 사고가 필요한 복잡한 프로젝트. **Copilot:** 일상적인 코딩 가속화. |
| **통합성** | **터미널 중심:** 명령줄과 깊이 통합.24 설정이 복잡할 수 있음(WSL).8 | **IDE 네이티브:** VS Code, JetBrains 등에 완벽하게 통합.14 | **Copilot:** 마찰 없는 인-에디터 지원을 원하는 사용자. |
| **추론 깊이** | **우수:** 장문 추론, 다단계 문제 해결, '왜'를 설명하는 데 탁월.13 | **짧은 컨텍스트:** 코드 완성기처럼 작동하며, 전체 애플리케이션 인식에 어려움을 겪을 수 있음.23 | **SuperClaude:** 디버깅, 아키텍처 설계, 새로운 개념 학습. |
| **자율성** | **높음:** 명령어 실행, 파일 편집 등 전체 워크플로우를 자율적으로 관리 가능.22 | **낮음:** 주로 코드를 제안하며, 자율적인 행동은 제한적. | **SuperClaude:** AI가 주도하는 에이전트 워크플로우. |
| **비용 모델** | 프레임워크는 무료지만, 터미널 접근을 위해 비싼 Claude Max(월 $100 이상) 또는 API 사용 필요.6 | 상대적으로 저렴한 구독료(월 $10-$20)에 포함.13 | **Copilot:** 개인 개발자에게 더 접근하기 쉬운 가격대. |

### **6.4. 시장의 대안들: 간략한 개요**

SuperClaude나 Copilot이 적합하지 않은 사용자를 위해 다른 도구들도 존재합니다.25

* **Cursor:** 강력한 에이전트 기능과 코드베이스 인식을 제공하는 'AI 네이티브' IDE.6  
* **Aider:** Git 중심적인 사용자를 위한, Git과 깊이 통합된 터미널 기반 도구.24  
* **DeepSeek Coder:** 코딩 능력으로 호평받는 강력한 오픈소스 모델.25  
* **Kimi K2 / OpenRouter:** Kimi K2와 같은 강력하고 비용 효율적인 모델을 OpenRouter와 같은 라우터를 통해 SuperClaude와 같은 프레임워크와 결합하여 전문가 수준의 맞춤형 스택을 구축하는 전략.28

---

## **7부: 결론 \- AI 증강 엔지니어링의 미래**

이 마지막 섹션은 핵심 내용을 요약하고 SuperClaude와 AI 기반 개발 분야의 미래를 조망합니다.

### **7.1. SuperClaude의 가치 제안 요약**

SuperClaude의 핵심 강점은 일반적인 AI를 규율 잡힌 전문가 팀으로 변모시키고, Git 기반 메모리로 AI 기억 상실 문제를 해결하며, 엄격한 규칙 기반 시스템으로 모범 사례를 강제하는 데 있습니다. 이는 개발자가 즉흥적인 '감성 코딩(vibe coding)'에서 벗어나 구조화되고 전문적이며 매우 효과적인 엔지니어링 프로세스로 나아가도록 돕습니다.2

### **7.2. v4와 그 너머를 향한 길**

SuperClaude는 활발하고 미래 지향적인 프로젝트이며, v4에 대한 계획은 이를 잘 보여줍니다.

* **재설계된 Hooks 시스템:** 더 견고하고 버그가 적은 맞춤형 자동화 시스템.  
* **광범위한 CLI 지원:** Claude Code를 넘어 다른 AI 코딩 어시스턴트를 지원하려는 계획은 사용자 기반을 극적으로 확장하고 SuperClaude를 보편적인 'AI 규율 프레임워크'로 만들 수 있는 중요한 전략적 움직임입니다.  
* **향상된 페르소나 및 MCP:** 핵심 기능의 지속적인 확장.

### **7.3. 최종 소고: AI로 프롬프팅하는 것을 넘어, AI로 엔지니어링하기**

SuperClaude와 같은 도구의 등장은 AI 개발 환경이 성숙하고 있음을 나타냅니다. 미래는 단순히 AI에게 프롬프트를 던질 수 있는 사람이 아니라, AI를 가지고 엔지니어링할 수 있는 사람의 것입니다. 즉, 전문가 수준의 결과를 달성하기 위해 복잡한 AI 에이전트 시스템을 구축, 관리 및 지휘할 수 있는 능력이 중요해질 것입니다. SuperClaude는 이러한 변화의 중심에 있는 핵심 도구 중 하나입니다.

#### **참고 자료**

1. SuperClaude: Power Up Your Claude Code Instantly \- Apidog, 7월 25, 2025에 액세스, [https://apidog.com/blog/superclaude/](https://apidog.com/blog/superclaude/)  
2. Upgrade Your Claude Code Workflow (The Pro SuperClaude Method) \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=Ph\_Pbaqn2EM](https://www.youtube.com/watch?v=Ph_Pbaqn2EM)  
3. SuperClaude \- Advanced Development Framework for Claude Code ..., 7월 25, 2025에 액세스, [https://superclaude.org/](https://superclaude.org/)  
4. I Present : SuperClaude \! : r/ClaudeAI \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/ClaudeAI/comments/1lhmts3/i\_present\_superclaude/](https://www.reddit.com/r/ClaudeAI/comments/1lhmts3/i_present_superclaude/)  
5. Full Tutorial: Build an App with Multiple AI Agents (Claude Code) \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=Z\_iWe6dyGzs](https://www.youtube.com/watch?v=Z_iWe6dyGzs)  
6. Claude AI pricing : r/ClaudeAI \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/ClaudeAI/comments/1kxet49/claude\_ai\_pricing/](https://www.reddit.com/r/ClaudeAI/comments/1kxet49/claude_ai_pricing/)  
7. How Much Does Claude AI Cost? \- Tactiq, 7월 25, 2025에 액세스, [https://tactiq.io/learn/claude-ai-cost](https://tactiq.io/learn/claude-ai-cost)  
8. This AI Tool Built My Web App In Minutes (SuperClaude for Claude Code) \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=76\_8ygZtios](https://www.youtube.com/watch?v=76_8ygZtios)  
9. How to Install Claude Code on Windows: Complete 2025 Guide \- iTecs, 7월 25, 2025에 액세스, [https://itecsonline.com/post/how-to-install-claude-code-on-windows](https://itecsonline.com/post/how-to-install-claude-code-on-windows)  
10. SuperClaude-Org/SuperClaude\_Framework: A configuration framework that enhances Claude Code with specialized commands, cognitive personas, and development methodologies. \- GitHub, 7월 25, 2025에 액세스, [https://github.com/SuperClaude-Org/SuperClaude\_Framework](https://github.com/SuperClaude-Org/SuperClaude_Framework)  
11. SUPERCHARGE Claude Code \- BEST AI Coder\! BYE Gemini CLI & OpenCode\! \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=tBOlhMajWfE](https://www.youtube.com/watch?v=tBOlhMajWfE)  
12. SuperClaude v3 \- Advanced Development Framework for Claude Code, 7월 25, 2025에 액세스, [https://superclaude-org.github.io/](https://superclaude-org.github.io/)  
13. I tested Claude vs GitHub Copilot with 5 coding prompts – Here's my winner, 7월 25, 2025에 액세스, [https://techpoint.africa/guide/claude-vs-github-copilot-for-coding/](https://techpoint.africa/guide/claude-vs-github-copilot-for-coding/)  
14. Claude Dev vs GitHub Copilot: The AI Coding Assistant Showdown | by Joe Wilson, 7월 25, 2025에 액세스, [https://medium.com/@dingersandks/claude-dev-vs-github-copilot-the-ai-coding-assistant-showdown-9d86438afb9d](https://medium.com/@dingersandks/claude-dev-vs-github-copilot-the-ai-coding-assistant-showdown-9d86438afb9d)  
15. This Supercharging CLAUDE CODE Toolkit is AMAZING\! \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=apr0AZ\_vj3Q](https://www.youtube.com/watch?v=apr0AZ_vj3Q)  
16. 1월 1, 1970에 액세스, [https.github.com/NomenAK/SuperClaude/blob/master/Docs/personas-guide.md](http://docs.google.com/https.github.com/NomenAK/SuperClaude/blob/master/Docs/personas-guide.md)  
17. 1월 1, 1970에 액세스, [https://github.com/NomenAK/SuperClaude/blob/master/Docs/flags-guide.md](https://github.com/NomenAK/SuperClaude/blob/master/Docs/flags-guide.md)  
18. \[Bug\] @include shared/constants.yml\#Process\_Symbols (user) · Issue \#12 · NomenAK/SuperClaude \- GitHub, 7월 25, 2025에 액세스, [https://github.com/NomenAK/SuperClaude/issues/12](https://github.com/NomenAK/SuperClaude/issues/12)  
19. Multi-Persona Task Orchestration & Automatic Workflow Chaining · Issue \#114 · NomenAK/SuperClaude \- GitHub, 7월 25, 2025에 액세스, [https://github.com/NomenAK/SuperClaude/issues/114](https://github.com/NomenAK/SuperClaude/issues/114)  
20. SuperClaude素振り \- Zenn, 7월 25, 2025에 액세스, [https://zenn.dev/mmrakt/scraps/b4f71b2548f4e0](https://zenn.dev/mmrakt/scraps/b4f71b2548f4e0)  
21. Claude AI Pricing Guide 2025: Complete Cost Breakdown (Free, Pro, Max, API) \- ScreenApp, 7월 25, 2025에 액세스, [https://screenapp.io/blog/claude-ai-pricing](https://screenapp.io/blog/claude-ai-pricing)  
22. AI vs Developer: Can GitHub Copilot or Claude Action Replace My Job? \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=ahTkFqssZxM](https://www.youtube.com/watch?v=ahTkFqssZxM)  
23. Github Copilot vs. Claude : r/GithubCopilot \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/GithubCopilot/comments/1ezrjkr/github\_copilot\_vs\_claude/](https://www.reddit.com/r/GithubCopilot/comments/1ezrjkr/github_copilot_vs_claude/)  
24. Claude, Cursor, Aider, Cline, Copilot: Which Is the Best One? | by Edwin Lisowski \- Medium, 7월 25, 2025에 액세스, [https://medium.com/@elisowski/claude-cursor-aider-cline-copilot-which-is-the-best-one-ef1a47eaa1e6](https://medium.com/@elisowski/claude-cursor-aider-cline-copilot-which-is-the-best-one-ef1a47eaa1e6)  
25. 7 Best Claude AI Alternatives to Use in 2025 \- Cabina.AI, 7월 25, 2025에 액세스, [https://cabina.ai/blog/7-best-claude-ai-alternatives-to-use/](https://cabina.ai/blog/7-best-claude-ai-alternatives-to-use/)  
26. Exploring 8 Best Claude AI Alternatives in 2025: When to Switch and Why \- Medium, 7월 25, 2025에 액세스, [https://medium.com/@CherryZhouTech/exploring-8-best-claude-ai-alternatives-when-to-switch-and-why-f3a552a45835](https://medium.com/@CherryZhouTech/exploring-8-best-claude-ai-alternatives-when-to-switch-and-why-f3a552a45835)  
27. 18 Best Claude AI Alternatives (2024) \- Exploding Topics, 7월 25, 2025에 액세스, [https://explodingtopics.com/blog/claude-alternatives](https://explodingtopics.com/blog/claude-alternatives)  
28. Kimi K2 \+ SuperClaude: The Ultimate AI Stack (Tutorial) \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=-K4fT8eP2qU](https://www.youtube.com/watch?v=-K4fT8eP2qU)
</file>

<file path="references/superclaude_commands_guide_workly.md">
# SuperClaude 명령어 가이드 (Workly 프로젝트용)

이 문서는 Workly 프로젝트에서 SuperClaude AI 에이전트의 명령어를 효과적으로 사용하기 위해 공식 가이드를 요약하고 프로젝트에 맞게 조정한 버전입니다.

---

## 핵심 명령어 (Quick Start)

우선 이것부터 사용해보세요. 대부분의 작업은 아래 명령어로 시작할 수 있습니다.

```bash
# 코드베이스 분석 (보안, 성능, 아키텍처 등)
/sc:analyze frontend/src/app

# 기능 구현 (컴포넌트, API, 서비스 등)
/sc:implement UserProfile component --framework react --with-tests

# 프로젝트 빌드 (frontend/backend)
/sc:build

# 코드 개선 (리팩토링, 최적화)
/sc:improve frontend/src/lib/api.ts --safe

# 문제 해결 및 디버깅
/sc:troubleshoot "API returning 500" --logs server.log

# 테스트 실행 및 커버리지 분석
/sc:test --type unit --coverage
```

---

## 전체 명령어 요약표

| 명령어 | 주요 기능 | 자동 활성화 전문가 | 추천 사용 사례 |
|---|---|---|---|
| `/sc:analyze` | 코드 분석 (품질, 보안, 성능) | 보안/성능 전문가 | 코드베이스 이해, 문제점 탐색 |
| `/sc:build` | 프로젝트 빌드 및 컴파일 | 프론트엔드/백엔드 전문가 | 컴파일, 번들링, 배포 준비 |
| `/sc:implement` | 기능 구현 (컴포넌트, API 등) | 도메인별 전문가 | 신규 기능, 컴포넌트, API, 서비스 개발 |
| `/sc:improve` | 코드 자동 개선 | 품질 전문가 | 리팩토링, 최적화, 품질 향상 |
| `/sc:troubleshoot` | 문제 해결 및 디버깅 | 디버깅 전문가 | 디버깅, 이슈 원인 분석 |
| `/sc:test` | 테스트 실행 및 분석 | QA 전문가 | 테스트 실행, 커버리지 분석 |
| `/sc:document` | 문서 자동 생성 | 문서화 전문가 | README, 코드 주석, 가이드 작성 |
| `/sc:git` | Git 워크플로우 향상 | DevOps 전문가 | 스마트 커밋, 브랜치 관리 |
| `/sc:design` | 시스템 설계 지원 | 아키텍처 전문가 | 아키텍처 설계, API 디자인 |
| `/sc:explain` | 코드 및 개념 설명 | 교육 전문가 | 코드 및 기술 개념 학습 |
| `/sc:cleanup` | 기술 부채 감소 | 리팩토링 전문가 | 미사용 코드 제거, 파일 구조 정리 |
| `/sc:load` | 프로젝트 컨텍스트 로딩 | 분석 전문가 | 프로젝트 구조 및 코드베이스 이해 |
| `/sc:estimate` | 작업량 예측 | 기획 전문가 | 시간/리소스 계획, 복잡도 분석 |
| `/sc:workflow` | PRD 기반 구현 계획 수립 | 워크플로우 시스템 | PRD를 단계별 실행 계획으로 변환 |
| `/sc:index` | 명령어 검색 및 탐색 | 도움말 시스템 | 특정 작업에 적합한 명령어 검색 |

---

## 주요 명령어 상세 가이드

### `/implement`: 기능 구현
**기능**: 새로운 기능, 컴포넌트, API, 서비스 등을 지능적으로 구현합니다.
**사용 시점**:
- 새로운 React 컴포넌트나 Next.js 페이지를 만들 때
- 새로운 NestJS 모듈이나 서비스를 구현할 때
- 테스트 코드를 포함한 기능 개발이 필요할 때

**기본 구문**:
```bash
/sc:implement [구현할 내용]
/sc:implement --type [타입] [이름]
```

**유용한 플래그**:
- `--type component|api|service|feature|module`: 구현할 코드의 종류 지정
- `--framework react|nextjs|nestjs`: 특정 프레임워크 지정
- `--with-tests`: 테스트 코드 함께 생성
- `--safe`: 보수적인(안전한) 방식으로 코드 생성

**Workly 프로젝트 예시**:
```bash
# frontend: 새로운 인증 관련 UI 컴포넌트 생성
/sc:implement --type component AuthForm --framework react --with-tests

# backend: 사용자 프로필 관리를 위한 API 및 서비스 구현
/sc:implement user profile management --type feature --framework nestjs

# shared: 새로운 타입 정의 추가
/sc:implement --type module shared/types/new-feature.types.ts
```

### `/analyze`: 코드 분석
**기능**: 코드 품질, 보안, 성능, 아키텍처를 종합적으로 분석합니다.
**사용 시점**:
- 코드 리뷰 전 잠재적인 문제점을 찾고 싶을 때
- 특정 부분의 성능 병목 현상을 분석할 때
- 보안 취약점을 점검할 때

**기본 구문**:
```bash
/sc:analyze [분석할 경로]
```

**유용한 플래그**:
- `--focus quality|security|performance|architecture`: 분석 초점 지정
- `--depth quick|deep`: 분석 깊이 조절
- `--format report|json`: 결과 포맷 지정

**Workly 프로젝트 예시**:
```bash
# backend: 보안 취약점 심층 분석
/sc:analyze backend/src --focus security --depth deep

# frontend: 성능 관련 분석
/sc:analyze frontend/src/app --focus performance

# 전체 프로젝트: 품질 분석 보고서 생성
/sc:analyze . --focus quality --format report
```

### `/improve`: 코드 개선
**기능**: 코드 품질, 성능, 유지보수성을 체계적으로 개선합니다. (리팩토링)
**사용 시점**:
- 오래되거나 복잡한 코드를 정리할 때
- 성능 최적화가 필요할 때
- 코드 스타일을 일관성 있게 맞추고 싶을 때

**기본 구문**:
```bash
/sc:improve [개선할 파일 또는 경로]
```

**유용한 플래그**:
- `--type quality|performance|style`: 개선 초점 지정
- `--safe`: 위험도가 낮은 변경사항만 적용
- `--preview`: 변경될 내용을 미리보기만 실행 (실제 적용 X)

**Workly 프로젝트 예시**:
```bash
# 특정 파일 개선 전 미리보기
/sc:improve --preview frontend/src/lib/utils.ts

# backend API 코드 성능 위주로 안전하게 개선
/sc:improve --type performance --safe backend/src/modules/tasks/

# 전체 프로젝트 코드 스타일 정리
/sc:improve --type style . --safe
```
**팁**: 적용하기 전에 항상 `--preview` 플래그로 변경 사항을 먼저 확인하는 것이 안전합니다.

### `/test`: 테스트
**기능**: 테스트를 실행하고, 커버리지 리포트를 생성하며, 테스트 품질을 유지합니다.
**사용 시점**:
- 단위/통합/E2E 테스트를 실행할 때
- 코드 변경 후 테스트 커버리지를 확인할 때

**기본 구문**:
```bash
/sc:test
```

**유용한 플래그**:
- `--type unit|integration|e2e|all`: 실행할 테스트 타입 지정
- `--coverage`: 커버리지 리포트 생성
- `--watch`: 파일 변경을 감지하여 자동으로 테스트 실행

**Workly 프로젝트 예시**:
```bash
# frontend 단위 테스트 실행 및 커버리지 확인
/sc:test frontend --type unit --coverage

# backend 통합 테스트 실행
/sc:test backend --type integration

# 특정 컴포넌트 변경사항 감지하며 테스트
/sc:test --watch frontend/src/components/ui/
```

### `/git`: Git 연동
**기능**: 지능적인 커밋 메시지 생성 등 Git 작업을 보조합니다.
**사용 시점**:
- 의미 있는 커밋 메시지를 작성하기 어려울 때
- 브랜치 관리 전략을 적용하고 싶을 때

**기본 구문**:
```bash
/sc:git commit
/sc:git --smart-commit add .
```

**Workly 프로젝트 예시**:
```bash
# 변경사항 스테이징 후 지능적으로 커밋 메시지 생성 및 커밋
git add .
/sc:git --smart-commit

# 커밋 메시지만 생성 (실제 커밋은 직접 실행)
/sc:git --smart-commit "fix: user login bug"
```
**팁**: 생성된 커밋 메시지는 최종 제출 전에 항상 직접 검토하는 것이 좋습니다.
</file>

<file path="references/Task-master-ai Guide.md">
# **Taskmaster AI 최종 가이드: PRD부터 프로덕션까지, 에이전트 기반 개발 마스터하기**

## **1부: 구조화된 AI 개발의 기초**

이 파트에서는 Taskmaster AI의 기본 개념을 정립하고, 그 정체성을 명확히 하며, 필수적인 설치 지침을 제공합니다. 사용자가 정확하고 안정적인 기반 위에서 시작할 수 있도록 보장합니다.

### **1장: Taskmaster AI 해부**

#### **1.1. "AI 에이전트를 위한 프로젝트 매니저": 핵심 철학과 가치 제안**

Taskmaster AI의 핵심 전제는 코딩 작업에서 종종 혼란스럽고 비결정적으로 작동하는 대규모 언어 모델(LLM)의 특성에 구조를 부여하는 것입니다.1 이 도구는 프로젝트 매니저 역할을 수행하며, 크고 복잡한 목표를 AI 에이전트가 한 번에 하나씩 안정적으로 실행할 수 있는 일련의 개별적이고 관리 가능한 작업으로 분해합니다.2 이 접근 방식은 컨텍스트 과부하를 제거하고, AI가 "궤도를 벗어나는" 것을 방지하며, 이미 작동하는 코드를 손상시키지 않도록 설계되었습니다.1 최종 목표는 AI를 단순한 코드 어시스턴트에서 전체 프로젝트를 설계하고 구축할 수 있는 개인 CTO 수준으로 격상시키는 것입니다.4

#### **1.2. 중의성 해소: task-master.dev와 다른 "Taskmaster" 도구들의 명확한 구분**

이 보고서는 task-master.dev에서 찾을 수 있는 오픈소스 개발자 도구와 관련 GitHub 리포지토리 eyaltoledano/claude-task-master에만 초점을 맞춥니다.2

다음과 같이 유사한 이름의 다른 프로젝트와 명확히 구별하는 것이 중요합니다.

* aamanbhagat/TaskMaster-AI가 개발한 KendoReact를 사용한 프로젝트 관리 애플리케이션.8  
* taskmaster.one에서 제공하는 학생용 요금제를 갖춘 학업 지원 SaaS 제품.9  
* GitHub에서 "taskmaster" 토픽 태그를 사용하는 다양한 기타 관련 없는 프로젝트들.4

여기서 논의하는 도구는 AI 기반 소프트웨어 개발에 특화되어 있으며, 완전 무료 오픈소스이고, "자신의 API 키 가져오기(BYOK)" 모델로 운영됩니다.2

AI 분야에서 "에이전트"와 "작업 관리"라는 개념을 중심으로 용어가 수렴하는 광범위한 경향이 나타나면서, 여러 "Taskmaster" 프로젝트의 존재는 사용자 혼란의 가능성을 보여줍니다. 이는 빠르게 혼잡해지는 시장에서 명확한 브랜딩과 문서화의 필요성을 강조합니다. "작업(task)"이라는 용어는 전통적인 프로젝트 관리 8와 AI 프롬프트를 세분화하는 새로운 패러다임 5 모두에서 근본적입니다. 이러한 용어의 중복은 AI가 워크플로우에 더 깊이 통합됨에 따라 기존 분야의 언어를 차용하면서 모호성이 발생할 수 있음을 시사합니다. 따라서 이 보고서가 제공해야 할 핵심 서비스는 도구를 설명하는 것뿐만 아니라, 그 경계를 명확히 정의하고 동명의 다른 도구들과 구별하여 사용자가 이 새로운 환경을 탐색하는 데 필요한 명확성을 제공하는 것입니다.

#### **1.3. 세 가지 기둥: CLI, MCP 서버, 그리고 규칙 엔진**

* **커맨드 라인 인터페이스(CLI):** 직접적인 상호작용을 위한 기본 계층입니다. 사용자는 터미널에서 task-master init, task-master parse-prd와 같은 명령을 직접 실행할 수 있습니다.7  
* **모델 제어 프로토콜(MCP) 서버:** Cursor나 Windsurf와 같은 AI 네이티브 IDE 내에서 원활한 상호작용을 가능하게 하는 다리 역할을 합니다. CLI의 기능을 AI 에이전트가 자연어 프롬프트를 통해 호출할 수 있는 "도구"로 노출시킵니다.5 이는 이 도구를 사용하는 가장 권장되고 강력한 방법입니다.7  
* **규칙 엔진:** 고급 사용자 정의 계층입니다. 개발자는 .cursor/rules/ 디렉토리의 .mdc 파일을 통해 AI에게 아키텍처, 코딩 표준, 워크플로우에 대한 영구적이고 프로젝트별 지침을 제공할 수 있습니다.11

### **2장: 설치 및 환경 구성**

#### **2.1. 사전 요구사항 및 단계별 설치**

Taskmaster AI는 Node.js 패키지입니다. 기본 설치 방법은 npm(Node Package Manager)을 통한 것입니다.  
권장되는 설치 방법은 전역 설치로, 어떤 프로젝트 디렉토리에서든 task-master 명령을 실행할 수 있게 합니다: npm install \-g task-master-ai.7

또는, 로컬 프로젝트 종속성으로 설치할 수도 있습니다: npm install task-master-ai.7

#### **2.2. 프로젝트 초기화: task-master init 명령어**

설치 후, 새로운 프로젝트에서 가장 먼저 해야 할 일은 task-master init (로컬 설치의 경우 npx task-master-init)을 실행하는 것입니다.7

이 명령어는 사용자에게 프로젝트 세부 정보를 대화형으로 묻고, .taskmaster/ 디렉토리와 기본 dev\_workflow.mdc 파일을 포함하는 .cursor/rules/ 디렉토리 등 필요한 파일 구조를 생성합니다.7 이 파일은 AI 에이전트에게 작업 관리 시스템에 대한 초기 지식을 제공하므로 매우 중요합니다.11

#### **2.3. 핵심 API 키 관리: "Bring Your Own Key" 모델**

Taskmaster AI 자체는 무료이지만, 핵심 기능은 유료인 강력한 LLM 호출에 의존합니다.2 사용자는 자신의 API 키를 제공할 책임이 있습니다.

* **지원 제공자:** 이 도구는 모델에 구애받지 않으며 Anthropic (Claude), OpenAI (GPT), Google (Gemini), Perplexity, xAI, OpenRouter 등 다양한 제공자를 지원합니다.5  
* **구성 위치:** 키는 사용 컨텍스트에 따라 올바른 위치에 배치되어야 합니다.  
  * CLI 사용 시: 프로젝트 루트의 .env 파일에 배치.11  
  * MCP 사용 시 (IDE 내에서): 해당 mcp.json 구성 파일(예: \~/.cursor/mcp.json)에 배치.5  
* 두 위치 모두에 키를 두고, 민감한 자격 증명이 실수로 커밋되는 것을 방지하기 위해 mcp.json과 .env 파일을 .gitignore에 추가하는 것이 가장 좋은 방법입니다.11

구성 과정에서 주목할 만한 점이자 사용자 혼란의 주요 원인이 될 수 있는 부분은 API 키를 두 개의 개별 위치에 배치해야 한다는 요구사항입니다. 이러한 분리는 CLI와 MCP 서버가 동일한 프로젝트 파일에서 작동하더라도 별개의 실행 환경으로 운영된다는 사실에서 비롯됩니다. 사용자는 논리적으로 단일 구성 지점이면 충분하다고 가정할 수 있으며, 이로 인해 한 방법은 작동하고 다른 방법은 인증 오류로 실패할 때 혼란을 겪을 수 있습니다. MCP 서버를 실행하는 npx 명령 5이 프로젝트의

.env 파일에서 환경 변수를 자동으로 상속하지 않기 때문에 이러한 현상이 발생합니다. 이는 사용자의 설정 과정에 숨겨진 의존성을 만들어내므로, 두 번째 위치를 잊어버리면 디버깅하기 어려운 문제로 이어질 수 있습니다. 따라서 이 보고서는 이 차이점을 사소한 구성 세부 사항이 아니라 도구의 아키텍처에 대한 핵심 개념적 포인트로 강조하며, 이는 신규 사용자에게 중요한 "함정"입니다.

## **2부: 실제 핵심 워크플로우**

이 파트에서는 높은 수준의 프로젝트 정의부터 작업별 실행에 이르기까지 완전하고 실용적인 워크플로우를 안내하며, 사용자의 일상적인 도구 상호작용의 핵심을 형성합니다.

### **3장: 청사진: 효과적인 제품 요구사항 문서(PRD) 작성하기**

#### **3.1. PRD가 Taskmaster AI의 초석인 이유**

전체 구조화된 워크플로우는 고품질의 PRD에서 시작됩니다.6 PRD는 AI가 모든 작업과 하위 작업을 생성하는 "단일 진실 공급원(single source of truth)" 또는 청사진 역할을 합니다.14 최종 결과물의 품질은 이 초기 문서의 상세함과 명확성에 정비례합니다.13 모호한 PRD는 AI가 중요한 구성 요소를 누락하거나 잘못된 가정을 하게 만듭니다.17

#### **3.2. PRD 작성 모범 사례**

좋은 PRD는 매우 상세하고 구조화되어야 합니다. 다음 내용을 명시적으로 포함해야 합니다:

* 앱 이름, 핵심 목적 및 목표.18  
* 라이브러리 버전을 포함한 전체 기술 스택.18  
* 핵심 기능 및 사용자 스토리.18  
* 데이터베이스 스키마 및 API 통합.18  
* 디자인 스타일 및 UI/UX 선호도.18  
* 중요하게는, 앱이 수행하지 *않아야* 할 "부정적 요구사항".18

이 과정은 AI를 사용하기 전에 인간 주도의 상세한 사고 단계를 포함합니다.18 PRD 자체에 대한 상세한 프롬프트를 작성하는 데 10-15분을 투자하는 것이 권장됩니다.18

이처럼 상세한 인간 주도 PRD에 대한 강조는 AI 개발에 대한 근본적인 철학적 입장을 나타냅니다. 즉, 인간의 역할이 *코드 구현자*에서 *시스템 설계자 및 요구사항 명세자*로 전환되고 있다는 것입니다. Taskmaster AI는 "모호한 아이디어를 코드로" 만드는 도구가 아니라 "상세한 명세를 코드로" 만드는 도구입니다. 이 워크플로우는 "AI와 채팅하며 무언가를 만들 때까지"의 자유로운 방식이 아니라, 인간 정의 \-\> AI 파싱 \-\> AI 구조화 \-\> 인간 승인 \-\> AI 구현이라는 공식적이고 다단계적인 프로세스입니다.11 이는 Taskmaster가 전통적인 소프트웨어 엔지니어링 생명주기(요구사항 수집, 계획, 구현)를 강제함을 의미합니다. 따라서 이 도구의 주요 가치는 개발자를 대체하는 것이 아니라,

*훈련된* 개발자를 보강하는 데 있습니다. 이는 AI 시대에 높은 수준의 계획 및 명세 작성 기술의 중요성을 더욱 부각시킵니다.

#### **3.3. 주석이 달린 PRD 예제 및 생성 프롬프트**

이 섹션에서는 가상의 애플리케이션(예: 간단한 CRM)에 대한 완전하고 잘 구조화된 샘플 PRD를 제공합니다.  
또한, 사용자가 Gemini 2.5 Pro와 같은 LLM에게 20 글머리 기호 목록에서 구조화된 PRD를 생성하도록 제공할 수 있는 강력한 프롬프트 템플릿을 포함할 것입니다. 이 프롬프트는 18에서 발견된 상세한 구조를 기반으로 하며, AI에게 서론, 제품 개요, 목표, 대상 고객, 기능 등의 섹션을 만들도록 지시합니다.

### **4장: 통합 개발 경험: AI 네이티브 IDE와 함께 Taskmaster 사용하기**

#### **4.1. 모델 제어 프로토콜(MCP) 이해하기**

MCP는 AI 클라이언트(IDE 등)가 외부 도구(Taskmaster AI 등)와 표준화된 방식으로 상호작용할 수 있게 하는 시스템입니다.5 이는 원활한 채팅 기반 워크플로우의 핵심입니다.

Taskmaster AI는 MCP 서버로 실행되며, IDE의 AI 에이전트로부터 명령을 수신 대기합니다. 이를 통해 에이전트는 사용자가 터미널을 전혀 건드리지 않고도 parse-prd나 list와 같은 기능을 실행할 수 있습니다.14 이는 에이전트가 목표를 달성하기 위해 여러 도구를 사용할 수 있는 에이전트 AI의 광범위한 추세의 일부입니다.21

#### **4.2. 워크플로우 시연: 자연어를 통한 상호작용**

MCP가 구성되면 워크플로우는 대화형이 됩니다. 사용자는 IDE의 채팅 에이전트(예: Cursor)와 상호작용합니다.

**상호작용 흐름 예시:**

1. "내 프로젝트에 taskmaster-ai를 초기화해 줘." 11  
2. 사용자는 prd.txt 파일을 scripts/ 또는 .taskmaster/docs/ 디렉토리에 배치합니다.5  
3. "scripts/prd.txt에 있는 내 PRD를 파싱해 줄 수 있니?" 에이전트는 task-master parse-prd를 실행하여 tasks.json을 생성합니다.7  
4. "다음에 작업해야 할 태스크는 뭐야?" 에이전트는 task-master next를 실행하여 상태와 종속성에 따라 다음에 실행 가능한 항목을 결정합니다.7  
5. "태스크 3을 구현하는 데 도움을 줄 수 있니?" 사용자와 에이전트는 이제 특정하고 범위가 좁혀진 태스크에 집중합니다.7  
6. "태스크 3이 완료되었어." 에이전트는 태스크 상태를 "완료(done)"로 업데이트합니다.6

#### **4.3. 주요 IDE를 위한 MCP 구성 표**

이 표는 가장 일반적인 개발 환경에서 MCP 서버를 설정하기 위한 단일하고 명확하며 복사-붙여넣기 가능한 참조를 제공합니다. 이는 오류가 발생하기 쉬운 중요한 단계로, 보고서를 통해 완벽하게 만들 수 있습니다.

| IDE | 구성 파일 경로 | JSON 구성 스니펫 |
| :---- | :---- | :---- |
| Cursor | \~/.cursor/mcp.json (전역) 또는 \<project\>/.cursor/mcp.json (프로젝트) | json { "mcpServers": { "task-master-ai": { "command": "npx", "args": \["-y", "--package=task-master-ai", "task-master-ai"\], "env": { "ANTHROPIC\_API\_KEY": "YOUR\_ANTHROPIC\_API\_KEY\_HERE", "OPENAI\_API\_KEY": "YOUR\_OPENAI\_KEY\_HERE", "GOOGLE\_API\_KEY": "YOUR\_GOOGLE\_KEY\_HERE" } } } } |
| VS Code | \<project\>/.vscode/mcp.json (프로젝트) | json { "servers": { "task-master-ai": { "command": "npx", "args": \["-y", "--package=task-master-ai", "task-master-ai"\], "env": { "ANTHROPIC\_API\_KEY": "YOUR\_ANTHROPIC\_API\_KEY\_HERE", "OPENAI\_API\_KEY": "YOUR\_OPENAI\_KEY\_HERE", "GOOGLE\_API\_KEY": "YOUR\_GOOGLE\_KEY\_HERE" } } } } |
| Windsurf | \~/.codeium/windsurf/mcp\_config.json (전역) | json { "mcpServers": { "task-master-ai": { "command": "npx", "args": \["-y", "--package=task-master-ai", "task-master-ai"\], "env": { "ANTHROPIC\_API\_KEY": "YOUR\_ANTHROPIC\_API\_KEY\_HERE", "OPENAI\_API\_KEY": "YOUR\_OPENAI\_KEY\_HERE", "GOOGLE\_API\_KEY": "YOUR\_GOOGLE\_KEY\_HERE" } } } } |

참고: env 객체에서 사용하지 않는 API 키는 제거할 수 있습니다. 5

### **5장: 커맨드 라인 인터페이스(CLI) 심층 분석**

#### **5.1. 작업 오케스트레이션을 위한 핵심 명령어 마스터하기**

MCP가 부드러운 UI를 제공하지만, 기본 CLI 명령어를 이해하는 것은 문제 해결 및 고급 스크립팅에 필수적입니다. 이 섹션에서는 각 주요 명령어의 기능과 플래그를 자세히 설명합니다.

#### **5.2. 비교 분석: CLI 대 MCP 사용 시점**

* **MCP:** 기본 개발 루프, 대화형 상호작용 및 IDE의 컨텍스트를 활용하는 작업에 이상적입니다.  
* **CLI:** 배치 작업, 스크립팅, CI/CD 파이프라인 통합 또는 지원되는 IDE가 없는 "헤드리스" 환경에서 작업할 때 더 좋습니다. 예를 들어, 스크립트는 새 PRD를 자동으로 파싱하고 초기 복잡성 보고서를 생성할 수 있습니다.

#### **5.3. 핵심 CLI 명령어 참조 표**

이 표는 도구의 커맨드 라인 기능에 대한 포괄적이고 빠른 참조 가이드 역할을 합니다.

| 명령어 | 설명 | 주요 플래그/옵션 | 사용 예시 |
| :---- | :---- | :---- | :---- |
| task-master init | 새 Taskmaster 프로젝트를 초기화하고 필요한 파일 구조를 설정합니다. | \-r, \--rules \<profiles\>: 특정 규칙 프로파일을 포함합니다. | task-master init \-r cursor,roo |
| task-master parse-prd \[file\] | PRD 파일을 파싱하여 tasks.json 파일을 생성합니다. | \--append: 기존 작업을 덮어쓰지 않고 새 작업을 추가합니다. | task-master parse-prd scripts/new\_features.txt \--append |
| task-master generate | tasks.json을 기반으로 개별 작업 파일(예: task\_001.txt)을 생성합니다. |  | task-master generate |
| task-master list | 모든 작업과 현재 상태를 나열합니다. |  | task-master list |
| task-master next | 종속성과 상태를 기반으로 다음에 작업할 작업을 제안합니다. |  | task-master next |
| task-master expand | 복잡한 작업을 더 작은 하위 작업으로 분해합니다. | \--id=\<id\>, \--prompt="\<prompt\>", \--all | task-master expand \--id=5 \--prompt="보안 측면에 집중" |
| task-master rules \[command\] | 프로젝트의 규칙 프로파일을 관리합니다. | add, remove, setup | task-master rules setup |

이 표는 7의 정보를 종합하여 작성되었습니다.

## **3부: 고급 기술 및 전략적 사용자 정의**

이 파트는 기본 워크플로우를 넘어 초보 사용자와 전문가를 구분하는 기능들을 탐색하며, 동적 프로젝트 관리와 깊이 있는 사용자 정의에 초점을 맞춥니다.

### **6장: 고급 작업 및 프로젝트 관리**

#### **6.1. 복잡성 분해: expand 명령어**

모든 작업을 AI가 "한 번에" 처리할 수는 없습니다. 복잡한 작업의 경우, expand 명령어를 사용하여 더 작고 관리하기 쉬운 하위 작업으로 분해합니다.6

이 명령어는 전용 "연구 모델"(예: Perplexity 모델)을 사용하여 상위 작업을 구현하는 최상의 방법을 연구한 다음 하위 작업을 생성할 수 있습니다.11 이는 익숙하지 않은 문제를 해결하는 데 강력한 기능입니다.

예시 프롬프트: "태스크 18을 어떻게 구현해야 할지 잘 모르겠어. Perplexity에서 연구해서 필요한 하위 태스크를 알아내 줄 수 있니?".24  
이 expand 명령어와 연구 모델의 조합은 단순하지만 강력한 형태의 에이전트 계획(agentic planning)을 나타냅니다. 시스템은 단순히 작업을 분해하는 것이 아니라, 계획 과정에 정보를 제공하기 위해 도구적 행동(연구)을 수행합니다. 이는 단순한 작업 실행을 넘어 문제 해결의 영역으로 들어서는 한 걸음입니다. 기본 워크플로우가 PRD 파싱 \-\> 작업 생성의 직접적인 변환인 반면, expand 명령어는 작업 선택 \-\> 구현 연구 \-\> 하위 작업 생성이라는 새로운 단계를 추가합니다.11 별도의 "연구 모델" 13 사용은 다중 에이전트 또는 다중 도구 접근 방식을 시사합니다. 한 에이전트는 계획에 능하고(주요 모델), 다른 에이전트는 정보 검색에 능합니다(연구 모델). 이는 RAG(검색 증강 생성) 및 도구 사용 에이전트와 같은 고급 에이전트 패턴을 반영합니다.21 따라서

expand는 단순한 편의 기능이 아니라, Taskmaster 내에 더 정교한 AI 아키텍처를 구현한 것으로, 행동하기 전에 스스로 정보를 수집할 수 있는 더 자율적이고 유능한 에이전트로 나아가는 길을 보여줍니다.

#### **6.2. 프로젝트 진화 관리: 작업 수정, 폐기 및 추가**

프로젝트는 정적이지 않습니다. Taskmaster는 변화하는 요구사항에 적응하기 위한 명령어와 프롬프트를 제공합니다.  
사용자는 새로운 작업을 추가하고, 기존 작업의 방향을 바꾸거나, 더 이상 필요 없는 작업을 표시하는 등 모든 것을 기본 도구를 트리거하는 자연어 프롬프트를 통해 수행할 수 있습니다.18

예시: "이미지 생성 태스크에 변경이 있어야 해. 태스크 3을 이걸로 업데이트하고 다시 보류 상태로 설정해 줘.".18

#### **6.3. 종속성 관리 및 논리적 흐름 보장**

tasks.json 파일은 각 작업에 대한 dependencies 필드를 포함합니다.11

task-master next 명령어는 이 정보를 지능적으로 사용하여 모든 종속성이 "완료"로 표시된 경우에만 다음 작업을 제안합니다.11

사용자는 AI에게 종속성 그래프를 검증하도록 요청할 수도 있습니다: "태스크 파일을 검토해서 종속성이 올바른지 확인해 줄 수 있니? 틀렸다면 수정해 줘.".24

### **7장: 지능 설계: 규칙 사용자 정의 가이드**

#### **7.1. .cursor/rules/ 디렉토리 설명**

이 디렉토리는 AI 에이전트를 위한 프로젝트별 영구 지침의 홈입니다.11

하나의 큰 .cursorrules 파일 대신, 규칙을 architecture.mdc, stack.mdc, styling.mdc와 같은 논리적 파일로 분할하여 더 나은 구성을 할 수 있습니다.15

Taskmaster의 init 명령어는 dev\_workflow.mdc 파일을 자동으로 생성하여 AI에게 Taskmaster 명령어를 사용하는 방법을 가르칩니다.11

#### **7.2. 사용자 정의 .mdc 파일 작성**

이곳에서 사용자는 프로젝트의 고유한 "DNA"를 주입할 수 있습니다. 사용자 정의 규칙은 다음을 포함해야 합니다:

* 기술 스택 및 라이브러리 버전.18  
* 전체 프로젝트 구조 및 폴더 명명 규칙.18  
* 코드 명명 규칙 (예: "변수에는 camelCase 사용").18  
* 스타일/언어 선호도 (예: "Python 함수에는 항상 docstring 포함").18  
* UI 코딩 선호도 (예: "Tailwind CSS 유틸리티 클래스 사용, 사용자 정의 CSS 파일 사용 금지").18

  Taskmaster AI의 최근 업데이트는 task-master rules add/remove/setup 명령어로 이러한 규칙 프로파일을 프로그래밍 방식으로 관리할 수 있게 해줍니다.23

"규칙" 시스템은 특정 프로젝트를 위한 일종의 "헌법적 AI(Constitutional AI)" 형태입니다. 이는 LLM의 행동을 제약하는 일련의 불가침 원칙을 제공하여, 길고 복잡한 프로젝트 전반에 걸쳐 일관성과 표준 준수를 보장합니다. 이는 품질을 확장하기 위한 메커니즘입니다. LLM의 주요 문제 중 하나는 긴 상호작용 동안 방향을 잃거나 "환각"을 일으키는 경향입니다.1

rules 파일은 모든 상호작용과 함께 로드되는 영구적이고 우선순위가 높은 컨텍스트를 제공합니다.11 이러한 규칙은 프로젝트 내에서 AI 행동에 대한 가드레일 또는 "헌법" 역할을 합니다.18 따라서

rules 시스템을 마스터하는 것은 단순히 사용자 정의에 관한 것이 아닙니다. 이는 AI 에이전트를 효과적으로 통제하여 대규모로 고품질의 유지보수 가능한 코드를 생산하는 방법을 배우는 것입니다. 이는 AI로 인한 기술 부채와 싸우는 주요 도구입니다.

#### **7.3. 실용 예제: Python/React 프로젝트를 위한 사용자 정의 규칙 세트**

이 섹션에서는 가상 프로젝트를 위한 상세하고 주석이 달린 .mdc 파일 세트를 제공합니다.

* stack.mdc: "React 18을 함수형 컴포넌트와 Hooks와 함께 사용합니다. 백엔드는 Flask를 사용하는 Python 3.11입니다."  
* styling.mdc: "모든 스타일링은 Tailwind CSS로 수행해야 합니다. 컴포넌트는 Shadcn/UI를 사용하여 구축해야 합니다."  
* testing.mdc: "모든 백엔드 API 엔드포인트에는 해당 Pytest 유닛 테스트가 있어야 합니다. 프론트엔드 컴포넌트에는 기본 Storybook 스토리가 있어야 합니다."

## **4부: 비판적 평가 및 전략적 도입**

이 마지막 파트는 Taskmaster AI에 대한 균형 잡힌 실제 평가를 제공하여, 사용자가 도구 도입에 대한 정보에 입각한 결정을 내리고 성공적으로 수행하는 방법을 돕습니다.

### **8장: 실제 평가: 사용자 경험에 대한 균형 잡힌 검토**

#### **8.1. 약속 대 현실: 과대 광고 분석**

* **약속:** 10배의 생산성 향상과 코딩 오류 90% 감소 주장은 홍보 자료와 튜토리얼에서 흔히 볼 수 있습니다.6 이 도구는 "게임 체인저"로 소개됩니다.6  
* **현실:** Reddit과 같은 플랫폼의 사용자 경험은 더 미묘한 그림을 그립니다. 많은 사람들이 작업을 구조화하는 데 강력하다고 생각하지만 20, 상당한 좌절과 가파른 학습 곡선에 직면하기도 합니다.17

#### **8.2. 장단점에 대한 미묘한 시각**

* **장점:**  
  * **구조와 집중:** AI를 궤도에 유지하고 컨텍스트 과부하를 줄이는 훈련되고 계획된 접근 방식을 강제합니다.1  
  * **복잡성 관리:** 크고 야심찬 프로젝트를 실행 가능한 단계로 나누는 데 탁월합니다.14  
  * **생산성 향상:** 워크플로우를 마스터하면 상용구 및 반복적인 코딩 작업을 자동화하여 개발 속도를 크게 높일 수 있습니다.26  
* **단점:**  
  * **가파른 학습 곡선:** 사고방식의 전환과 새롭고 복잡한 워크플로우 학습이 필요합니다. 간단한 "플러그 앤 플레이" 도구가 아닙니다.17  
  * **AI 무오류 신화:** AI는 완벽하지 않습니다. 최적이 아닌 코드를 생성하거나, 버그를 도입하거나, PRD의 요구사항을 누락할 수 있습니다. 인간의 감독과 검토는 필수적입니다.17  
  * **코드 품질 문제 가능성:** 개발자가 제안을 완전히 이해하지 않고 수락하면 AI에 대한 과도한 의존이 코드 변동(churn)이나 기술 부채로 이어질 수 있습니다.26

#### **8.3. 일반적인 문제 및 문제 해결 가이드 표**

이 표는 커뮤니티에서 보고된 가장 일반적인 좌절을 사용자가 극복하는 데 도움이 되는 실용적이고 실행 가능한 가이드를 만듭니다.

| 문제 | 증상 (사용자 보고 기준) | 잠재적 원인 | 완화 전략 / 해결책 |
| :---- | :---- | :---- | :---- |
| **과도한 API 비용** | "단 25개의 작업을 만드는 데 50만 토큰을 소모했다" 17 | 모호한 프롬프트나 실패하는 작업으로 인한 AI 에이전트의 루프; 너무 큰 PRD | API 지출 한도를 설정하고, 간단한 작업에는 더 작고 저렴한 모델을 사용하며, 컨텍스트를 지우기 위해 자주 새 채팅 스레드를 시작합니다. |
| **PRD 파싱 실패** | "Taskmaster가 내 PRD에서 중요한 구성 요소를 누락하고 있다" 17 | PRD가 너무 모호하거나 명시적인 지침이 부족함. | 더 구체적이고 명령적인 언어로 PRD를 개선하고, 실행 전에 작업 목록을 수동으로 검토하고 승인합니다. |
| **터미널 호환성 오류** | "MCP 서버가 Warp 터미널에서 제대로 시작되지 않는다" 17 | 터미널별 환경 변수 또는 렌더링 문제. | 기본 VS Code 또는 iTerm2와 같은 지원되는 터미널을 사용하고, GitHub 리포지토리에서 알려진 문제를 확인합니다. |
| **과도한 엔지니어링** | "Taskmaster \+ Cursor가 종종 과도하게 엔지니어링하는 경향이 있다" 20 | AI가 최상의 경로를 추론하려 하지만, 때로는 가장 복잡한 경로를 선택함. | PRD와 규칙에 제약 조건을 더 명확하게 명시하고(예: "이 기능에는 데이터베이스가 필요 없음"), AI가 생성한 계획을 면밀히 검토합니다. |

### **9장: 전략적 구현 및 미래 전망**

#### **9.1. Taskmaster AI는 누구를 위한 것인가? 이상적인 사용자 정의**

이상적인 사용자는 시스템 수준의 사고에 익숙한, 훈련되고 기술적으로 능숙한 개발자 또는 기술 리더입니다. 그들은 AI를 마법의 블랙박스가 아니라, 설계되고 통제되어야 할 강력한 시스템으로 봅니다. 초보자나 간단한 원클릭 솔루션을 찾는 사람들에게는 덜 적합합니다.1

#### **9.2. 개인 및 팀을 위한 단계적 도입 프레임워크**

* **1단계: 기본 배우기.** 작고 중요하지 않은 프로젝트로 시작합니다. PRD \-\> parse-prd \-\> next \-\> 구현의 핵심 루프를 마스터하는 데 집중합니다. 메커니즘을 이해하기 위해 CLI를 직접 사용합니다.  
* **2단계: IDE와 통합.** MCP 서버를 설정하고 대화형 워크플로우로 전환합니다.  
* **3단계: 사용자 정의 및 확장.** 팀 표준을 강제하기 위해 사용자 정의 rules 파일을 작성하기 시작합니다. 더 복잡한 작업에 expand 명령어를 실험합니다.  
* **4단계: 비용 관리 및 거버넌스.** API 사용량을 적극적으로 모니터링합니다. 어떤 작업을 위해 어떤 모델을 사용할지에 대한 명확한 정책을 정의합니다(예: 간단한 작업에는 저렴한 모델, 연구/확장에는 강력한 모델).

#### **9.3. 에이전트 AI 생태계에서 Taskmaster AI의 위치**

Taskmaster AI는 AI 개발에서 더 넓은 "다중 구성 요소 계획(Multi-Component Planning)" 패턴의 특정 구현으로 볼 수 있습니다.14

이는 Autogen, CrewAI (다중 에이전트 협업에 초점) 28 및 Roocode Boomerang Tasks나 Shrimp Task Manager와 같은 더 간단한 작업 관리 시스템과 같은 분야의 다른 도구들과 경쟁하고 보완합니다.18

#### **9.4. 결론: 인간-AI 협업의 미래**

Taskmaster AI는 까다롭지만 소프트웨어 개발의 미래를 엿볼 수 있는 강력한 도구입니다. 이는 가장 가치 있는 인간의 기술이 한 줄 한 줄 코드를 작성하는 것이 아니라, AI 인력이 실행할 명확하고 포괄적이며 모호하지 않은 명세를 만드는 능력인 패러다임을 제시합니다. 이러한 도구의 숙달은 차세대 엘리트 개발자에게 핵심적인 차별화 요소가 될 것입니다.

#### **참고 자료**

1. TaskMaster AI Changed How I Code With AI (And It Might Change Yours Too) \- Medium, 7월 25, 2025에 액세스, [https://medium.com/@fletlajn/taskmaster-ai-changed-how-i-code-with-ai-and-it-might-change-yours-too-853b958c54b0](https://medium.com/@fletlajn/taskmaster-ai-changed-how-i-code-with-ai-and-it-might-change-yours-too-853b958c54b0)  
2. Taskmaster AI Bookmarks \- William Callahan, 7월 25, 2025에 액세스, [https://williamcallahan.com/bookmarks/tags/taskmaster-ai](https://williamcallahan.com/bookmarks/tags/taskmaster-ai)  
3. AI Project Management Bookmarks \- William Callahan, 7월 25, 2025에 액세스, [https://williamcallahan.com/bookmarks/tags/ai-project-management](https://williamcallahan.com/bookmarks/tags/ai-project-management)  
4. taskmaster · GitHub Topics, 7월 25, 2025에 액세스, [https://github.com/topics/taskmaster](https://github.com/topics/taskmaster)  
5. eyaltoledano/claude-task-master: An AI-powered task-management system you can drop into Cursor, Lovable, Windsurf, Roo, and others. \- GitHub, 7월 25, 2025에 액세스, [https://github.com/eyaltoledano/claude-task-master](https://github.com/eyaltoledano/claude-task-master)  
6. Taskmaster AI Tutorial: 10X AI Coding & Cut 90% of Errors \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=iGqjh6cNEz8](https://www.youtube.com/watch?v=iGqjh6cNEz8)  
7. robson-paproski/task-master: An AI-powered task-management system you can drop into Cursor, Lovable, Windsurf, Roo, and others. \- GitHub, 7월 25, 2025에 액세스, [https://github.com/robson-paproski/task-master](https://github.com/robson-paproski/task-master)  
8. aamanbhagat/TaskMaster-AI \- GitHub, 7월 25, 2025에 액세스, [https://github.com/aamanbhagat/TaskMaster-AI](https://github.com/aamanbhagat/TaskMaster-AI)  
9. Pricing \- TaskMaster AI, 7월 25, 2025에 액세스, [https://www.taskmaster.one/pricing](https://www.taskmaster.one/pricing)  
10. TaskMaster AI: Your Smart AI Study Agent, 7월 25, 2025에 액세스, [https://www.taskmaster.one/](https://www.taskmaster.one/)  
11. claude-task-master/docs/tutorial.md at main \- GitHub, 7월 25, 2025에 액세스, [https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md](https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md)  
12. Task Master: Installation, 7월 25, 2025에 액세스, [https://taskmaster-49ce32d5.mintlify.app/](https://taskmaster-49ce32d5.mintlify.app/)  
13. eighty9nine/task-master: An AI-powered task-management system you can drop into Cursor, Lovable, Windsurf, Roo, and others. \- GitHub, 7월 25, 2025에 액세스, [https://github.com/eighty9nine/task-master](https://github.com/eighty9nine/task-master)  
14. How Taskmaster AI Reduces Vibe Coding Errors by 90% \- Geeky ..., 7월 25, 2025에 액세스, [https://www.geeky-gadgets.com/taskmaster-ai-coding-efficiency/](https://www.geeky-gadgets.com/taskmaster-ai-coding-efficiency/)  
15. Preparing a project to be vibe-coded \- seroperson.me, 7월 25, 2025에 액세스, [https://seroperson.me/2025/05/02/preparing-a-project-to-be-vibe-coded/](https://seroperson.me/2025/05/02/preparing-a-project-to-be-vibe-coded/)  
16. Taskmaster 2.0 \+ Cline, Roo, Windsurf & Cursor : This is NOW THE BEST Task Manager for YOUR AI Coder \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=IF1VuThI\_50\&pp=0gcJCfwAo7VqN5tD](https://www.youtube.com/watch?v=IF1VuThI_50&pp=0gcJCfwAo7VqN5tD)  
17. taskmasterai \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/taskmasterai/](https://www.reddit.com/r/taskmasterai/)  
18. How to Reduce AI Coding Errors with a Claude TaskMaster AI, a task manager MCP, 7월 25, 2025에 액세스, [https://shipixen.com/tutorials/reduce-ai-coding-errors-with-taskmaster-ai](https://shipixen.com/tutorials/reduce-ai-coding-errors-with-taskmaster-ai)  
19. Turning Cursor into a task-based AI coding system | by Meelis Ojasild | Jun, 2025 | Medium, 7월 25, 2025에 액세스, [https://meelis-ojasild.medium.com/turning-cursor-into-a-task-based-ai-coding-system-31e1e3bf047b](https://meelis-ojasild.medium.com/turning-cursor-into-a-task-based-ai-coding-system-31e1e3bf047b)  
20. AI-Powered Development with Cursor and TaskMaster : r/rails \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/rails/comments/1l5qk0l/aipowered\_development\_with\_cursor\_and\_taskmaster/](https://www.reddit.com/r/rails/comments/1l5qk0l/aipowered_development_with_cursor_and_taskmaster/)  
21. Agentic RAG vs. Traditional RAG \- Pureinsights, 7월 25, 2025에 액세스, [https://pureinsights.com/blog/2025/agentic-rag-vs-traditional-rag/](https://pureinsights.com/blog/2025/agentic-rag-vs-traditional-rag/)  
22. How I Made Coding 10x Faster With One Simple Setup\! (Task Master) \- YouTube, 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=47UW2XXpxms\&pp=0gcJCfwAo7VqN5tD](https://www.youtube.com/watch?v=47UW2XXpxms&pp=0gcJCfwAo7VqN5tD)  
23. Releases · eyaltoledano/claude-task-master \- GitHub, 7월 25, 2025에 액세스, [https://github.com/eyaltoledano/claude-task-master/releases](https://github.com/eyaltoledano/claude-task-master/releases)  
24. Task Master: How I solved Cursor code slop and escaped the AI loop of hell (Claude/Gemini/Perplexity powered) : r/ClaudeAI \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/ClaudeAI/comments/1jlhg7g/task\_master\_how\_i\_solved\_cursor\_code\_slop\_and/](https://www.reddit.com/r/ClaudeAI/comments/1jlhg7g/task_master_how_i_solved_cursor_code_slop_and/)  
25. Pattern 2: Contextual Conversational Clients — Grounding Conversations with Relevance | by Bhuvaneswari Subramani | Jun, 2025 | Medium, 7월 25, 2025에 액세스, [https://medium.com/@bhuvaneswari.subramani/pattern-2-contextual-conversational-clients-grounding-conversations-with-relevance-d8f82e0385e0](https://medium.com/@bhuvaneswari.subramani/pattern-2-contextual-conversational-clients-grounding-conversations-with-relevance-d8f82e0385e0)  
26. TaskMaster AI Review: Is It the Ultimate Automation Tool for Developers? \- Sidetool, 7월 25, 2025에 액세스, [https://www.sidetool.co/post/taskmaster-ai-review-is-it-the-ultimate-automation-tool-for-developers](https://www.sidetool.co/post/taskmaster-ai-review-is-it-the-ultimate-automation-tool-for-developers)  
27. TaskMaster consumed all available API credit while "timing out". : r/taskmasterai \- Reddit, 7월 25, 2025에 액세스, [https://www.reddit.com/r/taskmasterai/comments/1lehatt/taskmaster\_consumed\_all\_available\_api\_credit/](https://www.reddit.com/r/taskmasterai/comments/1lehatt/taskmaster_consumed_all_available_api_credit/)  
28. Best Free AI Agent Builders for Developers in 2025 \- GoCodeo, 7월 25, 2025에 액세스, [https://www.gocodeo.com/post/best-free-ai-agent-builders-for-developers-in-2025](https://www.gocodeo.com/post/best-free-ai-agent-builders-for-developers-in-2025)  
29. Didn't think AI can code like this (TaskMaster AI \+ Cursor guide for vibe coding setup), 7월 25, 2025에 액세스, [https://www.youtube.com/watch?v=dH4mc9VQ96g](https://www.youtube.com/watch?v=dH4mc9VQ96g)
</file>

<file path="references/threads-ui-analysis.md">
# Threads UI 레퍼런스 분석

## 분석 개요
- **파일**: threads-cleaned.html
- **분석일**: 2025-01-25
- **목적**: 워클리 프론트엔드 개발을 위한 UI/UX 패턴 연구

## 🎨 디자인 시스템

### 색상 팔레트
- **배경색**: #FAFAFA (밝은 회색)
- **카드 배경**: #FFF (순백)
- **텍스트**: #000 (순검정)
- **보조 텍스트**: #999, #424242 (회색 계열)
- **경계선**: #D5D5D5, #DBDBDB

### 타이포그래피
- **폰트 패밀리**: Roboto, -apple-system, BlinkMacSystemFont
- **주요 폰트 크기**: 15px (제목), 14px (본문), 13px (액션)
- **폰트 두께**: 700 (볼드), 400 (일반)

### CSS 변수 시스템
- 일관된 디자인 토큰 관리
- 재사용 가능한 컴포넌트 스타일링
- 반응형 디자인을 위한 유연한 값 관리

## 📱 레이아웃 구조

### 데스크톱 레이아웃
```
┌─────┬─────────────────┐
│ Nav │     Header      │
│(72) │   Feed(640px)   │
│     │                 │
│     │     Posts       │
│     │                 │
└─────┴─────────────────┘
```

### 모바일 레이아웃
```
┌───────────────────┐
│      Header       │
├───────────────────┤
│       Feed        │
│                   │
│      Posts        │
│                   │
├───────────────────┤
│   Bottom Nav      │
└───────────────────┘
```

### 주요 구조 요소
- **좌측 네비게이터**: 72px 고정 폭, 세로 중앙 정렬
- **메인 피드**: 640px 중앙 정렬
- **반응형 브레이크포인트**: 768px

## 🧭 네비게이션 패턴

### 좌측 네비게이션 (데스크톱)
1. **로고 영역**: @ 심볼 (32px)
2. **메인 메뉴** (5개 항목):
   - 홈 (활성 상태)
   - 검색
   - 추가 (+)
   - 활동 (하트)
   - 프로필
3. **오버플로우 메뉴**: 점 3개 (하단)

### 상단 헤더
- **데스크톱**: 제목 + 드롭다운 + 인증 버튼
- **모바일**: 로고 + 메뉴 버튼

### 하단 네비게이션 (모바일)
- 5개 아이콘 균등 배치
- 60px 높이
- 활성 상태 시각적 피드백

## 💬 소셜 기능 요소

### 포스트 카드 구조
```
┌─────────────────────────────┐
│ [Avatar] Username • 9h  [⋯] │
│                             │
│ Post content text...        │
│                             │
│ [❤209] [💬9] [🔄60] [✈5]    │
└─────────────────────────────┘
```

### 상호작용 요소
- **좋아요**: 하트 아이콘 + 숫자
- **댓글**: 말풍선 아이콘 + 숫자
- **리포스트**: 재순환 아이콘 + 숫자
- **공유**: 비행기 아이콘 + 숫자

### 사용자 정보
- **프로필 아바타**: 36px 원형, 그라데이션 배경
- **사용자명**: 볼드 폰트
- **타임스탬프**: 회색 텍스트

## 🎯 워클리 적용 가능한 핵심 패턴

### 1. 레이아웃 패턴
- **중앙 정렬 피드**: 640px 고정 폭
- **좌측 고정 네비**: 아이콘 기반 세로 메뉴
- **카드 기반 콘텐츠**: 명확한 구분과 그림자

### 2. 상호작용 패턴
- **호버 효과**: 미묘한 배경색 변화
- **드롭다운 메뉴**: 컨텍스트 메뉴
- **플로팅 액션**: 우하단 고정 버튼

### 3. 반응형 패턴
- **모바일 퍼스트**: 하단 네비게이션
- **적응형 헤더**: 컨텍스트에 따른 요소 표시/숨김
- **터치 친화적**: 44px 최소 터치 영역

### 4. 시각적 패턴
- **미니멀 색상**: 흑백 기반 + 포인트 컬러
- **일관된 간격**: 12px, 16px, 24px 규칙
- **명확한 계층**: 폰트 크기와 두께로 구분

## 🛠 기술적 구현 요소

### CSS 구조
- **CSS 변수**: 디자인 토큰 관리
- **Flexbox**: 레이아웃 구성
- **미디어 쿼리**: 반응형 구현

### JavaScript 기능
- **드롭다운 토글**: 메뉴 표시/숨김
- **외부 클릭 감지**: 메뉴 자동 닫기
- **이벤트 위임**: 효율적인 이벤트 처리

## 워클리 개발 권장사항

### 1. 디자인 시스템 구축
- Threads의 색상 팔레트를 기반으로 브랜드 컬러 추가
- CSS 변수를 활용한 일관된 디자인 토큰
- 컴포넌트 기반 재사용 가능한 UI 요소

### 2. 레이아웃 전략
- 640px 중앙 정렬 피드 레이아웃 채택
- 좌측 네비게이션을 비즈니스 기능에 맞게 조정
- 모바일 하단 네비게이션 구현

### 3. 사용자 경험
- 직관적인 아이콘 사용
- 명확한 시각적 피드백
- 터치 친화적인 인터페이스 요소

### 4. 성능 최적화
- 최소한의 JavaScript 사용
- CSS 기반 애니메이션
- 효율적인 이벤트 처리
</file>

<file path="references/WORKLY_PLAN_1.0.md">
# **프로젝트 "모멘텀": 게이미피케이션 기반 생산성 생태계 구축을 위한 청사진**

## **섹션 1: 핵심 경험 \- 기반 및 사용자 여정**

이 기초 섹션에서는 앱의 핵심 디자인 원칙, 정보 아키텍처, 그리고 초기 사용자 경험을 정립합니다. 이는 앱의 복잡한 기능들이 사용자의 주요 요구사항인 Threads 스타일의 UI를 직접적으로 반영하여, 단순하고 직관적이며 매력적인 기반 위에 구축되도록 보장합니다.

### **1.1. 디자인 철학: 'Threads' 정신의 집중된 미니멀리즘**

핵심 원칙은 생산성 스위트의 풍부한 기능과 현대 소셜 앱의 극명한 단순함을 결합하는 것입니다. 이는 '점진적 공개(progressive disclosure)' 원칙에 대한 헌신을 의미합니다. 즉, 핵심적인 행동에 대해서는 인터페이스를 깔끔하게 유지하면서, 숙련된 사용자들이 더 깊은 기능에 직관적으로 접근할 수 있도록 허용하는 것입니다.

이러한 철학을 구현하기 위한 UI/UX의 핵심 기둥은 다음과 같습니다.1

* **단순성 및 명확성:** 모든 비본질적인 요소를 제거합니다. 모든 화면은 단 하나의 주요 목적을 가져야 합니다.5 충분한 여백, 깔끔한 타이포그래피(크고 가독성 높은 제목), 제한된 색상 팔레트를 사용하여 인지 부하를 줄입니다.3  
* **일관성 및 친숙성:** 플랫폼(iOS/Android) 관례를 준수하고, 앱 전체에 걸쳐 일관된 시각적 언어(아이콘, 버튼, 간격)를 유지하여 제이콥의 법칙(사용자는 익숙한 패턴을 선호한다)을 활용합니다.1  
* **시각적 계층 구조:** 크기, 색상, 대비를 사용하여 사용자의 주의를 가장 중요한 요소로 유도하고, 주요 행동이 항상 명확하게 보이도록 합니다.1  
* **피드백 및 마이크로인터랙션:** 모든 사용자 행동(예: 버튼 탭, 업무 완료)에 대해 즉각적이고 미묘한 시각적 피드백을 제공하여 앱이 반응적으로 느껴지게 하고, 도허티 임계값 원칙을 강화합니다.1

이러한 미니멀리즘 정신은 로그인 흐름에서도 명확하게 나타납니다. 스플래시 화면에는 단 하나의 'Google로 시작하기' 버튼만 제공됩니다. 이는 힉의 법칙(선택지가 많을수록 결정이 어려워진다)에 따라 결정의 마찰을 제거하고 접근을 간소화하는 전략적 선택입니다.2

### **1.2. 정보 아키텍처 및 내비게이션**

* **하단 내비게이션 바:** '홈', '프로젝트', '게시판', '활동', '프로필'의 5개 탭으로 구성된 고정 바를 제공합니다. 이는 앱의 핵심 기능 전반에 걸쳐 명확하고 일관된 내비게이션을 보장합니다.  
* **플로팅 액션 버튼(FAB) \- '생성' 허브:**  
  * **디자인:** 인체공학적 접근성을 위해 화면 오른쪽 하단에 위치한 단일 원형 FAB입니다.9  
  * **상호작용:** FAB를 탭하면 '업무 추가', '프로젝트 추가', '게시글 추가'라는 세 가지 명확하고 건설적인 행동이 포함된 오버플로우 메뉴('스피드 다이얼' 전환)가 나타납니다.10 이 디자인은 주 인터페이스를 복잡하게 만들지 않으면서 생성 관련 행동을 중앙에 집중시킵니다.  
  * **상황 인식:** FAB는 생성을 위한 주요 맥락인 홈, 프로젝트, 게시판 화면에만 존재합니다. 소비나 검토가 주된 행동인 프로필과 활동 화면에서는 숨겨져 사용자의 집중을 돕습니다.11

### **1.3. 첫 5분: 온보딩 및 활성화**

온보딩의 목표는 사용자를 가능한 한 빨리 '아하\! 모멘트(Aha\! Moment)'로 안내하는 것입니다. 이 앱에서 '아하\! 모멘트'는 *첫 번째 업무를 입력하고 그것이 홈 화면 최상단에 우선순위로 표시되는 것을 보는 순간*으로 정의됩니다.

사용자가 제품의 가치를 즉시 경험하게 하는 것은 초기 이탈률을 줄이는 데 결정적입니다. 따라서 온보딩 과정은 앱의 모든 기능을 나열하는 수동적인 설명서가 되어서는 안 됩니다.12 대신, 앱의 핵심 사용 습관, 즉 업무 관리 루프를 직접 경험하게 함으로써 가치를 즉각적으로 증명해야 합니다. 이러한 접근 방식은 '화면당 하나의 행동' 원칙을 사용자의 첫 학습 경험에 직접 적용하여, 유지율과 인지된 가치를 극대화합니다.5

온보딩 흐름은 다음과 같이 설계됩니다.12

1. **환영 화면:** Google 로그인 후, "당신의 업무를 정리하고, 목표를 달성하며, 역량을 성장시키세요."라는 앱의 핵심 가치 제안을 간결하게 설명하는 단일 화면이 표시됩니다.  
2. **대화형 튜토리얼:** 수동적인 슬라이드쇼 대신, 사용자는 즉시 '업무 추가' 흐름으로 안내됩니다. 툴팁이 GTD 기반의 입력 과정을 단계별로 안내합니다 (예: "우선, 머릿속에서 꺼내세요. 무엇이 마음에 걸리나요?").  
3. **첫 가치 전달:** 업무를 저장하면, 사용자는 홈 화면으로 이동하며, 새로 생성된 업무 카드가 목록 상단에 하이라이트되는 애니메이션이 재생됩니다. 이는 앱의 핵심 기능을 즉시 시연하고 가치를 전달합니다.  
4. **권한 요청:** 알림과 같은 권한 요청은 초기부터 한꺼번에 요구하는 대신, 처음으로 마감일을 설정하는 등 관련 맥락에서만 이루어져 사용자 경험의 방해를 최소화합니다.

## **섹션 2: 생산성 엔진 \- 홈 및 업무 관리**

이 섹션은 앱의 핵심적인 일일 사용 기능을 상세히 설명하며, 강력한 생산성 방법론(GTD)을 지능적이고 미니멀한 인터페이스와 결합하여 사용자가 진정으로 중요한 것에 집중할 수 있도록 돕습니다.

### **2.1. 지능형 '오늘' 보기: 우선순위 기반 업무 목록**

* **UI:** Threads 피드처럼 깔끔하고 스크롤 가능한 '업무 카드' 피드로 구성됩니다. 각 카드는 업무 제목, 관련 프로젝트(색상 코딩된 태그 포함), 마감일을 표시합니다. 완료된 업무는 만족스러운 체크 애니메이션과 함께 '완료됨' 섹션으로 이동하며 흐려집니다.  
* **우선순위 알고리즘 \- '모멘텀 점수':** 목록 최상단의 업무는 단순히 마감일이 가장 가까운 것이 아닙니다. 이는 단순화된 RICE 모델을 사용하여 계산된 '모멘텀 점수'에 의해 결정됩니다.14  
  * **Reach (프로젝트 중요도):** 이 업무에 의존하는 다른 업무나 프로젝트 마일스톤은 몇 개인가?  
  * **Impact (긴급성/중요성):** 마감일 근접도와 사용자가 정의한 우선순위(아이젠하워 매트릭스 모델 사용)의 조합.  
  * **Confidence (명확성):** 업무가 명확한 다음 단계와 함께 잘 정의되었는가? (모호한 업무에는 낮은 점수를 부여하여 사용자가 명확히 하도록 유도).  
  * **Effort (예상 소요 시간):** 소요 시간이 적은 업무에 약간의 가산점을 주어 빠른 성공 경험을 통해 동기를 부여하고 모멘텀을 형성.  
* **보기 및 필터:** 상단의 간단한 탭이나 필터 아이콘을 통해 '오늘'(알고리즘 정렬), '완료됨', '전체', '나중에 할 일'(마감일 없는 업무) 보기 간 전환이 가능합니다.  
* **검색:** 모든 프로젝트의 모든 업무를 즉시 찾을 수 있는 눈에 띄는 검색 바를 제공합니다.

### **2.2. GTD 기반 업무 생성 흐름**

이 흐름은 데이비드 앨런의 GTD(Getting Things Done) 방법론을 직접 구현하여, 스트레스 없는 '브레인 덤프'를 유도하도록 설계되었습니다.17 많은 생산성 앱들이 제목, 프로젝트, 마감일, 우선순위 등 모든 필드를 한 번에 보여주는 거대한 양식을 제시함으로써 마찰을 유발합니다. GTD 방법론의 핵심은 순차적 프로세스입니다: 먼저 모든 것을 수집하고, 그 다음에 처리하는 것입니다. UI는 이러한 흐름을 반영해야 합니다. '업무 추가' 흐름을 '수집 → 명료화 → 정리'라는 개별 단계로 분해함으로써, 각 단계의 인지 부하를 줄입니다. 이는 데이터 입력처럼 느껴지는 경험을 안내받는 대화처럼 만들어, 사용자가 꾸준히 사용할 가능성을 높입니다.17

1. **1단계: 수집 (FAB으로 실행):** "무엇이 마음에 걸리나요?"라는 문구와 함께 간단한 텍스트 필드가 나타납니다. 유일한 목표는 업무나 아이디어를 적는 것입니다. 다른 것은 없습니다.  
2. **2단계: 명료화 ('실행 가능한가요?' 화면):** 앱이 간단한 질문들을 순차적으로 제시합니다.  
   * "실행 가능한 일인가요?" (아니오라면, '참고 자료' 또는 '언젠가/어쩌면' 목록으로 분류).  
   * "2분 안에 끝낼 수 있나요?" (예라면, UI는 지금 바로 처리하도록 권장 \- '2분 규칙').17  
   * "더 큰 목표의 일부인가요?" (기존 프로젝트에 할당하거나 새 프로젝트를 생성하도록 유도).  
3. **3단계: 정리 ('세부 정보' 화면):** 사용자는 마감일, 우선순위(긴급/중요, 중요/긴급하지 않음 등의 4분면 아이젠하워 매트릭스 UI 사용) 21, 공유 프로젝트인 경우 담당자 지정 등의 세부 정보를 추가합니다.  
4. **4단계: 실행:** 이제 업무는 '오늘' 보기에 나타나 실행 준비가 완료됩니다.  
5. **5단계: 검토:** 매주 알림을 통해 사용자에게 '주간 검토'를 수행하도록 안내합니다. 이는 수집되었지만 명료화되지 않은 업무들의 '수신함', 다가오는 마감일, 프로젝트 진행 상황을 체계적으로 검토하는 과정입니다.

### **2.3. 프로젝트 진행률 통합**

모든 업무는 프로젝트에 속합니다. 홈 화면의 최우선 업무 카드에는 관련 프로젝트의 진행률 표시줄이 미묘하게 표시되어, 개인의 노력이 더 큰 목표와 어떻게 연결되는지 시각적으로 보여줍니다. 업무를 완료하면 진행률 표시줄이 채워지는 애니메이션이 재생되어 직접적인 피드백 루프를 제공합니다.

## **섹션 3: 협업 허브 \- 프로젝트**

이 섹션에서는 프로젝트 공간을 현대적이고 민첩한 팀을 위해 설계된 역동적인 '채팅 우선' 환경으로 정의합니다. 단순한 업무 목록을 넘어 목표 설정, 팀 구성, 명확한 인센티브 시스템을 통합합니다.

### **3.1. 채팅 우선 프로젝트 관리**

* **핵심 개념:** 프로젝트의 주 화면은 Slack이나 Microsoft Teams와 유사한 영구적인 채팅 채널입니다.23 모든 프로젝트 관련 커뮤니케이션, 파일 공유, 업데이트가 이곳에서 이루어져 단일 정보 소스(Single Source of Truth)를 형성합니다. 전통적인 프로젝트 관리 도구는 커뮤니케이션(댓글, 이메일)과 작업 자체(업무 목록)를 분리하여 단절된 워크플로우를 만듭니다. 채팅을 기본 인터페이스로 만들고 슬래시 명령어와 같은 행동을 직접 통합함으로써, 컨텍스트 전환을 줄입니다. 문제에 대한 대화가 채팅 창을 떠나지 않고 바로 실행 가능한 업무로 전환될 수 있습니다. 이는 MS Teams의 '메시지에서 업무 만들기' 기능에서 영감을 받아 워크플로우를 더 빠르고 자연스럽게 만들며, 업무 생성의 맥락적 기록을 완벽하게 보존합니다.25  
* **생산성을 위한 슬래시 명령어:** 26  
  * /add-task \[업무 설명\] @\[사용자\]\[마감일\]: 프로젝트의 업무 목록에 즉시 새 업무를 생성하고, 담당자를 지정하며, 마감일을 설정합니다. 확인 메시지가 채팅에 표시됩니다.  
  * /delegate @\[사용자\]: 기존 업무를 재할당합니다.  
  * /set-milestone \[마일스톤 이름\]\[마감일\]: 새로운 프로젝트 마일스톤을 정의합니다.  
  * /link-wiki \[위키 문서명\]: 게시판의 위키에서 관련 문서를 채팅에 링크합니다.  
* **채팅-업무 변환:** 25 채팅의 모든 메시지를 길게 누르면 "메시지에서 업무 만들기" 옵션이 있는 컨텍스트 메뉴가 나타납니다. 이는 메시지 텍스트를 새 업무로 변환하며, 컨텍스트를 위해 원래 대화로 다시 연결됩니다.

### **3.2. 비전에서 성공까지: 목표 설정 및 마일스톤**

* **프로젝트 헌장:** 모든 프로젝트는 핵심 목적을 정의하는 '프로젝트 헌장' 설정 화면으로 시작됩니다.  
* **목표 (Objective \- '왜'):** 질적이고 영감을 주는 목표입니다 (예: "새로운 마케팅 웹사이트 런칭"). 이것이 프로젝트의 북극성입니다.  
* **핵심 결과 (Key Results \- '무엇' \- 마일스톤):** 목표는 3-5개의 정량적이고 측정 가능한 마일스톤으로 나뉩니다.30 예: KR1: "홈페이지 디자인 목업 최종 완료." KR2: "프론트엔드 개발 완료." KR3: "PageSpeed Insights에서 95점 이상 달성."  
* **진행 상황 시각화:** 프로젝트의 메인 페이지에는 전체 목표와 각 핵심 결과(마일스톤)의 완료 상태를 보여주는 눈에 띄는 시각적 대시보드가 있습니다. 이는 OKR 소프트웨어 UI에서 영감을 받아 진행 상황을 한눈에 파악할 수 있게 합니다.32

### **3.3. 팀 구성: 프로젝트 기반 모집**

* **프로젝트 설정:** 프로젝트 생성자는 다음을 정의합니다.  
  * **필요 기술:** 태그 기반 시스템 (예: 'UX 디자인', 'Python', '카피라이팅').  
  * **팀 규모:** 멤버 수에 대한 엄격한 제한 (예: "5자리 남음").  
* **모집 흐름 (Upwork에서 영감):** 34  
  1. 프로젝트는 '공개' 또는 '초대 전용'으로 설정할 수 있습니다.  
  2. 공개된 경우, 게시판의 '멤버 모집 중인 프로젝트' 섹션에 표시됩니다.  
  3. 사용자는 이 프로젝트들을 둘러보고 자신의 적합성을 설명하는 짧은 제안서와 함께 '참여 신청'을 할 수 있습니다.  
  4. 프로젝트 리더는 신청서를 받고, 신청자의 프로필(기술, 과거 프로젝트, 평판)을 검토한 후 '수락' 또는 '거절'할 수 있습니다.  
  5. 팀 규모 제한에 도달하면 신청은 자동으로 마감됩니다.

### **3.4. 성공 인센티브: 보상 및 결과물**

* **시스템 설계:** 프로젝트 설정 시, 생성자는 다음을 정의할 수 있습니다.  
  * **결과물(Deliverables):** 프로젝트 목표와 관련된 최종 산출물 (예: "완전히 기능하는 웹사이트", "20페이지 분량의 시장 조사 보고서").  
  * **보상:** 마일스톤 기반 및 최종 보상을 모두 설정할 수 있습니다. 초기에는 앱 내 보상에 중점을 둡니다.  
    * **XP 보너스:** "마일스톤 1 완료 시 모든 팀원에게 500 XP 보너스 지급."  
    * **독점 업적/배지:** 최종 목표 완료 시 "런칭 데이 영웅" 업적.  
    * **향후 금전적 통합:** 시스템은 나중에 임무 게시판 기능을 위해 금전적 보상(예: 프로젝트 예산, 현상금)을 수용할 수 있도록 설계됩니다.

## **섹션 4: 생태계 \- 게시판**

이 섹션은 사용자의 모호했던 '게시판' 개념을 전문적인 성장과 기회를 위한 강력하고 다각적인 허브로 전환합니다. 특히 커뮤니티 기능에 대한 전략적 전환을 제안함으로써 사용자의 개선 요청에 직접적으로 부응합니다.

### **4.1. 임무 게시판: 프리랜서 마켓플레이스**

* **개념:** 외부 클라이언트(또는 예산이 있는 다른 앱 사용자)가 유료 업무나 프로젝트('임무')를 게시할 수 있는 공간입니다. 이는 앱 내 경제를 창출하고, 숙련된 사용자들에게 직접적인 수익화 경로를 제공합니다.  
* **클라이언트용 사용자 흐름 (임무 게시):** 34  
  1. **임무 게시:** 임무 제목, 설명, 필요 기술, 예산(고정 금액 또는 시간제), 마감일을 정의하는 간단한 양식.  
  2. **제안서 수신:** 앱 사용자는 제안서를 제출하여 임무에 '입찰'할 수 있습니다.  
  3. **검토 및 고용:** 클라이언트는 입찰을 검토하고, 지원자의 프로필(스킬 트리, 완료된 프로젝트, 평판)을 확인한 후 사용자를 고용합니다.  
  4. **프로젝트 실행:** 클라이언트와 고용된 사용자가 협업할 수 있도록 비공개 프로젝트 공간이 자동으로 생성됩니다.  
* **프리랜서용 사용자 흐름 (임무 찾기):**  
  1. **임무 탐색:** 필터링 가능한 임무 목록. 사용자는 필요 기술, 예산 등으로 필터링할 수 있습니다.  
  2. **제안서 제출:** 자신의 기술과 일치하는 임무에 지원합니다.  
  3. **고용 및 작업:** 앱의 프로젝트 관리 시스템 내에서 작업을 완료합니다.  
  4. **결제 및 평가:** 완료 시 결제가 이루어지고, 양측은 피드백을 남겨 평판 점수에 기여합니다.

### **4.2. 지식 위키: 살아있는 매뉴얼**

* **개념:** Notion의 공개 템플릿이나 전문 기술을 위한 특화된 위키피디아와 유사한, 사용자가 생성하고 커뮤니티가 관리하는 지식 베이스입니다.37  
* **콘텐츠 생성:** 모든 사용자가 위키 문서를 만들 수 있습니다. 문서는 튜토리얼, 모범 사례 가이드, 도구 리뷰 또는 앱에 정의된 기술과 관련된 프로세스 템플릿이 될 수 있습니다.  
* **통합:**  
  * 업무나 프로젝트를 생성할 때, 사용자는 컨텍스트를 위해 위키 문서를 링크할 수 있습니다.  
  * 프로젝트 완료 후, 앱은 사용자에게 "이 프로젝트에서 'Python'과 '데이터 분석'을 사용하셨습니다. 위키에 당신의 과정이나 배운 점을 공유해주시겠어요?"라고 제안합니다.  
* **게이미피케이션 및 관리:**  
  * 인기 있는 위키 문서(조회수 및 추천수 기반)를 작성하면 저자는 상당한 XP와 '현자' 또는 '멘토' 업적을 얻습니다.  
  * Stack Overflow와 유사한 평판 기반 시스템을 통해, 높은 평판을 가진 사용자가 위키 콘텐츠를 편집하고 관리하여 품질을 보장합니다.39

### **4.3. 커뮤니티의 재해석: 포럼에서 '쇼케이스'로**

* **전략적 전환:** 일반적인 '커뮤니티' 게시판은 사용자가 완료된 프로젝트를 공유할 수 있는 공개적인 포트폴리오 스타일의 피드인 '프로젝트 쇼케이스'로 대체됩니다. 일반적인 온라인 커뮤니티는 목적 부족과 높은 관리 비용으로 인해 실패하는 경우가 많습니다.41 이 앱의 핵심 가치는  
  *수행*과 *성취*에 있습니다. 따라서 커뮤니티 기능은 이 가치를 중심으로 구축되어야 합니다. 이를 '프로젝트 쇼케이스'로 전환함으로써, 커뮤니티를 앱의 주요 활동과 직접적으로 연결합니다. 이는 강력한 선순환 구조를 만듭니다: 사용자는 XP와 기술을 얻기 위해 프로젝트를 완료하고(섹션 3), 자신의 평판과 공개 포트폴리오를 구축하기 위해 쇼케이스에 작업을 게시합니다(섹션 4, 5). 이렇게 강화된 프로필은 임무에 고용되거나(섹션 4\) 새로운 프로젝트에 초대될(섹션 3\) 가능성을 높입니다. 이제 모든 기능이 서로를 강화하여, 단편적인 도구 모음이 아닌 끈끈하고 가치 있는 생태계를 만듭니다.  
* **쇼케이스 게시물 콘텐츠 (Behance에서 영감):** 43  
  * 프로젝트 제목 및 목표.  
  * 최종 결과물 갤러리 (이미지, 링크, 비디오).  
  * 사용자가 도전 과제, 해결책, 배운 점에 대해 작성할 수 있는 '프로세스' 섹션.  
  * 사용된 기술에 대한 태그 및 협업한 팀원 목록.  
* **가치 제안:**  
  * **사용자에게:** 완료된 작업을 프로필에 직접 표시되는 실질적인 포트폴리오 항목으로 전환하여 전문적인 브랜드를 구축합니다.  
  * **커뮤니티에게:** 영감과 학습의 원천이 됩니다. 신규 사용자는 앱으로 무엇을 성취할 수 있는지 보고 숙련된 사용자의 프로세스에서 배울 수 있습니다.  
  * **플랫폼에게:** 앱의 가치를 보여주는 강력하고 자생적인 콘텐츠 루프를 생성합니다.

## **섹션 5: 플레이어 \- 프로필 및 게이미피케이션**

이 섹션은 앱의 장기적인 참여 전략의 핵심입니다. 전문적인 성장을 어떻게 매력적이고 동기 부여가 되는 게임으로 전환하는지 상세히 설명합니다.

### **5.1. 통합 대시보드**

프로필 화면 상단은 현재 XP/레벨, 연속 기록(일일 업무 완료), 완료된 프로젝트, 평판 점수 등 핵심 지표를 보여주는 개인 대시보드입니다. 사용자의 진행 상황을 한눈에 요약하여 제공합니다.

### **5.2. 성장 시스템: XP, 업적, 스킬 트리**

* **경험치 (XP):** 성장의 주요 화폐입니다. 앱 내 거의 모든 긍정적인 행동에 대해 XP를 획득합니다. (표 5.1: 게이미피케이션 경제 매트릭스 참조).  
* **업적/배지:** 44 특정 마일스톤 달성에 대한 일회성 보상입니다 (예: "첫 프로젝트 완료", "30일 연속 기록 유지", "평판 1000점 획득"). 이는 사용자의 프로필에 배지로 표시됩니다.  
* **스킬 트리:**  
  * **개념:** 다양한 전문 분야(예: 'UX 디자인', '제품 관리', '백엔드 개발')에서 사용자의 역량을 시각적으로 표현합니다.46  
  * **구조:** 각 '스킬 트리'는 핵심 기술(예: UX 디자인의 경우 '사용자 리서치', '와이어프레이밍', '프로토타이핑')을 가집니다. 각 기술은 레벨업(예: 레벨 1에서 10까지)할 수 있습니다.  
  * **레벨업:** 사용자가 특정 기술로 태그된 업무나 프로젝트를 완료하면, 획득한 XP가 해당 기술의 진행률 표시줄에도 적용됩니다. 충분한 '기술 XP'를 얻으면 해당 기술이 레벨업됩니다. 이는 성장을 실질적이고 직무와 관련 있게 만듭니다.

### **5.3. 소셜 구조: 평판, 추천, 네트워크**

* **평판 시스템 (Stack Overflow에서 영감):** 39  
  * 평판은 XP와 별개의 점수로, 커뮤니티의 신뢰도를 측정합니다.  
  * **평판 획득:**  
    * 팀과 함께 프로젝트 성공적으로 완료 시 \+15점.  
    * 완료된 프로젝트의 팀원으로부터 긍정적인 리뷰를 받을 때 \+10점.  
    * 다른 사람이 자신의 프로젝트 쇼케이스나 위키 문서를 추천할 때 \+5점.  
    * 유료 임무 성공적으로 완료 시 \+20점.  
  * **평판 상실:**  
    * 성과 부진으로 프로젝트에서 제외될 때 \-10점.  
  * **권한:** 높은 평판은 위키 관리 능력이나 '최고 전문가' 목록에 추천되는 등의 권한을 잠금 해제합니다.  
* **관계:** 간단한 팔로우/팔로잉 시스템과 인맥을 볼 수 있는 '네트워크' 탭을 제공합니다.

### **5.4. 고급 게이미피케이션: 리더보드 및 시즌**

* **리더보드:** 49  
  * **디자인:** 신규 사용자의 의욕 저하를 방지하기 위해 리더보드는 '상대적'이고 '범위가 지정'됩니다. 사용자는 매주 비슷한 활동 수준의 약 50명으로 구성된 리그에 배치됩니다 (듀오링고 리그와 유사).51  
  * **지표:** 다양한 행동을 보상하기 위해 여러 리더보드가 존재합니다: '최고 XP 획득자', '최고의 협업가'(긍정적인 팀 피드백 기반), '최고의 멘토'(위키 기여도 기반).  
* **시즌:** 53  
  * **개념:** 독특한 테마, 이야기, 도전 과제를 가진 분기별 3개월 '시즌'입니다. 이는 반복적인 참여 주기를 만들고 신선한 경험을 제공합니다.  
  * **테마 서사 (사용자 아이디어 기반):**  
    * **1분기 (봄): "설계자"** \- 새로운 프로젝트 계획 및 시작에 중점. 잘 정의된 프로젝트 헌장과 상세한 업무 백로그 생성을 보상하는 시즌 도전 과제.  
    * **2분기 (여름): "가속자"** \- 성장과 실행에 중점. 빠른 업무 완료 속도와 마일스톤 조기 달성을 보상하는 도전 과제.  
    * **3분기 (가을): "완성자"** \- 완료와 개선에 중점. 프로젝트 마무리, 쇼케이스 게시, 위키 기여를 보상하는 도전 과제.  
    * **4분기 (겨울): "비전가"** \- 회고와 장기 목표 설정에 중점. 프로젝트 사후 검토 수행 및 다음 해를 위한 야심찬 목표 설정을 보상하는 도전 과제.  
  * **시즌 패스:** 포트나이트 배틀 패스와 유사한 100레벨 트랙입니다.56 사용자는 일일/주간 도전 과제를 완료하여 '시즌 포인트'를 획득하고, 이를 통해 패스 레벨을 올려 독점적인 꾸미기 보상(프로필 테마, 특별 배지 등)을 잠금 해제합니다.

균형 잡힌 경제 시스템은 게이미피케이션의 성패를 좌우합니다. XP를 너무 쉽게 얻으면 레벨이 무의미해지고, 너무 어려우면 사용자는 포기합니다. 아래의 매트릭스는 모든 행동(업무 완료, 프로젝트 종료, 위키 문서 작성 등)을 나열하고 특정 XP, 평판, 시즌 포인트 값을 할당함으로써 시스템적인 접근을 강제합니다. 이를 통해 평균적인 사용자가 레벨 10에 도달하거나 기술을 레벨업하는 데 걸리는 시간을 모델링하고, '느낌'이 적절해질 때까지 수치를 조정할 수 있습니다. 이는 임의적인 보상 할당을 방지하고 전체 시스템을 디자인 관점에서 예측 가능하고 관리하기 쉽게 만듭니다.

**표 5.1: 게이미피케이션 경제 매트릭스**

| 행동 | 획득 XP | 평판 변화 | 시즌 포인트 | 잠금 해제/참고 |
| :---- | :---- | :---- | :---- | :---- |
| 일일 업무 완료 | 10 | 0 | 5 | 연속 기록 보너스 적용 |
| 주간 목표 달성 | 50 | 0 | 25 |  |
| 프로젝트 마일스톤 달성 | 100 | \+5 | 50 | 팀원 모두에게 지급 |
| 프로젝트 성공적 완료 | 250 | \+15 | 100 | 팀원 모두에게 지급 |
| 유료 임무 완료 | 300 | \+20 | 120 |  |
| 위키 문서 작성 | 20 | \+2 | 10 |  |
| 위키 문서 추천 받음 | 5 | \+1 | 2 | 추천당 |
| 프로젝트 쇼케이스 게시 | 50 | \+10 | 25 |  |
| 쇼케이스 추천 받음 | 10 | \+2 | 5 | 추천당 |
| 신규 멤버 초대 | 30 | \+1 | 15 | 초대된 멤버가 첫 업무 완료 시 |

단순히 '시즌이 있을 것'이라고 말하는 것만으로는 충분하지 않습니다. 구체적인 계획이 필요합니다. 아래 표는 전체 1년 계획을 개괄하며, 각 분기에 실제 업무 주기와 관련된 매력적인 테마를 부여합니다. 그리고 특정하고 바람직한 보상(예: 1분기 독점 '설계자의 청사진' 프로필 테마)을 해당 시즌과 연결합니다. 이는 장기적인 참여가 리그 오브 레전드나 디아블로와 같은 게임에서 볼 수 있는 강력한 동기 부여 요소인, 독점적이고 시간 제한적인 보상을 놓치는 것에 대한 두려움(FOMO)을 만들어 어떻게 유지될 것인지를 보여줍니다.53

**표 5.2: 시즌 테마 및 보상 일정 (1년 예시)**

| 분기 | 시즌 이름 | 테마/초점 | 주요 시즌 도전 과제 | 독점 시즌 패스 보상 |
| :---- | :---- | :---- | :---- | :---- |
| Q1 | 설계자 시즌 | 계획 및 시작 | 10개 이상의 업무로 구성된 프로젝트 3개 생성, 모든 마일스톤이 정의된 프로젝트 헌장 작성 | '설계자의 청사진' 프로필 테마, '초석' 배지 |
| Q2 | 가속자 시즌 | 성장 및 실행 | 주간 업무 완료율 90% 유지, 마일스톤 5개 조기 달성, 100개 업무 완료 | '추진력' 프로필 테마, '가속 엔진' 아바타 프레임 |
| Q3 | 완성자 시즌 | 완료 및 개선 | 프로젝트 3개 완료 및 쇼케이스 게시, 위키 문서 5개 기여, 긍정적 팀 피드백 10회 받기 | '마스터피스' 프로필 테마, '장인' 배지 |
| Q4 | 비전가 시즌 | 회고 및 목표 설정 | 완료된 프로젝트에 대한 사후 검토 3회 작성, 다음 해를 위한 야심찬 목표 5개 설정 | '별자리' 프로필 테마, '선구자' 아바타 프레임 |

## **섹션 6: 비즈니스 레이어 \- "워크스페이스" 및 미래 성장**

이 섹션은 사용자의 B2B 포부를 다루며, '길드'에 대한 전문적인 리브랜딩을 제공하고 확장 가능한 SaaS 모델을 제시합니다.

### **6.1. "워크스페이스" 소개: "길드"의 전문적 리브랜딩**

* **근거:** '길드'라는 용어는 게임과 강하게 연관되어 있어 전문적인 B2B 맥락에서 공감을 얻지 못할 수 있습니다. '워크스페이스'는 Slack 및 Asana와 같은 경쟁사들이 사용하는 표준적이고 널리 이해되는 용어로, 제안하는 기능을 즉시 인식 가능하고 전문적으로 만듭니다.58  
* **개념:** 워크스페이스는 회사나 공식 팀이 앱을 사용할 수 있는 프리미엄 중앙 허브입니다. 관리 제어, 강화된 보안, 팀 전체 분석 기능을 제공합니다.

### **6.2. 워크스페이스 관리 및 기능**

58

* **멤버 관리:** 워크스페이스 관리자가 멤버를 초대/제거하고, 역할(관리자, 멤버, 게스트)을 할당하며, 권한을 관리할 수 있는 중앙 대시보드.  
* **비공개 프로젝트:** 워크스페이스 내에서 생성된 프로젝트는 해당 멤버에게만 보입니다.  
* **중앙 집중식 결제:** 전체 팀을 위한 단일 구독.  
* **팀 전체 분석:** 조직 전체의 생산성, 프로젝트 완료율, 기술 개발 현황을 보여주는 대시보드.  
* **공유 리소스:** 워크스페이스 멤버만 접근할 수 있는 비공개 내부 위키 및 프로젝트 템플릿.  
* **보안 및 규정 준수:** 엔터프라이즈 고객을 위한 SSO(Single Sign-On), 감사 로그, 고급 데이터 관리 기능.

### **6.3. 수익화 전략 및 시장 포지셔닝**

* **프리미엄(Freemium) 모델:** 핵심 앱은 개인 사용자가 무료로 사용하여 채택을 장려하고 사용자 기반을 구축합니다.  
* **구독 등급 (표 6.1 참조):**  
  * **무료:** 개인 및 소규모 비공식 팀용.  
  * **워크스페이스 프로:** 전문 팀을 위한 유료 등급으로, 고급 협업 기능, 무제한 비공개 프로젝트, 관리 제어 기능을 제공합니다.  
  * **워크스페이스 엔터프라이즈:** 대규모 조직을 위한 맞춤형 가격 등급으로, 고급 보안, 전담 지원, 심층 통합을 제공합니다.  
* **시장 포지셔닝:** 이 앱은 "전문적인 성장을 게임처럼 느끼게 하는 개인 및 소규모 팀을 위한 Asana"로 자리매김할 것입니다. 단순히 기능만으로 경쟁하는 것이 아니라, 동기 부여와 참여라는 측면에서 경쟁하며, 이는 보다 전통적이고 순전히 기능적인 도구들과의 핵심적인 차별점입니다.62

성공적인 SaaS 비즈니스는 명확한 수익화 전략이 필요합니다. 아래 표는 제품의 기능을 분석하고 이를 다른 등급에 할당합니다. 무료 등급은 대규모 사용자 기반을 유치할 만큼 충분히 관대해야 하지만, 업그레이드할 강력한 이유를 만드는 명확한 제한이 있어야 합니다. 프로 등급은 성장하는 팀의 핵심적인 문제점(예: 개인 정보 보호, 관리)을 해결해야 합니다. 엔터프라이즈 등급은 대기업의 요구(보안, 규정 준수)를 충족시킵니다. '비공개 프로젝트', '관리 콘솔', 'SSO'와 같은 기능을 특정 등급에 매핑함으로써, B2B SaaS 제품의 모범 사례에 따라 비즈니스 모델을 제품 아키텍처에 직접 설계합니다.65

**표 6.1: "워크스페이스" 기능 등급**

| 기능 | 무료 등급 | 워크스페이스 프로 | 워크스페이스 엔터프라이즈 |
| :---- | :---- | :---- | :---- |
| 사용자 수 | 최대 5명 | 사용자당 과금 | 사용자당 과금 (볼륨 할인) |
| 공개 프로젝트 | 무제한 | 무제한 | 무제한 |
| 비공개 프로젝트 | 최대 3개 | 무제한 | 무제한 |
| 기본 업무 관리 | ✓ | ✓ | ✓ |
| 기본 게이미피케이션 | ✓ | ✓ | ✓ |
| 관리 콘솔 | X | ✓ | ✓ |
| 역할 및 권한 관리 | X | ✓ | ✓ |
| 팀 전체 분석 | X | ✓ | ✓ |
| SSO (Single Sign-On) | X | X | ✓ |
| 고급 보안 및 감사 로그 | X | X | ✓ |
| 전담 지원 | X | X | ✓ |

## **섹션 7: 시스템 아키텍처 및 개선 사항**

이 마지막 섹션에서는 필수적인 시스템 수준의 설정을 다루고, 개발을 위한 전략적 로드맵을 제공하여 완전하고 미래 지향적인 계획을 보장합니다.

### **7.1. 필수 설정**

* **언어:** 글로벌 시장 진출을 위한 다국어 지원.  
* **화면 모드:** 현대 UI/UX의 필수 기능인 라이트 모드와 다크 모드 간 명확한 전환 기능.67  
* **알림:** 사용자가 특정 이벤트(예: 업무 멘션, 프로젝트 업데이트, 지원서 승인)에 대한 알림을 켜고 끌 수 있는 세분화된 제어 기능을 제공하여 알림 피로를 방지.

### **7.2. 전략적 권장 사항 및 향후 로드맵**

* **통합:** Google 캘린더(마감일 동기화), Slack(알림 및 업무 생성), GitHub(커밋과 업무 연결)와 같은 필수 도구와의 통합을 우선순위에 둡니다.  
* **데이터 이동성:** 사용자가 자신의 데이터(업무, 프로젝트 기록)를 CSV 또는 JSON으로 내보낼 수 있는 기능을 제공하여 신뢰를 구축하고 플랫폼 종속성을 줄입니다.  
* **접근성 (A11y):** WCAG 가이드라인(예: 충분한 색상 대비, 스크린 리더 지원)을 준수하여 모든 사람이 앱을 사용할 수 있도록 처음부터 접근성을 계획합니다.67  
* **MVP 우선순위 설정 (표 7.1 참조):** 모든 기능을 단계별 출시 계획으로 나누어 시장에 신속하게 진입하고 사용자 피드백을 기반으로 반복 개발합니다.

모든 것을 한 번에 구축하는 것은 불가능하므로, 아래 표는 초기 제품 출시에 필수적인 것과 나중에 추가할 수 있는 것을 구분하는, 어렵지만 필요한 결정을 강제합니다. MoSCoW 방법론(Must-have, Should-have, Could-have, Won't-have)은 우선순위 설정을 위한 검증된 프레임워크입니다.68 이를 기능 목록에 적용함으로써, 우리는 간결하지만 실행 가능한 MVP를 정의할 수 있습니다. 'Must-haves'는 핵심 루프인 홈(업무 관리)과 프로젝트(기본 협업)가 될 것입니다. 'Should-haves'는 프로필 및 게이미피케이션의 초기 버전을 포함할 수 있습니다. 'Could-haves'는 임무 게시판과 고급 워크스페이스 기능이 될 수 있습니다. 'Won't-haves (당분간)'는 복잡한 통합이나 전체 시즌 시스템일 수 있습니다. 이는 초기 제품이 집중되고, 핵심 가치를 신속하게 전달하며, 팀이 더 복잡한 기능에 투자하기 전에 실제 사용자 데이터를 수집할 수 있도록 보장합니다.

**표 7.1: MVP 기능 우선순위 설정 (MoSCoW 방법)**

| 기능 | 분류 | 근거 |
| :---- | :---- | :---- |
| **핵심 기능** |  |  |
| Google 계정 로그인 | Must-have | 앱 접근을 위한 필수 전제 조건. |
| 홈: GTD 기반 업무 관리 | Must-have | 앱의 핵심 가치 제안이자 일일 사용의 중심. |
| 프로젝트: 채팅 기반 협업 | Must-have | 핵심 협업 기능으로, 업무 관리와 함께 시너지를 냄. |
| **게이미피케이션** |  |  |
| 프로필: XP, 레벨, 기본 대시보드 | Must-have | 기본적인 동기 부여 및 진행 상황 추적 시스템. |
| 업적/배지 시스템 | Should-have | 초기 참여를 유도하지만, 핵심 기능만큼 시급하지는 않음. |
| 스킬 트리 시스템 | Should-have | 장기적인 성장 비전을 제시하지만, MVP에서는 단순화 가능. |
| 평판 시스템 | Could-have | 커뮤니티 기능이 활성화된 후에 더 큰 의미를 가짐. |
| **게시판 기능** |  |  |
| 지식 위키 | Should-have | 사용자 생성 콘텐츠를 통해 초기부터 플랫폼 가치를 높일 수 있음. |
| 프로젝트 쇼케이스 | Could-have | 프로젝트 완료 데이터가 축적된 후 도입하는 것이 효과적. |
| 임무 게시판 (마켓플레이스) | Won't-have | 복잡한 결제 및 분쟁 해결 시스템이 필요하여 MVP 범위에서 제외. |
| **고급 기능** |  |  |
| 시즌제 및 시즌 패스 | Won't-have | 장기적인 참여 유도 기능으로, 안정적인 사용자 기반 확보 후 도입. |
| 리더보드 | Could-have | 경쟁 요소는 초기 단계보다 커뮤니티가 형성된 후 도입하는 것이 안전. |
| 워크스페이스 (B2B 모델) | Won't-have | 개인 사용자 기반을 먼저 확보하고 검증한 후 B2B 시장으로 확장. |
| **기타** |  |  |
| 다크 모드 및 기본 설정 | Must-have | 현대적인 앱의 필수적인 사용자 경험 요소. |
| 외부 앱 통합 (Slack, Google Calendar) | Should-have | 사용자의 기존 워크플로우에 통합되어 앱의 유용성을 크게 향상시킴. |

### **결론 및 권장 사항**

본 보고서에서 제시된 '프로젝트 모멘텀'은 단순한 생산성 도구를 넘어, 개인의 성장과 팀의 협업, 그리고 전문적인 기회를 하나의 유기적인 생태계로 통합하는 야심찬 비전을 담고 있습니다. Threads에서 영감을 받은 미니멀리즘 UI를 기반으로, GTD 방법론의 효율성과 깊이 있는 게이미피케이션 메커니즘을 결합하여 사용자의 내재적 동기를 자극하고 지속적인 참여를 유도하는 것을 목표로 합니다.

성공적인 출시와 지속 가능한 성장을 위해 다음의 전략적 권장 사항을 제시합니다.

1. **MVP(최소 기능 제품)에 집중:** 제안된 MoSCoW 우선순위 모델에 따라, 초기 개발은 '홈(업무 관리)'과 '프로젝트(기본 협업)'라는 핵심 가치에 집중해야 합니다. 이는 가장 빠른 시간 내에 시장에 제품을 선보이고, 실제 사용자 피드백을 통해 가설을 검증하며, 불필요한 기능 개발에 따르는 리소스를 최소화하는 가장 효율적인 접근 방식입니다.  
2. **게이미피케이션 경제의 정교한 균형:** XP, 평판, 시즌 포인트 등 보상 시스템의 수치적 균형은 앱의 장기적인 성공에 매우 중요합니다. 출시 전, 내부 테스트를 통해 제안된 '게이미피케이션 경제 매트릭스'를 면밀히 검토하고 조정하여, 성취감이 느껴지면서도 인플레이션이 발생하지 않는 견고한 시스템을 구축해야 합니다.  
3. **커뮤니티의 점진적 활성화:** '프로젝트 쇼케이스'와 '지식 위키'는 플랫폼의 강력한 자산이 될 잠재력을 가지고 있습니다. 초기에는 플랫폼이 직접 양질의 콘텐츠(모범 사례 프로젝트, 핵심 기술 가이드)를 제공하여 기준을 제시하고, 초기 사용자(얼리 어답터) 그룹을 대상으로 콘텐츠 기여를 적극적으로 장려하는 전략이 필요합니다.  
4. **B2B로의 신중한 확장:** '워크스페이스' 기능은 상당한 수익 잠재력을 가지고 있지만, 개인 사용자 시장에서 제품의 가치와 안정성이 충분히 입증된 후에 추진하는 것이 바람직합니다. 강력한 개인 사용자 기반은 B2B 시장 진입 시 중요한 사회적 증거(Social Proof)이자 마케팅 자산이 될 것입니다.

'프로젝트 모멘텀'은 단순한 업무 관리를 넘어, 사용자가 자신의 전문적인 여정을 '플레이'하고, 성취를 통해 성장하며, 다른 사람들과 연결되는 새로운 패러다임의 생산성 플랫폼이 될 잠재력을 가지고 있습니다. 제안된 청사진을 바탕으로 한 체계적이고 집중적인 실행이 이 비전을 현실로 만드는 열쇠가 될 것입니다.
</file>

<file path="references/WORKLY_PRD.md">
### **Workly 제품 요구 명세서 (Product Requirements Document) v2.0**

* **문서 버전:** 2.0
* **최종 수정일:** 2025년 8월 1일
* **문서 목적:** Workly 앱의 기획, 디자인, 개발을 위한 단일 진실 공급원(Single Source of Truth). 모든 팀원은 이 문서를 기준으로 작업을 진행한다.

---

### **1. 핵심 철학 및 디자인 원칙**

* **1.1. 극도의 간결함 (Simplicity First):** 모든 화면과 기능은 사용자의 인지 부하를 최소화하는 방향으로 설계한다. 본질을 제외한 모든 것은 군더더기다. 미니멀한 시각적 요소, 불필요한 그림자 제거, 간소한 구분선 사용으로 깔끔한 인터페이스를 구현한다.
* **1.2. 단일 컬러 시스템 (Unified Color System):** 앱 전체에 걸쳐 신뢰와 실행을 상징하는 단일 주조색 **`Primary Blue (#2563eb)`**를 사용한다. 해당 색상의 명도/채도 변화만으로 위계를 표현하여, 일관되고 안정적인 사용자 경험을 제공한다.
* **1.3. 유연한 데이터 관계 (Flexible Data Structure):** 핵심 데이터(`업무`, `프로젝트`, `목표`)는 독립적으로 존재하거나, 서로 유연하게 소속될 수 있는 계층 구조를 가진다.

---

### **2. 전역 UI/UX 시스템 (Global UI/UX System)**

이전에 정의된 디자인 시스템을 기반으로, 앱 전체에 적용될 시각적, 상호작용적 규칙을 정의한다.

* **2.1. 컬러 시스템 (Color System)**
    * **Primary:** `#2563eb` (blue-600) - 주요 액션, 링크, 활성 상태, 아이콘 강조
    * **Primary Hover:** `#1d4ed8` (blue-700) - 호버 상태
    * **Primary Light:** `#dbeafe` (blue-100) - 배경, 영역 강조
    * **Text Main:** `#111827` (gray-900) - 제목 및 주요 텍스트
    * **Text Secondary:** `#6b7280` (gray-500) - 보조 텍스트, 비활성 아이콘
    * **Background:** `#f9fafb` (gray-50) - 앱 전체 배경
    * **Border:** `#e5e7eb` (gray-200) - 카드 테두리, 구분선
    * **Semantic Colors:**
        * **Success:** `#059669` (green-600) - 완료, 성공
        * **Warning:** `#d97706` (amber-600) - 주의, 경고
        * **Error:** `#dc2626` (red-600) - 오류, 삭제

* **2.2. 타이포그래피 (Typography)**
    * **Font Family:** Pretendard (가독성과 범용성을 고려)
    * **Scale:**
        * **Page Title (H1):** 24px, Bold (700)
        * **Card Title (H2):** 18px, SemiBold (600)
        * **Body (본문):** 16px, Regular (400)
        * **Caption/Helper:** 14px, Regular (400)

* **2.3. 간격 및 레이아웃 (Spacing & Layout)**
    * **Spacing Scale:** Tailwind CSS 기본 스케일 (`4px` 단위)을 따른다. (e.g., `p-4` = 16px, `gap-2` = 8px)
    * **Layout:**
        * **Mobile (< 768px):** 하단 탭 바 네비게이션
        * **Desktop (>= 768px):** 좌측 사이드바 네비게이션

* **2.4. 아이코노그래피 (Iconography)**
    * **Library:** Heroicons ([https://heroicons.com/](https://heroicons.com/))
    * **Style:** **Outline** 스타일을 기본으로 사용하여 간결하고 미니멀한 톤앤매너를 유지한다. (24px, 1.5 stroke)

* **2.5. 핵심 컴포넌트 (Core Components) - 미니멀 디자인**
    * **Card:** `rounded-lg`, `bg-white`, `border border-gray-100`, `p-4` (그림자 제거로 미니멀화)
    * **List Card:** `rounded-lg`, `bg-white`, `border border-gray-100` (목록 컨테이너용, padding 없음, 그림자 제거)
    * **Button:** `rounded-md`, `font-semibold`, `px-4 py-2`. Primary 버튼은 `bg-blue-600`, `text-white`.
    * **Filter Chip:** `rounded-full`, `bg-gray-100`, `text-gray-700`, `px-3 py-1`, `text-sm`. 활성화 시 `bg-blue-100`, `text-blue-700`.
    * **Task Item:** 미니멀한 패딩(`p-3`), 얇은 왼쪽 보더(`border-l-2`), 투명한 기본 보더로 시각적 밀도 감소

---

### **3. 공통 기능 명세**

* **3.1. 통합 검색 (Unified Search)**
    * **A. 목적:** 사용자가 앱 내 모든 정보(`업무`, `프로젝트`, `목표` 등)를 한 곳에서 빠르게 찾도록 한다.
    * **B. UI 및 동작:**
        1.  **진입점:** 모바일 헤더의 **돋보기(🔍) 아이콘** 클릭.
        2.  **인터페이스:** 전체 화면 검색 UI가 나타나며, 키워드 입력 시 실시간으로 결과를 로드한다.
        3.  **결과 표시:** `업무`, `프로젝트`, `목표`, `위키` 등 카테고리별 탭으로 결과를 분류하여 보여준다.
        4.  **데이터 모델:** 검색 쿼리(string), 검색 결과 객체 리스트.

* **3.2. 필터링 시스템 (Filtering System)**
    * **A. 목적:** 각 페이지의 목록에서 원하는 조건의 항목만 필터링하여 보여준다.
    * **B. UI 및 동작:**
        1.  **위치:** 각 페이지 리스트 상단, 페이지 타이틀 아래.
        2.  **인터페이스:** 자주 쓰는 핵심 필터(예: `내 업무`)는 버튼으로, 그 외 상세 필터는 **'필터' 아이콘 버튼**을 통해 패널에서 설정.
        3.  **데이터 모델:** 필터 조건 객체(JSON), 필터링된 객체 리스트.

---

### **4. 화면별 상세 기능 명세**

#### **4.1. 업무 (홈)**

* **A. 목적:** 개인의 모든 할 일을 빠르게 수집하고, 직관적인 제스처를 통해 즉시 분류, 위임, 제거, 예약할 수 있도록 돕는다.

* **B. 핵심 상호작용 모델 (Default Interaction Model):**
'정리 마법사'라는 별도 모드 없이, 업무 카드 리스트 자체에 아래의 상호작용이 기본으로 적용된다.

    1. **탭 (Tap):** 업무 카드를 짧게 탭하면 '업무 상세' 화면으로 진입한다.

    2. **스와이프 (Swipe):**
        * **왼쪽으로 스와이프 → 삭제:** 카드를 왼쪽으로 밀어 즉시 삭제한다. (30일간 휴지통 보관)
        * **오른쪽으로 스와이프 → 추가 액션:** 카드를 오른쪽으로 밀면 [위임], [보류], [프로젝트로 전환] 옵션 메뉴가 나타난다.

    3. **길게 누른 후 드래그 (Long-press & Drag):**
        * **활성화:** 카드를 0.5초 이상 길게 누르면, 가벼운 햅틱 피드백과 함께 카드가 살짝 들어올려지는 시각적 효과가 나타나며 **'드래그 모드'**로 전환된다. (스와이프와의 동작 충돌 방지)
        * **실행:** 드래그 모드에서 카드를 끌어 화면 하단의 **'접이식 캘린더'**의 특정 날짜 위에 놓으면 해당 날짜가 마감일로 지정된다.

* **C. 화면 구성:**
    * **헤더:** `페이지 타이틀(업무)`, `통합 검색 아이콘(🔍)`.
    * **콘텐츠:** `빠른 추가 입력창`, `업무 카드 리스트`, `접이식 캘린더(하단)`.

* **D. 핵심 컴포넌트 및 기능:**
    1. **빠른 추가:** `placeholder="무엇을 해야 하나요?"` 텍스트 필드. Enter 입력 시 새 업무가 리스트 최상단에 생성. `status`는 'todo', `created_at`은 현재 시각.
    2. **업무 카드:** `업무 제목`, `마감일`, `소속 프로젝트/목표 태그` 표시. **마감일**이 가장 강조됨.
    3. **접이식 캘린더 (Collapsible Calendar):**
        * **기본 상태:** 화면 하단에 접혀있는 상태. 월 이름과 간단한 주간 뷰만 보임.
        * **드래그 모드 활성화:** 업무 카드를 길게 누르면 자동으로 펼쳐져 전체 월간 캘린더가 표시됨.
        * **날짜 선택:** 특정 날짜 위에 업무 카드를 드롭하면 해당 날짜가 마감일로 설정되고 캘린더가 다시 접힘.
        * **애니메이션:** 부드러운 슬라이드 업/다운 애니메이션으로 사용자 경험 향상.
        * **업무 표시:** 해당 날짜에 업무가 있으면 Primary Blue 색상의 작은 도트로 표시.
        * **오늘 날짜:** 특별한 테두리와 배경색으로 강조 표시.
        * **상호작용:** 접힌 상태에서도 좌우 스와이프로 월 이동 가능.
    4. **업무 상세 (노트):**
        * **UI:** 마크다운 에디터.
        * **기능:** 체크리스트 생성, 선행/후행 관계 설정, 위키 레퍼런스 첨부, 시간 추정/기록.

* **E. 데이터 모델 (Task Object):** `{ id, title, content(markdown), status, dueDate, createdAt, projectId?, goalId? }`

#### **4.2. 프로젝트**

* **A. 목적:** 팀원들이 실시간으로 소통하며 공동의 목표를 달성하는 협업 공간.
* **B. 화면 구성:**
    * **헤더:** `프로젝트 제목`, `멤버 목록 아이콘`, `... (더보기 메뉴)`.
    * **콘텐츠:** `채팅 영역(메인)`, `사이드바(접힘/펼침 가능)`.
* **C. 핵심 컴포넌트 및 기능:**
    1.  **프로젝트 카드:** `프로젝트 제목`, `참여 멤버 아바타`, `진행률`. **진행률(Progress Bar)**이 가장 강조됨.
    2.  **실시간 채팅:** 실시간 메시지 전송 및 수신. `/업무생성` 등 슬래시 커맨드 지원.
    3.  **사이드바:** `프로젝트 정보(목표, 보상 등)`, `업무 목록(멤버별 필터링 가능)`, `결정 보드`, `공유 파일` 등 모든 메타 정보 표시.
    4.  **팀 빌딩:**
        * **리더:** `프로젝트 생성`, `필요 스킬 등록`, `지원자 프로필 검토`, `수락/거절`.
        * **지원자:** `프로젝트 탐색`, `내 프로필로 지원`.
* **D. 데이터 모델 (Project Object):** `{ id, name, goal, requiredSkills[], members[], status, messages[], tasks[] }`

#### **4.3. 목표**

* **A. 목적:** 장기적인 비전을 시각화하고, 관련된 모든 활동을 추적하여 동기를 부여하는 대시보드.
* **B. 화면 구성:**
    * **헤더:** `목표 제목`, `... (더보기 메뉴)`.
    * **콘텐츠:** 위젯 기반의 커스텀 가능한 대시보드.
* **C. 핵심 컴포넌트 및 기능:**
    1.  **목표 카드:** `목표 제목`, `연관 프로젝트 수`. **활성도(Activity Aura)**가 가장 강조됨.
    2.  **활성도(Aura):** 목표 아이콘 주변에 `box-shadow`와 `animation`으로 구현된 빛 효과. 활성도 점수에 따라 밝기와 움직임이 변화.
    3.  **대시보드 위젯:** `KPI 트래커`, `연관 프로젝트 목록`, `전체 업무 번다운 차트`, `비전 보드(이미지/인용구)`.
* **D. 데이터 모델 (Goal Object):** `{ id, title, vision, kpis[], projects[], tasks[], activityScore }`

#### **4.4. 프로필**

* **A. 목적:** 사용자의 모든 활동과 성장을 기록하고 증명하는 게이미피케이션 기반 디지털 아이덴티티.
* **B. 화면 구성:**
    * **상단:** `프로필 카드(아바타, 이름, 레벨, 핵심 스킬 3개)`. 클릭 시 상세 프로필 모달.
    * **콘텐츠:** 탭 구조 - `활동`, `포트폴리오`, `스킬`, `코워커`.
* **C. 핵심 컴포넌트 및 기능:**
    1.  **XP & 레벨:** `업무 완료(+10 XP)`, `프로젝트 성공(+100 XP)` 등 명확한 규칙에 따라 XP 획득 및 레벨업.
    2.  **업적 뱃지:** `achievements.json`에 정의된 조건 달성 시 획득. `2xN 그리드`로 표시.
    3.  **스킬 트리:** 보유 스킬을 `마인드맵` 형태로 시각화. 관련 프로젝트 완료 시 해당 스킬의 숙련도(레벨) 상승.
    4.  **평판:** 코워커에게 받은 칭찬을 `태그 클라우드`로 시각화.
    5.  **코워커:** 프로젝트를 함께 한 동료 목록.
* **D. 데이터 모델 (User Object):** `{ id, name, email, avatarUrl, level, xp, skills[], achievements[], co-workers[] }`
</file>

<file path="scripts/deploy-production.sh">
#!/bin/bash

# Production 환경 배포 스크립트

set -e

echo "🌟 Production 환경에 배포를 시작합니다..."

# 1. AWS CLI 설정 확인
echo "☁️ AWS 설정 확인 중..."
if ! command -v aws &> /dev/null; then
    echo "❌ AWS CLI가 설치되지 않았습니다."
    exit 1
fi

aws sts get-caller-identity > /dev/null
echo "✅ AWS 인증 확인 완료"

# 2. Docker 이미지 빌드 및 태깅
echo "🐳 Docker 이미지 빌드 중..."

# Frontend 이미지
docker build -t workly-frontend:latest ./frontend
docker tag workly-frontend:latest ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-frontend:latest
docker tag workly-frontend:latest ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-frontend:$(git rev-parse HEAD)

# Backend 이미지
docker build -t workly-backend:latest ./backend
docker tag workly-backend:latest ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-backend:latest
docker tag workly-backend:latest ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-backend:$(git rev-parse HEAD)

# 3. ECR 로그인
echo "🔑 ECR 로그인 중..."
aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

# 4. 이미지 푸시
echo "📤 Docker 이미지 푸시 중..."
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-frontend:latest
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-frontend:$(git rev-parse HEAD)
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-backend:latest
docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/workly-backend:$(git rev-parse HEAD)

# 5. 데이터베이스 마이그레이션
echo "💾 데이터베이스 마이그레이션 실행 중..."
./scripts/migrate.sh production

# 6. ECS 서비스 업데이트
echo "🚀 ECS 서비스 업데이트 중..."

# Backend 서비스 업데이트
aws ecs update-service \
    --cluster workly-cluster \
    --service workly-backend \
    --force-new-deployment \
    --region ${AWS_REGION}

# Frontend는 Vercel에서 자동 배포됨
echo "🌐 Frontend는 Vercel에서 자동 배포됩니다."

# 7. 배포 상태 확인
echo "⏳ 배포 상태 확인 중..."
aws ecs wait services-stable \
    --cluster workly-cluster \
    --services workly-backend \
    --region ${AWS_REGION}

# 8. CDN 캐시 무효화 (필요한 경우)
if [ -n "${CLOUDFRONT_DISTRIBUTION_ID}" ]; then
    echo "🌐 CloudFront 캐시 무효화 중..."
    aws cloudfront create-invalidation \
        --distribution-id ${CLOUDFRONT_DISTRIBUTION_ID} \
        --paths "/*"
fi

# 9. Slack 알림 (선택사항)
if [ -n "${SLACK_WEBHOOK_URL}" ]; then
    echo "📢 Slack 알림 전송 중..."
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"✅ Workly Production 배포 완료\\n커밋: $(git rev-parse HEAD)\\n브랜치: $(git branch --show-current)\"}" \
        ${SLACK_WEBHOOK_URL}
fi

echo ""
echo "🎉 Production 배포가 성공적으로 완료되었습니다!"
echo ""
echo "배포 정보:"
echo "- 커밋 해시: $(git rev-parse HEAD)"
echo "- 브랜치: $(git branch --show-current)"
echo "- 배포 시간: $(date)"
echo ""
echo "서비스 URL:"
echo "- Frontend: https://workly.app"
echo "- Backend API: https://api.workly.app"
</file>

<file path="scripts/deploy.sh">
#!/bin/bash

# 워클리 프로젝트 배포 스크립트

set -e

# 환경 변수 설정
ENVIRONMENT=${1:-production}
FRONTEND_BUILD_DIR="frontend/.next"
BACKEND_BUILD_DIR="backend/dist"

echo "🚀 워클리 배포를 시작합니다... (환경: $ENVIRONMENT)"

# 1. 환경 확인
echo "📋 배포 환경 확인 중..."
case $ENVIRONMENT in
    development|staging|production)
        echo "✅ 배포 환경: $ENVIRONMENT"
        ;;
    *)
        echo "❌ 잘못된 환경입니다. development, staging, production 중 하나를 선택하세요."
        exit 1
        ;;
esac

# 2. Git 상태 확인
echo "📝 Git 상태 확인 중..."
if [ -n "$(git status --porcelain)" ]; then
    echo "⚠️ 커밋되지 않은 변경사항이 있습니다. 배포 전 커밋하세요."
    git status
    exit 1
fi
echo "✅ Git 상태가 깨끗합니다."

# 3. 현재 브랜치 확인
CURRENT_BRANCH=$(git branch --show-current)
if [ "$ENVIRONMENT" = "production" ] && [ "$CURRENT_BRANCH" != "main" ]; then
    echo "❌ Production 배포는 main 브랜치에서만 가능합니다. 현재 브랜치: $CURRENT_BRANCH"
    exit 1
fi
echo "✅ 브랜치 확인: $CURRENT_BRANCH"

# 4. 테스트 실행
echo "🧪 테스트 실행 중..."
npm run test
echo "✅ 모든 테스트가 통과했습니다."

# 5. 린팅 검사
echo "🔍 코드 품질 검사 중..."
npm run lint
echo "✅ 린팅 검사를 통과했습니다."

# 6. 의존성 설치 및 빌드
echo "📦 의존성 설치 및 빌드 중..."
npm ci
npm run build

# 7. 빌드 결과 확인
echo "📊 빌드 결과 확인 중..."
if [ ! -d "$FRONTEND_BUILD_DIR" ]; then
    echo "❌ 프론트엔드 빌드 실패"
    exit 1
fi

if [ ! -d "$BACKEND_BUILD_DIR" ]; then
    echo "❌ 백엔드 빌드 실패"
    exit 1
fi
echo "✅ 빌드가 성공적으로 완료되었습니다."

# 8. 환경별 배포 실행
case $ENVIRONMENT in
    development)
        echo "🔧 Development 환경 배포..."
        # Docker Compose를 사용한 로컬 배포
        docker-compose -f docker-compose.yml up --build -d
        ;;
    staging)
        echo "🎭 Staging 환경 배포..."
        # Staging 서버 배포 로직
        ./scripts/deploy-staging.sh
        ;;
    production)
        echo "🌟 Production 환경 배포..."
        # Production 배포 로직
        ./scripts/deploy-production.sh
        ;;
esac

# 9. 배포 완료 확인
echo "🏁 배포 완료 확인 중..."
sleep 10

# Health check URLs
case $ENVIRONMENT in
    development)
        FRONTEND_URL="http://localhost:3000"
        BACKEND_URL="http://localhost:3001"
        ;;
    staging)
        FRONTEND_URL="${STAGING_FRONTEND_URL:-https://staging.workly.app}"
        BACKEND_URL="${STAGING_BACKEND_URL:-https://api-staging.workly.app}"
        ;;
    production)
        FRONTEND_URL="${PROD_FRONTEND_URL:-https://workly.app}"
        BACKEND_URL="${PROD_BACKEND_URL:-https://api.workly.app}"
        ;;
esac

# Health check
echo "🔍 서비스 상태 확인 중..."
if curl -f -s "$BACKEND_URL/health" > /dev/null; then
    echo "✅ 백엔드 서비스가 정상적으로 실행 중입니다."
else
    echo "⚠️ 백엔드 서비스 상태 확인 실패"
fi

echo ""
echo "🎉 배포가 완료되었습니다!"
echo ""
echo "서비스 URL:"
echo "- 프론트엔드: $FRONTEND_URL"
echo "- 백엔드 API: $BACKEND_URL"
echo ""
echo "모니터링:"
echo "- 로그 확인: npm run logs"
echo "- 상태 확인: npm run status"
</file>

<file path="scripts/migrate.sh">
#!/bin/bash

# 데이터베이스 마이그레이션 스크립트

set -e

ENVIRONMENT=${1:-development}

echo "💾 데이터베이스 마이그레이션을 시작합니다... (환경: $ENVIRONMENT)"

# 환경별 설정
case $ENVIRONMENT in
    development)
        echo "🔧 Development 환경 마이그레이션"
        cd backend
        ;;
    staging)
        echo "🎭 Staging 환경 마이그레이션"
        cd backend
        ;;
    production)
        echo "🌟 Production 환경 마이그레이션"
        echo "⚠️ Production 마이그레이션은 신중하게 진행해야 합니다."
        read -p "계속하시겠습니까? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "마이그레이션이 취소되었습니다."
            exit 1
        fi
        cd backend
        ;;
    *)
        echo "❌ 잘못된 환경입니다. development, staging, production 중 하나를 선택하세요."
        exit 1
        ;;
esac

# 1. 백업 생성 (Production인 경우)
if [ "$ENVIRONMENT" = "production" ]; then
    echo "💾 데이터베이스 백업 생성 중..."
    BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
    
    # PostgreSQL 백업
    pg_dump \
        -h "${DATABASE_HOST}" \
        -p "${DATABASE_PORT}" \
        -U "${DATABASE_USERNAME}" \
        -d "${DATABASE_NAME}" \
        > "../backups/${BACKUP_FILE}"
    
    echo "✅ 백업 완료: ../backups/${BACKUP_FILE}"
fi

# 2. 마이그레이션 파일 확인
echo "📋 마이그레이션 파일 확인 중..."
MIGRATION_FILES=$(find src/database/migrations -name "*.ts" | wc -l)
echo "마이그레이션 파일 개수: $MIGRATION_FILES"

# 3. 마이그레이션 실행
echo "⚡ 마이그레이션 실행 중..."
npm run db:migrate

# 4. 마이그레이션 상태 확인
echo "📊 마이그레이션 상태 확인 중..."
# 마이그레이션 테이블 조회하여 상태 확인하는 로직 추가

# 5. 시드 데이터 적용 (Development인 경우)
if [ "$ENVIRONMENT" = "development" ]; then
    echo "🌱 시드 데이터 적용 중..."
    npm run db:seed
    echo "✅ 시드 데이터 적용 완료"
fi

echo ""
echo "🎉 데이터베이스 마이그레이션이 완료되었습니다!"
echo ""

# 6. 롤백 방법 안내
if [ "$ENVIRONMENT" = "production" ]; then
    echo "롤백이 필요한 경우:"
    echo "1. 마이그레이션 롤백: npm run db:migrate:revert"
    echo "2. 백업 복원: psql -h \$DATABASE_HOST -U \$DATABASE_USERNAME -d \$DATABASE_NAME < ../backups/${BACKUP_FILE}"
    echo ""
fi
</file>

<file path="scripts/setup.sh">
#!/bin/bash

# 워클리 프로젝트 초기 설정 스크립트

set -e

echo "🚀 워클리 프로젝트 초기 설정을 시작합니다..."

# 1. Node.js 버전 확인
echo "📋 Node.js 버전 확인 중..."
node_version=$(node -v | sed 's/v//' | cut -d'.' -f1)
if [ "$node_version" -lt 18 ]; then
    echo "❌ Node.js 18 이상이 필요합니다. 현재 버전: $(node -v)"
    exit 1
fi
echo "✅ Node.js 버전: $(node -v)"

# 2. npm 버전 확인
npm_version=$(npm -v | cut -d'.' -f1)
if [ "$npm_version" -lt 9 ]; then
    echo "❌ npm 9 이상이 필요합니다. 현재 버전: $(npm -v)"
    exit 1
fi
echo "✅ npm 버전: $(npm -v)"

# 3. 환경 변수 파일 설정
echo "🔧 환경 변수 파일 설정 중..."
if [ ! -f .env ]; then
    cp .env.example .env
    echo "✅ .env 파일이 생성되었습니다. 필요한 값들을 설정해주세요."
else
    echo "ℹ️ .env 파일이 이미 존재합니다."
fi

# 4. 의존성 설치
echo "📦 의존성 설치 중..."
npm install

# 5. Shared 모듈 빌드
echo "🔨 Shared 모듈 빌드 중..."
npm run build:shared

# 6. Git hooks 설정
echo "🪝 Git hooks 설정 중..."
npx husky install

# 7. Docker 환경 확인
echo "🐳 Docker 환경 확인 중..."
if command -v docker &> /dev/null; then
    echo "✅ Docker가 설치되어 있습니다."
    if docker info &> /dev/null; then
        echo "✅ Docker가 실행 중입니다."
    else
        echo "⚠️ Docker가 실행되지 않고 있습니다. Docker를 시작해주세요."
    fi
else
    echo "⚠️ Docker가 설치되지 않았습니다. 선택사항이지만 개발 환경 구성에 유용합니다."
fi

# 8. 데이터베이스 설정 안내
echo "💾 데이터베이스 설정 안내:"
echo "   개발용 PostgreSQL 실행: npm run docker:dev"
echo "   또는 로컬 PostgreSQL 설정 후 .env 파일 수정"

# 9. 개발 서버 실행 안내
echo ""
echo "🎉 초기 설정이 완료되었습니다!"
echo ""
echo "다음 단계:"
echo "1. .env 파일의 환경 변수를 설정하세요"
echo "2. 데이터베이스를 설정하세요: npm run docker:dev"
echo "3. 개발 서버를 실행하세요: npm run dev"
echo ""
echo "유용한 명령어:"
echo "- npm run dev          : 프론트엔드 + 백엔드 동시 실행"
echo "- npm run dev:frontend : 프론트엔드만 실행"
echo "- npm run dev:backend  : 백엔드만 실행"
echo "- npm run lint         : 전체 린팅"
echo "- npm run test         : 전체 테스트"
echo "- npm run build        : 전체 빌드"
</file>

<file path="shared/constants/socket-events.ts">
// Socket.io 이벤트 상수 정의

// 연결 관련 이벤트
export const CONNECTION_EVENTS = {
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  ERROR: 'error',
  RECONNECT: 'reconnect',
  RECONNECT_ERROR: 'reconnect_error',
} as const

// 사용자 관련 이벤트
export const USER_EVENTS = {
  JOIN: 'user:join',
  LEAVE: 'user:leave',
  ONLINE: 'user:online',
  OFFLINE: 'user:offline',
  STATUS_CHANGE: 'user:status_change',
} as const

// 프로젝트 관련 이벤트
export const PROJECT_EVENTS = {
  JOIN: 'project:join',
  LEAVE: 'project:leave',
  CREATED: 'project:created',
  UPDATED: 'project:updated',
  DELETED: 'project:deleted',
  MEMBER_ADDED: 'project:member_added',
  MEMBER_REMOVED: 'project:member_removed',
  STATUS_CHANGED: 'project:status_changed',
} as const

// 업무 관련 이벤트
export const TASK_EVENTS = {
  CREATED: 'task:created',
  UPDATED: 'task:updated',
  DELETED: 'task:deleted',
  STATUS_CHANGED: 'task:status_changed',
  ASSIGNED: 'task:assigned',
  UNASSIGNED: 'task:unassigned',
  COMMENT_ADDED: 'task:comment_added',
  DUE_DATE_REMINDER: 'task:due_date_reminder',
} as const

// 게시판 관련 이벤트
export const BOARD_EVENTS = {
  POST_CREATED: 'board:post_created',
  POST_UPDATED: 'board:post_updated',
  POST_DELETED: 'board:post_deleted',
  POST_LIKED: 'board:post_liked',
  POST_UNLIKED: 'board:post_unliked',
  COMMENT_ADDED: 'board:comment_added',
  COMMENT_UPDATED: 'board:comment_updated',
  COMMENT_DELETED: 'board:comment_deleted',
} as const

// 알림 관련 이벤트
export const NOTIFICATION_EVENTS = {
  NEW: 'notification:new',
  READ: 'notification:read',
  READ_ALL: 'notification:read_all',
  DELETED: 'notification:deleted',
} as const

// 채팅 관련 이벤트 (향후 확장용)
export const CHAT_EVENTS = {
  MESSAGE_SENT: 'chat:message_sent',
  MESSAGE_RECEIVED: 'chat:message_received',
  TYPING_START: 'chat:typing_start',
  TYPING_STOP: 'chat:typing_stop',
  USER_JOINED: 'chat:user_joined',
  USER_LEFT: 'chat:user_left',
} as const

// 시스템 관련 이벤트
export const SYSTEM_EVENTS = {
  MAINTENANCE_START: 'system:maintenance_start',
  MAINTENANCE_END: 'system:maintenance_end',
  UPDATE_AVAILABLE: 'system:update_available',
  BROADCAST: 'system:broadcast',
} as const

// 모든 이벤트를 하나의 객체로 통합
export const SOCKET_EVENTS = {
  CONNECTION: CONNECTION_EVENTS,
  USER: USER_EVENTS,
  PROJECT: PROJECT_EVENTS,
  TASK: TASK_EVENTS,
  BOARD: BOARD_EVENTS,
  NOTIFICATION: NOTIFICATION_EVENTS,
  CHAT: CHAT_EVENTS,
  SYSTEM: SYSTEM_EVENTS,
} as const

// 이벤트 타입 유니온
export type SocketEventType = 
  | keyof typeof CONNECTION_EVENTS
  | keyof typeof USER_EVENTS
  | keyof typeof PROJECT_EVENTS
  | keyof typeof TASK_EVENTS
  | keyof typeof BOARD_EVENTS
  | keyof typeof NOTIFICATION_EVENTS
  | keyof typeof CHAT_EVENTS
  | keyof typeof SYSTEM_EVENTS

// 룸 관련 상수
export const SOCKET_ROOMS = {
  USER: (userId: string) => `user:${userId}`,
  PROJECT: (projectId: string) => `project:${projectId}`,
  BOARD: 'board:global',
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  CHAT: (roomId: string) => `chat:${roomId}`,
} as const
</file>

<file path="shared/types/goal.types.ts">
/**
 * 워클리 고유 방법론 - 목표(Goal) 관련 타입 정의
 * 기존 OKR의 Objective를 대체하는 단순하고 유연한 목표 시스템
 */

// 목표 상태
export enum GoalStatus {
  DRAFT = 'draft',           // 초안
  ACTIVE = 'active',         // 진행 중
  ON_HOLD = 'on_hold',       // 보류
  COMPLETED = 'completed',    // 완료
  CANCELLED = 'cancelled',    // 취소
  ARCHIVED = 'archived',      // 보관됨
}

// 목표 우선순위
export enum GoalPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}

// 목표 유형
export enum GoalType {
  PERSONAL = 'personal',     // 개인 목표
  TEAM = 'team',            // 팀 목표
  ORGANIZATIONAL = 'organizational', // 조직 목표
  PROJECT = 'project',       // 프로젝트 목표
}

// 목표 시간 범위
export enum GoalTimeframe {
  SHORT_TERM = 'short_term',   // 단기 (1-3개월)
  MEDIUM_TERM = 'medium_term', // 중기 (3-12개월)
  LONG_TERM = 'long_term',     // 장기 (1년 이상)
}

// 기본 사용자 정보
export interface GoalUser {
  id: string;
  name: string;
  email: string;
  avatar?: string;
}

// 목표 메트릭 (간단한 진행 측정)
export interface GoalMetric {
  id: string;
  name: string;
  targetValue: number;
  currentValue: number;
  unit: string;
  description?: string;
}

// 메인 목표 인터페이스
export interface Goal {
  id: string;
  title: string;
  description?: string;
  status: GoalStatus;
  priority: GoalPriority;
  type: GoalType;
  timeframe: GoalTimeframe;
  
  // 날짜 관련
  startDate?: string;
  targetDate?: string;
  completedAt?: string;
  
  // 진행률 및 메트릭
  progress: number; // 0-100
  metrics: GoalMetric[];
  
  // 분류 및 태그
  tags: string[];
  color?: string;
  icon?: string;
  
  // 소유자 및 관계
  ownerId: string;
  owner: GoalUser;
  
  // 연결된 프로젝트 수 (계산된 값)
  projectCount: number;
  completedProjectCount: number;
  
  // 메타데이터
  createdAt: string;
  updatedAt: string;
  
  // 계산된 속성
  isOverdue?: boolean;
  isDueSoon?: boolean;
}

// 목표 생성 DTO
export interface CreateGoalDto {
  title: string;
  description?: string;
  priority?: GoalPriority;
  type?: GoalType;
  timeframe?: GoalTimeframe;
  startDate?: string;
  targetDate?: string;
  tags?: string[];
  color?: string;
  icon?: string;
  metrics?: Omit<GoalMetric, 'id'>[];
}

// 목표 업데이트 DTO
export interface UpdateGoalDto {
  title?: string;
  description?: string;
  status?: GoalStatus;
  priority?: GoalPriority;
  type?: GoalType;
  timeframe?: GoalTimeframe;
  startDate?: string;
  targetDate?: string;
  progress?: number;
  tags?: string[];
  color?: string;
  icon?: string;
  metrics?: GoalMetric[];
}

// 목표 쿼리 DTO
export interface GoalQueryDto {
  page?: number;
  limit?: number;
  status?: GoalStatus;
  priority?: GoalPriority;
  type?: GoalType;
  timeframe?: GoalTimeframe;
  ownerId?: string;
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
  includeArchived?: boolean;
  tags?: string[];
}

// 목표 통계
export interface GoalStats {
  total: number;
  draft: number;
  active: number;
  onHold: number;
  completed: number;
  cancelled: number;
  overdue: number;
  dueSoon: number;
}

// 목표 활동
export interface GoalActivity {
  id: string;
  type: 'created' | 'updated' | 'status_changed' | 'progress_updated' | 'metric_updated';
  description: string;
  userId: string;
  user: GoalUser;
  goalId: string;
  createdAt: string;
  metadata?: { [key: string]: any };
}

// 목표 대시보드 데이터
export interface GoalDashboard {
  goal: Goal;
  stats: {
    totalProjects: number;
    completedProjects: number;
    totalTasks: number;
    completedTasks: number;
    recentActivity: GoalActivity[];
  };
  recentProjects: SimpleProject[]; // SimpleProject 타입 (순환 참조 방지)
  upcomingMilestones: {
    id: string;
    title: string;
    dueDate: string;
    type: 'goal' | 'project' | 'task';
  }[];
}

// 목표 필터 설정
export interface GoalFilterSettings {
  status?: GoalStatus[];
  priority?: GoalPriority[];
  type?: GoalType[];
  timeframe?: GoalTimeframe[];
  ownerIds?: string[];
  tags?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

// SimpleProject 타입 (간단한 인터페이스 - 순환 참조 방지)
export interface SimpleProject {
  id: string;
  title: string;
  description?: string;
  status: string;
  progress: number;
  createdAt: string;
  updatedAt: string;
}
</file>

<file path="shared/types/inbox.types.ts">
/**
 * 워클리 고유 방법론 - 수집함(Inbox) 관련 타입 정의
 * CPER 워크플로우의 '수집(Capture)' 단계를 담당하는 중앙 집중식 입력 시스템
 */

// 수집함 항목 유형
export enum InboxItemType {
  QUICK_NOTE = 'quick_note',     // 빠른 메모
  TASK_IDEA = 'task_idea',       // 업무 아이디어
  PROJECT_IDEA = 'project_idea', // 프로젝트 아이디어
  GOAL_IDEA = 'goal_idea',       // 목표 아이디어
  MEETING_NOTE = 'meeting_note', // 회의 메모
  FEEDBACK = 'feedback',         // 피드백
  INSPIRATION = 'inspiration',   // 영감/아이디어
  REMINDER = 'reminder',         // 리마인더
  LINK = 'link',                // 링크/참조
  FILE = 'file',                // 파일 첨부
}

// 수집함 항목 상태
export enum InboxItemStatus {
  CAPTURED = 'captured',     // 수집됨 (초기 상태)
  CLARIFIED = 'clarified',   // 명확화됨
  ORGANIZED = 'organized',   // 정리됨 (프로젝트/업무로 전환)
  DEFERRED = 'deferred',     // 미루어짐
  DELETED = 'deleted',       // 삭제됨
}

// 수집함 항목 우선순위
export enum InboxItemPriority {
  LOW = 'low',
  MEDIUM = 'medium', 
  HIGH = 'high',
  URGENT = 'urgent',
}

// 기본 사용자 정보
export interface InboxUser {
  id: string;
  name: string;
  email: string;
  avatar?: string;
}

// 첨부 파일 정보
export interface InboxAttachment {
  id: string;
  fileName: string;
  fileSize: number;
  fileType: string;
  fileUrl: string;
  thumbnailUrl?: string;
  uploadedAt: string;
}

// 메인 수집함 항목 인터페이스
export interface InboxItem {
  id: string;
  title: string;
  content?: string;
  type: InboxItemType;
  status: InboxItemStatus;
  priority: InboxItemPriority;
  
  // 수집 방식 메타데이터
  source: 'manual' | 'email' | 'web_clipper' | 'mobile_app' | 'api' | 'voice_note';
  captureContext?: {
    url?: string;           // 웹에서 수집한 경우 원본 URL
    deviceType?: string;    // 수집 시 사용한 디바이스
    location?: string;      // GPS 위치 (선택적)
    timestamp: string;      // 수집 시점
  };
  
  // 첨부 파일 및 링크
  attachments: InboxAttachment[];
  relatedUrls: string[];
  
  // 태그 및 분류
  tags: string[];
  
  // 처리 결과 (정리 단계에서 설정)
  processedInto?: {
    type: 'goal' | 'project' | 'task' | 'note';
    id: string;
    title: string;
  };
  
  // 스케줄링
  scheduledFor?: string; // 나중에 처리할 날짜
  reminderAt?: string;   // 리마인더 시간
  
  // 소유자 및 관계
  userId: string;
  user: InboxUser;
  
  // 메타데이터
  createdAt: string;
  updatedAt: string;
  processedAt?: string;
  
  // 계산된 속성
  isOverdue?: boolean;
  daysSinceCapture?: number;
}

// 수집함 항목 생성 DTO (빠른 수집용)
export interface CreateInboxItemDto {
  title: string;
  content?: string;
  type?: InboxItemType;
  priority?: InboxItemPriority;
  source?: string;
  tags?: string[];
  relatedUrls?: string[];
  scheduledFor?: string;
  reminderAt?: string;
  attachments?: File[];
}

// 수집함 항목 업데이트 DTO (명확화 단계용)
export interface UpdateInboxItemDto {
  title?: string;
  content?: string;
  type?: InboxItemType;
  status?: InboxItemStatus;
  priority?: InboxItemPriority;
  tags?: string[];
  scheduledFor?: string;
  reminderAt?: string;
  processedInto?: {
    type: 'goal' | 'project' | 'task' | 'note';
    id: string;
    title: string;
  };
}

// 수집함 항목 쿼리 DTO
export interface InboxQueryDto {
  page?: number;
  limit?: number;
  status?: InboxItemStatus;
  type?: InboxItemType;
  priority?: InboxItemPriority;
  source?: string;
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
  tags?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

// 수집함 빠른 입력 DTO (글로벌 캡처 UI용)
export interface QuickCaptureDto {
  content: string;
  type?: InboxItemType;
  priority?: InboxItemPriority;
  tags?: string[];
  scheduledFor?: string;
}

// 수집함 일괄 처리 DTO
export interface InboxBatchProcessDto {
  itemIds: string[];
  action: 'clarify' | 'organize' | 'defer' | 'delete';
  data?: {
    scheduledFor?: string;
    processedInto?: {
      type: 'goal' | 'project' | 'task';
      title: string;
      description?: string;
    };
  };
}

// 수집함 통계
export interface InboxStats {
  total: number;
  captured: number;
  clarified: number;
  organized: number;
  deferred: number;
  overdueItems: number;
  todaysCaptureCount: number;
  averageProcessingTime: number; // 시간 단위
}

// 수집함 활동
export interface InboxActivity {
  id: string;
  type: 'captured' | 'clarified' | 'organized' | 'deferred' | 'processed';
  description: string;
  userId: string;
  user: InboxUser;
  itemId: string;
  createdAt: string;
  metadata?: { [key: string]: any };
}

// 수집함 대시보드 데이터
export interface InboxDashboard {
  stats: InboxStats;
  recentItems: InboxItem[];
  overdueItems: InboxItem[];
  scheduledItems: InboxItem[];
  recentActivity: InboxActivity[];
  processingInsights: {
    mostCapturedType: InboxItemType;
    averageItemsPerDay: number;
    processingEfficiency: number; // 0-100 (처리된 비율)
  };
}

// 수집함 필터 설정
export interface InboxFilterSettings {
  status?: InboxItemStatus[];
  type?: InboxItemType[];
  priority?: InboxItemPriority[];
  source?: string[];
  tags?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

// 수집함 뷰 설정
export interface InboxViewSettings {
  groupBy?: 'none' | 'type' | 'priority' | 'status' | 'date';
  sortBy: string;
  sortOrder: 'ASC' | 'DESC';
  filters: InboxFilterSettings;
  showProcessed: boolean;
}
</file>

<file path="shared/types/navigation.types.ts">
/**
 * 워클리 고유 방법론 - 네비게이션 관련 타입 정의
 * 5개 핵심 네비게이션 항목: 업무 → 프로젝트 → 수집함 → 목표 → 프로필
 */

// 메인 네비게이션 항목
export enum NavigationItem {
  TASKS = 'tasks',           // 업무
  PROJECTS = 'projects',     // 프로젝트  
  INBOX = 'inbox',          // 수집함 (중앙 위치, 강조)
  GOALS = 'goals',          // 목표
  PROFILE = 'profile',      // 프로필
}

// 네비게이션 아이템 정보
export interface NavigationItemInfo {
  id: NavigationItem;
  label: string;
  icon: string;
  path: string;
  isCenter?: boolean;       // 중앙 위치 (수집함용)
  isEmphasized?: boolean;   // 시각적 강조
  badgeCount?: number;      // 뱃지 카운트
  isActive?: boolean;       // 현재 활성화 상태
}

// 플로팅 액션 버튼 설정
export interface FloatingActionButtonConfig {
  showOnDesktop: boolean;   // 데스크톱에서만 표시
  showOnMobile: boolean;    // 모바일에서 표시 여부
  position: 'bottom-right' | 'bottom-left' | 'bottom-center';
  actions: FloatingAction[];
}

// 플로팅 액션 항목
export interface FloatingAction {
  id: string;
  label: string;
  icon: string;
  action: 'quick-capture' | 'add-task' | 'add-project' | 'add-goal';
  color?: string;
  shortcut?: string;        // 키보드 단축키
}

// 빠른 캡처 모달 설정
export interface QuickCaptureConfig {
  placeholder: string;
  showTypeSelector: boolean;
  showPrioritySelector: boolean;
  showTagInput: boolean;
  showScheduleOption: boolean;
  autoFocus: boolean;
}

// 네비게이션 상태
export interface NavigationState {
  currentItem: NavigationItem;
  previousItem?: NavigationItem;
  breadcrumbs: BreadcrumbItem[];
  isLoading: boolean;
  error?: string;
}

// 브레드크럼 아이템
export interface BreadcrumbItem {
  label: string;
  path: string;
  icon?: string;
  isClickable: boolean;
}

// 네비게이션 설정
export interface NavigationSettings {
  layout: 'bottom' | 'sidebar' | 'top';
  showLabels: boolean;
  showBadges: boolean;
  enableSwipeGestures: boolean;
  floatingActionButton: FloatingActionButtonConfig;
  quickCapture: QuickCaptureConfig;
}

// 워클리 방법론 워크플로우 단계
export enum CPERStep {
  CAPTURE = 'capture',   // 수집
  PLAN = 'plan',        // 계획
  EXECUTE = 'execute',  // 실행
  REVIEW = 'review',    // 검토
}

// 워크플로우 상태
export interface WorkflowState {
  currentStep: CPERStep;
  completedSteps: CPERStep[];
  nextStep?: CPERStep;
  progress: number; // 0-100
}

// 사용자 컨텍스트 (네비게이션에서 사용)
export interface UserNavigationContext {
  userId: string;
  preferences: NavigationSettings;
  workflow: WorkflowState;
  quickStats: {
    inboxCount: number;
    todayTasksCount: number;
    activeProjectsCount: number;
    activeGoalsCount: number;
  };
}
</file>

<file path="shared/types/socket.types.ts">
import { Task, Project, Notification, User } from './api.types'

// Socket 이벤트 타입 정의
export interface SocketEvents {
  // 클라이언트 → 서버 이벤트
  'join:project': (projectId: string) => void
  'leave:project': (projectId: string) => void
  'join:user': (userId: string) => void
  'leave:user': (userId: string) => void

  // 서버 → 클라이언트 이벤트
  'task:created': (data: TaskCreatedPayload) => void
  'task:updated': (data: TaskUpdatedPayload) => void
  'task:deleted': (data: TaskDeletedPayload) => void
  'task:assigned': (data: TaskAssignedPayload) => void
  
  'project:updated': (data: ProjectUpdatedPayload) => void
  'project:member:added': (data: ProjectMemberAddedPayload) => void
  'project:member:removed': (data: ProjectMemberRemovedPayload) => void
  
  'notification:new': (data: NotificationPayload) => void
  'notification:read': (data: NotificationReadPayload) => void
  
  'user:online': (data: UserOnlinePayload) => void
  'user:offline': (data: UserOfflinePayload) => void
  
  // 시스템 이벤트
  'connection': () => void
  'disconnect': () => void
  'error': (error: SocketError) => void
}

// 이벤트 페이로드 타입들
export interface TaskCreatedPayload {
  task: Task
  projectId?: string
  createdBy: User
}

export interface TaskUpdatedPayload {
  task: Task
  changes: Partial<Task>
  updatedBy: User
  projectId?: string
}

export interface TaskDeletedPayload {
  taskId: string
  projectId?: string
  deletedBy: User
}

export interface TaskAssignedPayload {
  task: Task
  assignee: User
  assignedBy: User
  projectId?: string
}

export interface ProjectUpdatedPayload {
  project: Project
  changes: Partial<Project>
  updatedBy: User
}

export interface ProjectMemberAddedPayload {
  project: Project
  member: User
  addedBy: User
}

export interface ProjectMemberRemovedPayload {
  projectId: string
  member: User
  removedBy: User
}

export interface NotificationPayload {
  notification: Notification
}

export interface NotificationReadPayload {
  notificationId: string
  userId: string
  readAt: string
}

export interface UserOnlinePayload {
  userId: string
  user: User
  onlineAt: string
}

export interface UserOfflinePayload {
  userId: string
  user: User
  offlineAt: string
}

export interface SocketError {
  message: string
  code?: string
  details?: any
}

// Socket 연결 상태
export interface SocketState {
  isConnected: boolean
  isConnecting: boolean
  error?: string
  onlineUsers: User[]
  joinedProjects: string[]
}

// Socket 클라이언트 설정
export interface SocketConfig {
  url: string
  options?: {
    autoConnect?: boolean
    reconnection?: boolean
    reconnectionAttempts?: number
    reconnectionDelay?: number
    timeout?: number
  }
}
</file>

<file path="shared/package.json">
{
  "name": "@workly/shared",
  "version": "1.0.0",
  "description": "워클리 공유 타입 및 유틸리티",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "clean": "rm -rf dist",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "files": [
    "dist"
  ]
}
</file>

<file path="shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": false,
    "esModuleInterop": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "src/**/*",
    "types/**/*",
    "constants/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path=".prettierignore">
# Dependencies
node_modules
*/node_modules

# Build outputs
dist
*/dist
.next
*/.next
build
*/build
coverage
*/coverage

# Generated files
*.d.ts
*.tsbuildinfo

# Lock files
package-lock.json
*/package-lock.json
yarn.lock
*/yarn.lock

# Logs
*.log

# Environment files
.env
.env.*

# Storybook
storybook-static

# Database
*.sqlite
*.db

# Docker
Dockerfile
docker-compose*.yml

# Git
.git
.gitignore

# IDE
.vscode
.idea

# OS
.DS_Store
Thumbs.db
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "bracketSameLine": false,
  "arrowParens": "avoid",
  "endOfLine": "lf",
  "quoteProps": "as-needed",
  "jsxSingleQuote": true,
  "proseWrap": "preserve"
}
</file>

<file path="README.md">
# 워클리 (Workly) - 업무 관리 플랫폼

효율적인 업무 관리와 팀 협업을 위한 현대적인 웹 애플리케이션

## 🚀 주요 기능

- **📊 업무 대시보드**: 개인 및 팀 업무 현황을 한눈에 파악
- **🗂️ 프로젝트 관리**: 프로젝트별 업무 조직화 및 진행 상황 추적
- **💬 게시판**: 팀 소통 및 정보 공유
- **🔔 실시간 알림**: Socket.io 기반 실시간 업데이트
- **👥 팀 협업**: 사용자 권한 관리 및 협업 도구
- **🔐 보안 인증**: JWT 및 Google OAuth 통합

## 🛠️ 기술 스택

### Frontend
- **Next.js 14**: React 기반 풀스택 프레임워크
- **TypeScript**: 타입 안전성을 위한 정적 타입 언어
- **Tailwind CSS**: 유틸리티 우선 CSS 프레임워크
- **Zustand**: 가벼운 상태 관리 라이브러리
- **Socket.io Client**: 실시간 통신

### Backend
- **NestJS**: Node.js 기반 확장 가능한 서버 프레임워크
- **TypeORM**: TypeScript용 ORM
- **PostgreSQL**: 관계형 데이터베이스
- **Socket.io**: 실시간 양방향 통신
- **JWT**: 사용자 인증 및 권한 관리
- **Google OAuth**: 소셜 로그인

### DevOps & 인프라
- **Docker**: 컨테이너화
- **Redis**: 세션 관리 및 캐싱
- **AWS S3**: 파일 스토리지 (프로덕션)
- **GitHub Actions**: CI/CD 파이프라인

## 📁 프로젝트 구조

```
Workly/
├── 📁 frontend/           # Next.js 프론트엔드
├── 📁 backend/            # NestJS 백엔드
├── 📁 shared/             # 공유 타입 및 상수
├── 📁 docs/               # 프로젝트 문서
├── 📁 scripts/            # 유틸리티 스크립트
├── docker-compose.yml     # 개발 환경 Docker
└── README.md
```

자세한 구조는 [PROJECT_STRUCTURE.md](./PROJECT_STRUCTURE.md)를 참조하세요.

## 🚀 빠른 시작

### 1. 저장소 클론
```bash
git clone https://github.com/your-username/workly.git
cd workly
```

### 2. 환경 변수 설정
```bash
cp .env.example .env
# .env 파일을 편집하여 필요한 환경 변수를 설정하세요
```

### 3. Docker로 개발 환경 실행
```bash
# 모든 서비스 실행 (데이터베이스, 백엔드, 프론트엔드)
docker-compose up -d

# 로그 확인
docker-compose logs -f
```

### 4. 로컬 개발 (선택사항)

#### 데이터베이스만 Docker로 실행
```bash
docker-compose up -d postgres redis
```

#### 백엔드 실행
```bash
cd backend
npm install
npm run start:dev
```

#### 프론트엔드 실행
```bash
cd frontend
npm install
npm run dev
```

## 📱 애플리케이션 접속

- **프론트엔드**: http://localhost:3000
- **백엔드 API**: http://localhost:3001
- **API 문서**: http://localhost:3001/api (Swagger)
- **데이터베이스**: localhost:5432
- **Redis**: localhost:6379
- **MinIO Console**: http://localhost:9001

## 🧪 테스트

### 백엔드 테스트
```bash
cd backend
# 단위 테스트
npm run test

# E2E 테스트
npm run test:e2e

# 테스트 커버리지
npm run test:cov
```

### 프론트엔드 테스트
```bash
cd frontend
# Jest 테스트
npm run test

# Cypress E2E 테스트
npm run cypress:open
```

## 📦 배포

### 프로덕션 빌드
```bash
# 백엔드 빌드
cd backend
npm run build

# 프론트엔드 빌드
cd frontend
npm run build
```

### Docker 프로덕션 배포
```bash
docker-compose -f docker-compose.prod.yml up -d
```

## 🔧 개발 가이드

### 코드 스타일
- **ESLint**: 코드 품질 및 스타일 검사
- **Prettier**: 코드 포매팅
- **Husky**: Git 훅을 통한 자동 검사

### API 개발
1. 백엔드에서 NestJS 모듈 생성
2. DTO 및 엔티티 정의
3. 서비스 로직 구현
4. 컨트롤러 API 엔드포인트 생성
5. 프론트엔드 서비스 레이어에서 API 연동

### 실시간 기능 개발
1. 백엔드 WebSocket Gateway 이벤트 정의
2. Socket 이벤트 타입을 shared/types에 추가
3. 프론트엔드에서 Socket 연결 및 이벤트 리스너 구현

## 🤝 기여하기

1. 이 저장소를 포크합니다
2. 새로운 기능 브랜치를 생성합니다 (`git checkout -b feature/새기능`)
3. 변경사항을 커밋합니다 (`git commit -am '새기능 추가'`)
4. 브랜치에 푸시합니다 (`git push origin feature/새기능`)
5. Pull Request를 생성합니다

## 📄 라이센스

이 프로젝트는 MIT 라이센스 하에 배포됩니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 참조하세요.

## 🆘 지원

문제가 발생하거나 질문이 있으시면:

1. [GitHub Issues](https://github.com/your-username/workly/issues)에 이슈를 등록해주세요
2. [토론 게시판](https://github.com/your-username/workly/discussions)에서 커뮤니티와 소통하세요
3. 문서를 확인하세요: [docs/](./docs/)

---

**워클리**로 더 효율적인 업무 관리를 시작하세요! 🚀
</file>

<file path="vercel.json">
{
  "framework": "nextjs",
  "name": "workly",
  "buildCommand": "npm run build:frontend",
  "devCommand": "npm run dev:frontend",
  "installCommand": "npm install",
  "outputDirectory": "frontend/.next"
}
</file>

<file path="backend/src/config/auth.config.ts">
import { ConfigService } from '@nestjs/config';

export interface AuthConfig {
  jwt: {
    secret: string;
    expiresIn: string;
    refreshExpiresIn: string;
  };
  google: {
    clientId: string;
    clientSecret: string;
    callbackUrl: string;
  };
  bcrypt: {
    saltRounds: number;
  };
  session: {
    secret: string;
    maxAge: number;
  };
}

export const getAuthConfig = (configService: ConfigService): AuthConfig => {
  return {
    jwt: {
      secret: configService.get('JWT_SECRET', 'workly-super-secret-key'),
      expiresIn: configService.get('JWT_EXPIRES_IN', '7d'),
      refreshExpiresIn: configService.get('JWT_REFRESH_EXPIRES_IN', '30d'),
    },
    google: {
      clientId: configService.get('GOOGLE_CLIENT_ID', ''),
      clientSecret: configService.get('GOOGLE_CLIENT_SECRET', ''),
      callbackUrl: configService.get('GOOGLE_CALLBACK_URL', 'http://localhost:8000/auth/google/callback'),
    },
    bcrypt: {
      saltRounds: parseInt(configService.get('BCRYPT_SALT_ROUNDS', '12')),
    },
    session: {
      secret: configService.get('SESSION_SECRET', 'workly-session-secret'),
      maxAge: parseInt(configService.get('SESSION_MAX_AGE', '86400000')), // 24시간
    },
  };
};
</file>

<file path="backend/src/config/database.config.ts">
import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';
import { DataSource, DataSourceOptions } from 'typeorm';

// 환경변수를 읽는 헬퍼 함수
const getEnvVar = (key: string, defaultValue: string): string => {
  return process.env[key] || defaultValue;
};

const getEnvNumber = (key: string, defaultValue: number): number => {
  const value = process.env[key];
  return value ? parseInt(value, 10) : defaultValue;
};

const isProduction = (): boolean => {
  return process.env.NODE_ENV === 'production';
};

const isDevelopment = (): boolean => {
  return process.env.NODE_ENV === 'development';
};

// 단일 데이터베이스 설정 - Single Source of Truth
const createDatabaseConfig = (): DataSourceOptions => ({
  type: 'postgres',
  host: getEnvVar('DATABASE_HOST', 'localhost'),
  port: getEnvNumber('DATABASE_PORT', 5432),
  username: getEnvVar('DATABASE_USERNAME', 'workly'),
  password: getEnvVar('DATABASE_PASSWORD', 'workly123'),
  database: getEnvVar('DATABASE_NAME', 'workly'),
  entities: [__dirname + '/../database/entities/*{.ts,.js}'],
  migrations: [__dirname + '/../database/migrations/*{.ts,.js}'],
  synchronize: isDevelopment(), // 개발환경에서만 true
  logging: isDevelopment(),
  ssl: isProduction() ? {
    rejectUnauthorized: false
  } : false,
  extra: {
    max: 20, // 최대 연결 수
    idleTimeoutMillis: 30000, // 유휴 연결 타임아웃
    connectionTimeoutMillis: 2000, // 연결 타임아웃
  },
});

// NestJS TypeORM 모듈용 설정
export const getDatabaseConfig = (configService: ConfigService): TypeOrmModuleOptions => {
  // ConfigService를 통해 환경변수를 다시 검증
  const baseConfig = createDatabaseConfig();
  
  return {
    ...baseConfig,
    // ConfigService로 한번 더 검증하여 더 안전하게
    host: configService.get<string>('DATABASE_HOST', getEnvVar('DATABASE_HOST', 'localhost')),
    port: configService.get<number>('DATABASE_PORT', getEnvNumber('DATABASE_PORT', 5432)),
    username: configService.get<string>('DATABASE_USERNAME', getEnvVar('DATABASE_USERNAME', 'workly')),
    password: configService.get<string>('DATABASE_PASSWORD', getEnvVar('DATABASE_PASSWORD', 'workly123')),
    database: configService.get<string>('DATABASE_NAME', getEnvVar('DATABASE_NAME', 'workly')),
    synchronize: configService.get('NODE_ENV') === 'development',
    logging: configService.get('NODE_ENV') === 'development',
  } as TypeOrmModuleOptions;
};

// CLI용 데이터소스 설정 (마이그레이션 등) - 동일한 설정 재사용
export const dataSourceOptions: DataSourceOptions = createDatabaseConfig();

export default new DataSource(dataSourceOptions);
</file>

<file path="backend/src/database/entities/file.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  Index,
} from 'typeorm';
import { User } from './user.entity';

@Entity('files')
@Index(['filename'])
@Index(['mimetype'])
@Index(['uploaderId'])
@Index(['createdAt'])
@Index(['entityType', 'entityId'])
export class File {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  filename: string;

  @Column()
  originalName: string;

  @Column()
  mimetype: string;

  @Column({ type: 'bigint' })
  size: number;

  @Column()
  path: string;

  @Column()
  url: string;

  @Column({ nullable: true })
  thumbnailUrl?: string;

  @Column()
  uploaderId: string;

  @Column({ nullable: true })
  entityType?: string; // 'task', 'project', 'user', 'post' 등

  @Column({ nullable: true })
  entityId?: string;

  @Column({ default: false })
  isPublic: boolean;

  @Column({ default: false })
  isProcessed: boolean;

  @Column('simple-array', { default: [] })
  tags: string[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => User, { eager: true })
  uploader: User;

  // 파일 타입 확인 메서드들
  isImage(): boolean {
    return this.mimetype.startsWith('image/');
  }

  isVideo(): boolean {
    return this.mimetype.startsWith('video/');
  }

  isAudio(): boolean {
    return this.mimetype.startsWith('audio/');
  }

  isDocument(): boolean {
    const documentTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'text/plain',
      'text/csv',
    ];
    return documentTypes.includes(this.mimetype);
  }

  isArchive(): boolean {
    const archiveTypes = [
      'application/zip',
      'application/x-rar-compressed',
      'application/x-7z-compressed',
      'application/x-tar',
      'application/gzip',
    ];
    return archiveTypes.includes(this.mimetype);
  }

  isCode(): boolean {
    const codeTypes = [
      'text/javascript',
      'text/typescript',
      'text/html',
      'text/css',
      'application/json',
      'text/xml',
      'application/xml',
    ];
    return codeTypes.includes(this.mimetype) || 
           Boolean(this.filename.match(/\.(js|ts|jsx|tsx|html|css|scss|sass|less|json|xml|yaml|yml|md|py|java|c|cpp|h|hpp|cs|php|rb|go|rs|swift|kt)$/i));
  }

  // 파일 크기를 읽기 쉬운 형태로 반환
  getSizeFormatted(): string {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = this.size;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    return `${size.toFixed(1)} ${units[unitIndex]}`;
  }

  // 파일 확장자 반환
  getExtension(): string {
    const lastDotIndex = this.filename.lastIndexOf('.');
    return lastDotIndex !== -1 ? this.filename.substring(lastDotIndex + 1).toLowerCase() : '';
  }

  // 파일 타입 카테고리 반환
  getCategory(): string {
    if (this.isImage()) return 'image';
    if (this.isVideo()) return 'video';
    if (this.isAudio()) return 'audio';
    if (this.isDocument()) return 'document';
    if (this.isArchive()) return 'archive';
    if (this.isCode()) return 'code';
    return 'other';
  }

  // 썸네일이 필요한지 확인
  needsThumbnail(): boolean {
    return this.isImage() || this.isVideo() || this.isDocument();
  }

  // 미리보기 가능한지 확인
  isPreviewable(): boolean {
    return this.isImage() || 
           this.isCode() || 
           this.mimetype === 'text/plain' ||
           this.mimetype === 'application/pdf';
  }

  // 브라우저에서 직접 열 수 있는지 확인
  isViewableInBrowser(): boolean {
    const viewableTypes = [
      'text/plain',
      'text/html',
      'text/css',
      'text/javascript',
      'application/json',
      'application/pdf',
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/svg+xml',
      'video/mp4',
      'video/webm',
      'audio/mp3',
      'audio/wav',
      'audio/ogg',
    ];
    return viewableTypes.includes(this.mimetype);
  }

  // 다운로드 권한 확인
  canDownload(userId: string): boolean {
    if (this.isPublic) return true;
    return this.uploaderId === userId;
  }

  // 삭제 권한 확인
  canDelete(userId: string): boolean {
    return this.uploaderId === userId;
  }

  // 편집 권한 확인 (메타데이터만)
  canEdit(userId: string): boolean {
    return this.uploaderId === userId;
  }

  // 파일을 공개로 설정
  makePublic(): void {
    this.isPublic = true;
  }

  // 파일을 비공개로 설정
  makePrivate(): void {
    this.isPublic = false;
  }

  // 처리 완료 표시 (썸네일 생성 등)
  markAsProcessed(): void {
    this.isProcessed = true;
  }

  // 태그 추가
  addTag(tag: string): void {
    if (!this.tags.includes(tag)) {
      this.tags.push(tag);
    }
  }

  // 태그 제거
  removeTag(tag: string): void {
    this.tags = this.tags.filter(t => t !== tag);
  }

  // 엔티티에 연결
  attachTo(entityType: string, entityId: string): void {
    this.entityType = entityType;
    this.entityId = entityId;
  }

  // 엔티티에서 분리
  detach(): void {
    this.entityType = undefined;
    this.entityId = undefined;
  }

  // 연결된 엔티티 확인
  isAttachedTo(entityType: string, entityId: string): boolean {
    return this.entityType === entityType && this.entityId === entityId;
  }

  // 파일 유효성 검증
  validate(): string[] {
    const errors: string[] = [];

    if (!this.filename) {
      errors.push('Filename is required');
    }

    if (!this.originalName) {
      errors.push('Original name is required');
    }

    if (!this.mimetype) {
      errors.push('MIME type is required');
    }

    if (this.size <= 0) {
      errors.push('File size must be greater than 0');
    }

    // 파일 크기 제한 (예: 100MB)
    const maxSize = 100 * 1024 * 1024; // 100MB
    if (this.size > maxSize) {
      errors.push(`File size cannot exceed ${maxSize / (1024 * 1024)}MB`);
    }

    return errors;
  }
}
</file>

<file path="backend/src/database/entities/project-member.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  Index,
  Unique,
} from 'typeorm';
import { 
  ProjectRole,
  ProjectPermission
} from '@workly/shared';
import { User } from './user.entity';
import { Project } from './project.entity';

@Entity('project_members')
@Unique(['projectId', 'userId'])
@Index(['projectId'])
@Index(['userId'])
@Index(['role'])
export class ProjectMember {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  projectId: string;

  @Column()
  userId: string;

  @Column({
    type: 'enum',
    enum: ProjectRole,
    default: ProjectRole.MEMBER,
  })
  role: ProjectRole;

  @Column('simple-array')
  permissions: ProjectPermission[];

  @CreateDateColumn()
  joinedAt: Date;

  // 관계 설정
  @ManyToOne(() => Project, project => project.members, {
    onDelete: 'CASCADE'
  })
  project: Project;

  @ManyToOne(() => User, { eager: true })
  user: User;

  // 권한 확인 메서드들
  hasPermission(permission: ProjectPermission): boolean {
    return this.permissions.includes(permission);
  }

  isOwner(): boolean {
    return this.role === ProjectRole.OWNER;
  }

  isAdmin(): boolean {
    return this.role === ProjectRole.ADMIN || this.isOwner();
  }

  canManageProject(): boolean {
    return this.isAdmin() || this.hasPermission(ProjectPermission.EDIT_PROJECT);
  }

  canManageMembers(): boolean {
    return this.isAdmin() || this.hasPermission(ProjectPermission.MANAGE_MEMBERS);
  }

  canCreateTasks(): boolean {
    return this.hasPermission(ProjectPermission.CREATE_TASKS);
  }

  canEditTasks(): boolean {
    return this.hasPermission(ProjectPermission.EDIT_TASKS);
  }

  canDeleteTasks(): boolean {
    return this.hasPermission(ProjectPermission.DELETE_TASKS);
  }

  canAssignTasks(): boolean {
    return this.hasPermission(ProjectPermission.ASSIGN_TASKS);
  }

  // 권한 설정 메서드들
  grantPermission(permission: ProjectPermission): void {
    if (!this.hasPermission(permission)) {
      this.permissions.push(permission);
    }
  }

  revokePermission(permission: ProjectPermission): void {
    this.permissions = this.permissions.filter(p => p !== permission);
  }

  setRole(role: ProjectRole): void {
    this.role = role;
    this.setDefaultPermissions();
  }

  // 역할별 기본 권한 설정
  private setDefaultPermissions(): void {
    switch (this.role) {
      case ProjectRole.OWNER:
        this.permissions = Object.values(ProjectPermission);
        break;
      case ProjectRole.ADMIN:
        this.permissions = [
          ProjectPermission.VIEW_PROJECT,
          ProjectPermission.EDIT_PROJECT,
          ProjectPermission.MANAGE_MEMBERS,
          ProjectPermission.CREATE_TASKS,
          ProjectPermission.EDIT_TASKS,
          ProjectPermission.DELETE_TASKS,
          ProjectPermission.ASSIGN_TASKS,
          ProjectPermission.MANAGE_SETTINGS,
        ];
        break;
      case ProjectRole.MEMBER:
        this.permissions = [
          ProjectPermission.VIEW_PROJECT,
          ProjectPermission.CREATE_TASKS,
          ProjectPermission.EDIT_TASKS,
          ProjectPermission.ASSIGN_TASKS,
        ];
        break;
      case ProjectRole.VIEWER:
        this.permissions = [ProjectPermission.VIEW_PROJECT];
        break;
      default:
        this.permissions = [];
    }
  }
}
</file>

<file path="backend/src/database/entities/project.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  OneToMany,
  ManyToMany,
  JoinTable,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import { 
  ProjectStatus, 
  ProjectPriority, 
  ProjectVisibility,
  ProjectSettings,
  ProjectPermission,
  WorkflowStage
} from '@workly/shared';
import { User } from './user.entity';
import { Task } from './task.entity';
import { ProjectMember } from './project-member.entity';

@Entity('projects')
@Index(['title'])
@Index(['status'])
@Index(['priority'])
@Index(['ownerId'])
@Index(['createdAt'])
@Index(['startDate'])
@Index(['endDate'])
@Index(['isArchived'])
export class Project {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column('text', { nullable: true })
  description?: string;

  @Column({
    type: 'enum',
    enum: ProjectStatus,
    default: ProjectStatus.PLANNING,
  })
  status: ProjectStatus;

  @Column({
    type: 'enum',
    enum: ProjectPriority,
    default: ProjectPriority.MEDIUM,
  })
  priority: ProjectPriority;

  @Column({ type: 'date', nullable: true })
  startDate?: Date;

  @Column({ type: 'date', nullable: true })
  endDate?: Date;

  @Column({ type: 'int', default: 0 })
  progress: number;

  @Column({ type: 'decimal', precision: 12, scale: 2, nullable: true })
  budget?: number;

  @Column({ length: 3, nullable: true })
  currency?: string;

  @Column('simple-array', { default: [] })
  tags: string[];

  @Column({ default: false })
  isArchived: boolean;

  @Column({ default: false })
  isTemplate: boolean;

  @Column({ nullable: true })
  templateId?: string;

  @Column({ length: 7, nullable: true })
  color?: string;

  @Column({ nullable: true })
  icon?: string;

  @Column({
    type: 'enum',
    enum: ProjectVisibility,
    default: ProjectVisibility.PRIVATE,
  })
  visibility: ProjectVisibility;

  @Column('jsonb')
  settings: ProjectSettings;

  @Column()
  ownerId: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => User, { eager: true })
  owner: User;

  @OneToMany(() => ProjectMember, member => member.project, { 
    cascade: true, 
    eager: false 
  })
  members: ProjectMember[];

  @OneToMany(() => Task, task => task.project, { 
    cascade: true 
  })
  tasks: Task[];

  // 계산된 필드들
  tasksCount: number;
  completedTasksCount: number;

  // 기본값 설정
  @BeforeInsert()
  @BeforeUpdate()
  setDefaultValues() {
    if (!this.settings) {
      this.settings = {
        allowGuestAccess: false,
        requireApprovalForTasks: false,
        enableTimeTracking: true,
        enableBudgetTracking: false,
        enableNotifications: true,
        enableComments: true,
        enableFileAttachments: true,
        defaultTaskPriority: ProjectPriority.MEDIUM,
        workflowStages: [
          {
            id: 'todo',
            name: 'To Do',
            description: '작업 대기',
            color: '#6B7280',
            order: 1,
            isDefault: true,
            isCompleted: false,
          },
          {
            id: 'in-progress',
            name: 'In Progress',
            description: '진행 중',
            color: '#3B82F6',
            order: 2,
            isDefault: false,
            isCompleted: false,
          },
          {
            id: 'review',
            name: 'Review',
            description: '검토 중',
            color: '#F59E0B',
            order: 3,
            isDefault: false,
            isCompleted: false,
          },
          {
            id: 'completed',
            name: 'Completed',
            description: '완료',
            color: '#10B981',
            order: 4,
            isDefault: false,
            isCompleted: true,
          },
        ] as any[],
      } as ProjectSettings;
    }

    if (!this.tags) {
      this.tags = [];
    }
  }

  // 진행률 계산
  calculateProgress(): number {
    if (!this.tasks || this.tasks.length === 0) {
      return 0;
    }

    const completedTasks = this.tasks.filter(task => 
      task.status === 'completed'
    ).length;

    return Math.round((completedTasks / this.tasks.length) * 100);
  }

  // 프로젝트 완료 처리
  complete(): void {
    this.status = ProjectStatus.COMPLETED;
    this.progress = 100;
  }

  // 프로젝트 일시 중단
  hold(): void {
    this.status = ProjectStatus.ON_HOLD;
  }

  // 프로젝트 재개
  resume(): void {
    this.status = ProjectStatus.IN_PROGRESS;
  }

  // 프로젝트 취소
  cancel(): void {
    this.status = ProjectStatus.CANCELLED;
  }

  // 프로젝트 아카이브
  archive(): void {
    this.isArchived = true;
    this.status = ProjectStatus.ARCHIVED;
  }

  // 프로젝트 복원
  unarchive(): void {
    this.isArchived = false;
    if (this.status === ProjectStatus.ARCHIVED) {
      this.status = ProjectStatus.PLANNING;
    }
  }

  // 마감일 체크
  isOverdue(): boolean {
    if (!this.endDate) return false;
    return new Date() > this.endDate && this.status !== ProjectStatus.COMPLETED;
  }

  // 곧 마감되는지 체크 (7일 이내)
  isDueSoon(): boolean {
    if (!this.endDate) return false;
    const sevenDaysFromNow = new Date();
    sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);
    return this.endDate <= sevenDaysFromNow && !this.isOverdue();
  }

  // 프로젝트 기간 계산 (일 단위)
  getDuration(): number | null {
    if (!this.startDate || !this.endDate) return null;
    const diffTime = Math.abs(this.endDate.getTime() - this.startDate.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  // 권한 확인 메서드들
  isOwner(userId: string): boolean {
    return this.ownerId === userId;
  }

  isMember(userId: string): boolean {
    return this.members?.some(member => member.userId === userId) || false;
  }

  canView(userId: string): boolean {
    if (this.visibility === ProjectVisibility.PUBLIC) return true;
    return this.isOwner(userId) || this.isMember(userId);
  }

  canEdit(userId: string): boolean {
    if (this.isOwner(userId)) return true;
    const member = this.members?.find(m => m.userId === userId);
    return member?.permissions?.includes(ProjectPermission.EDIT_PROJECT) || false;
  }

  canManageMembers(userId: string): boolean {
    if (this.isOwner(userId)) return true;
    const member = this.members?.find(m => m.userId === userId);
    return member?.permissions?.includes(ProjectPermission.MANAGE_MEMBERS) || false;
  }

  // JSON 직렬화시 계산된 필드 포함
  toJSON() {
    return {
      ...this,
      tasksCount: this.tasks?.length || 0,
      completedTasksCount: this.tasks?.filter(t => t.status === 'completed').length || 0,
    };
  }
}
</file>

<file path="backend/src/database/entities/task-dependency.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  Index,
  Unique,
} from 'typeorm';
import { DependencyType } from '@workly/shared';
import { Task } from './task.entity';

@Entity('task_dependencies')
@Unique(['dependentTaskId', 'dependsOnTaskId'])
@Index(['dependentTaskId'])
@Index(['dependsOnTaskId'])
@Index(['type'])
export class TaskDependency {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  dependentTaskId: string;

  @Column()
  dependsOnTaskId: string;

  @Column({
    type: 'enum',
    enum: DependencyType,
    default: DependencyType.BLOCKS,
  })
  type: DependencyType;

  @CreateDateColumn()
  createdAt: Date;

  // 관계 설정
  @ManyToOne(() => Task, task => task.dependencies, {
    onDelete: 'CASCADE'
  })
  dependentTask: Task;

  @ManyToOne(() => Task, task => task.dependents, {
    onDelete: 'CASCADE'
  })
  dependsOnTask: Task;

  // 차단 관계인지 확인
  isBlocking(): boolean {
    return this.type === DependencyType.BLOCKS;
  }

  // 차단됨 관계인지 확인
  isBlockedBy(): boolean {
    return this.type === DependencyType.BLOCKED_BY;
  }

  // 관련됨 관계인지 확인
  isRelated(): boolean {
    return this.type === DependencyType.RELATES_TO;
  }

  // 중복 관계인지 확인
  isDuplicate(): boolean {
    return this.type === DependencyType.DUPLICATES || 
           this.type === DependencyType.DUPLICATED_BY;
  }

  // 순환 의존성 체크를 위한 메서드
  static async checkCircularDependency(
    dependentTaskId: string,
    dependsOnTaskId: string
  ): Promise<boolean> {
    // 실제 구현에서는 재귀적으로 의존성 체인을 확인하여 순환 참조 검사
    // 여기서는 간단히 직접적인 순환만 체크
    return dependentTaskId === dependsOnTaskId;
  }

  // 의존성 유효성 검사
  async isValid(): Promise<boolean> {
    // 자기 자신에 대한 의존성 체크
    if (this.dependentTaskId === this.dependsOnTaskId) {
      return false;
    }

    // 순환 의존성 체크
    const hasCircularDependency = await TaskDependency.checkCircularDependency(
      this.dependentTaskId,
      this.dependsOnTaskId
    );

    return !hasCircularDependency;
  }
}
</file>

<file path="backend/src/database/entities/time-entry.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import { Task } from './task.entity';
import { User } from './user.entity';

@Entity('time_entries')
@Index(['taskId'])
@Index(['userId'])
@Index(['startTime'])
@Index(['billable'])
@Index(['approved'])
@Index(['createdAt'])
export class TimeEntry {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', { nullable: true })
  description?: string;

  @Column({ type: 'int' })
  duration: number; // 분 단위

  @Column({ type: 'timestamp' })
  startTime: Date;

  @Column({ type: 'timestamp', nullable: true })
  endTime?: Date;

  @Column()
  taskId: string;

  @Column()
  userId: string;

  @Column({ default: false })
  billable: boolean;

  @Column({ default: false })
  approved: boolean;

  @Column({ nullable: true })
  approvedBy?: string;

  @Column({ type: 'timestamp', nullable: true })
  approvedAt?: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => Task, task => task.timeEntries, {
    onDelete: 'CASCADE'
  })
  task: Task;

  @ManyToOne(() => User, { eager: true })
  user: User;

  @ManyToOne(() => User, { eager: false })
  approver?: User;

  // 시간 계산 및 검증
  @BeforeInsert()
  @BeforeUpdate()
  calculateDuration() {
    if (this.endTime && this.startTime) {
      const diffMs = this.endTime.getTime() - this.startTime.getTime();
      this.duration = Math.round(diffMs / (1000 * 60)); // 분 단위로 변환
    }
  }

  // 시간을 시간:분 형식으로 반환
  getDurationFormatted(): string {
    const hours = Math.floor(this.duration / 60);
    const minutes = this.duration % 60;
    return `${hours}:${minutes.toString().padStart(2, '0')}`;
  }

  // 시간을 소수점 형태로 반환 (예: 1.5시간)
  getDurationInHours(): number {
    return this.duration / 60;
  }

  // 진행 중인 시간 추적인지 확인
  isRunning(): boolean {
    return this.startTime !== null && this.endTime === null;
  }

  // 완료된 시간 추적인지 확인
  isCompleted(): boolean {
    return this.startTime !== null && this.endTime !== null;
  }

  // 시간 추적 시작
  start(): void {
    this.startTime = new Date();
    this.endTime = undefined;
  }

  // 시간 추적 중지
  stop(): void {
    if (this.isRunning()) {
      this.endTime = new Date();
      this.calculateDuration();
    }
  }

  // 시간 추적 재시작
  restart(): void {
    this.start();
  }

  // 수동으로 시간 설정
  setDuration(minutes: number): void {
    this.duration = Math.max(0, minutes);
    
    // endTime을 duration에 맞춰 계산
    if (this.startTime) {
      this.endTime = new Date(this.startTime.getTime() + (minutes * 60 * 1000));
    }
  }

  // 청구 가능 상태 설정
  markAsBillable(): void {
    this.billable = true;
  }

  // 청구 불가능 상태 설정
  markAsNonBillable(): void {
    this.billable = false;
  }

  // 승인 처리
  approve(approverId: string): void {
    this.approved = true;
    this.approvedBy = approverId;
    this.approvedAt = new Date();
  }

  // 승인 취소
  reject(): void {
    this.approved = false;
    this.approvedBy = undefined;
    this.approvedAt = undefined;
  }

  // 소유자 확인
  belongsTo(userId: string): boolean {
    return this.userId === userId;
  }

  // 편집 가능한지 확인
  canEdit(userId: string): boolean {
    return this.belongsTo(userId) && !this.approved;
  }

  // 삭제 가능한지 확인
  canDelete(userId: string): boolean {
    return this.belongsTo(userId) && !this.approved;
  }

  // 승인 가능한지 확인 (태스크 담당자나 프로젝트 매니저)
  canApprove(userId: string): boolean {
    // 실제 구현에서는 프로젝트 권한을 확인해야 함
    return !this.belongsTo(userId) && !this.approved;
  }

  // 유효성 검증
  validate(): string[] {
    const errors: string[] = [];

    if (this.duration <= 0) {
      errors.push('Duration must be greater than 0');
    }

    if (this.duration > 24 * 60) { // 24시간 초과
      errors.push('Duration cannot exceed 24 hours');
    }

    if (this.endTime && this.startTime && this.endTime <= this.startTime) {
      errors.push('End time must be after start time');
    }

    const now = new Date();
    if (this.startTime > now) {
      errors.push('Start time cannot be in the future');
    }

    if (this.endTime && this.endTime > now) {
      errors.push('End time cannot be in the future');
    }

    return errors;
  }

  // 중복 시간 체크 (같은 사용자의 겹치는 시간대)
  static async checkOverlap(
    userId: string,
    startTime: Date,
    endTime: Date,
    excludeId?: string
  ): Promise<boolean> {
    // 실제 구현에서는 데이터베이스 쿼리로 겹치는 시간대 확인
    // 여기서는 기본 구조만 제공
    return false;
  }
}
</file>

<file path="backend/src/modules/admin/controllers/users-admin.controller.ts">
import { 
  Controller, 
  Get, 
  Post,
  Put,
  Delete,
  Param,
  Body,
  Query,
  UseGuards, 
  UseInterceptors,
  ParseUUIDPipe,
} from '@nestjs/common';
import { AdminGuard } from '../guards/admin.guard';
import { PermissionsGuard } from '../guards/permissions.guard';
import { RequirePermissions } from '../decorators/permissions.decorator';
import { AuditLog } from '../decorators/audit-log.decorator';
import { AuditLogInterceptor } from '../interceptors/audit-log.interceptor';
import { AdminService } from '../services/admin.service';
import { AdminRole } from '../../../types/admin.types';

class UpdateUserRoleDto {
  role: AdminRole;
  permissions: string[];
}

@Controller('api/admin/users')
@UseGuards(AdminGuard, PermissionsGuard)
@UseInterceptors(AuditLogInterceptor)
export class UsersAdminController {
  constructor(private adminService: AdminService) {}

  @Get()
  @RequirePermissions('admin:users:read')
  @AuditLog('사용자 목록 조회')
  async getAllUsers(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('search') search?: string,
    @Query('role') role?: AdminRole,
  ) {
    const result = await this.adminService.getAllUsers({
      page: page ? Number(page) : 1,
      limit: limit ? Number(limit) : 20,
      search,
      role,
    });

    return {
      success: true,
      data: result.data,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        totalPages: result.totalPages,
      },
    };
  }

  @Get(':id')
  @RequirePermissions('admin:users:read')
  @AuditLog('사용자 상세 조회')
  async getUserById(@Param('id', ParseUUIDPipe) id: string) {
    const user = await this.adminService.getUserById(id);

    return {
      success: true,
      data: user,
    };
  }

  @Put(':id/role')
  @RequirePermissions('admin:users:update', 'admin:roles:manage')
  @AuditLog('사용자 권한 변경')
  async updateUserRole(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateRoleDto: UpdateUserRoleDto,
  ) {
    const user = await this.adminService.updateUserAdminRole(
      id,
      updateRoleDto.role,
      updateRoleDto.permissions,
    );

    return {
      success: true,
      data: user,
      message: '사용자 권한이 성공적으로 변경되었습니다',
    };
  }

  @Delete(':id')
  @RequirePermissions('admin:users:delete')
  @AuditLog('사용자 삭제')
  async deleteUser(@Param('id', ParseUUIDPipe) id: string) {
    await this.adminService.deleteUser(id);

    return {
      success: true,
      message: '사용자가 성공적으로 삭제되었습니다',
    };
  }
}
</file>

<file path="backend/src/modules/admin/guards/admin.guard.ts">
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';

@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const authHeader = request.headers.authorization;

    // 개발 환경에서 dev-admin-token 처리
    if (process.env.NODE_ENV === 'development' && authHeader === 'Bearer dev-admin-token') {
      // 개발용 관리자 사용자 객체 생성
      request.user = {
        id: 'dev-admin-1',
        name: '워클리 개발 관리자',
        email: 'dev-admin@workly.com',
        adminRole: 'super_admin',
        adminPermissions: ['*'],
        isAdminUser: () => true,
        updateLastAdminLogin: () => {},
        lastAdminLogin: new Date(),
        twoFactorEnabled: false,
        allowedIPs: ['*']
      };
      return true;
    }

    if (!user) {
      throw new ForbiddenException('인증이 필요합니다');
    }

    // 디버깅을 위한 로그 추가
    console.log('Admin Guard - User data:', {
      id: user.id,
      email: user.email,
      name: user.name,
      adminRole: user.adminRole,
      adminPermissions: user.adminPermissions,
      isAdminUser: typeof user.isAdminUser === 'function' ? user.isAdminUser() : 'not a function'
    });

    if (!user.isAdminUser()) {
      throw new ForbiddenException('관리자 권한이 필요합니다');
    }

    // 마지막 어드민 로그인 시간 업데이트
    user.updateLastAdminLogin();

    return true;
  }
}
</file>

<file path="backend/src/modules/admin/guards/permissions.guard.ts">
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PERMISSIONS_KEY } from '../decorators/permissions.decorator';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(
      PERMISSIONS_KEY,
      [context.getHandler(), context.getClass()]
    );

    if (!requiredPermissions) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const authHeader = request.headers.authorization;

    if (!user) {
      throw new ForbiddenException('인증이 필요합니다');
    }

    // 개발 환경에서 dev-admin-token은 모든 권한 허용
    if (process.env.NODE_ENV === 'development' && authHeader === 'Bearer dev-admin-token') {
      return true;
    }

    const hasPermission = user.hasAllAdminPermissions && user.hasAllAdminPermissions(requiredPermissions);

    if (!hasPermission) {
      throw new ForbiddenException(
        `다음 권한이 필요합니다: ${requiredPermissions.join(', ')}`
      );
    }

    return true;
  }
}
</file>

<file path="backend/src/modules/admin/services/admin.service.ts">
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../../../database/entities/user.entity';
import { Project } from '../../../database/entities/project.entity';
import { Task } from '../../../database/entities/task.entity';
import { AdminRole, TaskStatus } from '../../../types/admin.types';

@Injectable()
export class AdminService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Project)
    private projectRepository: Repository<Project>,
    @InjectRepository(Task)
    private taskRepository: Repository<Task>,
  ) {}

  // Dashboard Statistics
  async getDashboardStats() {
    const [
      totalUsers,
      totalProjects,
      totalTasks,
      activeUsersCount,
      completedTasksCount,
    ] = await Promise.all([
      this.userRepository.count(),
      this.projectRepository.count(),
      this.taskRepository.count(),
      this.userRepository.count({
        where: {
          lastLoginAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) as any, // 7일 이내
        },
      }),
      this.taskRepository.count({
        where: { status: TaskStatus.COMPLETED },
      }),
    ]);

    return {
      totalUsers,
      totalProjects,
      totalTasks,
      activeUsersCount,
      completedTasksCount,
      completionRate: totalTasks > 0 ? (completedTasksCount / totalTasks) * 100 : 0,
    };
  }

  // User Management
  async getAllUsers(options: {
    page?: number;
    limit?: number;
    search?: string;
    role?: AdminRole;
  }) {
    const { page = 1, limit = 20, search, role } = options;
    const skip = (page - 1) * limit;

    const queryBuilder = this.userRepository.createQueryBuilder('user');

    if (search) {
      queryBuilder.andWhere(
        '(user.name ILIKE :search OR user.email ILIKE :search)',
        { search: `%${search}%` }
      );
    }

    if (role) {
      queryBuilder.andWhere('user.adminRole = :role', { role });
    }

    queryBuilder
      .orderBy('user.createdAt', 'DESC')
      .skip(skip)
      .take(limit);

    const [users, total] = await queryBuilder.getManyAndCount();

    return {
      data: users,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUserById(id: string): Promise<User> {
    const user = await this.userRepository.findOne({
      where: { id },
      relations: ['projects', 'tasks'],
    });

    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다');
    }

    return user;
  }

  async updateUserAdminRole(userId: string, role: AdminRole, permissions: string[]) {
    const user = await this.getUserById(userId);

    user.adminRole = role;
    user.adminPermissions = permissions;

    return this.userRepository.save(user);
  }

  async deleteUser(id: string): Promise<void> {
    const user = await this.getUserById(id);
    
    if (user.isSuperAdmin()) {
      throw new BadRequestException('슈퍼 관리자는 삭제할 수 없습니다');
    }

    await this.userRepository.remove(user);
  }

  // Project Management
  async getAllProjects(options: {
    page?: number;
    limit?: number;
    search?: string;
    status?: string;
  }) {
    const { page = 1, limit = 20, search, status } = options;
    const skip = (page - 1) * limit;

    const queryBuilder = this.projectRepository.createQueryBuilder('project')
      .leftJoinAndSelect('project.owner', 'owner')
      .leftJoinAndSelect('project.members', 'members');

    if (search) {
      queryBuilder.andWhere(
        '(project.name ILIKE :search OR project.description ILIKE :search)',
        { search: `%${search}%` }
      );
    }

    if (status) {
      queryBuilder.andWhere('project.status = :status', { status });
    }

    queryBuilder
      .orderBy('project.createdAt', 'DESC')
      .skip(skip)
      .take(limit);

    const [projects, total] = await queryBuilder.getManyAndCount();

    return {
      data: projects,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getProjectById(id: string): Promise<Project> {
    const project = await this.projectRepository.findOne({
      where: { id },
      relations: ['owner', 'members', 'tasks'],
    });

    if (!project) {
      throw new NotFoundException('프로젝트를 찾을 수 없습니다');
    }

    return project;
  }

  async deleteProject(id: string): Promise<void> {
    const project = await this.getProjectById(id);
    await this.projectRepository.remove(project);
  }

  // System Settings
  async getSystemSettings() {
    // 시스템 설정은 추후 별도 엔티티로 관리할 예정
    return {
      maintenanceMode: false,
      registrationEnabled: true,
      maxUsersPerProject: 50,
      maxProjectsPerUser: 10,
      emailNotifications: true,
    };
  }

  async updateSystemSettings(settings: Record<string, any>) {
    // 시스템 설정 업데이트 로직
    return settings;
  }
}
</file>

<file path="backend/src/modules/auth/decorators/roles.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@workly/shared';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);
</file>

<file path="backend/src/modules/auth/guards/roles.guard.ts">
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '@workly/shared';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    
    if (!user) {
      return false;
    }

    return requiredRoles.some((role) => user.role === role);
  }
}
</file>

<file path="backend/src/modules/auth/guards/throttle.guard.ts">
import { Injectable, ExecutionContext } from '@nestjs/common';
import { ThrottlerGuard, ThrottlerException } from '@nestjs/throttler';

@Injectable()
export class CustomThrottlerGuard extends ThrottlerGuard {
  protected async throwThrottlingException(context: ExecutionContext): Promise<void> {
    throw new ThrottlerException('요청이 너무 많습니다. 잠시 후 다시 시도해주세요.');
  }

  protected async getTracker(req: Record<string, any>): Promise<string> {
    // IP 주소와 사용자 ID를 조합하여 더 정확한 추적
    const userId = req.user?.sub || 'anonymous';
    const ip = req.ip || req.connection.remoteAddress || 'unknown';
    return `${ip}-${userId}`;
  }
}
</file>

<file path="backend/src/modules/auth/middleware/audit.middleware.ts">
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class AuditMiddleware implements NestMiddleware {
  private readonly logger = new Logger(AuditMiddleware.name);

  use(req: Request, res: Response, next: NextFunction) {
    const { method, originalUrl, ip, headers } = req;
    const userAgent = headers['user-agent'] || '';
    const user = req['user'];
    
    // 로그인/로그아웃/인증 관련 엔드포인트만 감사 로그 기록
    const auditPaths = ['/auth/login', '/auth/logout', '/auth/register', '/auth/refresh'];
    const shouldAudit = auditPaths.some(path => originalUrl.includes(path));

    if (shouldAudit) {
      const startTime = Date.now();

      // 응답 완료 시 로그 기록
      res.on('finish', () => {
        const { statusCode } = res;
        const contentLength = res.get('content-length');
        const responseTime = Date.now() - startTime;

        const logData = {
          method,
          url: originalUrl,
          statusCode,
          contentLength,
          responseTime: `${responseTime}ms`,
          ip,
          userAgent,
          userId: (user as any)?.id || 'anonymous',
          timestamp: new Date().toISOString(),
        };

        if (statusCode >= 400) {
          this.logger.warn(`인증 실패: ${JSON.stringify(logData)}`);
        } else {
          this.logger.log(`인증 성공: ${JSON.stringify(logData)}`);
        }
      });
    }

    next();
  }
}
</file>

<file path="backend/src/modules/auth/auth.controller.ts">
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Req,
  Res,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { Throttle } from '@nestjs/throttler';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiBody,
} from '@nestjs/swagger';

import { AuthService } from './auth.service';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { GoogleAuthGuard } from './guards/google-auth.guard';
import { Public } from './decorators/public.decorator';
import { CurrentUser } from './decorators/current-user.decorator';
import { User } from '../../database/entities/user.entity';
import {
  LoginDto,
  RegisterDto,
  GoogleAuthDto,
  RefreshTokenDto,
  ChangePasswordDto,
  ForgotPasswordDto,
  ResetPasswordDto,
  VerifyEmailDto,
  ResendVerificationDto,
} from './dto/auth.dto';
import {
  AuthResponse,
  LoginResponse,
} from '@workly/shared';

@ApiTags('Authentication')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Public()
  @Post('login')
  @HttpCode(HttpStatus.OK)
  @Throttle({ default: { limit: 5, ttl: 60000 } }) // 1분에 5번 시도 제한
  @ApiOperation({ summary: '로그인' })
  @ApiBody({ type: LoginDto })
  @ApiResponse({
    status: 200,
    description: '로그인 성공',
  })
  @ApiResponse({
    status: 401,
    description: '인증 실패',
  })
  @ApiResponse({
    status: 429,
    description: '너무 많은 로그인 시도',
  })
  async login(@Body() loginDto: LoginDto): Promise<LoginResponse> {
    return this.authService.login(loginDto);
  }

  @Public()
  @Post('register')
  @Throttle({ default: { limit: 3, ttl: 3600000 } }) // 1시간에 3번 가입 제한
  @ApiOperation({ summary: '회원가입' })
  @ApiBody({ type: RegisterDto })
  @ApiResponse({
    status: 201,
    description: '회원가입 성공',
  })
  @ApiResponse({
    status: 409,
    description: '이미 존재하는 이메일',
  })
  @ApiResponse({
    status: 429,
    description: '너무 많은 가입 시도',
  })
  async register(@Body() registerDto: RegisterDto): Promise<AuthResponse> {
    return this.authService.register(registerDto);
  }

  @Public()
  @Get('google')
  @UseGuards(GoogleAuthGuard)
  @ApiOperation({ summary: 'Google OAuth 로그인 시작' })
  @ApiResponse({
    status: 302,
    description: 'Google OAuth 페이지로 리다이렉트',
  })
  async googleAuth(@Req() req: Request) {
    // Google OAuth 시작 - Passport가 처리
  }

  @Public()
  @Get('google/callback')
  @UseGuards(GoogleAuthGuard)
  @ApiOperation({ summary: 'Google OAuth 콜백' })
  @ApiResponse({
    status: 200,
    description: 'Google 로그인 성공',
  })
  async googleAuthRedirect(@Req() req: Request, @Res() res: Response) {
    try {
      const user = req.user as User;
      
      // JWT 토큰 생성
      const tokens = await this.authService.generateTokensForUser(user);
      
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3001';
      const redirectUrl = `${frontendUrl}/auth/callback?` +
        `status=success&` +
        `accessToken=${encodeURIComponent(tokens.accessToken)}&` +
        `refreshToken=${encodeURIComponent(tokens.refreshToken)}`;
      
      res.redirect(redirectUrl);
    } catch (error) {
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3001';
      const redirectUrl = `${frontendUrl}/auth/callback?status=error&message=${encodeURIComponent('로그인 중 오류가 발생했습니다.')}`;
      
      res.redirect(redirectUrl);
    }
  }

  @Public()
  @Post('google/login')
  @ApiOperation({ summary: 'Google OAuth 토큰으로 로그인' })
  @ApiBody({ type: GoogleAuthDto })
  @ApiResponse({
    status: 200,
    description: 'Google 로그인 성공',
  })
  async googleLogin(@Body() googleAuthDto: GoogleAuthDto): Promise<LoginResponse> {
    return this.authService.googleLogin(googleAuthDto);
  }

  @Public()
  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '토큰 새로고침' })
  @ApiBody({ type: RefreshTokenDto })
  @ApiResponse({
    status: 200,
    description: '토큰 새로고침 성공',
  })
  async refreshToken(@Body() refreshTokenDto: RefreshTokenDto): Promise<{ accessToken: string }> {
    return this.authService.refreshToken(refreshTokenDto);
  }

  @UseGuards(JwtAuthGuard)
  @Post('change-password')
  @ApiBearerAuth()
  @ApiOperation({ summary: '비밀번호 변경' })
  @ApiBody({ type: ChangePasswordDto })
  @ApiResponse({
    status: 200,
    description: '비밀번호 변경 성공',
  })
  async changePassword(
    @CurrentUser('id') userId: string,
    @Body() changePasswordDto: ChangePasswordDto,
  ): Promise<AuthResponse> {
    return this.authService.changePassword(userId, changePasswordDto);
  }

  @Public()
  @Post('forgot-password')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '비밀번호 재설정 요청' })
  @ApiBody({ type: ForgotPasswordDto })
  @ApiResponse({
    status: 200,
    description: '비밀번호 재설정 이메일 발송',
  })
  async forgotPassword(@Body() forgotPasswordDto: ForgotPasswordDto): Promise<AuthResponse> {
    return this.authService.forgotPassword(forgotPasswordDto);
  }

  @Public()
  @Post('reset-password')
  @ApiOperation({ summary: '비밀번호 재설정' })
  @ApiBody({ type: ResetPasswordDto })
  @ApiResponse({
    status: 200,
    description: '비밀번호 재설정 성공',
  })
  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto): Promise<AuthResponse> {
    return this.authService.resetPassword(resetPasswordDto);
  }

  @Public()
  @Post('verify-email')
  @ApiOperation({ summary: '이메일 인증' })
  @ApiBody({ type: VerifyEmailDto })
  @ApiResponse({
    status: 200,
    description: '이메일 인증 성공',
  })
  async verifyEmail(@Body() verifyEmailDto: VerifyEmailDto): Promise<AuthResponse> {
    return this.authService.verifyEmail(verifyEmailDto);
  }

  @Public()
  @Post('resend-verification')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '인증 이메일 재발송' })
  @ApiBody({ type: ResendVerificationDto })
  @ApiResponse({
    status: 200,
    description: '인증 이메일 재발송 완료',
  })
  async resendVerification(@Body() resendVerificationDto: ResendVerificationDto): Promise<AuthResponse> {
    return this.authService.resendVerification(resendVerificationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  @ApiBearerAuth()
  @ApiOperation({ summary: '현재 사용자 프로필 조회' })
  @ApiResponse({
    status: 200,
    description: '사용자 프로필 조회 성공',
  })
  async getProfile(@CurrentUser() user: User) {
    return {
      user,
    };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  @HttpCode(HttpStatus.OK)
  @ApiBearerAuth()
  @ApiOperation({ summary: '로그아웃' })
  @ApiResponse({
    status: 200,
    description: '로그아웃 성공',
  })
  async logout(@CurrentUser() user: User): Promise<AuthResponse> {
    // TODO: 리프레시 토큰 무효화 로직 구현
    return {
      message: '로그아웃되었습니다.',
    };
  }
}
</file>

<file path="backend/src/modules/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';

import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from '../../database/entities/user.entity';
import { JwtStrategy } from './strategies/jwt.strategy';
import { GoogleStrategy } from './strategies/google.strategy';
import { getAuthConfig } from '../../config/auth.config';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const authConfig = getAuthConfig(configService);
        return {
          secret: authConfig.jwt.secret,
          signOptions: {
            expiresIn: authConfig.jwt.expiresIn,
          },
        };
      },
      inject: [ConfigService],
    }),
    ConfigModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, GoogleStrategy],
  exports: [AuthService, PassportModule, JwtModule],
})
export class AuthModule {}
</file>

<file path="backend/src/modules/projects/dto/project.dto.ts">
import {
  IsString,
  IsOptional,
  IsEnum,
  IsUUID,
  IsArray,
  IsNumber,
  IsObject,
  IsDateString,
  IsBoolean,
  Min,
  MaxLength,
  MinLength,
  IsInt,
  IsDecimal,
} from 'class-validator';
import { Type, Transform } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { 
  ProjectStatus, 
  ProjectPriority, 
  ProjectVisibility,
  ProjectMemberRole 
} from '@workly/shared';

export class CreateProjectDto {
  @ApiProperty({
    description: '프로젝트 제목',
    example: '워클리 웹 애플리케이션 개발',
    minLength: 1,
    maxLength: 100,
  })
  @IsString()
  @MinLength(1, { message: '프로젝트 제목은 필수입니다.' })
  @MaxLength(100, { message: '프로젝트 제목은 100자를 초과할 수 없습니다.' })
  title: string;

  @ApiPropertyOptional({
    description: '프로젝트 설명',
    example: '사용자 친화적인 업무 관리 웹 애플리케이션을 개발합니다.',
  })
  @IsOptional()
  @IsString()
  @MaxLength(1000, { message: '프로젝트 설명은 1000자를 초과할 수 없습니다.' })
  description?: string;

  @ApiPropertyOptional({
    description: '프로젝트 우선순위',
    enum: ProjectPriority,
    example: 'high',
  })
  @IsOptional()
  @IsEnum(ProjectPriority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: ProjectPriority;

  @ApiPropertyOptional({
    description: '프로젝트 시작일',
    example: '2024-01-15T00:00:00.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  startDate?: string;

  @ApiPropertyOptional({
    description: '프로젝트 종료일',
    example: '2024-06-30T23:59:59.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  endDate?: string;

  @ApiPropertyOptional({
    description: '프로젝트 예산',
    example: 50000.00,
    minimum: 0,
  })
  @IsOptional()
  @IsNumber({ maxDecimalPlaces: 2 }, { message: '유효한 금액을 입력해주세요.' })
  @Min(0, { message: '예산은 0 이상이어야 합니다.' })
  budget?: number;

  @ApiPropertyOptional({
    description: '통화 단위',
    example: 'KRW',
    maxLength: 3,
  })
  @IsOptional()
  @IsString()
  @MaxLength(3, { message: '통화 코드는 3자여야 합니다.' })
  currency?: string;

  @ApiPropertyOptional({
    description: '프로젝트 태그',
    example: ['web', 'react', 'nestjs'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: '프로젝트 색상 (HEX)',
    example: '#3B82F6',
    maxLength: 7,
  })
  @IsOptional()
  @IsString()
  @MaxLength(7, { message: '색상은 7자를 초과할 수 없습니다.' })
  color?: string;

  @ApiPropertyOptional({
    description: '프로젝트 아이콘',
    example: 'folder',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50, { message: '아이콘 이름은 50자를 초과할 수 없습니다.' })
  icon?: string;

  @ApiPropertyOptional({
    description: '프로젝트 가시성',
    enum: ProjectVisibility,
    example: 'team',
  })
  @IsOptional()
  @IsEnum(ProjectVisibility, { message: '유효한 가시성을 선택해주세요.' })
  visibility?: ProjectVisibility;

  @ApiPropertyOptional({
    description: '프로젝트 설정',
    example: { enableTimeTracking: true, enableComments: true },
  })
  @IsOptional()
  @IsObject()
  settings?: Record<string, any>;
}

export class UpdateProjectDto {
  @ApiPropertyOptional({
    description: '프로젝트 제목',
    example: '워클리 웹 애플리케이션 개발 v2',
    maxLength: 100,
  })
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: '프로젝트 제목은 100자를 초과할 수 없습니다.' })
  title?: string;

  @ApiPropertyOptional({
    description: '프로젝트 설명',
    example: '향상된 기능을 포함한 업무 관리 웹 애플리케이션입니다.',
  })
  @IsOptional()
  @IsString()
  @MaxLength(1000, { message: '프로젝트 설명은 1000자를 초과할 수 없습니다.' })
  description?: string;

  @ApiPropertyOptional({
    description: '프로젝트 상태',
    enum: ProjectStatus,
    example: 'in_progress',
  })
  @IsOptional()
  @IsEnum(ProjectStatus, { message: '유효한 프로젝트 상태를 선택해주세요.' })
  status?: ProjectStatus;

  @ApiPropertyOptional({
    description: '프로젝트 우선순위',
    enum: ProjectPriority,
    example: 'medium',
  })
  @IsOptional()
  @IsEnum(ProjectPriority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: ProjectPriority;

  @ApiPropertyOptional({
    description: '프로젝트 시작일',
    example: '2024-01-20T00:00:00.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  startDate?: string;

  @ApiPropertyOptional({
    description: '프로젝트 종료일',
    example: '2024-07-31T23:59:59.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  endDate?: string;

  @ApiPropertyOptional({
    description: '프로젝트 예산',
    example: 75000.00,
    minimum: 0,
  })
  @IsOptional()
  @IsNumber({ maxDecimalPlaces: 2 }, { message: '유효한 금액을 입력해주세요.' })
  @Min(0, { message: '예산은 0 이상이어야 합니다.' })
  budget?: number;

  @ApiPropertyOptional({
    description: '통화 단위',
    example: 'USD',
  })
  @IsOptional()
  @IsString()
  @MaxLength(3, { message: '통화 코드는 3자여야 합니다.' })
  currency?: string;

  @ApiPropertyOptional({
    description: '프로젝트 태그',
    example: ['web', 'react', 'nestjs', 'typescript'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: '프로젝트 색상 (HEX)',
    example: '#10B981',
  })
  @IsOptional()
  @IsString()
  @MaxLength(7, { message: '색상은 7자를 초과할 수 없습니다.' })
  color?: string;

  @ApiPropertyOptional({
    description: '프로젝트 아이콘',
    example: 'rocket',
  })
  @IsOptional()
  @IsString()
  @MaxLength(50, { message: '아이콘 이름은 50자를 초과할 수 없습니다.' })
  icon?: string;

  @ApiPropertyOptional({
    description: '프로젝트 가시성',
    enum: ProjectVisibility,
    example: 'public',
  })
  @IsOptional()
  @IsEnum(ProjectVisibility, { message: '유효한 가시성을 선택해주세요.' })
  visibility?: ProjectVisibility;

  @ApiPropertyOptional({
    description: '프로젝트 설정',
    example: { enableTimeTracking: false, enableFileAttachments: true },
  })
  @IsOptional()
  @IsObject()
  settings?: Record<string, any>;
}

export class ProjectQueryDto {
  @ApiPropertyOptional({
    description: '페이지 번호',
    example: 1,
    minimum: 1,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '페이지 번호는 정수여야 합니다.' })
  @Min(1, { message: '페이지 번호는 1 이상이어야 합니다.' })
  page?: number;

  @ApiPropertyOptional({
    description: '페이지 크기',
    example: 20,
    minimum: 1,
    maximum: 100,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '페이지 크기는 정수여야 합니다.' })
  @Min(1, { message: '페이지 크기는 1 이상이어야 합니다.' })
  limit?: number;

  @ApiPropertyOptional({
    description: '프로젝트 상태 필터',
    enum: ProjectStatus,
    example: 'in_progress',
  })
  @IsOptional()
  @IsEnum(ProjectStatus, { message: '유효한 프로젝트 상태를 선택해주세요.' })
  status?: ProjectStatus;

  @ApiPropertyOptional({
    description: '우선순위 필터',
    enum: ProjectPriority,
    example: 'high',
  })
  @IsOptional()
  @IsEnum(ProjectPriority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: ProjectPriority;

  @ApiPropertyOptional({
    description: '가시성 필터',
    enum: ProjectVisibility,
    example: 'team',
  })
  @IsOptional()
  @IsEnum(ProjectVisibility, { message: '유효한 가시성을 선택해주세요.' })
  visibility?: ProjectVisibility;

  @ApiPropertyOptional({
    description: '검색어 (제목, 설명, 태그)',
    example: '워클리',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: '검색어는 100자를 초과할 수 없습니다.' })
  search?: string;

  @ApiPropertyOptional({
    description: '정렬 기준',
    example: 'updatedAt',
    enum: ['createdAt', 'updatedAt', 'title', 'priority', 'startDate', 'endDate'],
  })
  @IsOptional()
  @IsString()
  sortBy?: string;

  @ApiPropertyOptional({
    description: '정렬 순서',
    example: 'DESC',
    enum: ['ASC', 'DESC'],
  })
  @IsOptional()
  @IsEnum(['ASC', 'DESC'], { message: '정렬 순서는 ASC 또는 DESC여야 합니다.' })
  sortOrder?: 'ASC' | 'DESC';

  @ApiPropertyOptional({
    description: '아카이브된 프로젝트 포함 여부',
    example: false,
  })
  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  includeArchived?: boolean;

  @ApiPropertyOptional({
    description: '태그 필터 목록',
    example: ['web', 'react'],
    type: [String],
  })
  @IsOptional()
  @Transform(({ value }) => Array.isArray(value) ? value : [value])
  @IsArray()
  @IsString({ each: true })
  tags?: string[];
}

export class AddProjectMemberDto {
  @ApiProperty({
    description: '추가할 사용자 ID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsUUID(4, { message: '유효한 사용자 ID를 입력해주세요.' })
  userId: string;

  @ApiPropertyOptional({
    description: '멤버 역할',
    enum: ProjectMemberRole,
    example: 'member',
  })
  @IsOptional()
  @IsEnum(ProjectMemberRole, { message: '유효한 멤버 역할을 선택해주세요.' })
  role?: ProjectMemberRole;

  @ApiPropertyOptional({
    description: '멤버 권한 목록',
    example: ['read', 'write', 'manage_tasks'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  permissions?: string[];
}
</file>

<file path="backend/src/modules/projects/projects.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { Throttle } from '@nestjs/throttler';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';

import { ProjectsService } from './projects.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { 
  CreateProjectDto, 
  UpdateProjectDto, 
  ProjectQueryDto,
  AddProjectMemberDto 
} from './dto/project.dto';
import { ProjectStatus } from '@workly/shared';

@ApiTags('Projects')
@Controller('projects')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class ProjectsController {
  constructor(private readonly projectsService: ProjectsService) {}

  // 프로젝트 생성
  @Post()
  @Throttle({ default: { limit: 10, ttl: 60000 } }) // 1분에 10개 생성 제한
  @ApiOperation({ summary: '새 프로젝트 생성' })
  @ApiResponse({
    status: 201,
    description: '프로젝트가 성공적으로 생성되었습니다.',
  })
  @ApiResponse({
    status: 400,
    description: '잘못된 요청 데이터',
  })
  async create(
    @Body() createProjectDto: CreateProjectDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.create(createProjectDto, userId);
  }

  // 프로젝트 목록 조회
  @Get()
  @ApiOperation({ summary: '프로젝트 목록 조회 (필터링, 정렬, 페이징 지원)' })
  @ApiResponse({
    status: 200,
    description: '프로젝트 목록이 성공적으로 조회되었습니다.',
  })
  async findAll(
    @Query() query: ProjectQueryDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.findAll(query, userId);
  }

  // 내 프로젝트 조회
  @Get('my')
  @ApiOperation({ summary: '내 프로젝트 목록 조회' })
  @ApiResponse({
    status: 200,
    description: '내 프로젝트 목록이 성공적으로 조회되었습니다.',
  })
  async getMyProjects(@CurrentUser('id') userId: string) {
    return this.projectsService.getMyProjects(userId);
  }

  // 특정 프로젝트 조회
  @Get(':id')
  @ApiOperation({ summary: '특정 프로젝트 상세 조회' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '프로젝트 정보가 성공적으로 조회되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '프로젝트를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '프로젝트에 접근할 권한이 없습니다.',
  })
  async findOne(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.findOne(id, userId);
  }

  // 프로젝트 정보 수정
  @Patch(':id')
  @ApiOperation({ summary: '프로젝트 정보 수정' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '프로젝트가 성공적으로 수정되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '프로젝트를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '프로젝트를 수정할 권한이 없습니다.',
  })
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateProjectDto: UpdateProjectDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.update(id, updateProjectDto, userId);
  }

  // 프로젝트 상태 변경
  @Patch(':id/status')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '프로젝트 상태 변경' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiQuery({
    name: 'status',
    description: '새로운 상태',
    enum: ProjectStatus,
  })
  @ApiResponse({
    status: 200,
    description: '프로젝트 상태가 성공적으로 변경되었습니다.',
  })
  async updateStatus(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('status') status: ProjectStatus,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.updateStatus(id, status, userId);
  }

  // 프로젝트 멤버 추가
  @Post(':id/members')
  @ApiOperation({ summary: '프로젝트 멤버 추가' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 201,
    description: '멤버가 성공적으로 추가되었습니다.',
  })
  @ApiResponse({
    status: 400,
    description: '이미 프로젝트 멤버입니다.',
  })
  @ApiResponse({
    status: 403,
    description: '멤버를 추가할 권한이 없습니다.',
  })
  async addMember(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() addMemberDto: AddProjectMemberDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.addMember(id, addMemberDto, userId);
  }

  // 프로젝트 멤버 목록 조회
  @Get(':id/members')
  @ApiOperation({ summary: '프로젝트 멤버 목록 조회' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '프로젝트 멤버 목록이 성공적으로 조회되었습니다.',
  })
  async getMembers(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.getMembers(id, userId);
  }

  // 프로젝트 멤버 제거
  @Delete(':id/members/:memberId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: '프로젝트 멤버 제거' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiParam({
    name: 'memberId',
    description: '제거할 멤버 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 204,
    description: '멤버가 성공적으로 제거되었습니다.',
  })
  @ApiResponse({
    status: 400,
    description: '프로젝트 소유자는 제거할 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '멤버를 제거할 권한이 없습니다.',
  })
  async removeMember(
    @Param('id', ParseUUIDPipe) id: string,
    @Param('memberId', ParseUUIDPipe) memberId: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.removeMember(id, memberId, userId);
  }

  // 프로젝트 삭제 (아카이브)
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: '프로젝트 삭제 (아카이브)' })
  @ApiParam({
    name: 'id',
    description: '프로젝트 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 204,
    description: '프로젝트가 성공적으로 삭제되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '프로젝트를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '프로젝트를 삭제할 권한이 없습니다.',
  })
  async remove(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.projectsService.remove(id, userId);
  }
}
</file>

<file path="backend/src/modules/projects/projects.service.ts">
import { 
  Injectable, 
  NotFoundException, 
  ForbiddenException,
  BadRequestException 
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindOptionsWhere } from 'typeorm';
import { Project } from '../../database/entities/project.entity';
import { ProjectMember } from '../../database/entities/project-member.entity';
import { User } from '../../database/entities/user.entity';
import { 
  CreateProjectDto, 
  UpdateProjectDto, 
  ProjectQueryDto,
  AddProjectMemberDto 
} from './dto/project.dto';
import { 
  ProjectStatus, 
  ProjectPriority, 
  ProjectVisibility,
  ProjectMemberRole,
  PaginatedResponse,
  TaskStatus,
  ProjectPermission
} from '@workly/shared';

@Injectable()
export class ProjectsService {
  constructor(
    @InjectRepository(Project)
    private projectRepository: Repository<Project>,
    @InjectRepository(ProjectMember)
    private projectMemberRepository: Repository<ProjectMember>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {}

  // 프로젝트 생성
  async create(createProjectDto: CreateProjectDto, ownerId: string): Promise<Project> {
    const {
      title,
      description,
      priority = 'medium',
      startDate,
      endDate,
      budget,
      currency,
      tags = [],
      color,
      icon,
      visibility = 'private',
      settings = {},
    } = createProjectDto;

    // 시작일과 종료일 유효성 검사
    if (startDate && endDate) {
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (start >= end) {
        throw new BadRequestException('종료일은 시작일보다 늦어야 합니다.');
      }
    }

    // 프로젝트 생성
    const project = this.projectRepository.create({
      title,
      description,
      ownerId,
      status: ProjectStatus.ACTIVE,
      priority: priority as ProjectPriority,
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
      budget,
      currency,
      tags,
      color,
      icon,
      visibility: visibility as ProjectVisibility,
      settings: {
        enableTimeTracking: true,
        enableComments: true,
        enableFileAttachments: true,
        workflowStages: ['planning', 'in_progress', 'review', 'done'],
        ...settings,
      },
    } as any);

    const savedProject = await this.projectRepository.save(project) as unknown as Project;

    // 프로젝트 소유자를 관리자 멤버로 추가
    const ownerMember = this.projectMemberRepository.create({
      projectId: savedProject.id,
      userId: ownerId,
      role: ProjectMemberRole.OWNER,
      permissions: [
        'read', 'write', 'delete', 
        'manage_members', 'manage_settings', 
        'manage_tasks', 'manage_files'
      ],
    } as any);

    await this.projectMemberRepository.save(ownerMember);

    // 관계 포함하여 반환
    return this.projectRepository.findOne({
      where: { id: savedProject.id },
      relations: ['members', 'members.user', 'tasks'],
    }) as Promise<Project>;
  }

  // 프로젝트 목록 조회
  async findAll(queryDto: ProjectQueryDto, userId: string): Promise<PaginatedResponse<Project>> {
    const {
      page = 1,
      limit = 20,
      status,
      priority,
      visibility,
      search,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
      includeArchived = false,
      tags,
    } = queryDto;

    const queryBuilder = this.projectRepository.createQueryBuilder('project')
      .leftJoinAndSelect('project.members', 'members')
      .leftJoinAndSelect('members.user', 'user')
      .leftJoinAndSelect('project.tasks', 'tasks');

    // 권한 필터링: 소유자이거나 멤버인 프로젝트만
    queryBuilder.where(`(
      project.ownerId = :userId OR 
      EXISTS (
        SELECT 1 FROM project_members pm 
        WHERE pm.projectId = project.id AND pm.userId = :userId
      )
    )`, { userId });

    // 상태 필터
    if (status) {
      queryBuilder.andWhere('project.status = :status', { status });
    }

    // 우선순위 필터
    if (priority) {
      queryBuilder.andWhere('project.priority = :priority', { priority });
    }

    // 가시성 필터
    if (visibility) {
      queryBuilder.andWhere('project.visibility = :visibility', { visibility });
    }

    // 아카이브 필터
    if (!includeArchived) {
      queryBuilder.andWhere('project.isArchived = false');
    }

    // 검색 필터
    if (search) {
      queryBuilder.andWhere(`(
        project.title ILIKE :search OR 
        project.description ILIKE :search OR
        array_to_string(project.tags, ' ') ILIKE :search
      )`, { search: `%${search}%` });
    }

    // 태그 필터
    if (tags && tags.length > 0) {
      queryBuilder.andWhere('project.tags && :tags', { tags });
    }

    // 정렬
    const allowedSortFields = ['createdAt', 'updatedAt', 'title', 'priority', 'startDate', 'endDate'];
    const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'createdAt';
    queryBuilder.orderBy(`project.${sortField}`, sortOrder as 'ASC' | 'DESC');

    // 페이징
    const offset = (page - 1) * limit;
    queryBuilder.skip(offset).take(limit);

    // 실행
    const [items, total] = await queryBuilder.getManyAndCount();

    // 각 프로젝트의 진행률 계산
    const itemsWithProgress = items.map(project => {
      const progress = this.calculateProjectProgress(project);
      return { ...project, progress };
    });

    return {
      success: true,
      data: itemsWithProgress as any,
      items: itemsWithProgress as any,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // 특정 프로젝트 조회
  async findOne(id: string, userId: string): Promise<Project> {
    const project = await this.projectRepository.findOne({
      where: { id },
      relations: [
        'members', 
        'members.user', 
        'tasks', 
        'tasks.assignee',
        'tasks.labels'
      ],
    });

    if (!project) {
      throw new NotFoundException('프로젝트를 찾을 수 없습니다.');
    }

    // 권한 확인
    await this.checkProjectAccess(project, userId);

    // 진행률 계산
    const progress = this.calculateProjectProgress(project);
    
    return { ...project, progress } as any;
  }

  // 프로젝트 수정
  async update(id: string, updateProjectDto: UpdateProjectDto, userId: string): Promise<Project> {
    const project = await this.findOne(id, userId);

    // 수정 권한 확인 (소유자 또는 관리자만)
    await this.checkProjectManagePermission(project, userId);

    const {
      title,
      description,
      status,
      priority,
      startDate,
      endDate,
      budget,
      currency,
      tags,
      color,
      icon,
      visibility,
      settings,
    } = updateProjectDto;

    // 시작일과 종료일 유효성 검사
    const newStartDate = startDate ? new Date(startDate) : project.startDate;
    const newEndDate = endDate ? new Date(endDate) : project.endDate;

    if (newStartDate && newEndDate && newStartDate >= newEndDate) {
      throw new BadRequestException('종료일은 시작일보다 늦어야 합니다.');
    }

    // 업데이트할 필드들
    if (title !== undefined) project.title = title;
    if (description !== undefined) project.description = description;
    if (status !== undefined) project.status = status;
    if (priority !== undefined) project.priority = priority;
    if (startDate !== undefined) project.startDate = newStartDate;
    if (endDate !== undefined) project.endDate = newEndDate;
    if (budget !== undefined) project.budget = budget;
    if (currency !== undefined) project.currency = currency;
    if (tags !== undefined) project.tags = tags;
    if (color !== undefined) project.color = color;
    if (icon !== undefined) project.icon = icon;
    if (visibility !== undefined) project.visibility = visibility;
    if (settings !== undefined) {
      project.settings = { ...project.settings, ...settings };
    }

    const updatedProject = await this.projectRepository.save(project);
    return this.findOne(updatedProject.id, userId);
  }

  // 프로젝트 삭제 (아카이브)
  async remove(id: string, userId: string): Promise<void> {
    const project = await this.findOne(id, userId);

    // 삭제 권한 확인 (소유자만)
    if (project.ownerId !== userId) {
      throw new ForbiddenException('프로젝트를 삭제할 권한이 없습니다.');
    }

    // 소프트 삭제 (아카이브)
    project.isArchived = true;
    await this.projectRepository.save(project);
  }

  // 프로젝트 멤버 추가
  async addMember(projectId: string, addMemberDto: AddProjectMemberDto, userId: string): Promise<ProjectMember> {
    const { userId: newMemberId, role = 'member', permissions = [] } = addMemberDto;

    const project = await this.findOne(projectId, userId);

    // 멤버 관리 권한 확인
    await this.checkProjectManagePermission(project, userId);

    // 새 멤버 사용자 확인
    const newMember = await this.userRepository.findOne({
      where: { id: newMemberId },
    });

    if (!newMember) {
      throw new NotFoundException('추가할 사용자를 찾을 수 없습니다.');
    }

    // 이미 멤버인지 확인
    const existingMember = await this.projectMemberRepository.findOne({
      where: { projectId, userId: newMemberId },
    });

    if (existingMember) {
      throw new BadRequestException('이미 프로젝트 멤버입니다.');
    }

    // 기본 권한 설정
    const defaultPermissions = this.getDefaultPermissions(role as ProjectMemberRole);
    const finalPermissions = permissions.length > 0 ? permissions : defaultPermissions;

    // 멤버 추가
    const projectMember = this.projectMemberRepository.create({
      projectId,
      userId: newMemberId,
      role,
      permissions: finalPermissions,
    } as any);

    return this.projectMemberRepository.save(projectMember) as unknown as Promise<ProjectMember>;
  }

  // 프로젝트 멤버 목록 조회
  async getMembers(projectId: string, userId: string): Promise<ProjectMember[]> {
    const project = await this.findOne(projectId, userId);

    // 프로젝트 접근 권한 확인
    await this.checkProjectAccess(project, userId);

    const members = await this.projectMemberRepository.find({
      where: { projectId },
      relations: ['user'],
      order: { joinedAt: 'ASC' },
    });

    return members;
  }

  // 프로젝트 멤버 제거
  async removeMember(projectId: string, memberId: string, userId: string): Promise<void> {
    const project = await this.findOne(projectId, userId);

    // 멤버 관리 권한 확인
    await this.checkProjectManagePermission(project, userId);

    // 프로젝트 소유자는 제거할 수 없음
    if (project.ownerId === memberId) {
      throw new BadRequestException('프로젝트 소유자는 제거할 수 없습니다.');
    }

    const member = await this.projectMemberRepository.findOne({
      where: { projectId, userId: memberId },
    });

    if (!member) {
      throw new NotFoundException('프로젝트 멤버를 찾을 수 없습니다.');
    }

    await this.projectMemberRepository.remove(member);
  }

  // 프로젝트 상태 변경
  async updateStatus(id: string, status: ProjectStatus, userId: string): Promise<Project> {
    return this.update(id, { status }, userId);
  }

  // 내 프로젝트 조회
  async getMyProjects(userId: string): Promise<Project[]> {
    const projects = await this.projectRepository.find({
      where: [
        { ownerId: userId },
        { members: { userId } }
      ],
      relations: ['members', 'members.user', 'tasks'],
      order: { updatedAt: 'DESC' },
    });

    return projects.map(project => ({
      ...project,
      progress: this.calculateProjectProgress(project),
    })) as any;
  }

  // 프로젝트 진행률 계산
  private calculateProjectProgress(project: Project): number {
    if (!project.tasks || project.tasks.length === 0) {
      return 0;
    }

    const completedTasks = project.tasks.filter(task => task.status === TaskStatus.COMPLETED).length;
    return Math.round((completedTasks / project.tasks.length) * 100);
  }

  // 프로젝트 접근 권한 확인
  private async checkProjectAccess(project: Project, userId: string): Promise<void> {
    const hasAccess = (
      project.ownerId === userId ||
      project.members?.some(member => member.userId === userId) ||
      project.visibility === 'public'
    );

    if (!hasAccess) {
      throw new ForbiddenException('프로젝트에 접근할 권한이 없습니다.');
    }
  }

  // 프로젝트 관리 권한 확인
  private async checkProjectManagePermission(project: Project, userId: string): Promise<void> {
    if (project.ownerId === userId) {
      return; // 소유자는 모든 권한
    }

    const member = project.members?.find(m => m.userId === userId);
    if (!member || (member.role !== 'admin' && !member.permissions.includes(ProjectPermission.MANAGE_MEMBERS))) {
      throw new ForbiddenException('프로젝트 관리 권한이 없습니다.');
    }
  }

  // 역할별 기본 권한 반환
  private getDefaultPermissions(role: ProjectMemberRole): string[] {
    switch (role) {
      case 'admin':
        return [
          'read', 'write', 'delete', 
          'manage_members', 'manage_settings', 
          'manage_tasks', 'manage_files'
        ];
      case 'member':
        return ['read', 'write', 'manage_tasks'];
      case 'viewer':
        return ['read'];
      default:
        return ['read'];
    }
  }
}
</file>

<file path="backend/src/modules/users/dto/update-user.dto.ts">
import {
  IsString,
  IsOptional,
  IsEmail,
  MaxLength,
  IsUrl,
  IsObject,
  ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';
import { UserProfile, UserPreferences } from '@workly/shared';

export class UpdateUserDto {
  @ApiProperty({
    description: '사용자 이름 (성)',
    example: '홍',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(50, { message: '성은 50자를 초과할 수 없습니다.' })
  firstName?: string;

  @ApiProperty({
    description: '사용자 이름 (이름)',
    example: '길동',
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(50, { message: '이름은 50자를 초과할 수 없습니다.' })
  lastName?: string;

  @ApiProperty({
    description: '이메일 주소',
    example: 'user@example.com',
    required: false,
  })
  @IsOptional()
  @IsEmail({}, { message: '올바른 이메일 형식이 아닙니다.' })
  email?: string;

  @ApiProperty({
    description: '프로필 이미지 URL',
    example: 'https://example.com/avatar.jpg',
    required: false,
  })
  @IsOptional()
  @IsUrl({}, { message: '올바른 URL 형식이 아닙니다.' })
  avatar?: string;

  @ApiProperty({
    description: '사용자 프로필 정보',
    required: false,
  })
  @IsOptional()
  @IsObject()
  @ValidateNested()
  @Type(() => Object)
  profile?: Partial<UserProfile>;

  @ApiProperty({
    description: '사용자 환경설정',
    required: false,
  })
  @IsOptional()
  @IsObject()
  @ValidateNested()
  @Type(() => Object)
  preferences?: Partial<UserPreferences>;
}
</file>

<file path="backend/src/modules/users/users.controller.ts">
import {
  Controller,
  Get,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  ParseUUIDPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
} from '@nestjs/swagger';

import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { User } from '../../database/entities/user.entity';
import { UserRole } from '@workly/shared';

@ApiTags('Users')
@Controller('users')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  @ApiOperation({ summary: '모든 사용자 조회 (관리자 전용)' })
  @ApiResponse({
    status: 200,
    description: '사용자 목록 조회 성공',
  })
  findAll() {
    return this.usersService.findAll();
  }

  @Get('me')
  @ApiOperation({ summary: '현재 사용자 정보 조회' })
  @ApiResponse({
    status: 200,
    description: '사용자 정보 조회 성공',
  })
  getProfile(@CurrentUser() user: User) {
    return user;
  }

  @Get(':id')
  @ApiOperation({ summary: '특정 사용자 정보 조회' })
  @ApiParam({
    name: 'id',
    description: '사용자 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '사용자 정보 조회 성공',
  })
  @ApiResponse({
    status: 404,
    description: '사용자를 찾을 수 없음',
  })
  findOne(@Param('id', ParseUUIDPipe) id: string) {
    return this.usersService.findOne(id);
  }

  @Patch('me')
  @ApiOperation({ summary: '현재 사용자 정보 수정' })
  @ApiResponse({
    status: 200,
    description: '사용자 정보 수정 성공',
  })
  updateProfile(@CurrentUser('id') userId: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(userId, updateUserDto);
  }

  @Patch(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  @ApiOperation({ summary: '특정 사용자 정보 수정 (관리자 전용)' })
  @ApiParam({
    name: 'id',
    description: '사용자 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '사용자 정보 수정 성공',
  })
  update(@Param('id', ParseUUIDPipe) id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(id, updateUserDto);
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles(UserRole.ADMIN)
  @ApiOperation({ summary: '사용자 삭제 (관리자 전용)' })
  @ApiParam({
    name: 'id',
    description: '사용자 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '사용자 삭제 성공',
  })
  remove(@Param('id', ParseUUIDPipe) id: string) {
    return this.usersService.remove(id);
  }
}
</file>

<file path="backend/src/modules/websocket/websocket.gateway.ts">
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
} from '@nestjs/websockets';
import { 
  Injectable, 
  Logger,
  UseGuards 
} from '@nestjs/common';
import { Server, Socket } from 'socket.io';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { getAuthConfig } from '../../config/auth.config';

interface AuthenticatedSocket extends Socket {
  userId?: string;
  user?: any;
}

interface RoomData {
  projectId?: string;
  taskId?: string;
  type: 'project' | 'task' | 'user';
}

@Injectable()
@WebSocketGateway({
  cors: {
    origin: ['http://localhost:3000'],
    credentials: true,
  },
  namespace: '/',
})
export class WorklyWebSocketGateway 
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect 
{
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(WorklyWebSocketGateway.name);
  private connectedUsers = new Map<string, Set<string>>(); // userId -> socketIds
  private socketRooms = new Map<string, Set<string>>(); // socketId -> rooms

  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  afterInit(server: Server) {
    this.logger.log('WebSocket Gateway initialized');
  }

  async handleConnection(client: AuthenticatedSocket) {
    try {
      // JWT 토큰으로 사용자 인증
      const token = this.extractTokenFromSocket(client);
      if (!token) {
        this.logger.warn(`Connection rejected - No token provided: ${client.id}`);
        client.disconnect();
        return;
      }

      const authConfig = getAuthConfig(this.configService);
      const payload = this.jwtService.verify(token, {
        secret: authConfig.jwt.secret,
      });

      client.userId = payload.sub;
      client.user = payload;

      // 사용자별 연결 추적
      if (client.userId && !this.connectedUsers.has(client.userId)) {
        this.connectedUsers.set(client.userId, new Set());
      }
      if (client.userId) {
        this.connectedUsers.get(client.userId)?.add(client.id);
      }

      // 사용자 개인 룸에 자동 조인
      const userRoom = `user:${client.userId}`;
      client.join(userRoom);

      this.logger.log(`User ${client.userId} connected: ${client.id}`);

      // 연결된 다른 클라이언트들에게 사용자 온라인 상태 알림
      client.broadcast.emit('user:online', {
        userId: client.userId,
        timestamp: new Date().toISOString(),
      });

    } catch (error) {
      this.logger.error(`Authentication failed for socket ${client.id}:`, error);
      client.disconnect();
    }
  }

  handleDisconnect(client: AuthenticatedSocket) {
    if (client.userId) {
      // 사용자 연결 목록에서 제거
      const userSockets = this.connectedUsers.get(client.userId);
      if (userSockets) {
        userSockets.delete(client.id);
        if (userSockets.size === 0) {
          this.connectedUsers.delete(client.userId);
          // 마지막 연결이 끊어졌을 때만 오프라인 상태 알림
          client.broadcast.emit('user:offline', {
            userId: client.userId,
            timestamp: new Date().toISOString(),
          });
        }
      }

      // 소켓 룸 정보 정리
      this.socketRooms.delete(client.id);

      this.logger.log(`User ${client.userId} disconnected: ${client.id}`);
    }
  }

  // 프로젝트 룸 조인
  @SubscribeMessage('join:project')
  handleJoinProject(
    @ConnectedSocket() client: AuthenticatedSocket,
    @MessageBody() data: { projectId: string },
  ) {
    const roomName = `project:${data.projectId}`;
    client.join(roomName);

    // 소켓 룸 추적
    if (!this.socketRooms.has(client.id)) {
      this.socketRooms.set(client.id, new Set());
    }
    this.socketRooms.get(client.id)?.add(roomName);

    this.logger.log(`User ${client.userId} joined project room: ${roomName}`);

    // 프로젝트 멤버들에게 참여 알림
    client.to(roomName).emit('project:user_joined', {
      userId: client.userId,
      projectId: data.projectId,
      timestamp: new Date().toISOString(),
    });

    return { success: true, room: roomName };
  }

  // 프로젝트 룸 나가기
  @SubscribeMessage('leave:project')
  handleLeaveProject(
    @ConnectedSocket() client: AuthenticatedSocket,
    @MessageBody() data: { projectId: string },
  ) {
    const roomName = `project:${data.projectId}`;
    client.leave(roomName);

    // 소켓 룸 추적에서 제거
    this.socketRooms.get(client.id)?.delete(roomName);

    this.logger.log(`User ${client.userId} left project room: ${roomName}`);

    // 프로젝트 멤버들에게 나감 알림
    client.to(roomName).emit('project:user_left', {
      userId: client.userId,
      projectId: data.projectId,
      timestamp: new Date().toISOString(),
    });

    return { success: true };
  }

  // 태스크 룸 조인
  @SubscribeMessage('join:task')
  handleJoinTask(
    @ConnectedSocket() client: AuthenticatedSocket,
    @MessageBody() data: { taskId: string },
  ) {
    const roomName = `task:${data.taskId}`;
    client.join(roomName);

    if (!this.socketRooms.has(client.id)) {
      this.socketRooms.set(client.id, new Set());
    }
    this.socketRooms.get(client.id)?.add(roomName);

    this.logger.log(`User ${client.userId} joined task room: ${roomName}`);

    // 태스크 관련자들에게 참여 알림
    client.to(roomName).emit('task:user_joined', {
      userId: client.userId,
      taskId: data.taskId,
      timestamp: new Date().toISOString(),
    });

    return { success: true, room: roomName };
  }

  // 태스크 룸 나가기
  @SubscribeMessage('leave:task')
  handleLeaveTask(
    @ConnectedSocket() client: AuthenticatedSocket,
    @MessageBody() data: { taskId: string },
  ) {
    const roomName = `task:${data.taskId}`;
    client.leave(roomName);

    this.socketRooms.get(client.id)?.delete(roomName);

    client.to(roomName).emit('task:user_left', {
      userId: client.userId,
      taskId: data.taskId,
      timestamp: new Date().toISOString(),
    });

    return { success: true };
  }

  // 태스크 실시간 편집 (타이핑 상태)
  @SubscribeMessage('task:typing')
  handleTaskTyping(
    @ConnectedSocket() client: AuthenticatedSocket,
    @MessageBody() data: { taskId: string; field: string; isTyping: boolean },
  ) {
    const roomName = `task:${data.taskId}`;
    
    client.to(roomName).emit('task:typing', {
      userId: client.userId,
      taskId: data.taskId,
      field: data.field,
      isTyping: data.isTyping,
      timestamp: new Date().toISOString(),
    });
  }

  // 실시간 업데이트 브로드캐스트 메서드들
  
  // 태스크 업데이트 알림
  async broadcastTaskUpdate(taskId: string, updateData: any, excludeUserId?: string) {
    const roomName = `task:${taskId}`;
    const payload = {
      type: 'task:updated',
      taskId,
      data: updateData,
      timestamp: new Date().toISOString(),
    };

    if (excludeUserId) {
      // 특정 사용자 제외하고 브로드캐스트
      const excludeSockets = this.connectedUsers.get(excludeUserId) || new Set();
      const room = this.server.to(roomName);
      for (const socketId of excludeSockets) {
        room.except(socketId);
      }
      room.emit('task:updated', payload);
    } else {
      this.server.to(roomName).emit('task:updated', payload);
    }
  }

  // 프로젝트 업데이트 알림
  async broadcastProjectUpdate(projectId: string, updateData: any, excludeUserId?: string) {
    const roomName = `project:${projectId}`;
    const payload = {
      type: 'project:updated',
      projectId,
      data: updateData,
      timestamp: new Date().toISOString(),
    };

    if (excludeUserId) {
      const excludeSockets = this.connectedUsers.get(excludeUserId) || new Set();
      const room = this.server.to(roomName);
      for (const socketId of excludeSockets) {
        room.except(socketId);
      }
      room.emit('project:updated', payload);
    } else {
      this.server.to(roomName).emit('project:updated', payload);
    }
  }

  // 사용자별 알림
  async sendUserNotification(userId: string, notification: any) {
    const userRoom = `user:${userId}`;
    this.server.to(userRoom).emit('notification', {
      ...notification,
      timestamp: new Date().toISOString(),
    });
  }

  // 댓글 추가 알림
  async broadcastCommentAdded(taskId: string, comment: any, excludeUserId?: string) {
    const roomName = `task:${taskId}`;
    const payload = {
      type: 'comment:added',
      taskId,
      comment,
      timestamp: new Date().toISOString(),
    };

    if (excludeUserId) {
      const excludeSockets = this.connectedUsers.get(excludeUserId) || new Set();
      const room = this.server.to(roomName);
      for (const socketId of excludeSockets) {
        room.except(socketId);
      }
      room.emit('comment:added', payload);
    } else {
      this.server.to(roomName).emit('comment:added', payload);
    }
  }

  // 연결된 사용자 목록 조회
  getConnectedUsers(): string[] {
    return Array.from(this.connectedUsers.keys());
  }

  // 특정 프로젝트/태스크의 활성 사용자 조회
  getRoomUsers(roomName: string): string[] {
    const room = this.server.sockets.adapter.rooms.get(roomName);
    if (!room) return [];

    const userIds = new Set<string>();
    for (const socketId of room) {
      const socket = this.server.sockets.sockets.get(socketId) as AuthenticatedSocket;
      if (socket?.userId) {
        userIds.add(socket.userId);
      }
    }

    return Array.from(userIds);
  }

  // JWT 토큰 추출
  private extractTokenFromSocket(socket: Socket): string | null {
    // Authorization 헤더에서 추출
    const authHeader = socket.handshake.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    // 쿼리 파라미터에서 추출
    const token = socket.handshake.auth?.token || socket.handshake.query?.token;
    if (token && typeof token === 'string') {
      return token;
    }

    return null;
  }
}
</file>

<file path="backend/src/modules/websocket/websocket.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { WorklyWebSocketGateway } from './websocket.gateway';
import { getAuthConfig } from '../../config/auth.config';

@Module({
  imports: [
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const authConfig = getAuthConfig(configService);
        return {
          secret: authConfig.jwt.secret,
          signOptions: {
            expiresIn: authConfig.jwt.expiresIn,
          },
        };
      },
      inject: [ConfigService],
    }),
    ConfigModule,
  ],
  providers: [WorklyWebSocketGateway],
  exports: [WorklyWebSocketGateway],
})
export class WebSocketModule {}
</file>

<file path="backend/src/main.ts">
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { ConfigService } from '@nestjs/config';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);

  // CORS 설정
  app.enableCors({
    origin: [
      'http://localhost:3000', // 프론트엔드 개발 서버
      configService.get('FRONTEND_URL', 'http://localhost:3000'),
      /\.vercel\.app$/, // Vercel 프리뷰 URL들
      'https://workly.vercel.app', // Vercel 프로덕션 URL (예시)
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  });

  // 글로벌 파이프 설정
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // DTO에 정의되지 않은 속성 제거
      forbidNonWhitelisted: true, // 정의되지 않은 속성이 있으면 오류 발생
      transform: true, // 요청 데이터를 DTO 타입으로 자동 변환
      disableErrorMessages: configService.get('NODE_ENV') === 'production',
    }),
  );

  // API 전역 프리픽스 설정 (auth는 제외)
  app.setGlobalPrefix('api/v1', {
    exclude: ['/auth(.*)']
  });

  // Swagger 설정
  if (configService.get('NODE_ENV') !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('Workly API')
      .setDescription('워클리 백엔드 API 문서')
      .setVersion('1.0')
      .addBearerAuth(
        {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
          name: 'JWT',
          description: 'JWT 토큰을 입력하세요',
          in: 'header',
        },
        'JWT-auth',
      )
      .addTag('Authentication', '인증 관련 API')
      .addTag('Users', '사용자 관리 API')
      .addTag('Projects', '프로젝트 관리 API')
      .addTag('Tasks', '태스크 관리 API')
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api/docs', app, document, {
      swaggerOptions: {
        persistAuthorization: true,
      },
    });

    console.log(`📚 API 문서: http://localhost:${configService.get('PORT', 3001)}/api/docs`);
  }

  // 서버 시작
  const port = configService.get('PORT', 3001);
  await app.listen(port);

  console.log(`🚀 서버가 포트 ${port}에서 실행 중입니다.`);
  console.log(`🌍 환경: ${configService.get('NODE_ENV', 'development')}`);
}

bootstrap();
</file>

<file path="backend/Dockerfile">
# Backend Dockerfile
FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /root

# Copy all package files
COPY package*.json ./
COPY shared/package*.json ./shared/
COPY backend/package*.json ./backend/

# Install all dependencies
RUN npm ci

# Build shared module
FROM base AS shared-builder
WORKDIR /root
COPY --from=deps /root/node_modules ./node_modules
COPY shared ./shared
WORKDIR /root/shared
RUN npm run build

# Build backend
FROM base AS builder
WORKDIR /root/backend
COPY --from=deps /root/node_modules ../node_modules
COPY --from=deps /root/package-lock.json ../package-lock.json
COPY --from=shared-builder /root/shared/dist ../shared/dist
COPY --from=shared-builder /root/shared/package.json ../shared/package.json
COPY backend ./

# Build application
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

# Create non-root user
RUN addgroup --system --gid 1001 nestjs
RUN adduser --system --uid 1001 nestjs

# Copy built application
COPY --from=builder --chown=nestjs:nestjs /root/backend/dist ./dist
COPY --from=builder --chown=nestjs:nestjs /root/backend/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nestjs /root/backend/package*.json ./

USER nestjs

EXPOSE 3001

CMD ["node", "dist/main"]
</file>

<file path="backend/package.json">
{
  "name": "@workly/backend",
  "version": "1.0.0",
  "description": "워클리 백엔드 NestJS 애플리케이션",
  "author": "Workly Team",
  "private": true,
  "license": "MIT",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "lint:fix": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "db:migrate": "typeorm migration:run -d src/config/typeorm.config.ts",
    "db:migrate:create": "typeorm migration:create",
    "db:migrate:revert": "typeorm migration:revert -d src/config/typeorm.config.ts",
    "db:seed": "ts-node src/database/seeds/run-seeds.ts"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/platform-socket.io": "^10.0.0",
    "@nestjs/websockets": "^10.0.0",
    "@nestjs/passport": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/swagger": "^7.0.0",
    "typeorm": "^0.3.17",
    "pg": "^8.11.0",
    "passport": "^0.6.0",
    "passport-jwt": "^4.0.1",
    "passport-google-oauth20": "^2.0.0",
    "bcryptjs": "^2.4.3",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1",
    "socket.io": "^4.7.0",
    "uuid": "^9.0.0",
    "@nestjs/throttler": "^5.0.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "@workly/shared": "*"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/passport-jwt": "^3.0.9",
    "@types/passport-google-oauth20": "^2.0.11",
    "@types/bcryptjs": "^2.4.2",
    "@types/uuid": "^9.0.0",
    "@types/pg": "^8.10.0",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2020",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictBindCallApply": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["src/*"],
      "@workly/shared": ["../shared/dist/src"]
    },
    "lib": ["ES2020"]
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "test"
  ]
}
</file>

<file path="frontend/src/app/admin/users/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { 
  MagnifyingGlassIcon,
  FunnelIcon,
  PencilIcon,
  TrashIcon,
  ShieldCheckIcon,
  UserIcon,
} from '@heroicons/react/24/outline';

interface User {
  id: string;
  email: string;
  name: string;
  role: string;
  adminRole?: string;
  status: string;
  createdAt: string;
  lastLoginAt?: string;
  emailVerifiedAt?: string;
}

interface UserFilters {
  search: string;
  role: string;
  adminRole: string;
  status: string;
}

export default function UsersManagement() {
  const [users, setUsers] = useState<User[]>([]);
  const [filteredUsers, setFilteredUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [filters, setFilters] = useState<UserFilters>({
    search: '',
    role: '',
    adminRole: '',
    status: '',
  });

  useEffect(() => {
    const fetchUsers = async () => {  
      try {
        // 실제 API 호출
        const token = localStorage.getItem('token') || 'dev-admin-token';
        const queryParams = new URLSearchParams({
          page: currentPage.toString(),
          limit: '20',
          ...(filters.search && { search: filters.search }),
          ...(filters.role && { role: filters.role }),
        });

        const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/v1/api/admin/users?${queryParams}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          const usersData = data.success ? data.data : data;
          
          setUsers(usersData.data || usersData);
          setTotalPages(usersData.totalPages || 1);
          
          console.log('🚀 실제 백엔드에서 사용자 데이터를 가져왔습니다.', usersData);
        } else {
          // API 호출 실패 시 임시 데이터 사용
          console.warn('백엔드 API 연결 실패, 임시 데이터 사용');
          const mockUsers: User[] = [
          {
            id: '1',
            email: 'admin@workly.co',
            name: '시스템 관리자',
            role: 'ADMIN',
            adminRole: 'super_admin',
            status: 'ACTIVE',
            createdAt: '2024-01-01T00:00:00Z',
            lastLoginAt: '2024-01-15T10:30:00Z',
            emailVerifiedAt: '2024-01-01T00:00:00Z',
          },
          {
            id: '2',
            email: 'user1@example.com',
            name: '김사용자',
            role: 'MEMBER',
            status: 'ACTIVE',
            createdAt: '2024-01-05T00:00:00Z',
            lastLoginAt: '2024-01-14T15:22:00Z',
            emailVerifiedAt: '2024-01-05T00:00:00Z',
          },
          {
            id: '3',
            email: 'user2@example.com',
            name: '이프로젝트',
            role: 'MANAGER',
            adminRole: 'moderator',
            status: 'ACTIVE',
            createdAt: '2024-01-08T00:00:00Z',
            lastLoginAt: '2024-01-13T09:15:00Z',
            emailVerifiedAt: '2024-01-08T00:00:00Z',
          },
          {
            id: '4',
            email: 'pending@example.com',
            name: '박대기자',
            role: 'MEMBER',
            status: 'PENDING_VERIFICATION',
            createdAt: '2024-01-12T00:00:00Z',
          },
          ];
          
          setUsers(mockUsers);
          setTotalPages(1);
        }
      } catch (error) {
        console.error('사용자 데이터 로드 오류:', error);
        
        // 에러 발생 시 빈 배열로 설정
        setUsers([]);
        setTotalPages(1);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();
  }, [currentPage, filters.search, filters.role]);

  // 필터링 효과
  useEffect(() => {
    let filtered = users;

    if (filters.search) {
      filtered = filtered.filter(user =>
        user.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        user.email.toLowerCase().includes(filters.search.toLowerCase())
      );
    }

    if (filters.role) {
      filtered = filtered.filter(user => user.role === filters.role);
    }

    if (filters.adminRole) {
      filtered = filtered.filter(user => user.adminRole === filters.adminRole);
    }

    if (filters.status) {
      filtered = filtered.filter(user => user.status === filters.status);
    }

    setFilteredUsers(filtered);
    setCurrentPage(1);
  }, [filters, users]);

  const handleFilterChange = (key: keyof UserFilters, value: string) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };

  const getStatusBadge = (status: string) => {
    const badges = {
      ACTIVE: 'bg-green-100 text-green-800',
      INACTIVE: 'bg-gray-100 text-gray-800',
      SUSPENDED: 'bg-red-100 text-red-800',
      PENDING_VERIFICATION: 'bg-yellow-100 text-yellow-800',
    };
    
    const labels = {
      ACTIVE: '활성',
      INACTIVE: '비활성',
      SUSPENDED: '정지',
      PENDING_VERIFICATION: '이메일 인증 대기',
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${badges[status as keyof typeof badges] || 'bg-gray-100 text-gray-800'}`}>
        {labels[status as keyof typeof labels] || status}
      </span>
    );
  };

  const getRoleBadge = (role: string) => {
    const badges = {
      ADMIN: 'bg-purple-100 text-purple-800',
      MANAGER: 'bg-blue-100 text-blue-800',
      MEMBER: 'bg-gray-100 text-gray-800',
    };
    
    const labels = {
      ADMIN: '관리자',
      MANAGER: '매니저',
      MEMBER: '일반 사용자',
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${badges[role as keyof typeof badges] || 'bg-gray-100 text-gray-800'}`}>
        {labels[role as keyof typeof labels] || role}
      </span>
    );
  };

  const getAdminRoleBadge = (adminRole?: string) => {
    if (!adminRole) return null;

    const badges = {
      super_admin: 'bg-red-100 text-red-800',
      admin: 'bg-orange-100 text-orange-800',
      moderator: 'bg-indigo-100 text-indigo-800',
      support: 'bg-teal-100 text-teal-800',
    };
    
    const labels = {
      super_admin: '슈퍼 관리자',
      admin: '어드민',
      moderator: '모더레이터',
      support: '지원팀',
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${badges[adminRole as keyof typeof badges] || 'bg-gray-100 text-gray-800'}`}>
        <ShieldCheckIcon className="w-3 h-3 mr-1" />
        {labels[adminRole as keyof typeof labels] || adminRole}
      </span>
    );
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="border-b border-gray-200 pb-4">
        <h1 className="text-2xl font-bold text-gray-900">사용자 관리</h1>
        <p className="mt-1 text-sm text-gray-600">
          전체 사용자 목록을 확인하고 관리하세요
        </p>
      </div>

      {/* 필터 영역 */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          {/* 검색 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              검색
            </label>
            <div className="relative">
              <MagnifyingGlassIcon className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
              <input
                type="text"
                placeholder="이름 또는 이메일 검색"
                value={filters.search}
                onChange={(e) => handleFilterChange('search', e.target.value)}
                className="pl-10 w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              />
            </div>
          </div>

          {/* 역할 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              사용자 역할
            </label>
            <select
              value={filters.role}
              onChange={(e) => handleFilterChange('role', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="ADMIN">관리자</option>
              <option value="MANAGER">매니저</option>
              <option value="MEMBER">일반 사용자</option>
            </select>
          </div>

          {/* 어드민 역할 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              어드민 권한
            </label>
            <select
              value={filters.adminRole}
              onChange={(e) => handleFilterChange('adminRole', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="super_admin">슈퍼 관리자</option>
              <option value="admin">어드민</option>
              <option value="moderator">모더레이터</option>
              <option value="support">지원팀</option>
            </select>
          </div>

          {/* 상태 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              상태
            </label>
            <select
              value={filters.status}
              onChange={(e) => handleFilterChange('status', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            >
              <option value="">전체</option>
              <option value="ACTIVE">활성</option>
              <option value="INACTIVE">비활성</option>
              <option value="SUSPENDED">정지</option>
              <option value="PENDING_VERIFICATION">이메일 인증 대기</option>
            </select>
          </div>
        </div>
      </div>

      {/* 사용자 목록 */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-900">
              사용자 목록 ({filteredUsers.length}명)
            </h2>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  사용자
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  역할
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  상태
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  가입일
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  마지막 로그인
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  작업
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredUsers.map((user) => (
                <tr key={user.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      <div className="flex-shrink-0 h-10 w-10">
                        <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center">
                          <UserIcon className="h-5 w-5 text-gray-500" />
                        </div>
                      </div>
                      <div className="ml-4">
                        <div className="text-sm font-medium text-gray-900">{user.name}</div>
                        <div className="text-sm text-gray-500">{user.email}</div>
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="space-y-1">
                      {getRoleBadge(user.role)}
                      {user.adminRole && getAdminRoleBadge(user.adminRole)}
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    {getStatusBadge(user.status)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {new Date(user.createdAt).toLocaleDateString('ko-KR')}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {user.lastLoginAt 
                      ? new Date(user.lastLoginAt).toLocaleDateString('ko-KR')
                      : '없음'
                    }
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <div className="flex items-center justify-end space-x-2">
                      <button className="text-indigo-600 hover:text-indigo-900">
                        <PencilIcon className="h-4 w-4" />
                      </button>
                      {user.adminRole !== 'super_admin' && (
                        <button className="text-red-600 hover:text-red-900">
                          <TrashIcon className="h-4 w-4" />
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {filteredUsers.length === 0 && (
          <div className="text-center py-12">
            <UserIcon className="mx-auto h-12 w-12 text-gray-400" />
            <h3 className="mt-2 text-sm font-medium text-gray-900">사용자가 없습니다</h3>
            <p className="mt-1 text-sm text-gray-500">필터 조건을 변경해보세요.</p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/admin/page.tsx">
'use client';

import { useEffect, useState } from 'react';
import { 
  UsersIcon, 
  FolderIcon, 
  ClipboardDocumentListIcon,
  CheckCircleIcon 
} from '@heroicons/react/24/outline';

interface DashboardStats {
  totalUsers: number;
  totalProjects: number;
  totalTasks: number;
  activeUsersCount: number;
  completedTasksCount: number;
  completionRate: number;
}

interface AdminInfo {
  id: string;
  name: string;
  role: string;
  permissions: string[];
  lastAdminLogin?: string;
}

export default function AdminDashboard() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [adminInfo, setAdminInfo] = useState<AdminInfo | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        // 실제 API 호출
        const token = localStorage.getItem('token') || 'dev-admin-token';
        const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/v1/api/admin/dashboard`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          const dashboardData = data.success ? data.data : data;
          
          setStats(dashboardData.stats);
          setAdminInfo(dashboardData.adminInfo);
          
          console.log('🚀 실제 백엔드에서 대시보드 데이터를 가져왔습니다.', dashboardData);
        } else {
          // API 호출 실패 시 임시 데이터 사용
          console.warn('백엔드 API 연결 실패, 임시 데이터 사용');
          setStats({
            totalUsers: 0,
            totalProjects: 0,
            totalTasks: 0,
            activeUsersCount: 0,
            completedTasksCount: 0,
            completionRate: 0,
          });

          setAdminInfo({
            id: 'dev-admin-1',
            name: '워클리 개발 관리자',
            role: 'super_admin',
            permissions: ['*'],
            lastAdminLogin: new Date().toISOString(),
          });
        }
      } catch (error) {
        console.error('대시보드 데이터 로드 오류:', error);
        
        // 에러 발생 시 임시 데이터 사용
        setStats({
          totalUsers: 0,
          totalProjects: 0,
          totalTasks: 0,
          activeUsersCount: 0,
          completedTasksCount: 0,
          completionRate: 0,
        });

        setAdminInfo({
          id: 'dev-admin-1',
          name: '워클리 개발 관리자',
          role: 'super_admin',
          permissions: ['*'],
          lastAdminLogin: new Date().toISOString(),
        });
      } finally {
        setIsLoading(false);
      }
    };

    fetchDashboardData();
  }, []);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  const statCards = [
    {
      name: '전체 사용자',
      value: stats?.totalUsers.toLocaleString() || '0',
      icon: UsersIcon,
      color: 'bg-blue-500',
      change: '+12%',
      changeType: 'positive',
    },
    {
      name: '활성 사용자',
      value: stats?.activeUsersCount.toLocaleString() || '0',
      icon: UsersIcon,
      color: 'bg-green-500',
      change: '+8%',
      changeType: 'positive',
    },
    {
      name: '전체 프로젝트',
      value: stats?.totalProjects.toLocaleString() || '0',
      icon: FolderIcon,
      color: 'bg-purple-500',
      change: '+5%',
      changeType: 'positive',
    },
    {
      name: '전체 업무',
      value: stats?.totalTasks.toLocaleString() || '0',
      icon: ClipboardDocumentListIcon,
      color: 'bg-orange-500',
      change: '+15%',
      changeType: 'positive',
    },
    {
      name: '완료된 업무',
      value: stats?.completedTasksCount.toLocaleString() || '0',
      icon: CheckCircleIcon,
      color: 'bg-teal-500',
      change: '+22%',
      changeType: 'positive',
    },
    {
      name: '완료율',
      value: `${stats?.completionRate.toFixed(1)}%` || '0%',
      icon: CheckCircleIcon,
      color: 'bg-indigo-500',
      change: '+3%',
      changeType: 'positive',
    },
  ];

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="border-b border-gray-200 pb-4">
        <h1 className="text-2xl font-bold text-gray-900">어드민 대시보드</h1>
        <p className="mt-1 text-sm text-gray-600">
          워클리 시스템 전반의 현황을 한눈에 확인하세요
        </p>
      </div>

      {/* 관리자 정보 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">관리자 정보</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div>
            <p className="text-sm text-gray-500">이름</p>
            <p className="font-medium text-gray-900">{adminInfo?.name}</p>
          </div>
          <div>
            <p className="text-sm text-gray-500">역할</p>
            <p className="font-medium text-gray-900">
              {adminInfo?.role === 'super_admin' && '슈퍼 관리자'}
              {adminInfo?.role === 'admin' && '관리자'}
              {adminInfo?.role === 'moderator' && '모더레이터'}
              {adminInfo?.role === 'support' && '지원팀'}
            </p>
          </div>
          <div>
            <p className="text-sm text-gray-500">권한 수</p>
            <p className="font-medium text-gray-900">{adminInfo?.permissions.length}개</p>
          </div>
          <div>
            <p className="text-sm text-gray-500">마지막 관리자 로그인</p>
            <p className="font-medium text-gray-900">
              {adminInfo?.lastAdminLogin ? 
                new Date(adminInfo.lastAdminLogin).toLocaleString('ko-KR') : 
                '정보 없음'
              }
            </p>
          </div>
        </div>
      </div>

      {/* 주요 통계 카드 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {statCards.map((card, index) => {
          const Icon = card.icon;
          return (
            <div key={index} className="bg-white rounded-lg shadow p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-gray-600">{card.name}</p>
                  <p className="text-2xl font-bold text-gray-900">{card.value}</p>
                </div>
                <div className={`${card.color} p-3 rounded-full`}>
                  <Icon className="h-6 w-6 text-white" />
                </div>
              </div>
              <div className="mt-4 flex items-center">
                <span className={`text-sm font-medium ${
                  card.changeType === 'positive' ? 'text-green-600' : 'text-red-600'
                }`}>
                  {card.change}
                </span>
                <span className="text-sm text-gray-500 ml-1">지난 주 대비</span>
              </div>
            </div>
          );
        })}
      </div>

      {/* 빠른 작업 */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">빠른 작업</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <button className="flex items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-colors">
            <div className="text-center">
              <UsersIcon className="h-8 w-8 text-gray-400 mx-auto mb-2" />
              <span className="text-sm font-medium text-gray-900">사용자 관리</span>
            </div>
          </button>
          
          <button className="flex items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-colors">
            <div className="text-center">
              <FolderIcon className="h-8 w-8 text-gray-400 mx-auto mb-2" />
              <span className="text-sm font-medium text-gray-900">프로젝트 관리</span>
            </div>
          </button>
          
          <button className="flex items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-colors">
            <div className="text-center">
              <ClipboardDocumentListIcon className="h-8 w-8 text-gray-400 mx-auto mb-2" />
              <span className="text-sm font-medium text-gray-900">감사 로그</span>
            </div>
          </button>
          
          <button className="flex items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-gray-400 hover:bg-gray-50 transition-colors">
            <div className="text-center">
              <svg className="h-8 w-8 text-gray-400 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
              <span className="text-sm font-medium text-gray-900">시스템 설정</span>
            </div>
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/privacy/page.tsx">
import React from 'react';

const PrivacyPolicyPage = () => {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="max-w-[720px] mx-auto px-4 py-12">
        <h1 className="text-4xl font-bold mb-8 text-center">개인정보처리방침</h1>
        <div className="space-y-6 bg-card p-8 rounded-lg shadow-md">
          <p className="text-muted-foreground">최종 수정일: 2025년 7월 26일</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 1조 (총칙)</h2>
          <p>워클리(이하 "회사")는 개인정보보호법 등 관련 법령상의 개인정보보호 규정을 준수하며, 관련 법령에 의거한 개인정보처리방침을 정하여 이용자 권익 보호에 최선을 다하고 있습니다. 본 방침은 회사가 제공하는 모든 서비스에 적용됩니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 2조 (수집하는 개인정보의 항목 및 수집 방법)</h2>
          <p>1. 회사는 회원가입, 원활한 고객상담, 각종 서비스의 제공을 위해 아래와 같은 최소한의 개인정보를 필수항목으로 수집하고 있습니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li><strong>필수항목:</strong> 이메일 주소, 이름(또는 닉네임), Google 계정 프로필 정보</li>
            <li><strong>선택항목:</strong> 프로필 사진, 기술 스택, 포트폴리오 링크 등 회원이 프로필에 직접 입력하는 정보</li>
          </ul>
          <p>2. 서비스 이용 과정에서 아래와 같은 정보들이 자동으로 생성되어 수집될 수 있습니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li>IP 주소, 쿠키, 서비스 이용 기록, 기기 정보</li>
          </ul>
          <p>3. 개인정보는 Google OAuth를 통한 소셜 로그인 시 동의 절차를 거쳐 수집됩니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 3조 (개인정보의 수집 및 이용 목적)</h2>
          <p>회사는 수집한 개인정보를 다음의 목적을 위해 활용합니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li><strong>서비스 제공:</strong> 콘텐츠 제공, 개인 맞춤 서비스 제공, 본인 인증, 요금 결제(유료 서비스의 경우).</li>
            <li><strong>회원 관리:</strong> 회원제 서비스 이용에 따른 본인확인, 개인 식별, 불량회원의 부정 이용 방지와 비인가 사용 방지, 가입 의사 확인, 분쟁 조정을 위한 기록 보존.</li>
            <li><strong>게이미피케이션 및 소셜 기능:</strong> XP, 레벨, 스킬 트리, 평판 등 게이미피케이션 시스템 운영, 리더보드 표시, 프로젝트 팀원 간 정보 공유, "임무 게시판" 및 "프로젝트 쇼케이스"에서의 프로필 정보 공개.</li>
            <li><strong>신규 서비스 개발 및 마케팅:</strong> 신규 서비스 개발 및 맞춤 서비스 제공, 통계학적 특성에 따른 서비스 제공 및 광고 게재, 서비스의 유효성 확인, 이벤트 정보 및 참여기회 제공.</li>
          </ul>

          <h2 className="text-2xl font-semibold border-b pb-2">제 4조 (개인정보의 보유 및 이용기간)</h2>
          <p>회사는 원칙적으로 개인정보 수집 및 이용목적이 달성된 후에는 해당 정보를 지체 없이 파기합니다. 단, 관계법령의 규정에 의하여 보존할 필요가 있는 경우 회사는 아래와 같이 관계법령에서 정한 일정한 기간 동안 회원정보를 보관합니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li>계약 또는 청약철회 등에 관한 기록: 5년 (전자상거래 등에서의 소비자보호에 관한 법률)</li>
            <li>대금결제 및 재화 등의 공급에 관한 기록: 5년 (전자상거래 등에서의 소비자보호에 관한 법률)</li>
            <li>소비자의 불만 또는 분쟁처리에 관한 기록: 3년 (전자상거래 등에서의 소비자보호에 관한 법률)</li>
          </ul>

          <h2 className="text-2xl font-semibold border-b pb-2">제 5조 (개인정보의 파기절차 및 방법)</h2>
          <p>회사는 원칙적으로 개인정보 수집 및 이용목적이 달성된 후에는 해당 정보를 지체없이 파기합니다. 파기절차 및 방법은 다음과 같습니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li><strong>파기절차:</strong> 회원이 회원가입 등을 위해 입력한 정보는 목적이 달성된 후 별도의 DB로 옮겨져(종이의 경우 별도의 서류함) 내부 방침 및 기타 관련 법령에 의한 정보보호 사유에 따라(보유 및 이용기간 참조) 일정 기간 저장된 후 파기됩니다.</li>
            <li><strong>파기방법:</strong> 전자적 파일형태로 저장된 개인정보는 기록을 재생할 수 없는 기술적 방법을 사용하여 삭제합니다.</li>
          </ul>

          <h2 className="text-2xl font-semibold border-b pb-2">제 6조 (이용자의 권리와 그 행사방법)</h2>
          <p>이용자는 언제든지 등록되어 있는 자신의 개인정보를 조회하거나 수정할 수 있으며 가입해지를 요청할 수도 있습니다. 개인정보 조회, 수정을 위해서는 ‘프로필 설정’ 기능을, 가입해지(동의철회)를 위해서는 ‘회원탈퇴’ 기능을 이용하여 본인 확인 절차를 거치신 후 직접 열람, 정정 또는 탈퇴가 가능합니다.</p>

          <div className="bg-destructive/10 border-l-4 border-destructive p-4 mt-6 rounded-md">
            <p className="font-bold text-destructive">면책 조항</p>
            <p className="text-sm text-destructive-foreground">본 개인정보처리방침은 `WorklyPlanning.md` 문서를 기반으로 생성된 예시이며, 법적 효력을 갖지 않습니다. 실제 서비스 운영 시에는 반드시 법률 전문가의 검토를 거쳐야 합니다.</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PrivacyPolicyPage;
</file>

<file path="frontend/src/app/settings/page.tsx">
'use client'

import { useState } from 'react'
import { 
  ChevronRightIcon, 
  GlobeAltIcon, 
  SunIcon, 
  MoonIcon, 
  ComputerDesktopIcon,
  BellIcon 
} from '@heroicons/react/24/outline'

interface SettingSectionProps {
  title: string
  description: string
  children: React.ReactNode
}

function SettingSection({ title, description, children }: SettingSectionProps) {
  return (
    <div className="space-y-4">
      <div>
        <h2 className="text-lg font-semibold text-foreground">{title}</h2>
        <p className="text-sm text-muted-foreground">{description}</p>
      </div>
      <div className="bg-card border border-border rounded-xl p-4">
        {children}
      </div>
    </div>
  )
}

export default function SettingsPage() {
  const [language, setLanguage] = useState('ko')
  const [theme, setTheme] = useState('system')
  const [notifications, setNotifications] = useState({
    taskMentions: true,
    projectUpdates: true,
    applicationApproval: false,
    deadlineReminders: true,
    systemAnnouncements: false
  })

  const languages = [
    { code: 'ko', name: '한국어', nativeName: '한국어' },
    { code: 'en', name: 'English', nativeName: 'English' }
  ]

  const themes = [
    { value: 'light', label: '라이트 모드', icon: SunIcon },
    { value: 'dark', label: '다크 모드', icon: MoonIcon },
    { value: 'system', label: '시스템 설정', icon: ComputerDesktopIcon }
  ]

  const notificationSettings = [
    { key: 'taskMentions', label: '업무 멘션', description: '업무에서 나를 언급했을 때' },
    { key: 'projectUpdates', label: '프로젝트 업데이트', description: '참여 중인 프로젝트의 새로운 소식' },
    { key: 'applicationApproval', label: '지원서 승인', description: '프로젝트 지원서가 승인되었을 때' },
    { key: 'deadlineReminders', label: '마감일 알림', description: '업무 마감일이 다가왔을 때' },
    { key: 'systemAnnouncements', label: '시스템 공지', description: '워클리의 새로운 기능이나 공지사항' }
  ]

  const handleNotificationChange = (key: string) => {
    setNotifications(prev => ({
      ...prev,
      [key]: !prev[key as keyof typeof prev]
    }))
  }

  return (
    <div className="min-h-screen bg-background">
      {/* 헤더 */}
      <div className="sticky top-0 bg-background border-b border-border z-10">
        <div className="max-w-[720px] mx-auto px-0 md:px-6 py-4">
          <h1 className="text-xl font-bold text-foreground">설정</h1>
        </div>
      </div>

      {/* 설정 내용 */}
      <div className="max-w-[720px] mx-auto p-4 md:p-6 space-y-8">
        {/* 언어 설정 */}
        <SettingSection 
          title="언어 설정"
          description="앱에서 사용할 언어를 선택하세요"
        >
          <div className="space-y-2">
            {languages.map((lang) => (
              <button
                key={lang.code}
                onClick={() => setLanguage(lang.code)}
                className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors ${
                  language === lang.code 
                    ? 'bg-accent text-foreground' 
                    : 'hover:bg-accent/50 text-muted-foreground'
                }`}
              >
                <div className="flex items-center gap-3">
                  <GlobeAltIcon className="w-5 h-5" />
                  <div className="text-left">
                    <div className="font-medium">{lang.nativeName}</div>
                    <div className="text-sm text-muted-foreground">{lang.name}</div>
                  </div>
                </div>
                {language === lang.code && (
                  <div className="w-2 h-2 bg-foreground rounded-full" />
                )}
              </button>
            ))}
          </div>
        </SettingSection>

        {/* 테마 설정 */}
        <SettingSection 
          title="화면 테마"
          description="라이트 모드, 다크 모드, 또는 시스템 설정을 따릅니다"
        >
          <div className="space-y-2">
            {themes.map((themeOption) => {
              const Icon = themeOption.icon
              return (
                <button
                  key={themeOption.value}
                  onClick={() => setTheme(themeOption.value)}
                  className={`w-full flex items-center justify-between p-3 rounded-lg transition-colors ${
                    theme === themeOption.value 
                      ? 'bg-accent text-foreground' 
                      : 'hover:bg-accent/50 text-muted-foreground'
                  }`}
                >
                  <div className="flex items-center gap-3">
                    <Icon className="w-5 h-5" />
                    <span className="font-medium">{themeOption.label}</span>
                  </div>
                  {theme === themeOption.value && (
                    <div className="w-2 h-2 bg-foreground rounded-full" />
                  )}
                </button>
              )
            })}
          </div>
        </SettingSection>

        {/* 알림 설정 */}
        <SettingSection 
          title="알림 설정"
          description="받고 싶은 알림을 선택하세요"
        >
          <div className="space-y-4">
            {notificationSettings.map((setting) => (
              <div key={setting.key} className="flex items-center justify-between">
                <div className="flex items-start gap-3 flex-1">
                  <BellIcon className="w-5 h-5 text-muted-foreground mt-0.5" />
                  <div>
                    <div className="font-medium text-foreground">{setting.label}</div>
                    <div className="text-sm text-muted-foreground">{setting.description}</div>
                  </div>
                </div>
                <button
                  onClick={() => handleNotificationChange(setting.key)}
                  className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-foreground ${
                    notifications[setting.key as keyof typeof notifications]
                      ? 'bg-foreground'
                      : 'bg-muted'
                  }`}
                >
                  <span
                    className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                      notifications[setting.key as keyof typeof notifications]
                        ? 'translate-x-6'
                        : 'translate-x-1'
                    }`}
                  />
                </button>
              </div>
            ))}
          </div>
        </SettingSection>

        {/* 추가 옵션 */}
        <div className="pt-8 border-t border-border">
          <div className="space-y-2">
            <button className="w-full flex items-center justify-between p-4 text-left hover:bg-accent rounded-lg transition-colors">
              <span className="text-foreground">계정 정보</span>
              <ChevronRightIcon className="w-5 h-5 text-muted-foreground" />
            </button>
            <button className="w-full flex items-center justify-between p-4 text-left hover:bg-accent rounded-lg transition-colors">
              <span className="text-foreground">데이터 내보내기</span>
              <ChevronRightIcon className="w-5 h-5 text-muted-foreground" />
            </button>
            <button className="w-full flex items-center justify-between p-4 text-left hover:bg-accent rounded-lg transition-colors">
              <span className="text-foreground">도움말</span>
              <ChevronRightIcon className="w-5 h-5 text-muted-foreground" />
            </button>
            <button className="w-full flex items-center justify-between p-4 text-left hover:bg-accent rounded-lg transition-colors text-red-600">
              <span>로그아웃</span>
              <ChevronRightIcon className="w-5 h-5" />
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/app/tasks/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { Plus, Search, Filter, SortAsc, SortDesc } from 'lucide-react';
import MainContainer from '@/components/layout/MainContainer';
import TaskList from '@/components/tasks/TaskList';
import TaskFilters from '@/components/tasks/TaskFilters';
import TaskCreationWizard from '@/components/tasks/TaskCreationWizard';
import { apiClient } from '@/lib/api';
import { Task, CreateTaskDto, TaskStatus, SmartFilter } from '@/types/task.types';

interface TaskCounts {
  today: number;
  completed: number;
  all: number;
}

interface SortOption {
  value: string;
  label: string;
  field: keyof Task;
  direction: 'asc' | 'desc';
}

const SORT_OPTIONS: SortOption[] = [
  { value: 'dueDate-asc', label: '마감일 빠른 순', field: 'dueDate', direction: 'asc' },
  { value: 'dueDate-desc', label: '마감일 늦은 순', field: 'dueDate', direction: 'desc' },
  { value: 'priority-desc', label: '우선순위 높은 순', field: 'priority', direction: 'desc' },
  { value: 'priority-asc', label: '우선순위 낮은 순', field: 'priority', direction: 'asc' },
  { value: 'createdAt-desc', label: '최근 생성 순', field: 'createdAt', direction: 'desc' },
  { value: 'createdAt-asc', label: '오래된 순', field: 'createdAt', direction: 'asc' },
  { value: 'title-asc', label: '제목 A-Z', field: 'title', direction: 'asc' },
  { value: 'title-desc', label: '제목 Z-A', field: 'title', direction: 'desc' }
];

const PRIORITY_ORDER = {
  urgent: 4,
  high: 3,
  medium: 2,
  low: 1
};

export default function TasksPage() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const [taskCounts, setTaskCounts] = useState<TaskCounts>({ today: 0, completed: 0, all: 0 });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 필터 및 검색 상태
  const [currentFilter, setCurrentFilter] = useState<SmartFilter>('today');
  const [searchQuery, setSearchQuery] = useState('');
  const [sortOption, setSortOption] = useState<string>('dueDate-asc');

  // UI 상태
  const [isCreationWizardOpen, setIsCreationWizardOpen] = useState(false);
  const [projects, setProjects] = useState<Array<{ id: string; name: string }>>([]);
  const [assignees, setAssignees] = useState<Array<{ id: string; firstName: string; lastName: string }>>([]);

  // 데이터 로드
  useEffect(() => {
    loadTasks();
    loadProjects();
    loadAssignees();
  }, []);

  // 필터 및 정렬 적용
  useEffect(() => {
    applyFiltersAndSort();
  }, [tasks, currentFilter, searchQuery, sortOption]);

  const loadTasks = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 모든 태스크 로드
      const allTasks = await apiClient.get<Task[]>('/tasks');
      setTasks(allTasks);

      // 스마트 필터별 카운트 계산
      const today = new Date();
      today.setHours(23, 59, 59, 999); // 오늘 끝까지

      const todayTasks = allTasks.filter(task => {
        if (!task.dueDate) return false;
        const dueDate = new Date(task.dueDate);
        return dueDate <= today && task.status !== TaskStatus.DONE;
      });

      const completedTasks = allTasks.filter(task => task.status === TaskStatus.DONE);

      setTaskCounts({
        today: todayTasks.length,
        completed: completedTasks.length,
        all: allTasks.length
      });

    } catch (err) {
      console.error('태스크 로드 실패:', err);
      setError('태스크를 불러오는데 실패했습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  const loadProjects = async () => {
    try {
      const projectsData = await apiClient.get<Array<{ id: string; name: string }>>('/projects');
      setProjects(projectsData);
    } catch (err) {
      console.error('프로젝트 로드 실패:', err);
    }
  };

  const loadAssignees = async () => {
    try {
      const assigneesData = await apiClient.get<Array<{ id: string; firstName: string; lastName: string }>>('/users');
      setAssignees(assigneesData);
    } catch (err) {
      console.error('사용자 로드 실패:', err);
    }
  };

  const applyFiltersAndSort = () => {
    let filtered = [...tasks];

    // 스마트 필터 적용
    const today = new Date();
    today.setHours(23, 59, 59, 999);

    switch (currentFilter) {
      case 'today':
        filtered = filtered.filter(task => {
          if (!task.dueDate) return false;
          const dueDate = new Date(task.dueDate);
          return dueDate <= today && task.status !== TaskStatus.DONE;
        });
        break;
      case 'completed':
        filtered = filtered.filter(task => task.status === TaskStatus.DONE);
        break;
      case 'all':
      default:
        // 모든 태스크 표시
        break;
    }

    // 검색 쿼리 적용
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(task => 
        task.title.toLowerCase().includes(query) ||
        task.description?.toLowerCase().includes(query) ||
        task.tags?.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // 정렬 적용
    const sortConfig = SORT_OPTIONS.find(opt => opt.value === sortOption);
    if (sortConfig) {
      filtered.sort((a, b) => {
        let aValue = a[sortConfig.field];
        let bValue = b[sortConfig.field];

        // 특별한 정렬 로직
        if (sortConfig.field === 'priority') {
          aValue = PRIORITY_ORDER[a.priority as keyof typeof PRIORITY_ORDER] || 0;
          bValue = PRIORITY_ORDER[b.priority as keyof typeof PRIORITY_ORDER] || 0;
        } else if (sortConfig.field === 'dueDate') {
          // null 값 처리
          if (!aValue && !bValue) return 0;
          if (!aValue) return sortConfig.direction === 'asc' ? 1 : -1;
          if (!bValue) return sortConfig.direction === 'asc' ? -1 : 1;
          aValue = new Date(aValue as string).getTime();
          bValue = new Date(bValue as string).getTime();
        } else if (sortConfig.field === 'createdAt') {
          aValue = new Date(aValue as string).getTime();
          bValue = new Date(bValue as string).getTime();
        }

        if (aValue === bValue) return 0;
        
        const result = aValue < bValue ? -1 : 1;
        return sortConfig.direction === 'asc' ? result : -result;
      });
    }

    setFilteredTasks(filtered);
  };

  const handleCreateTask = async (taskData: CreateTaskDto) => {
    try {
      await apiClient.post<Task>('/tasks', taskData);
      await loadTasks(); // 태스크 목록 새로고침
    } catch (err) {
      console.error('태스크 생성 실패:', err);
      throw err;
    }
  };

  const handleStatusChange = async (taskId: string, status: TaskStatus) => {
    try {
      await apiClient.put(`/tasks/${taskId}`, { status });
      await loadTasks(); // 태스크 목록 새로고침
    } catch (err) {
      console.error('태스크 상태 변경 실패:', err);
    }
  };

  const handleTaskEdit = (task: Task) => {
    // TODO: 태스크 편집 모달 또는 페이지로 이동
    console.log('Edit task:', task);
  };

  const handleTaskDelete = async (task: Task) => {
    if (confirm(`"${task.title}" 태스크를 삭제하시겠습니까?`)) {
      try {
        await apiClient.delete(`/tasks/${task.id}`);
        await loadTasks(); // 태스크 목록 새로고침
      } catch (err) {
        console.error('태스크 삭제 실패:', err);
      }
    }
  };

  if (error) {
    return (
      <MainContainer className="px-4">
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 text-center">
          <p className="text-red-600">{error}</p>
          <button
            onClick={loadTasks}
            className="mt-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
          >
            다시 시도
          </button>
        </div>
      </MainContainer>
    );
  }

  return (
    <MainContainer className="px-4">
      {/* 헤더 */}
      <div className="flex items-center justify-between mb-8">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">태스크 관리</h1>
          <p className="text-gray-600 mt-1">GTD 방법론을 활용한 체계적인 태스크 관리</p>
        </div>
        <button
          onClick={() => setIsCreationWizardOpen(true)}
          className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
        >
          <Plus className="w-5 h-5" />
          <span>새 태스크</span>
        </button>
      </div>

      {/* 필터 및 검색 */}
      <div className="space-y-4 mb-6">
        {/* 스마트 필터 */}
        <TaskFilters
          currentFilter={currentFilter}
          onFilterChange={setCurrentFilter}
          taskCounts={taskCounts}
        />

        {/* 검색 및 정렬 */}
        <div className="flex flex-col sm:flex-row gap-4">
          {/* 검색 */}
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
            <input
              type="text"
              placeholder="태스크 제목, 설명, 태그로 검색..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>

          {/* 정렬 */}
          <div className="flex items-center space-x-2">
            <Filter className="w-5 h-5 text-gray-400" />
            <select
              value={sortOption}
              onChange={(e) => setSortOption(e.target.value)}
              className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
              {SORT_OPTIONS.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>
        </div>
      </div>

      {/* 결과 표시 */}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          총 {filteredTasks.length}개의 태스크
          {searchQuery && ` (검색: "${searchQuery}")`}
        </p>
      </div>

      {/* 태스크 목록 */}
      <TaskList
        tasks={filteredTasks}
        onStatusChange={handleStatusChange}
        onTaskEdit={handleTaskEdit}
        onTaskDelete={handleTaskDelete}
        isLoading={isLoading}
        emptyMessage={
          currentFilter === 'today' 
            ? '오늘 해야 할 태스크가 없습니다.'
            : currentFilter === 'completed'
            ? '완료된 태스크가 없습니다.'
            : searchQuery
            ? '검색 조건에 맞는 태스크가 없습니다.'
            : '등록된 태스크가 없습니다.'
        }
      />

      {/* 태스크 생성 마법사 */}
      <TaskCreationWizard
        isOpen={isCreationWizardOpen}
        onClose={() => setIsCreationWizardOpen(false)}
        onSubmit={handleCreateTask}
        projects={projects}
        assignees={assignees}
      />
    </MainContainer>
  );
}
</file>

<file path="frontend/src/app/terms/page.tsx">
import React from 'react';

const TermsOfServicePage = () => {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="max-w-[720px] mx-auto px-4 py-12">
        <h1 className="text-4xl font-bold mb-8 text-center">서비스 약관</h1>
        <div className="space-y-6 bg-card p-8 rounded-lg shadow-md">
          <p className="text-muted-foreground">최종 수정일: 2025년 7월 26일</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 1조 (목적)</h2>
          <p>이 약관은 워클리(이하 "회사")가 제공하는 게이미피케이션 기반 생산성 애플리케이션 및 관련 제반 서비스(이하 "서비스")의 이용과 관련하여 회사와 회원과의 권리, 의무 및 책임사항, 기타 필요한 사항을 규정함을 목적으로 합니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 2조 (용어의 정의)</h2>
          <p>본 약관에서 사용하는 용어의 정의는 다음과 같습니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li>"회원": 본 약관에 동의하고 회사가 제공하는 서비스를 이용하는 개인 또는 팀.</li>
            <li>"XP (경험치)": 서비스 내에서 특정 활동을 완료하고 얻는 보상 포인트.</li>
            <li>"프로젝트": 회원이 목표 달성을 위해 생성하고 관리하는 작업 공간.</li>
            <li>"임무 게시판": 외부 클라이언트 또는 다른 회원이 유료 업무를 게시하고, 회원이 이를 수행하여 수익을 창출할 수 있는 마켓플레이스.</li>
            <li>"지식 위키": 회원이 생성하고 커뮤니티가 관리하는 지식 베이스.</li>
            <li>"워크스페이스": 팀 및 기업 사용자를 위한 프리미엄 중앙 허브.</li>
          </ul>

          <h2 className="text-2xl font-semibold border-b pb-2">제 3조 (서비스의 제공 및 변경)</h2>
          <p>1. 회사는 회원에게 GTD(Getting Things Done) 방법론에 기반한 업무 관리, 프로젝트 협업, 게이미피케이션을 통한 동기 부여, 포트폴리오 관리 등의 기능을 제공합니다.</p>
          <p>2. 회사는 상당한 이유가 있는 경우에 운영상, 기술상의 필요에 따라 제공하고 있는 전부 또는 일부 서비스를 변경할 수 있습니다.</p>
          <p>3. 무료 서비스는 개인 사용자를 대상으로 하며, 회사는 유료 구독 모델("워크스페이스 프로", "워크스페이스 엔터프라이즈")을 통해 고급 기능 및 관리 도구를 제공할 수 있습니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 4조 (회원의 의무 및 책임)</h2>
          <p>1. 회원은 자신의 계정 정보를 안전하게 관리할 책임이 있습니다.</p>
          <p>2. 회원은 다음 각 호에 해당하는 행위를 하여서는 안 됩니다.</p>
          <ul className="list-disc list-inside space-y-2 pl-4">
            <li>타인의 정보를 도용하는 행위</li>
            <li>서비스의 운영을 고의로 방해하는 행위</li>
            <li>공공질서 및 미풍양속에 저해되는 내용을 유포하는 행위 (예: 지식 위키, 프로젝트 쇼케이스 등)</li>
            <li>회사의 지적재산권을 침해하는 행위</li>
          </ul>
          <p>3. 회원은 "임무 게시판"을 통해 발생하는 모든 거래와 계약에 대해 스스로 책임을 집니다. 회사는 회원 간의 거래를 중개할 뿐, 계약의 당사자가 아닙니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 5조 (사용자 생성 콘텐츠)</h2>
          <p>1. 회원이 서비스 내에 게시하는 모든 콘텐츠(업무, 프로젝트, 위키 문서, 쇼케이스 게시물 등)에 대한 저작권은 해당 콘텐츠를 게시한 회원에게 있습니다.</p>
          <p>2. 회원은 회사에 서비스 운영, 홍보, 개선을 위해 필요한 범위 내에서 해당 콘텐츠를 사용, 저장, 복제, 수정, 배포할 수 있는 비독점적이고 전 세계적인 라이선스를 부여합니다.</p>

          <h2 className="text-2xl font-semibold border-b pb-2">제 6조 (서비스 이용의 제한 및 정지)</h2>
          <p>회사는 회원이 본 약관의 의무를 위반하거나 서비스의 정상적인 운영을 방해한 경우, 경고, 일시정지, 영구이용정지 등으로 서비스 이용을 단계적으로 제한할 수 있습니다.</p>
          
          <div className="bg-destructive/10 border-l-4 border-destructive p-4 mt-6 rounded-md">
            <p className="font-bold text-destructive">면책 조항</p>
            <p className="text-sm text-destructive-foreground">본 서비스 약관은 `WorklyPlanning.md` 문서를 기반으로 생성된 예시이며, 법적 효력을 갖지 않습니다. 실제 서비스 운영 시에는 반드시 법률 전문가의 검토를 거쳐야 합니다.</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TermsOfServicePage;
</file>

<file path="frontend/src/components/layout/MainContainer.tsx">
'use client'

import { ReactNode } from 'react'

interface MainContainerProps {
  children: ReactNode
  className?: string
}

/**
 * 메인 컨텐츠 영역 컨테이너
 * - 데스크톱: 720px 고정폭, 중앙 정렬
 * - 모바일: 좌우 여백 없이 전체 폭 사용
 */
export default function MainContainer({ children, className = '' }: MainContainerProps) {
  return (
    <main 
      className={`
        w-full 
        max-w-[720px] 
        mx-auto 
        px-0 md:px-0
        ${className}
      `}
      role="main"
    >
      {children}
    </main>
  )
}
</file>

<file path="frontend/src/components/projects/ProjectChatChannel.tsx">
'use client'

import React, { useState, useEffect, useRef } from 'react'
import { Send, Plus, Paperclip, Smile, MoreHorizontal, User, Calendar, Hash, ArrowLeft, PanelRightOpen, PanelRightClose } from 'lucide-react'
import { useRouter } from 'next/navigation'
import { Project, ProjectMember } from '@/types/project.types'
import SlashCommandInput from './SlashCommandInput'
import { useScrollVisibility } from '@/hooks/useScrollVisibility'

// 채팅 메시지 타입
interface ChatMessage {
  id: string
  type: 'message' | 'system' | 'task_created' | 'milestone_update'
  content: string
  userId: string
  user: {
    id: string
    name: string
    avatar?: string
  }
  timestamp: string
  metadata?: any
  isEdited?: boolean
  editedAt?: string
  mentions?: string[]
  attachments?: {
    id: string
    name: string
    type: string
    url: string
    size: number
  }[]
  slashCommandResult?: {
    type: 'task_created' | 'milestone_set' | 'user_delegated'
    data: any
  }
}

interface ProjectChatChannelProps {
  project: Project
  members: ProjectMember[]
  isSidebarOpen?: boolean
  isMobile?: boolean
  onToggleSidebar?: () => void
  onTaskCreate?: (taskData: any) => void
  onMilestoneCreate?: (milestoneData: any) => void
  onUserDelegate?: (delegationData: any) => void
}

export default function ProjectChatChannel({ 
  project, 
  members,
  isSidebarOpen = true,
  isMobile = false,
  onToggleSidebar,
  onTaskCreate,
  onMilestoneCreate,
  onUserDelegate
}: ProjectChatChannelProps) {
  const router = useRouter()
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [newMessage, setNewMessage] = useState('')
  const [isSlashCommandMode, setIsSlashCommandMode] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLInputElement>(null)
  
  // 스크롤 가시성 관리
  const { elementRef: messageScrollRef } = useScrollVisibility({
    hideDelay: 1500,
    showOnHover: true
  })

  // 목업 메시지 데이터
  useEffect(() => {
    const mockMessages: ChatMessage[] = [
      {
        id: '1',
        type: 'system',
        content: `${project.title} 프로젝트 채널에 오신 것을 환영합니다!`,
        userId: 'system',
        user: { id: 'system', name: 'System' },
        timestamp: new Date(Date.now() - 86400000).toISOString(), // 1일 전
      },
      {
        id: '2',
        type: 'message',
        content: '안녕하세요! 프로젝트 킥오프 미팅 일정을 공유드립니다.',
        userId: 'user1',
        user: { id: 'user1', name: '김워클리', avatar: '👤' },
        timestamp: new Date(Date.now() - 3600000).toISOString(), // 1시간 전
      },
      {
        id: '3',
        type: 'task_created',
        content: '/add-task UI 목업 디자인 완료 @김디자이너 2024-01-30',
        userId: 'user2',
        user: { id: 'user2', name: '박매니저', avatar: '👨‍💼' },
        timestamp: new Date(Date.now() - 1800000).toISOString(), // 30분 전
        slashCommandResult: {
          type: 'task_created',
          data: {
            title: 'UI 목업 디자인 완료',
            assignee: '김디자이너',
            dueDate: '2024-01-30'
          }
        }
      },
      {
        id: '4',
        type: 'message',
        content: '네, 확인했습니다! 내일까지 완료하겠습니다.',
        userId: 'user3',
        user: { id: 'user3', name: '김디자이너', avatar: '🎨' },
        timestamp: new Date(Date.now() - 900000).toISOString(), // 15분 전
      }
    ]
    setMessages(mockMessages)
  }, [project.title])

  // 메시지 목록 스크롤 자동 이동
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])


  // 모바일 키보드 감지 및 viewport 처리
  useEffect(() => {
    if (!isMobile) return

    const handleResize = () => {
      const viewport = window.visualViewport
      if (viewport) {
        const keyboardHeight = window.innerHeight - viewport.height
        setIsKeyboardVisible(keyboardHeight > 100)
      }
    }

    const handleFocus = () => {
      if (isMobile) {
        setTimeout(() => {
          messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
        }, 300)
      }
    }

    window.visualViewport?.addEventListener('resize', handleResize)
    inputRef.current?.addEventListener('focus', handleFocus)

    return () => {
      window.visualViewport?.removeEventListener('resize', handleResize)
      inputRef.current?.removeEventListener('focus', handleFocus)
    }
  }, [isMobile])

  // 입력 변화 감지 (슬래시 명령어 모드)
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    setNewMessage(value)
    
    // 슬래시 명령어 감지
    if (value.startsWith('/')) {
      setIsSlashCommandMode(true)
    } else {
      setIsSlashCommandMode(false)
    }
  }

  // 일반 메시지 전송
  const handleSendMessage = async () => {
    if (!newMessage.trim() || isLoading) return

    const message: ChatMessage = {
      id: Date.now().toString(),
      type: 'message',
      content: newMessage,
      userId: 'current_user',
      user: { id: 'current_user', name: '나', avatar: '👤' },
      timestamp: new Date().toISOString(),
    }

    setMessages(prev => [...prev, message])
    setNewMessage('')
    setIsSlashCommandMode(false)
  }

  // 슬래시 명령어 실행
  const handleSlashCommand = async (command: string, params: any) => {
    setIsLoading(true)
    
    try {
      let systemMessage: ChatMessage

      switch (command) {
        case 'add-task':
          systemMessage = {
            id: Date.now().toString(),
            type: 'task_created',
            content: `✅ 새 업무가 생성되었습니다: "${params.title}" → ${params.assignee} (마감: ${params.dueDate})`,
            userId: 'current_user',
            user: { id: 'current_user', name: '나', avatar: '👤' },
            timestamp: new Date().toISOString(),
            slashCommandResult: {
              type: 'task_created',
              data: params
            }
          }
          onTaskCreate?.(params)
          break

        case 'set-milestone':
          systemMessage = {
            id: Date.now().toString(),
            type: 'milestone_update',
            content: `🎯 마일스톤이 설정되었습니다: "${params.name}" (마감: ${params.dueDate})`,
            userId: 'current_user',
            user: { id: 'current_user', name: '나', avatar: '👤' },
            timestamp: new Date().toISOString(),
            slashCommandResult: {
              type: 'milestone_set',
              data: params
            }
          }
          onMilestoneCreate?.(params)
          break

        case 'delegate':
          systemMessage = {
            id: Date.now().toString(),
            type: 'system',
            content: `🔄 업무가 ${params.fromUser}에서 ${params.toUser}로 재할당되었습니다`,
            userId: 'current_user',
            user: { id: 'current_user', name: '나', avatar: '👤' },
            timestamp: new Date().toISOString(),
            slashCommandResult: {
              type: 'user_delegated',
              data: params
            }
          }
          onUserDelegate?.(params)
          break

        default:
          systemMessage = {
            id: Date.now().toString(),
            type: 'system',
            content: `❌ 알 수 없는 명령어: /${command}`,
            userId: 'system',
            user: { id: 'system', name: 'System' },
            timestamp: new Date().toISOString(),
          }
      }

      setMessages(prev => [...prev, systemMessage])
      setNewMessage('')
      setIsSlashCommandMode(false)

    } catch (error) {
      console.error('슬래시 명령어 실행 실패:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // 키보드 이벤트 핸들링
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      if (isSlashCommandMode) {
        // 슬래시 명령어는 SlashCommandInput에서 처리
        return
      }
      handleSendMessage()
    }
  }

  // 메시지 렌더링
  const renderMessage = (message: ChatMessage) => {
    const isSystem = message.type === 'system'
    const isTaskCreated = message.type === 'task_created'
    const isMilestoneUpdate = message.type === 'milestone_update'

    return (
      <div
        key={message.id}
        className={`mb-4 ${isSystem ? 'text-center' : ''}`}
      >
        {isSystem ? (
          <div className="inline-block px-3 py-1 bg-gray-100 rounded-full text-sm text-gray-600">
            {message.content}
          </div>
        ) : (
          <div className="flex items-start space-x-3">
            <div className="flex-shrink-0">
              <div className="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center text-sm font-medium">
                {message.user.avatar || message.user.name.charAt(0)}
              </div>
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center space-x-2 mb-1">
                <span className="font-medium text-gray-900">{message.user.name}</span>
                <span className="text-xs text-gray-500">
                  {new Date(message.timestamp).toLocaleTimeString('ko-KR', {
                    hour: '2-digit',
                    minute: '2-digit'
                  })}
                </span>
              </div>
              <div className={`${
                isTaskCreated || isMilestoneUpdate 
                  ? 'bg-green-50 border border-green-200 rounded-lg p-3' 
                  : ''
              }`}>
                <p className={`text-gray-800 ${
                  isTaskCreated || isMilestoneUpdate ? 'text-green-800' : ''
                }`}>
                  {message.content}
                </p>
                {message.slashCommandResult && (
                  <div className="mt-2 text-xs text-green-600">
                    {message.slashCommandResult.type === 'task_created' && '📝 업무 생성됨'}
                    {message.slashCommandResult.type === 'milestone_set' && '🎯 마일스톤 설정됨'}
                    {message.slashCommandResult.type === 'user_delegated' && '🔄 업무 재할당됨'}
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    )
  }

  return (
    <div className="fixed inset-0 bg-white flex flex-col">
      {/* 채널 헤더 - 상단 고정 */}
      <div className={`fixed top-0 flex-shrink-0 flex items-center justify-between p-4 border-b border-gray-200 bg-white shadow-sm transition-all duration-300 ${
        isMobile || !isSidebarOpen ? 'left-0 right-0' : 'left-0 right-[640px]'
      } z-50`}>
        <div className="flex items-center space-x-3">
          <button
            onClick={() => router.back()}
            className="p-2 hover:bg-gray-100 rounded-lg"
          >
            <ArrowLeft className="w-5 h-5 text-gray-600" />
          </button>
          <Hash className="w-5 h-5 text-gray-500" />
          <div>
            <h2 className="font-semibold text-gray-900">{project.title}</h2>
            <p className="text-sm text-gray-500">{members.length}명의 멤버</p>
          </div>
        </div>
        <div className="flex items-center space-x-2">
          <button className="p-2 hover:bg-gray-100 rounded-lg">
            <Calendar className="w-5 h-5 text-gray-500" />
          </button>
          <button className="p-2 hover:bg-gray-100 rounded-lg">
            <User className="w-5 h-5 text-gray-500" />
          </button>
          <button className="p-2 hover:bg-gray-100 rounded-lg">
            <MoreHorizontal className="w-5 h-5 text-gray-500" />
          </button>
          {onToggleSidebar && (
            <button 
              onClick={onToggleSidebar}
              className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
              title={isSidebarOpen ? "사이드바 닫기" : "사이드바 열기"}
            >
              {isSidebarOpen ? (
                <PanelRightClose className="w-5 h-5 text-gray-500" />
              ) : (
                <PanelRightOpen className="w-5 h-5 text-gray-500" />
              )}
            </button>
          )}
        </div>
      </div>

      {/* 메시지 목록 - 완전 독립적인 스크롤 영역 */}
      <div 
        ref={messageScrollRef}
        className={`fixed overflow-y-auto p-4 space-y-4 scroll-smooth scrollbar-on-hover bg-white transition-all duration-300 ${
          isMobile || !isSidebarOpen ? 'left-0 right-0' : 'left-0 right-[640px]'
        }`} 
        style={{
          top: '80px', // 헤더 바로 아래
          bottom: '80px' // 입력창 바로 위
        }}
      >
        {messages.map(renderMessage)}
        <div ref={messagesEndRef} />
      </div>

      {/* 슬래시 명령어 입력 - 고정 위치 */}
      {isSlashCommandMode && (
        <div className={`fixed z-60 border-t border-gray-200 bg-gray-50 transition-all duration-200 ${
          isMobile || !isSidebarOpen ? 'left-0 right-0' : 'left-0 right-[640px]'
        }`} style={{
          bottom: '80px' // 입력창 바로 위
        }}>
          <SlashCommandInput
            input={newMessage}
            onCommandExecute={handleSlashCommand}
            onCancel={() => {
              setIsSlashCommandMode(false)
              setNewMessage('')
            }}
            members={members}
          />
        </div>
      )}

      {/* 메시지 입력 - 하단 고정 */}
      <div className={`fixed z-55 p-4 border-t border-gray-200 bg-white shadow-lg transition-all duration-200 ${
        isMobile || !isSidebarOpen ? 'left-0 right-0' : 'left-0 right-[640px]'
      }`} style={{
        bottom: '0'
      }}>
        <div className={`flex items-end space-x-3 max-w-full ${
          isMobile ? 'pb-safe' : ''
        }`}>
          <div className="flex-1 relative">
            <input
              ref={inputRef}
              type="text"
              value={newMessage}
              onChange={handleInputChange}
              onKeyDown={handleKeyDown}
              placeholder={isSlashCommandMode ? "슬래시 명령어를 입력하세요..." : `${project.title}에 메시지 보내기...`}
              className={`w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none ${
                isSlashCommandMode ? 'border-blue-300 bg-blue-50' : 'border-gray-300'
              } text-base`}
              disabled={isLoading}
              enterKeyHint="send"
              autoComplete="off"
              autoCorrect="off"
              autoCapitalize="sentences"
            />
          </div>
          <div className="flex items-center space-x-1">
            <button 
              className="p-2 hover:bg-gray-100 rounded-lg transition-colors touch-manipulation"
              type="button"
            >
              <Paperclip className="w-5 h-5 text-gray-500" />
            </button>
            <button 
              className="p-2 hover:bg-gray-100 rounded-lg transition-colors touch-manipulation"
              type="button"
            >
              <Smile className="w-5 h-5 text-gray-500" />
            </button>
            <button
              onClick={handleSendMessage}
              disabled={!newMessage.trim() || isLoading || isSlashCommandMode}
              className="p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-manipulation min-w-[44px] min-h-[44px] flex items-center justify-center"
              type="button"
            >
              <Send className="w-5 h-5" />
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/CollapsibleCalendar.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { ChevronLeftIcon, ChevronRightIcon } from '@heroicons/react/24/outline'
import { useCalendarFilterStore } from '@/lib/stores/calendarFilterStore'

interface CollapsibleCalendarProps {
  isExpanded: boolean
  onDateSelect: (date: Date) => void
  onClose: () => void
  onToggle?: () => void // 수동 토글 기능
  tasksWithDates: { [dateKey: string]: number } // 날짜별 업무 개수
  selectedDate?: Date
  keepOpenOnDrop?: boolean // 드롭 시 달력 유지 여부
  isDragMode?: boolean // 드래그 중인지 여부
}

export default function CollapsibleCalendar({
  isExpanded,
  onDateSelect,
  onClose,
  onToggle,
  tasksWithDates,
  selectedDate,
  keepOpenOnDrop = false,
  isDragMode = false
}: CollapsibleCalendarProps) {
  const [currentMonth, setCurrentMonth] = useState(new Date())
  const [animatingDate, setAnimatingDate] = useState<string | null>(null)
  const calendarRef = useRef<HTMLDivElement>(null)
  
  // 전역 캘린더 필터 상태
  const { showNoDue, showOverdue, setShowNoDue, setShowOverdue } = useCalendarFilterStore()

  // 달력 바깥 클릭 감지
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      // 드래그 중일 때는 외부 클릭으로 달력 닫지 않음
      if (isDragMode) return
      
      if (isExpanded && calendarRef.current && !calendarRef.current.contains(event.target as Node)) {
        // 클릭된 요소가 드래그 가능한 업무 카드인지 확인
        const clickedElement = event.target as HTMLElement
        const taskCard = clickedElement.closest('[draggable="true"]') || clickedElement.closest('.group')
        
        // 업무 카드를 클릭한 경우 달력을 닫지 않음
        if (taskCard) return
        
        onClose()
      }
    }

    if (isExpanded) {
      // 약간의 지연 후 이벤트 리스너 등록 (달력 열림 애니메이션과 충돌 방지)
      const timer = setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside)
      }, 300)
      
      return () => {
        clearTimeout(timer)
        document.removeEventListener('mousedown', handleClickOutside)
      }
    }
  }, [isExpanded, onClose, isDragMode])

  // 현재 월의 달력 데이터 생성
  const generateCalendarDays = (date: Date) => {
    const year = date.getFullYear()
    const month = date.getMonth()
    
    // 월의 첫째 날과 마지막 날
    const firstDay = new Date(year, month, 1)
    const lastDay = new Date(year, month + 1, 0)
    
    // 달력 시작일 (첫째 주 일요일)
    const startDate = new Date(firstDay)
    startDate.setDate(startDate.getDate() - firstDay.getDay())
    
    // 달력 종료일 (마지막 주 토요일)
    const endDate = new Date(lastDay)
    endDate.setDate(endDate.getDate() + (6 - lastDay.getDay()))
    
    const days = []
    const current = new Date(startDate)
    
    while (current <= endDate) {
      days.push(new Date(current))
      current.setDate(current.getDate() + 1)
    }
    
    return days
  }

  // 날짜 키 생성 (YYYY-MM-DD 형식)
  const getDateKey = (date: Date) => {
    return date.toISOString().split('T')[0]
  }

  // 날짜가 오늘인지 확인
  const isToday = (date: Date) => {
    const today = new Date()
    return date.toDateString() === today.toDateString()
  }

  // 날짜가 현재 월에 속하는지 확인
  const isCurrentMonth = (date: Date) => {
    return date.getMonth() === currentMonth.getMonth() && 
           date.getFullYear() === currentMonth.getFullYear()
  }

  // 월 이동
  const navigateMonth = (direction: 'prev' | 'next') => {
    setCurrentMonth(prev => {
      const newDate = new Date(prev)
      newDate.setMonth(prev.getMonth() + (direction === 'next' ? 1 : -1))
      return newDate
    })
  }

  // 날짜 선택 처리
  const handleDateClick = (date: Date) => {
    onDateSelect(date)
    if (!keepOpenOnDrop) {
      onClose()
    }
  }

  // 드래그 앤 드롭 처리
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }

  const handleDrop = (e: React.DragEvent, date: Date) => {
    e.preventDefault()
    const dateKey = getDateKey(date)
    
    // 드롭 성공 애니메이션 시작
    setAnimatingDate(dateKey)
    
    // 날짜 선택 처리
    onDateSelect(date)
    
    // keepOpenOnDrop이 false일 때만 달력 닫기
    if (!keepOpenOnDrop) {
      onClose()
    }
    
    // 2초 후 애니메이션 종료
    setTimeout(() => {
      setAnimatingDate(null)
    }, 2000)
  }

  const calendarDays = generateCalendarDays(currentMonth)
  const weekDays = ['일', '월', '화', '수', '목', '금', '토']

  // 접힌 상태에서의 주간 뷰 (현재 주)
  const getCurrentWeekDays = () => {
    const today = new Date()
    const startOfWeek = new Date(today)
    startOfWeek.setDate(today.getDate() - today.getDay())
    
    const weekDays = []
    for (let i = 0; i < 7; i++) {
      const day = new Date(startOfWeek)
      day.setDate(startOfWeek.getDate() + i)
      weekDays.push(day)
    }
    return weekDays
  }

  const currentWeek = getCurrentWeekDays()

  // 완전 숨기기/보이기만 - 접힌 상태 없음
  if (!isExpanded) {
    return null
  }

  return (
    <div className="relative">
      {/* 전체 월간 캘린더 */}
      <div 
        ref={calendarRef}
        className="bg-white border-t border-gray-200 shadow-lg animate-slide-up"
        style={{
          animation: 'slideUp 0.3s ease-out'
        }}
      >
          <div className="p-4">
            {/* 헤더 */}
            <div className="mb-4">
              {/* 3칸 구조: 스케일 왼쪽여백 | 중앙헤더 | 스케일 오른쪽여백 */}
              <div className="flex mb-3">
                {/* 왼쪽 여백 - 화면 크기에 비례해서 스케일 (일 텍스트 바깥쪽) */}
                <div style={{
                  width: '5vw',
                  minWidth: '16px',
                  maxWidth: '60px'
                }}></div>
                
                {/* 중앙 헤더: 날짜 + 버튼 + 필터 - 가득 채우기 */}
                <div className="flex-1 flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <h3 className="text-lg font-semibold text-gray-900">
                      {currentMonth.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long' })}
                    </h3>
                    <button
                      onClick={() => navigateMonth('prev')}
                      className="p-1.5 hover:bg-gray-100 rounded-full"
                    >
                      <ChevronLeftIcon className="w-4 h-4" />
                    </button>
                    <button
                      onClick={() => navigateMonth('next')}
                      className="p-1.5 hover:bg-gray-100 rounded-full"
                    >
                      <ChevronRightIcon className="w-4 h-4" />
                    </button>
                  </div>
                  
                  <div className="flex gap-2">
                    <button
                      onClick={() => setShowNoDue(!showNoDue)}
                      className={`px-3 py-1.5 text-xs font-medium rounded-full transition-colors ${
                        showNoDue 
                          ? 'bg-blue-500 text-white' 
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`}
                    >
                      마감일 미지정
                    </button>
                    <button
                      onClick={() => setShowOverdue(!showOverdue)}
                      className={`px-3 py-1.5 text-xs font-medium rounded-full transition-colors ${
                        showOverdue 
                          ? 'bg-red-500 text-white' 
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`}
                    >
                      마감일 지남
                    </button>
                  </div>
                </div>
                
                {/* 오른쪽 여백 - 화면 크기에 비례해서 스케일 (토 텍스트 바깐쪽) */}
                <div style={{
                  width: '5vw',
                  minWidth: '16px',
                  maxWidth: '60px'
                }}></div>
              </div>
            </div>

            {/* 요일 헤더 */}
            <div className="grid grid-cols-7 gap-1 mb-2">
              {weekDays.map((day) => (
                <div
                  key={day}
                  className="h-8 flex items-center justify-center text-sm font-medium text-gray-500"
                >
                  {day}
                </div>
              ))}
            </div>

            {/* 달력 그리드 */}
            <div className="grid grid-cols-7 gap-1">
              {calendarDays.map((day, index) => {
                const dateKey = getDateKey(day)
                const taskCount = tasksWithDates[dateKey] || 0
                const isCurrentDay = isToday(day)
                const isInCurrentMonth = isCurrentMonth(day)
                const isSelected = selectedDate && day.toDateString() === selectedDate.toDateString()
                const isAnimating = animatingDate === dateKey
                
                return (
                  <button
                    key={index}
                    onClick={() => handleDateClick(day)}
                    onDragOver={handleDragOver}
                    onDrop={(e) => handleDrop(e, day)}
                    className={`
                      h-12 flex flex-col items-center justify-center text-sm rounded-lg transition-all relative
                      ${isInCurrentMonth ? 'text-gray-900 hover:bg-gray-100' : 'text-gray-400'}
                      ${isCurrentDay ? 'bg-blue-600 text-white hover:bg-blue-700' : ''}
                      ${isSelected ? 'ring-2 ring-blue-500 bg-blue-50' : ''}
                      ${taskCount > 0 && !isCurrentDay ? 'font-semibold' : ''}
                      ${isAnimating ? 'ring-4 ring-blue-400 bg-blue-100 animate-pulse' : ''}
                    `}
                  >
                    <span>{day.getDate()}</span>
                    {taskCount > 0 && !isCurrentDay && (
                      <div className="flex gap-0.5 mt-0.5">
                        {Array.from({ length: Math.min(taskCount, 3) }).map((_, i) => (
                          <div
                            key={i}
                            className="w-1.5 h-1.5 bg-blue-500 rounded-full"
                          />
                        ))}
                        {taskCount > 3 && (
                          <div className="text-xs text-blue-600 ml-1">+</div>
                        )}
                      </div>
                    )}
                    
                    {/* 드롭 성공 체크마크 */}
                    {isAnimating && (
                      <div className="absolute -top-1 -right-1 w-5 h-5 bg-blue-600 text-white rounded-full flex items-center justify-center animate-bounce">
                        <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                        </svg>
                      </div>
                    )}
                  </button>
                )
              })}
            </div>


            {/* 하단 안내 텍스트 */}
            <div className="mt-4 text-center text-sm text-gray-500">
              업무를 드래그해서 날짜를 지정해보세요.
            </div>
          </div>
        </div>

      {/* CSS 애니메이션 */}
      <style jsx>{`
        @keyframes slideUp {
          from {
            transform: translateY(100%);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
        
        .animate-slide-up {
          animation: slideUp 0.3s ease-out;
        }
      `}</style>
    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/TaskCard.tsx">
'use client'

import React from 'react'
import { GTDTask, TaskStatus, TaskPriority } from '@/types/task.types'

interface TaskCardProps {
  task: GTDTask
  isLast?: boolean
  onToggleComplete?: (taskId: string) => void
  onEdit?: (task: GTDTask) => void
  showMomentumScore?: boolean
}

export default function TaskCard({ 
  task, 
  isLast = false, 
  onToggleComplete,
  onEdit,
  showMomentumScore = true 
}: TaskCardProps) {
  const isCompleted = task.status === TaskStatus.DONE
  
  // 우선순위 색상 매핑
  const getPriorityColor = (priority: TaskPriority) => {
    switch (priority) {
      case TaskPriority.URGENT:
        return 'text-red-500 bg-red-50'
      case TaskPriority.HIGH:
        return 'text-blue-500 bg-blue-50'
      case TaskPriority.MEDIUM:
        return 'text-yellow-500 bg-yellow-50'
      case TaskPriority.LOW:
        return 'text-blue-500 bg-blue-50'
      default:
        return 'text-gray-500 bg-gray-50'
    }
  }

  // 마감일 색상 및 텍스트
  const getDueDateInfo = () => {
    if (isCompleted) {
      return { text: '완료됨', color: 'text-green-600' }
    }
    
    if (!task.dueDate) {
      return { text: '마감일 없음', color: 'text-gray-500' }
    }

    const now = new Date()
    const dueDate = new Date(task.dueDate)
    const timeDiff = dueDate.getTime() - now.getTime()
    const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24))

    if (daysDiff < 0) {
      return { text: `${Math.abs(daysDiff)}일 지남`, color: 'text-red-500' }
    } else if (daysDiff === 0) {
      return { text: '오늘 마감', color: 'text-blue-600' }
    } else if (daysDiff === 1) {
      return { text: '내일 마감', color: 'text-blue-500' }
    } else if (daysDiff <= 7) {
      return { text: `${daysDiff}일 남음`, color: 'text-yellow-500' }
    } else {
      const options: Intl.DateTimeFormatOptions = { 
        month: 'short', 
        day: 'numeric' 
      }
      return { 
        text: dueDate.toLocaleDateString('ko-KR', options), 
        color: 'text-gray-500' 
      }
    }
  }

  const dueDateInfo = getDueDateInfo()

  // 모멘텀 점수 시각화
  const renderMomentumScore = () => {
    if (!showMomentumScore || isCompleted) return null

    const score = task.momentumScore.total
    const getScoreColor = (score: number) => {
      if (score >= 8) return 'bg-red-500'
      if (score >= 6) return 'bg-blue-500'
      if (score >= 4) return 'bg-yellow-500'
      return 'bg-gray-400'
    }

    return (
      <div className="flex items-center gap-1">
        <div 
          className={`w-2 h-2 rounded-full ${getScoreColor(score)}`}
          title={`모멘텀 점수: ${score.toFixed(1)}`}
        />
        {score >= 7 && (
          <span className="text-xs text-blue-600 font-medium">우선</span>
        )}
      </div>
    )
  }

  // 프로젝트 진행률 표시
  const renderProjectProgress = () => {
    if (!task.project || isCompleted) return null

    // 임시 진행률 (실제로는 프로젝트에서 계산)
    const progress = 65 // 실제 구현 시 프로젝트 진행률 API에서 가져옴

    return (
      <div className="mt-2">
        <div className="flex items-center gap-2 text-xs text-gray-500">
          <span>{task.project.name}</span>
          <div className="flex-1 bg-gray-200 rounded-full h-1">
            <div 
              className="bg-blue-500 h-1 rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
          <span>{progress}%</span>
        </div>
      </div>
    )
  }

  const handleCheckboxChange = () => {
    if (onToggleComplete) {
      onToggleComplete(task.id)
    }
  }

  const handleCardClick = (e: React.MouseEvent) => {
    // 체크박스 클릭은 제외
    if ((e.target as HTMLElement).type === 'checkbox') {
      return
    }
    
    if (onEdit) {
      onEdit(task)
    }
  }

  return (
    <article 
      className={`p-4 ${!isLast ? 'border-b border-gray-100' : ''} ${
        isCompleted ? 'opacity-60' : ''
      } hover:bg-gray-50 transition-colors cursor-pointer`}
      onClick={handleCardClick}
      aria-labelledby={`task-${task.id}-title`}
      aria-describedby={`task-${task.id}-description task-${task.id}-meta`}
    >
      <div className="flex items-start gap-3">
        {/* 체크박스 */}
        <div className="mt-1">
          <input 
            type="checkbox" 
            checked={isCompleted}
            onChange={handleCheckboxChange}
            className="w-5 h-5 rounded border-2 border-gray-300 
                     checked:bg-green-500 checked:border-green-500 
                     focus:ring-2 focus:ring-green-200 transition-colors"
            aria-label={`${task.title} ${isCompleted ? '완료됨' : '미완료'}`}
            onClick={(e) => e.stopPropagation()}
          />
        </div>
        
        {/* 업무 내용 */}
        <div className="flex-1 min-w-0">
          {/* 제목과 모멘텀 점수 */}
          <div className="flex items-start justify-between gap-2">
            <h3 
              id={`task-${task.id}-title`}
              className={`font-medium text-gray-900 leading-tight ${
                isCompleted ? 'line-through text-gray-500' : ''
              }`}
            >
              {task.title}
            </h3>
            {renderMomentumScore()}
          </div>
          
          {/* 설명 */}
          {task.description && (
            <p 
              id={`task-${task.id}-description`}
              className={`text-sm text-gray-600 mt-1 ${
                isCompleted ? 'line-through' : ''
              }`}
            >
              {task.description}
            </p>
          )}
          
          {/* 메타 정보 */}
          <div id={`task-${task.id}-meta`} className="flex items-center gap-2 mt-3 flex-wrap">
            {/* 우선순위 */}
            <span 
              className={`px-2 py-1 text-xs rounded-full font-medium ${getPriorityColor(task.priority)}`}
              aria-label={`우선순위: ${task.priority}`}
            >
              {task.priority}
            </span>
            
            {/* 마감일 */}
            <span 
              className={`text-xs ${dueDateInfo.color}`}
              aria-label={isCompleted ? '상태: 완료됨' : `마감일: ${dueDateInfo.text}`}
            >
              {dueDateInfo.text}
            </span>
            
            {/* 예상 시간 */}
            {task.estimatedHours && !isCompleted && (
              <span className="text-xs text-gray-500">
                {task.estimatedHours}시간 예상
              </span>
            )}
            
            {/* GTD 컨텍스트 */}
            {task.gtdContext !== 'next' && (
              <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">
                {task.gtdContext === 'inbox' && '수신함'}
                {task.gtdContext === 'waiting' && '대기중'}
                {task.gtdContext === 'someday' && '언젠가'}
              </span>
            )}
          </div>
          
          {/* 프로젝트 진행률 */}
          {renderProjectProgress()}
        </div>
      </div>
    </article>
  )
}
</file>

<file path="frontend/src/components/tasks/TaskPriorityBadge.tsx">
'use client';

import React from 'react';
import { TaskPriority } from '@/types/task.types';
import { ArrowUp, ArrowDown, Minus } from 'lucide-react';

interface TaskPriorityBadgeProps {
  priority: TaskPriority;
  size?: 'sm' | 'md' | 'lg';
  showIcon?: boolean;
  showLabel?: boolean;
}

const priorityConfig = {
  low: {
    label: '낮음',
    bgColor: 'bg-gray-50',
    textColor: 'text-gray-500',
    borderColor: 'border-gray-200',
    icon: ArrowDown,
    iconColor: 'text-gray-400',
  },
  medium: {
    label: '보통',
    bgColor: 'bg-gray-100',
    textColor: 'text-gray-600',
    borderColor: 'border-gray-200',
    icon: Minus,
    iconColor: 'text-gray-500',
  },
  high: {
    label: '높음',
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-600',
    borderColor: 'border-blue-200',
    icon: ArrowUp,
    iconColor: 'text-blue-600',
  },
  urgent: {
    label: '긴급',
    bgColor: 'bg-blue-600',
    textColor: 'text-white',
    borderColor: 'border-blue-600',
    icon: ArrowUp,
    iconColor: 'text-white',
  },
};

const sizeConfig = {
  sm: {
    container: 'px-2 py-1 text-xs',
    icon: 'w-3 h-3',
  },
  md: {
    container: 'px-3 py-1 text-sm',
    icon: 'w-4 h-4',
  },
  lg: {
    container: 'px-4 py-2 text-base',
    icon: 'w-5 h-5',
  },
};

export default function TaskPriorityBadge({ 
  priority, 
  size = 'md', 
  showIcon = true,
  showLabel = true
}: TaskPriorityBadgeProps) {
  const config = priorityConfig[priority];
  const sizeClass = sizeConfig[size];
  const IconComponent = config.icon;

  return (
    <span
      className={`inline-flex items-center rounded-md font-medium border ${config.bgColor} ${config.textColor} ${config.borderColor} ${sizeClass.container}`}
    >
      {showIcon && (
        <IconComponent 
          className={`${sizeClass.icon} ${config.iconColor} ${showLabel ? 'mr-1' : ''}`}
        />
      )}
      {showLabel && config.label}
    </span>
  );
}
</file>

<file path="frontend/src/components/tasks/TaskStatusBadge.tsx">
'use client';

import React from 'react';
import { TaskStatus } from '@/types/task.types';

interface TaskStatusBadgeProps {
  status: TaskStatus;
  size?: 'sm' | 'md' | 'lg';
  showIcon?: boolean;
}

const statusConfig = {
  todo: {
    label: '할 일',
    bgColor: 'bg-gray-50',
    textColor: 'text-gray-700',
    icon: '📋',
  },
  in_progress: {
    label: '진행 중',
    bgColor: 'bg-blue-100',
    textColor: 'text-blue-600',
    icon: '🔄',
  },
  in_review: {
    label: '검토',
    bgColor: 'bg-gray-100',
    textColor: 'text-gray-600',
    icon: '👀',
  },
  done: {
    label: '완료',
    bgColor: 'bg-green-100',
    textColor: 'text-green-600',
    icon: '✅',
  },
  blocked: {
    label: '차단됨',
    bgColor: 'bg-gray-100',
    textColor: 'text-gray-500',
    icon: '🚫',
  },
  cancelled: {
    label: '취소됨',
    bgColor: 'bg-gray-50',
    textColor: 'text-gray-500',
    icon: '❌',
  },
};

const sizeConfig = {
  sm: 'px-2 py-1 text-xs',
  md: 'px-3 py-1 text-sm',
  lg: 'px-4 py-2 text-base',
};

export default function TaskStatusBadge({ 
  status, 
  size = 'md', 
  showIcon = true 
}: TaskStatusBadgeProps) {
  const config = statusConfig[status];
  const sizeClass = sizeConfig[size];

  return (
    <span
      className={`inline-flex items-center rounded-full font-medium ${config.bgColor} ${config.textColor} ${sizeClass}`}
    >
      {showIcon && (
        <span className="mr-1">{config.icon}</span>
      )}
      {config.label}
    </span>
  );
}
</file>

<file path="frontend/src/components/tasks/TaskStatusSelector.tsx">
'use client';

import React, { useState } from 'react';
import { ChevronDown, Check } from 'lucide-react';
import { TaskStatus } from '@/types/task.types';
import TaskStatusBadge from './TaskStatusBadge';

interface TaskStatusSelectorProps {
  currentStatus: TaskStatus;
  onStatusChange: (status: TaskStatus) => void;
  disabled?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

const statusOptions: TaskStatus[] = [
  TaskStatus.TODO,
  TaskStatus.IN_PROGRESS, 
  TaskStatus.IN_REVIEW,
  TaskStatus.DONE,
  TaskStatus.BLOCKED,
  TaskStatus.CANCELLED
];

const statusLabels = {
  [TaskStatus.TODO]: '할 일',
  [TaskStatus.IN_PROGRESS]: '진행 중',
  [TaskStatus.IN_REVIEW]: '검토',
  [TaskStatus.DONE]: '완료',
  [TaskStatus.BLOCKED]: '차단됨',
  [TaskStatus.CANCELLED]: '취소됨',
};

export default function TaskStatusSelector({
  currentStatus,
  onStatusChange,
  disabled = false,
  size = 'md'
}: TaskStatusSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);

  const handleStatusSelect = (status: TaskStatus) => {
    onStatusChange(status);
    setIsOpen(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      setIsOpen(!isOpen);
    } else if (e.key === 'Escape') {
      setIsOpen(false);
    }
  };

  return (
    <div className="relative inline-block">
      <button
        type="button"
        onClick={() => !disabled && setIsOpen(!isOpen)}
        onKeyDown={handleKeyDown}
        disabled={disabled}
        className={`inline-flex items-center space-x-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded-lg ${
          disabled ? 'cursor-not-allowed opacity-50' : 'cursor-pointer hover:opacity-80'
        }`}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
      >
        <TaskStatusBadge status={currentStatus} size={size} />
        {!disabled && (
          <ChevronDown 
            className={`w-4 h-4 text-gray-400 transition-transform duration-200 ${
              isOpen ? 'transform rotate-180' : ''
            }`}
          />
        )}
      </button>

      {isOpen && !disabled && (
        <>
          {/* 오버레이 */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />
          
          {/* 드롭다운 메뉴 */}
          <div className="absolute right-0 z-20 mt-2 w-40 bg-white rounded-lg shadow-lg border border-gray-200 py-1">
            <div className="max-h-60 overflow-auto scrollbar-on-hover">
              {statusOptions.map((status) => (
                <button
                  key={status}
                  type="button"
                  onClick={() => handleStatusSelect(status)}
                  className={`w-full px-3 py-2 text-left text-sm hover:bg-gray-50 focus:bg-gray-50 focus:outline-none flex items-center justify-between ${
                    status === currentStatus ? 'bg-blue-50' : ''
                  }`}
                  role="option"
                  aria-selected={status === currentStatus}
                >
                  <span className="flex items-center space-x-2">
                    <TaskStatusBadge status={status} size="sm" showIcon={false} />
                  </span>
                  {status === currentStatus && (
                    <Check className="w-4 h-4 text-blue-600" />
                  )}
                </button>
              ))}
            </div>
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/ui/Card.tsx">
import React from 'react';
import { cn } from '@/lib/utils';

export interface CardProps extends React.HTMLAttributes<HTMLDivElement> {}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'rounded-lg border border-gray-200 bg-white shadow-sm hover:shadow-md transition-shadow',
        className
      )}
      {...props}
    />
  )
);
Card.displayName = 'Card';

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('p-4', className)}
      {...props}
    />
  )
);
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn(
        'font-medium text-gray-900 mb-1',
        className
      )}
      {...props}
    />
  )
);
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p
      ref={ref}
      className={cn('text-sm text-gray-500', className)}
      {...props}
    />
  )
);
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('p-4', className)} {...props} />
  )
);
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex items-center p-4 pt-0', className)}
      {...props}
    />
  )
);
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="frontend/src/components/ui/FilterChips.tsx">
'use client'

import { ReactNode, useRef, useEffect, useState } from 'react'
import { ChevronDownIcon, XMarkIcon, FunnelIcon, AdjustmentsHorizontalIcon } from '@heroicons/react/24/outline'

interface FilterOption {
  key: string
  label: string
  count?: number
  icon?: ReactNode
  color?: 'blue' | 'green' | 'purple' | 'orange' | 'red' | 'gray'
}

interface FilterChipsProps {
  options: FilterOption[]
  activeFilter: string
  onFilterChange: (filter: string) => void
  className?: string
  variant?: 'compact' | 'comfortable' | 'spacious'
  style?: 'modern' | 'minimal' | 'glassmorphism' | 'neumorphism'
  showClearAll?: boolean
  maxVisibleItems?: number
  sortable?: boolean
  filterSettings?: {
    title: string
    settings: Array<{
      key: string
      label: string
      type: 'toggle' | 'select' | 'range'
      value?: any
      options?: string[]
      onChange: (value: any) => void
    }>
  }
}

/**
 * 최신 트렌드 통합 필터 칩 컴포넌트
 * - 반응형 디자인 (모바일/데스크톱 통일)
 * - 다양한 스타일 변형 지원
 * - 스마트 오버플로우 처리
 * - 접근성 최적화
 */
export default function FilterChips({ 
  options, 
  activeFilter, 
  onFilterChange,
  className = '',
  variant = 'comfortable',
  style = 'modern',
  showClearAll = false,
  maxVisibleItems,
  sortable = false,
  filterSettings
}: FilterChipsProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const [showOverflow, setShowOverflow] = useState(false)
  const [overflowItems, setOverflowItems] = useState<FilterOption[]>([])
  const [visibleItems, setVisibleItems] = useState<FilterOption[]>(options)
  const [showFilterSettings, setShowFilterSettings] = useState(false)

  // 오버플로우 처리
  useEffect(() => {
    if (maxVisibleItems && options.length > maxVisibleItems) {
      setVisibleItems(options.slice(0, maxVisibleItems))
      setOverflowItems(options.slice(maxVisibleItems))
    } else {
      setVisibleItems(options)
      setOverflowItems([])
    }
  }, [options, maxVisibleItems])

  // 활성 필터로 자동 스크롤
  useEffect(() => {
    if (scrollContainerRef.current) {
      const activeElement = scrollContainerRef.current.querySelector(`[data-filter="${activeFilter}"]`)
      if (activeElement) {
        activeElement.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center'
        })
      }
    }
  }, [activeFilter])

  // 색상별 클래스
  const getColorClasses = (color: string, isActive: boolean) => {
    const colors = {
      blue: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      green: {
        active: 'bg-gradient-to-r from-green-500 to-green-600 text-white shadow-lg shadow-green-500/25',
        inactive: 'text-green-600 hover:bg-green-50 border-green-200 hover:border-green-300'
      },
      purple: {
        active: 'bg-gradient-to-r from-purple-500 to-purple-600 text-white shadow-lg shadow-purple-500/25',
        inactive: 'text-purple-600 hover:bg-purple-50 border-purple-200 hover:border-purple-300'
      },
      orange: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      red: {
        active: 'bg-gradient-to-r from-red-500 to-red-600 text-white shadow-lg shadow-red-500/25',
        inactive: 'text-red-600 hover:bg-red-50 border-red-200 hover:border-red-300'
      },
      gray: {
        active: 'bg-gradient-to-r from-gray-500 to-gray-600 text-white shadow-lg shadow-gray-500/25',
        inactive: 'text-gray-600 hover:bg-gray-50 border-gray-200 hover:border-gray-300'
      }
    }
    
    return colors[color as keyof typeof colors] || colors.gray
  }

  // 스타일 변형별 클래스
  const getStyleClasses = () => {
    switch (style) {
      case 'minimal':
        return {
          container: 'bg-transparent',
          active: 'bg-gray-900 text-white border-gray-900',
          inactive: 'bg-transparent text-gray-600 hover:text-gray-900 border border-gray-300 hover:border-gray-400',
          badge: 'bg-white/20 text-white'
        }
      case 'glassmorphism':
        return {
          container: 'bg-white/10 backdrop-blur-lg',
          active: 'bg-white/20 text-gray-900 border-white/30 backdrop-blur-sm',
          inactive: 'bg-white/5 text-gray-700 hover:bg-white/10 border border-white/20 hover:border-white/30 backdrop-blur-sm',
          badge: 'bg-white/30 text-gray-900'
        }
      case 'neumorphism':
        return {
          container: 'bg-gray-100',
          active: 'bg-gray-100 text-gray-900 shadow-inner border-none',
          inactive: 'bg-gray-100 text-gray-600 hover:text-gray-900 shadow-lg hover:shadow-xl border-none',
          badge: 'bg-gray-200 text-gray-700'
        }
      default: // modern
        return {
          container: 'bg-gradient-to-r from-gray-50/50 to-white/50',
          active: 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg shadow-blue-500/25 border-none',
          inactive: 'bg-white text-gray-600 hover:text-gray-900 hover:bg-gray-50 border border-gray-200 hover:border-gray-300 hover:shadow-md',
          badge: 'bg-white/20 text-white'
        }
    }
  }

  // 변형별 패딩 클래스
  const getVariantClasses = () => {
    switch (variant) {
      case 'compact':
        return 'px-3 py-1.5 text-xs'
      case 'spacious':
        return 'px-6 py-3 text-base'
      default: // comfortable
        return 'px-4 py-2 text-sm'
    }
  }

  const styleClasses = getStyleClasses()
  const variantClasses = getVariantClasses()

  const handleClearAll = () => {
    onFilterChange('')
  }

  const renderChip = (option: FilterOption, isOverflow = false) => {
    const isActive = activeFilter === option.key
    const colorClasses = option.color ? getColorClasses(option.color, isActive) : null
    
    return (
      <button
        key={option.key}
        data-filter={option.key}
        onClick={() => onFilterChange(option.key)}
        className={`
          flex-shrink-0
          ${variantClasses}
          font-medium
          rounded-full
          transition-all duration-300
          flex items-center gap-2
          min-w-max
          transform hover:scale-105 active:scale-95
          focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
          ${
            colorClasses
              ? isActive 
                ? `${colorClasses.active} border-none`
                : `bg-white ${colorClasses.inactive} border`
              : isActive
                ? styleClasses.active
                : styleClasses.inactive
          }
          ${isOverflow ? 'w-full justify-start' : ''}
        `}
        aria-pressed={isActive}
        role="button"
      >
      {option.icon && (
        <span className="w-4 h-4 flex items-center justify-center flex-shrink-0">
          {option.icon}
        </span>
      )}
      <span className="whitespace-nowrap">{option.label}</span>
      {option.count !== undefined && option.count > 0 && (
        <span 
          className={`
            text-xs 
            min-w-[20px] 
            h-5
            rounded-full 
            flex 
            items-center 
            justify-center 
            font-semibold
            flex-shrink-0
            ${
              isActive 
                ? 'bg-white/20 text-white'
                : 'bg-gray-100 text-gray-600'
            }
          `}
        >
          {option.count > 999 ? '999+' : option.count}
        </span>
      )}
      </button>
    )
  }

  return (
    <div className={`relative ${styleClasses.container} ${className}`}>
      {/* 데스크톱: 가로 스크롤 + 오버플로우 */}
      <div className="hidden md:block">
        <div className="flex items-center gap-3 px-6 py-4">
          {/* 메인 필터 칩들 */}
          <div 
            ref={scrollContainerRef}
            className="flex space-x-2 overflow-x-auto scrollbar-hide flex-1"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {visibleItems.map((option) => renderChip(option))}
          </div>

          {/* 오버플로우 메뉴 */}
          {overflowItems.length > 0 && (
            <div className="relative">
              <button
                onClick={() => setShowOverflow(!showOverflow)}
                className={`
                  ${variantClasses}
                  ${styleClasses.inactive}
                  rounded-full
                  transition-all duration-300
                  flex items-center gap-1
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                `}
                aria-expanded={showOverflow}
                aria-haspopup="true"
              >
                <FunnelIcon className="w-4 h-4" />
                <span>+{overflowItems.length}</span>
                <ChevronDownIcon className={`w-3 h-3 transition-transform ${showOverflow ? 'rotate-180' : ''}`} />
              </button>

              {showOverflow && (
                <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[200px] py-2 z-50">
                  <div className="space-y-1 px-2">
                    {overflowItems.map((option) => renderChip(option, true))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* 필터 설정 버튼 */}
          {filterSettings && (
            <div className="relative">
              <button
                onClick={() => setShowFilterSettings(!showFilterSettings)}
                className={`
                  text-gray-600 hover:text-gray-900 hover:bg-gray-50
                  border border-gray-300 hover:border-gray-400
                  rounded-full
                  transition-all duration-300
                  flex items-center justify-center
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                  w-11 h-11
                  min-w-[2.75rem]
                  p-0
                  bg-white
                  shadow-sm
                `}
                aria-expanded={showFilterSettings}
                aria-haspopup="true"
                aria-label="필터 설정"
              >
                <AdjustmentsHorizontalIcon className="w-5 h-5" />
              </button>

              {showFilterSettings && (
                <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[280px] p-4 z-50">
                  <div className="mb-3">
                    <h3 className="text-sm font-semibold text-gray-900">{filterSettings.title}</h3>
                  </div>
                  <div className="space-y-3">
                    {filterSettings.settings.map((setting) => (
                      <div key={setting.key} className="flex items-center justify-between">
                        <label className="text-sm text-gray-700">{setting.label}</label>
                        {setting.type === 'toggle' && (
                          <button
                            onClick={() => setting.onChange(!setting.value)}
                            className={`
                              w-10 h-6 rounded-full transition-colors relative
                              ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
                            `}
                          >
                            <div className={`
                              w-4 h-4 bg-white rounded-full absolute top-1 transition-transform
                              ${setting.value ? 'translate-x-5' : 'translate-x-1'}
                            `} />
                          </button>
                        )}
                        {setting.type === 'select' && setting.options && (
                          <select 
                            value={setting.value || ''}
                            onChange={(e) => setting.onChange(e.target.value)}
                            className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
                          >
                            {setting.options.map((option) => (
                              <option key={option} value={option}>
                                {option === 'deadline' ? '마감일순' :
                                 option === 'priority' ? '우선순위순' :
                                 option === 'created' ? '생성일순' :
                                 option === 'updated' ? '수정일순' :
                                 option === 'latest' ? '최신순' :
                                 option === 'popular' ? '인기순' :
                                 option === 'comments' ? '댓글순' :
                                 option === 'views' ? '조회순' :
                                 option === 'recent' ? '최근순' :
                                 option === 'progress' ? '진행률순' :
                                 option === 'members' ? '멤버순' :
                                 option}
                              </option>
                            ))}
                          </select>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* 모바일: 가로 스크롤 + 필터 설정 버튼 */}
      <div className="md:hidden">
        {/* 향상된 그라디언트 페이드 효과 */}
        <div className="absolute left-0 top-0 bottom-0 w-6 bg-gradient-to-r from-gray-50 via-gray-50/80 to-transparent pointer-events-none z-10" />
        <div className="absolute right-0 top-0 bottom-0 w-6 bg-gradient-to-l from-white via-white/80 to-transparent pointer-events-none z-10" />
        
        <div className="flex items-center gap-3">
          <div 
            ref={scrollContainerRef}
            className="flex space-x-3 overflow-x-auto scrollbar-hide px-4 py-3 flex-1"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {options.map((option) => renderChip(option))}
          </div>
          
          {/* 모바일 필터 설정 버튼 */}
          {filterSettings && (
            <div className="pr-4">
              <button
                onClick={() => setShowFilterSettings(!showFilterSettings)}
                className={`
                  text-gray-600 hover:text-gray-900 hover:bg-gray-50
                  border border-gray-300 hover:border-gray-400
                  rounded-full
                  transition-all duration-300
                  flex items-center justify-center
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                  w-11 h-11
                  min-w-[2.75rem]
                  p-0
                  bg-white
                  shadow-sm
                `}
                aria-expanded={showFilterSettings}
                aria-haspopup="true"
                aria-label="필터 설정"
              >
                <AdjustmentsHorizontalIcon className="w-5 h-5" />
              </button>
            </div>
          )}
        </div>
      </div>
      
      {/* 모바일 바텀시트 필터 설정 모달 */}
      {filterSettings && showFilterSettings && (
        <div className="md:hidden fixed inset-0 z-[60] flex items-end">
          <div 
            className="absolute inset-0 bg-black bg-opacity-25" 
            onClick={() => setShowFilterSettings(false)}
          />
          <div className="relative bg-white w-full max-h-[70vh] rounded-t-xl shadow-xl">
            {/* 모달 헤더 */}
            <div className="flex items-center justify-between p-4 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-900">{filterSettings.title}</h3>
              <button
                onClick={() => setShowFilterSettings(false)}
                className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-gray-100"
              >
                <XMarkIcon className="w-5 h-5 text-gray-400" />
              </button>
            </div>
            
            {/* 모달 콘텐츠 */}
            <div className="p-4 space-y-4 max-h-[50vh] overflow-y-auto">
              {filterSettings.settings.map((setting) => (
                <div key={setting.key} className="flex items-center justify-between py-2">
                  <label className="text-sm font-medium text-gray-700">{setting.label}</label>
                  {setting.type === 'toggle' && (
                    <button
                      onClick={() => setting.onChange(!setting.value)}
                      className={`
                        w-12 h-7 rounded-full transition-colors relative
                        ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
                      `}
                    >
                      <div className={`
                        w-5 h-5 bg-white rounded-full absolute top-1 transition-transform
                        ${setting.value ? 'translate-x-6' : 'translate-x-1'}
                      `} />
                    </button>
                  )}
                  {setting.type === 'select' && setting.options && (
                    <select 
                      value={setting.value || ''}
                      onChange={(e) => setting.onChange(e.target.value)}
                      className="text-sm border border-gray-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-[120px]"
                    >
                      {setting.options.map((option) => (
                        <option key={option} value={option}>
                          {option === 'deadline' ? '마감일순' :
                           option === 'priority' ? '우선순위순' :
                           option === 'created' ? '생성일순' :
                           option === 'updated' ? '수정일순' :
                           option === 'latest' ? '최신순' :
                           option === 'popular' ? '인기순' :
                           option === 'comments' ? '댓글순' :
                           option === 'views' ? '조회순' :
                           option === 'recent' ? '최근순' :
                           option === 'progress' ? '진행률순' :
                           option === 'members' ? '멤버순' :
                           option}
                        </option>
                      ))}
                    </select>
                  )}
                </div>
              ))}
            </div>
            
            {/* 모달 푸터 */}
            <div className="p-4 border-t border-gray-200">
              <button
                onClick={() => setShowFilterSettings(false)}
                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
              >
                적용
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/FilterManager.tsx">
'use client'

import { ReactNode, useRef, useEffect, useState } from 'react'
import { ChevronDownIcon, XMarkIcon, AdjustmentsHorizontalIcon, PlusIcon } from '@heroicons/react/24/outline'

// 필터 조건 인터페이스
interface FilterCondition {
  key: string
  operator: 'equals' | 'contains' | 'range' | 'in' | 'boolean'
  value: any
  label: string
}

// 필터 칩 인터페이스
interface FilterChip {
  id: string
  label: string
  isDefault: boolean // 기본 칩 여부 (삭제 불가)
  conditions: FilterCondition[]
  count?: number
  color?: 'blue' | 'green' | 'purple' | 'orange' | 'red' | 'gray'
  icon?: ReactNode
  removable: boolean
}

// 필터 설정 옵션
interface FilterSetting {
  key: string
  label: string
  type: 'toggle' | 'select' | 'multi-select' | 'range' | 'tag-selector' | 'date-range' | 'text'
  value?: any
  options?: string[] | Array<{key: string, label: string}>
  placeholder?: string
  validation?: (value: any) => boolean
  onChange: (value: any) => void
}

// 칩 이름 생성 규칙
interface ChipNamingRule {
  conditions: Array<{key: string, operator?: string}>
  getName: (conditions: FilterCondition[]) => string
  getColor: () => FilterChip['color']
}

interface FilterManagerProps {
  // 기본 칩들 (필수)
  defaultChips: Omit<FilterChip, 'removable'>[]
  
  // 현재 활성 칩
  activeChipId: string
  onChipChange: (chipId: string) => void
  
  // 필터 설정들
  settings: FilterSetting[]
  settingsTitle?: string
  
  // 칩 생성 규칙들
  namingRules?: ChipNamingRule[]
  
  // 데이터 카운트 함수 (칩별 개수 계산)
  getChipCount?: (conditions: FilterCondition[]) => number
  
  // 스타일 옵션
  className?: string
  variant?: 'compact' | 'comfortable' | 'spacious'
  style?: 'modern' | 'minimal' | 'glassmorphism'
}

export default function FilterManager({
  defaultChips,
  activeChipId,
  onChipChange,
  settings,
  settingsTitle = '필터 설정',
  namingRules = [],
  getChipCount,
  className = '',
  variant = 'comfortable',
  style = 'modern'
}: FilterManagerProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const [showSettings, setShowSettings] = useState(false)
  const [customChips, setCustomChips] = useState<FilterChip[]>([])
  
  // 모든 칩들 (기본 + 커스텀)
  const allChips = [
    ...defaultChips.map(chip => ({ ...chip, removable: false })),
    ...customChips
  ]

  // 활성 칩으로 자동 스크롤
  useEffect(() => {
    if (scrollContainerRef.current) {
      const activeElement = scrollContainerRef.current.querySelector(`[data-chip-id="${activeChipId}"]`)
      if (activeElement) {
        activeElement.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center'
        })
      }
    }
  }, [activeChipId])

  // 칩 이름 자동 생성
  const generateChipName = (conditions: FilterCondition[]): string => {
    for (const rule of namingRules) {
      const matches = rule.conditions.every(ruleCondition => 
        conditions.some(condition => 
          condition.key === ruleCondition.key && 
          (!ruleCondition.operator || condition.operator === ruleCondition.operator)
        )
      )
      if (matches) {
        return rule.getName(conditions)
      }
    }
    
    // 기본 이름 생성
    if (conditions.length === 1) {
      return conditions[0].label
    } else if (conditions.length === 2) {
      return `${conditions[0].label} + ${conditions[1].label}`
    } else {
      return `복합 필터 (${conditions.length}개 조건)`
    }
  }

  // 칩 색상 자동 결정
  const generateChipColor = (conditions: FilterCondition[]): FilterChip['color'] => {
    for (const rule of namingRules) {
      const matches = rule.conditions.every(ruleCondition => 
        conditions.some(condition => condition.key === ruleCondition.key)
      )
      if (matches) {
        return rule.getColor()
      }
    }
    return 'blue' // 기본 색상
  }

  // 새 칩 생성 (필터 설정에서 조건이 변경될 때)
  const createChipFromConditions = () => {
    const conditions: FilterCondition[] = []
    
    // 설정들을 조건으로 변환
    settings.forEach(setting => {
      if (setting.value !== undefined && setting.value !== '' && setting.value !== false) {
        if (setting.type === 'toggle' && setting.value) {
          conditions.push({
            key: setting.key,
            operator: 'boolean',
            value: true,
            label: setting.label
          })
        } else if (setting.type === 'select' && setting.value !== 'all') {
          conditions.push({
            key: setting.key,
            operator: 'equals',
            value: setting.value,
            label: `${setting.label}: ${getOptionLabel(setting.value)}`
          })
        } else if (setting.type === 'multi-select' && Array.isArray(setting.value) && setting.value.length > 0) {
          conditions.push({
            key: setting.key,
            operator: 'in',
            value: setting.value,
            label: `${setting.label}: ${setting.value.map(v => getOptionLabel(v)).join(', ')}`
          })
        } else if (setting.type === 'tag-selector' && Array.isArray(setting.value) && setting.value.length > 0) {
          conditions.push({
            key: setting.key,
            operator: 'in',
            value: setting.value,
            label: `${setting.label}: ${setting.value.map(v => getOptionLabel(v)).join(', ')}`
          })
        } else if (setting.type === 'range' && Array.isArray(setting.value)) {
          const [min, max] = setting.value
          if (min > 0 || max < 100) {
            conditions.push({
              key: setting.key,
              operator: 'range',
              value: setting.value,
              label: `${setting.label}: ${min}-${max}`
            })
          }
        }
      }
    })

    if (conditions.length === 0) return

    // 이미 같은 조건의 칩이 있는지 확인
    const existingChip = customChips.find(chip => 
      chip.conditions.length === conditions.length &&
      chip.conditions.every(condition => 
        conditions.some(newCondition => 
          newCondition.key === condition.key && 
          newCondition.operator === condition.operator &&
          JSON.stringify(newCondition.value) === JSON.stringify(condition.value)
        )
      )
    )

    if (existingChip) {
      // 기존 칩 활성화
      onChipChange(existingChip.id)
      return
    }

    // 새 칩 생성
    const newChip: FilterChip = {
      id: `custom-${Date.now()}`,
      label: generateChipName(conditions),
      isDefault: false,
      conditions,
      count: getChipCount ? getChipCount(conditions) : undefined,
      color: generateChipColor(conditions),
      removable: true
    }

    setCustomChips(prev => [...prev, newChip])
    onChipChange(newChip.id)
  }

  // 칩 삭제
  const removeChip = (chipId: string) => {
    setCustomChips(prev => prev.filter(chip => chip.id !== chipId))
    
    // 삭제된 칩이 현재 활성 칩이면 기본 칩으로 변경
    if (activeChipId === chipId) {
      onChipChange(defaultChips[0]?.id || 'all')
    }
  }

  // 옵션 라벨 가져오기
  const getOptionLabel = (value: string) => {
    const labels: { [key: string]: string } = {
      'deadline': '마감일순',
      'priority': '우선순위순',
      'created': '생성일순',
      'updated': '수정일순',
      'momentum': '모멘텀 점수순',
      'energy': '에너지 레벨순',
      'latest': '최신순',
      'popular': '인기순',
      'comments': '댓글순',
      'views': '조회순',
      'recent': '최근순',
      'progress': '진행률순',
      'members': '멤버순',
      'objectives': 'OKR 진행률순',
      'all': '전체',
      'recruiting': '모집 중',
      'closed': '모집 완료',
      '24h': '24시간 이내',
      '7d': '7일 이내',
      '30d': '30일 이내',
      '1-2명': '1-2명',
      '3-5명': '3-5명',
      '6명 이상': '6명 이상',
      'fixed': '고정 금액',
      'hourly': '시간제',
      'beginner': '초급',
      'intermediate': '중급',
      'advanced': '고급',
      'tutorial': '튜토리얼',
      'guide': '가이드',
      'reference': '참고자료',
      'template': '템플릿',
      'individual': '개인',
      'small': '2-3명',
      'large': '4명+',
      'prototype': '프로토타입',
      'mvp': 'MVP',
      'complete': '완제품'
    }
    return labels[value] || value
  }

  // 색상별 클래스
  const getColorClasses = (color: string, isActive: boolean) => {
    const colors = {
      blue: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      green: {
        active: 'bg-gradient-to-r from-green-500 to-green-600 text-white shadow-lg shadow-green-500/25',
        inactive: 'text-green-600 hover:bg-green-50 border-green-200 hover:border-green-300'
      },
      purple: {
        active: 'bg-gradient-to-r from-purple-500 to-purple-600 text-white shadow-lg shadow-purple-500/25',
        inactive: 'text-purple-600 hover:bg-purple-50 border-purple-200 hover:border-purple-300'
      },
      orange: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      red: {
        active: 'bg-gradient-to-r from-red-500 to-red-600 text-white shadow-lg shadow-red-500/25',
        inactive: 'text-red-600 hover:bg-red-50 border-red-200 hover:border-red-300'
      },
      gray: {
        active: 'bg-gradient-to-r from-gray-500 to-gray-600 text-white shadow-lg shadow-gray-500/25',
        inactive: 'text-gray-600 hover:bg-gray-50 border-gray-200 hover:border-gray-300'
      }
    }
    
    return colors[color as keyof typeof colors] || colors.gray
  }

  // 변형별 패딩 클래스
  const getVariantClasses = () => {
    switch (variant) {
      case 'compact':
        return 'px-3 py-1.5 text-xs'
      case 'spacious':
        return 'px-6 py-3 text-base'
      default: // comfortable
        return 'px-4 py-2 text-sm'
    }
  }

  const variantClasses = getVariantClasses()

  const renderChip = (chip: FilterChip) => {
    const isActive = activeChipId === chip.id
    const colorClasses = chip.color ? getColorClasses(chip.color, isActive) : null
    
    return (
      <div key={chip.id} className="flex items-center gap-1">
        <button
          data-chip-id={chip.id}
          onClick={() => onChipChange(chip.id)}
          className={`
            flex-shrink-0
            ${variantClasses}
            font-medium
            rounded-full
            transition-all duration-300
            flex items-center gap-2
            min-w-max
            transform hover:scale-105 active:scale-95
            focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
            ${
              colorClasses
                ? isActive 
                  ? `${colorClasses.active} border-none`
                  : `bg-white ${colorClasses.inactive} border`
                : isActive
                  ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg shadow-blue-500/25 border-none'
                  : 'bg-white text-gray-600 hover:text-gray-900 hover:bg-gray-50 border border-gray-200 hover:border-gray-300 hover:shadow-md'
            }
          `}
          aria-pressed={isActive}
          role="button"
        >
          {chip.icon && (
            <span className="w-4 h-4 flex items-center justify-center flex-shrink-0">
              {chip.icon}
            </span>
          )}
          <span className="whitespace-nowrap">{chip.label}</span>
          {chip.count !== undefined && chip.count > 0 && (
            <span 
              className={`
                text-xs 
                min-w-[20px] 
                h-5
                rounded-full 
                flex 
                items-center 
                justify-center 
                font-semibold
                flex-shrink-0
                ${
                  isActive 
                    ? 'bg-white/20 text-white'
                    : 'bg-gray-100 text-gray-600'
                }
              `}
            >
              {chip.count > 999 ? '999+' : chip.count}
            </span>
          )}
        </button>
        
        {/* 삭제 버튼 */}
        {chip.removable && (
          <button
            onClick={(e) => {
              e.stopPropagation()
              removeChip(chip.id)
            }}
            className="w-5 h-5 rounded-full bg-gray-200 hover:bg-red-100 text-gray-500 hover:text-red-600 transition-colors flex items-center justify-center ml-1"
            aria-label={`${chip.label} 필터 삭제`}
          >
            <XMarkIcon className="w-3 h-3" />
          </button>
        )}
      </div>
    )
  }

  const renderSettingControl = (setting: FilterSetting) => {
    switch (setting.type) {
      case 'toggle':
        return (
          <button
            onClick={() => setting.onChange(!setting.value)}
            className={`
              w-10 h-6 rounded-full transition-colors relative
              ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
            `}
          >
            <div className={`
              w-4 h-4 bg-white rounded-full absolute top-1 transition-transform
              ${setting.value ? 'translate-x-5' : 'translate-x-1'}
            `} />
          </button>
        )
      
      case 'select':
        return (
          <select 
            value={setting.value || ''}
            onChange={(e) => setting.onChange(e.target.value)}
            className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
          >
            {(setting.options || []).map((option) => (
              <option key={option} value={option}>
                {getOptionLabel(option)}
              </option>
            ))}
          </select>
        )
      
      case 'multi-select':
        return (
          <select 
            multiple
            value={setting.value || []}
            onChange={(e) => {
              const values = Array.from(e.target.selectedOptions, option => option.value)
              setting.onChange(values)
            }}
            className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 min-h-[80px]"
          >
            {(setting.options || []).map((option) => (
              <option key={option} value={option}>
                {getOptionLabel(option)}
              </option>
            ))}
          </select>
        )
      
      case 'range':
        return (
          <div className="flex items-center gap-2">
            <input
              type="number"
              placeholder="최소"
              value={setting.value?.[0] || ''}
              onChange={(e) => {
                const newValue = [parseInt(e.target.value) || 0, setting.value?.[1] || 100]
                setting.onChange(newValue)
              }}
              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 w-16"
            />
            <span className="text-gray-400">~</span>
            <input
              type="number"
              placeholder="최대"
              value={setting.value?.[1] || ''}
              onChange={(e) => {
                const newValue = [setting.value?.[0] || 0, parseInt(e.target.value) || 100]
                setting.onChange(newValue)
              }}
              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 w-16"
            />
          </div>
        )
      
      case 'tag-selector':
        return (
          <div className="flex flex-wrap gap-1 max-w-[200px]">
            {(setting.options || []).map((option) => {
              const isSelected = setting.value?.includes(option)
              return (
                <button
                  key={option}
                  onClick={() => {
                    const currentValue = setting.value || []
                    const newValue = isSelected 
                      ? currentValue.filter((v: string) => v !== option)
                      : [...currentValue, option]
                    setting.onChange(newValue)
                  }}
                  className={`
                    px-2 py-1 text-xs rounded-full border transition-colors
                    ${isSelected 
                      ? 'bg-blue-100 border-blue-300 text-blue-700' 
                      : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                    }
                  `}
                >
                  {getOptionLabel(option)}
                </button>
              )
            })}
          </div>
        )
      
      case 'date-range':
        return (
          <div className="flex items-center gap-2">
            <input
              type="date"
              value={setting.value?.[0] || ''}
              onChange={(e) => {
                const newValue = [e.target.value, setting.value?.[1] || '']
                setting.onChange(newValue)
              }}
              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
            <span className="text-gray-400">~</span>
            <input
              type="date"
              value={setting.value?.[1] || ''}
              onChange={(e) => {
                const newValue = [setting.value?.[0] || '', e.target.value]
                setting.onChange(newValue)
              }}
              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
          </div>
        )
      
      case 'text':
        return (
          <input
            type="text"
            value={setting.value || ''}
            onChange={(e) => setting.onChange(e.target.value)}
            placeholder={setting.placeholder}
            className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
          />
        )
      
      default:
        return null
    }
  }

  return (
    <div className={`relative bg-gradient-to-r from-gray-50/50 to-white/50 ${className}`}>
      {/* 데스크톱 */}
      <div className="hidden md:block">
        <div className="flex items-center gap-3 px-0 py-0">
          {/* 필터 칩들 */}
          <div 
            ref={scrollContainerRef}
            className="flex space-x-2 overflow-x-auto scrollbar-hide flex-1 px-0 py-0"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {allChips.map((chip) => renderChip(chip))}
          </div>

          {/* 설정 버튼 */}
          <div className="relative">
            <button
              onClick={() => setShowSettings(!showSettings)}
              className={`
                text-gray-600 hover:text-gray-900 hover:bg-gray-50
                border border-gray-300 hover:border-gray-400
                rounded-full
                transition-all duration-300
                flex items-center justify-center
                hover:scale-105 active:scale-95
                focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                w-11 h-11
                min-w-[2.75rem]
                p-0
                bg-white
                shadow-sm
              `}
              aria-expanded={showSettings}
              aria-haspopup="true"
              aria-label="필터 설정"
            >
              <AdjustmentsHorizontalIcon className="w-5 h-5" />
            </button>

            {showSettings && (
              <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[320px] p-4 z-50">
                <div className="mb-3 flex items-center justify-between">
                  <h3 className="text-sm font-semibold text-gray-900">{settingsTitle}</h3>
                  <button
                    onClick={createChipFromConditions}
                    className="flex items-center gap-1 px-2 py-1 text-xs bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  >
                    <PlusIcon className="w-3 h-3" />
                    칩 생성
                  </button>
                </div>
                <div className="space-y-3">
                  {settings.map((setting) => (
                    <div key={setting.key} className="flex items-center justify-between">
                      <label className="text-sm text-gray-700">{setting.label}</label>
                      {renderSettingControl(setting)}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* 모바일 */}
      <div className="md:hidden">
        <div className="absolute left-0 top-0 bottom-0 w-6 bg-gradient-to-r from-gray-50 via-gray-50/80 to-transparent pointer-events-none z-10" />
        <div className="absolute right-0 top-0 bottom-0 w-6 bg-gradient-to-l from-white via-white/80 to-transparent pointer-events-none z-10" />
        
        <div className="flex items-center">
          <div 
            ref={scrollContainerRef}
            className="flex space-x-3 overflow-x-auto scrollbar-hide px-4 py-2 flex-1"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {allChips.map((chip) => renderChip(chip))}
          </div>
          
          {/* 모바일 설정 버튼 */}
          <div className="pr-4 pl-3">
            <button
              onClick={() => setShowSettings(!showSettings)}
              className={`
                text-gray-600 hover:text-gray-900 hover:bg-gray-50
                border border-gray-300 hover:border-gray-400
                rounded-full
                transition-all duration-300
                flex items-center justify-center
                hover:scale-105 active:scale-95
                focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                w-11 h-11
                min-w-[2.75rem]
                p-0
                bg-white
                shadow-sm
              `}
              aria-expanded={showSettings}
              aria-haspopup="true"
              aria-label="필터 설정"
            >
              <AdjustmentsHorizontalIcon className="w-5 h-5" />
            </button>
          </div>
        </div>
      </div>
      
      {/* 모바일 바텀시트 설정 모달 */}
      {showSettings && (
        <div className="md:hidden fixed inset-0 z-[60] flex items-end">
          <div 
            className="absolute inset-0 bg-black bg-opacity-25" 
            onClick={() => setShowSettings(false)}
          />
          <div className="relative bg-white w-full max-h-[70vh] rounded-t-xl shadow-xl">
            {/* 모달 헤더 */}
            <div className="flex items-center justify-between p-4 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-900">{settingsTitle}</h3>
              <div className="flex items-center gap-2">
                <button
                  onClick={createChipFromConditions}
                  className="flex items-center gap-1 px-3 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  <PlusIcon className="w-4 h-4" />
                  칩 생성
                </button>
                <button
                  onClick={() => setShowSettings(false)}
                  className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-gray-100"
                >
                  <XMarkIcon className="w-5 h-5 text-gray-400" />
                </button>
              </div>
            </div>
            
            {/* 모달 콘텐츠 */}
            <div className="p-4 space-y-4 max-h-[50vh] overflow-y-auto">
              {settings.map((setting) => (
                <div key={setting.key} className="flex items-center justify-between py-2">
                  <label className="text-sm font-medium text-gray-700">{setting.label}</label>
                  {renderSettingControl(setting)}
                </div>
              ))}
            </div>
            
            {/* 모달 푸터 */}
            <div className="p-4 border-t border-gray-200">
              <button
                onClick={() => setShowSettings(false)}
                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
              >
                적용
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/Input.tsx">
import React from 'react';
import { cn } from '@/lib/utils';

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  error?: string;
  label?: string;
  helperText?: string;
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, error, label, helperText, id, ...props }, ref) => {
    const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`;

    return (
      <div className="w-full">
        {label && (
          <label 
            htmlFor={inputId}
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            {label}
            {props.required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        <input
          type={type}
          id={inputId}
          className={cn(
            'flex h-10 w-full rounded-md border border-gray-200 bg-white px-3 py-2 text-sm',
            'file:border-0 file:bg-transparent file:text-sm file:font-medium',
            'placeholder:text-gray-500',
            'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
            'disabled:cursor-not-allowed disabled:opacity-50',
            error && 'border-red-500 focus:ring-red-500',
            className
          )}
          ref={ref}
          {...props}
        />
        {error && (
          <p className="mt-1 text-sm text-red-600">{error}</p>
        )}
        {helperText && !error && (
          <p className="mt-1 text-sm text-gray-500">{helperText}</p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

export { Input };
</file>

<file path="frontend/src/components/ui/MobileTabs.tsx">
'use client'

import { useState } from 'react'

interface MobileTabsProps {
  tabs: string[]
  activeTab?: string
  onTabChange?: (tab: string) => void
}

export default function MobileTabs({ tabs, activeTab, onTabChange }: MobileTabsProps) {
  const [currentTab, setCurrentTab] = useState(activeTab || tabs[0])

  const handleTabClick = (tab: string) => {
    setCurrentTab(tab)
    onTabChange?.(tab)
  }

  return (
    <div className="md:hidden bg-background border-b border-border">
      <div className="flex w-full" role="tablist" aria-label="탭 네비게이션">
        {tabs.map((tab, index) => (
          <button
            key={tab}
            id={`tab-${index}`}
            onClick={() => handleTabClick(tab)}
            className={`flex-1 px-4 py-3 text-sm font-medium transition-colors ${
              currentTab === tab
                ? 'text-foreground border-b-2 border-foreground'
                : 'text-muted-foreground hover:text-foreground'
            }`}
            role="tab"
            aria-selected={currentTab === tab}
            aria-controls={`tabpanel-${index}`}
            tabIndex={currentTab === tab ? 0 : -1}
          >
            {tab}
          </button>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/Select.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { ChevronDownIcon } from '@heroicons/react/24/outline';

export interface SelectOption {
  value: string;
  label: string;
  disabled?: boolean;
}

export interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {
  options: SelectOption[];
  error?: string;
  label?: string;
  helperText?: string;
  placeholder?: string;
}

const Select = React.forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, options, error, label, helperText, placeholder, id, ...props }, ref) => {
    const selectId = id || `select-${Math.random().toString(36).substr(2, 9)}`;

    return (
      <div className="w-full">
        {label && (
          <label 
            htmlFor={selectId}
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            {label}
            {props.required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        <div className="relative">
          <select
            id={selectId}
            className={cn(
              'flex h-10 w-full rounded-md border border-gray-200 bg-white px-3 py-2 text-sm',
              'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
              'disabled:cursor-not-allowed disabled:opacity-50',
              'appearance-none cursor-pointer',
              error && 'border-red-500 focus:ring-red-500',
              className
            )}
            ref={ref}
            {...props}
          >
            {placeholder && (
              <option value="" disabled>
                {placeholder}
              </option>
            )}
            {options.map((option) => (
              <option 
                key={option.value} 
                value={option.value}
                disabled={option.disabled}
              >
                {option.label}
              </option>
            ))}
          </select>
          <ChevronDownIcon className="absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400 pointer-events-none" />
        </div>
        {error && (
          <p className="mt-1 text-sm text-red-600">{error}</p>
        )}
        {helperText && !error && (
          <p className="mt-1 text-sm text-gray-500">{helperText}</p>
        )}
      </div>
    );
  }
);

Select.displayName = 'Select';

export { Select };
</file>

<file path="frontend/src/components/ui/SimpleFilterChips.tsx">
'use client'

import { useState } from 'react'
import { XMarkIcon, AdjustmentsHorizontalIcon, FunnelIcon } from '@heroicons/react/24/outline'

interface FilterOption {
  key: string
  label: string
  count?: number
}

interface FilterSetting {
  key: string
  label: string
  type: 'toggle' | 'select'
  value?: any
  options?: string[]
  onChange: (value: any) => void
}

interface SimpleFilterChipsProps {
  options: FilterOption[]
  activeFilters: string[]
  onFilterChange: (filters: string[]) => void
  className?: string
  settings?: {
    title: string
    settings: FilterSetting[]
  }
  onAdvancedFilterClick?: () => void
  hasAdvancedFilters?: boolean
}

/**
 * 워클리 디자인 시스템을 준수하는 매우 간결한 필터 칩 컴포넌트
 * - 단일 색상 체계 (Blue Primary + Gray Secondary)
 * - 간결한 디자인
 * - 모바일/데스크톱 통합 대응
 */
export default function SimpleFilterChips({ 
  options, 
  activeFilters,
  onFilterChange,
  className = '',
  settings,
  onAdvancedFilterClick,
  hasAdvancedFilters = false
}: SimpleFilterChipsProps) {
  
  const [showSettings, setShowSettings] = useState(false)
  
  const handleChipClick = (key: string) => {
    if (activeFilters.includes(key)) {
      onFilterChange(activeFilters.filter(f => f !== key))
    } else {
      onFilterChange([...activeFilters, key])
    }
  }

  const handleRemoveFilter = (key: string) => {
    onFilterChange(activeFilters.filter(f => f !== key))
  }

  return (
    <div className={`flex items-center justify-between gap-4 ${className}`}>
      {/* 활성 필터 칩들 */}
      <div className="flex items-center gap-2 flex-1">
        {activeFilters.length > 0 ? (
          <>
            {activeFilters.map(filterKey => {
              const option = options.find(opt => opt.key === filterKey)
              if (!option) return null
              
              return (
                <div
                  key={filterKey}
                  className="workly-filter-chip active inline-flex items-center gap-2 font-medium"
                >
                  <span>{option.label}</span>
                  {option.count && (
                    <span className="text-xs bg-blue-200 text-blue-700 px-1.5 py-0.5 rounded-full">
                      {option.count}
                    </span>
                  )}
                  <button
                    onClick={() => handleRemoveFilter(filterKey)}
                    className="w-4 h-4 flex items-center justify-center hover:bg-blue-200 rounded-full transition-colors"
                    aria-label={`${option.label} 필터 제거`}
                  >
                    <XMarkIcon className="w-3 h-3" />
                  </button>
                </div>
              )
            })}
          </>
        ) : (
          <div className="flex gap-2 overflow-x-auto scrollbar-hide">
            {options.map(option => (
              <button
                key={option.key}
                onClick={() => handleChipClick(option.key)}
                className="workly-filter-chip flex-shrink-0 inline-flex items-center gap-2 font-medium"
              >
                <span>{option.label}</span>
                {option.count && (
                  <span className="text-xs bg-gray-100 text-gray-500 px-1.5 py-0.5 rounded-full">
                    {option.count}
                  </span>
                )}
              </button>
            ))}
          </div>
        )}
      </div>
      
      {/* 상세 필터 버튼 */}
      {onAdvancedFilterClick && (
        <button
          onClick={onAdvancedFilterClick}
          className={`flex-shrink-0 w-10 h-10 flex items-center justify-center bg-white border border-gray-200 rounded-full hover:border-gray-300 hover:bg-gray-50 transition-colors ${
            hasAdvancedFilters ? 'text-blue-600 border-blue-200 bg-blue-50' : 'text-gray-600'
          }`}
          aria-label="상세 필터"
        >
          <FunnelIcon className="w-5 h-5" />
        </button>
      )}
      
      {/* 필터 설정 버튼 */}
      {settings && (
        <div className="relative">
          <button
            onClick={() => setShowSettings(!showSettings)}
            className="flex-shrink-0 w-10 h-10 flex items-center justify-center bg-white text-gray-600 border border-gray-200 rounded-full hover:border-gray-300 hover:bg-gray-50 transition-colors"
            aria-label="필터 설정"
          >
            <AdjustmentsHorizontalIcon className="w-5 h-5" />
          </button>
          
          {/* 설정 드롭다운 */}
          {showSettings && (
            <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-lg shadow-lg min-w-[200px] p-4 z-50">
              <h3 className="text-sm font-semibold text-gray-900 mb-3">{settings.title}</h3>
              <div className="space-y-3">
                {settings.settings.map((setting) => (
                  <div key={setting.key} className="flex items-center justify-between">
                    <label className="text-sm text-gray-700">{setting.label}</label>
                    {setting.type === 'toggle' && (
                      <button
                        onClick={() => setting.onChange(!setting.value)}
                        className={`
                          w-10 h-6 rounded-full transition-colors relative
                          ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
                        `}
                      >
                        <div className={`
                          w-4 h-4 bg-white rounded-full absolute top-1 transition-transform
                          ${setting.value ? 'translate-x-5' : 'translate-x-1'}
                        `} />
                      </button>
                    )}
                    {setting.type === 'select' && setting.options && (
                      <select 
                        value={setting.value || ''}
                        onChange={(e) => setting.onChange(e.target.value)}
                        className="text-sm border border-gray-200 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        {setting.options.map((option) => (
                          <option key={option} value={option}>
                            {option === 'priority' ? '우선순위순' :
                             option === 'dueDate' ? '마감일순' :
                             option === 'status' ? '상태순' :
                             option === 'created' ? '생성순' : option}
                          </option>
                        ))}
                      </select>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/UnifiedFilter.tsx">
'use client'

import { ReactNode, useRef, useEffect, useState } from 'react'
import { ChevronDownIcon, XMarkIcon, AdjustmentsHorizontalIcon } from '@heroicons/react/24/outline'

interface FilterOption {
  key: string
  label: string
  count?: number
  icon?: ReactNode
  color?: 'blue' | 'green' | 'purple' | 'orange' | 'red' | 'gray'
}

interface FilterSetting {
  key: string
  label: string
  type: 'toggle' | 'select' | 'multi-select' | 'range' | 'tag-selector' | 'date-range'
  value?: any
  options?: string[] | FilterOption[]
  placeholder?: string
  validation?: (value: any) => boolean
  dependency?: string // 다른 설정에 의존
  onChange: (value: any) => void
}

interface UnifiedFilterProps {
  // 메인 필터 칩들
  options: FilterOption[]
  activeFilter: string
  onFilterChange: (filter: string) => void
  
  // 설정
  settings?: FilterSetting[]
  settingsTitle?: string
  
  // 스타일 옵션
  className?: string
  variant?: 'compact' | 'comfortable' | 'spacious'
  style?: 'modern' | 'minimal' | 'glassmorphism'
  maxVisibleItems?: number
}

export default function UnifiedFilter({ 
  options, 
  activeFilter, 
  onFilterChange,
  settings = [],
  settingsTitle = '필터 설정',
  className = '',
  variant = 'comfortable',
  style = 'modern',
  maxVisibleItems
}: UnifiedFilterProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const [showOverflow, setShowOverflow] = useState(false)
  const [overflowItems, setOverflowItems] = useState<FilterOption[]>([])
  const [visibleItems, setVisibleItems] = useState<FilterOption[]>(options)
  const [showSettings, setShowSettings] = useState(false)

  // 오버플로우 처리
  useEffect(() => {
    if (maxVisibleItems && options.length > maxVisibleItems) {
      setVisibleItems(options.slice(0, maxVisibleItems))
      setOverflowItems(options.slice(maxVisibleItems))
    } else {
      setVisibleItems(options)
      setOverflowItems([])
    }
  }, [options, maxVisibleItems])

  // 활성 필터로 자동 스크롤
  useEffect(() => {
    if (scrollContainerRef.current) {
      const activeElement = scrollContainerRef.current.querySelector(`[data-filter="${activeFilter}"]`)
      if (activeElement) {
        activeElement.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center'
        })
      }
    }
  }, [activeFilter])

  // 색상별 클래스
  const getColorClasses = (color: string, isActive: boolean) => {
    const colors = {
      blue: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      green: {
        active: 'bg-gradient-to-r from-green-500 to-green-600 text-white shadow-lg shadow-green-500/25',
        inactive: 'text-green-600 hover:bg-green-50 border-green-200 hover:border-green-300'
      },
      purple: {
        active: 'bg-gradient-to-r from-purple-500 to-purple-600 text-white shadow-lg shadow-purple-500/25',
        inactive: 'text-purple-600 hover:bg-purple-50 border-purple-200 hover:border-purple-300'
      },
      orange: {
        active: 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25',
        inactive: 'text-blue-600 hover:bg-blue-50 border-blue-200 hover:border-blue-300'
      },
      red: {
        active: 'bg-gradient-to-r from-red-500 to-red-600 text-white shadow-lg shadow-red-500/25',
        inactive: 'text-red-600 hover:bg-red-50 border-red-200 hover:border-red-300'
      },
      gray: {
        active: 'bg-gradient-to-r from-gray-500 to-gray-600 text-white shadow-lg shadow-gray-500/25',
        inactive: 'text-gray-600 hover:bg-gray-50 border-gray-200 hover:border-gray-300'
      }
    }
    
    return colors[color as keyof typeof colors] || colors.gray
  }

  // 변형별 패딩 클래스
  const getVariantClasses = () => {
    switch (variant) {
      case 'compact':
        return 'px-3 py-1.5 text-xs'
      case 'spacious':
        return 'px-6 py-3 text-base'
      default: // comfortable
        return 'px-4 py-2 text-sm'
    }
  }

  const variantClasses = getVariantClasses()

  const renderChip = (option: FilterOption, isOverflow = false) => {
    const isActive = activeFilter === option.key
    const colorClasses = option.color ? getColorClasses(option.color, isActive) : null
    
    return (
      <button
        key={option.key}
        data-filter={option.key}
        onClick={() => onFilterChange(option.key)}
        className={`
          flex-shrink-0
          ${variantClasses}
          font-medium
          rounded-full
          transition-all duration-300
          flex items-center gap-2
          min-w-max
          transform hover:scale-105 active:scale-95
          focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
          ${
            colorClasses
              ? isActive 
                ? `${colorClasses.active} border-none`
                : `bg-white ${colorClasses.inactive} border`
              : isActive
                ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg shadow-blue-500/25 border-none'
                : 'bg-white text-gray-600 hover:text-gray-900 hover:bg-gray-50 border border-gray-200 hover:border-gray-300 hover:shadow-md'
          }
          ${isOverflow ? 'w-full justify-start' : ''}
        `}
        aria-pressed={isActive}
        role="button"
      >
      {option.icon && (
        <span className="w-4 h-4 flex items-center justify-center flex-shrink-0">
          {option.icon}
        </span>
      )}
      <span className="whitespace-nowrap">{option.label}</span>
      {option.count !== undefined && option.count > 0 && (
        <span 
          className={`
            text-xs 
            min-w-[20px] 
            h-5
            rounded-full 
            flex 
            items-center 
            justify-center 
            font-semibold
            flex-shrink-0
            ${
              isActive 
                ? 'bg-white/20 text-white'
                : 'bg-gray-100 text-gray-600'
            }
          `}
        >
          {option.count > 999 ? '999+' : option.count}
        </span>
      )}
      </button>
    )
  }

  const getOptionLabel = (option: string) => {
    const labels: { [key: string]: string } = {
      'deadline': '마감일순',
      'priority': '우선순위순',
      'created': '생성일순',
      'updated': '수정일순',
      'momentum': '모멘텀 점수순',
      'energy': '에너지 레벨순',
      'latest': '최신순',
      'popular': '인기순',
      'comments': '댓글순',
      'views': '조회순',
      'recent': '최근순',
      'progress': '진행률순',
      'members': '멤버순',
      'objectives': 'OKR 진행률순',
      'all': '전체',
      'recruiting': '모집 중',
      'closed': '모집 완료',
      '24h': '24시간 이내',
      '7d': '7일 이내',
      '30d': '30일 이내',
      '1-2명': '1-2명',
      '3-5명': '3-5명',
      '6명 이상': '6명 이상',
      'fixed': '고정 금액',
      'hourly': '시간제',
      'beginner': '초급',
      'intermediate': '중급',
      'advanced': '고급',
      'tutorial': '튜토리얼',
      'guide': '가이드',
      'reference': '참고자료',
      'template': '템플릿',
      'individual': '개인',
      'small': '2-3명',
      'large': '4명+',
      'prototype': '프로토타입',
      'mvp': 'MVP',
      'complete': '완제품'
    }
    return labels[option] || option
  }

  return (
    <div className={`relative bg-gradient-to-r from-gray-50/50 to-white/50 ${className}`}>
      {/* 데스크톱 */}
      <div className="hidden md:block">
        <div className="flex items-center gap-3 px-6 py-4">
          {/* 메인 필터 칩들 */}
          <div 
            ref={scrollContainerRef}
            className="flex space-x-2 overflow-x-auto scrollbar-hide flex-1 px-3 py-2"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {visibleItems.map((option) => renderChip(option))}
          </div>

          {/* 오버플로우 메뉴 */}
          {overflowItems.length > 0 && (
            <div className="relative">
              <button
                onClick={() => setShowOverflow(!showOverflow)}
                className={`
                  text-gray-600 hover:text-gray-900 hover:bg-gray-50
                  border border-gray-300 hover:border-gray-400
                  rounded-full
                  transition-all duration-300
                  flex items-center gap-1
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                  ${variantClasses}
                `}
                aria-expanded={showOverflow}
                aria-haspopup="true"
              >
                <span>+{overflowItems.length}</span>
                <ChevronDownIcon className={`w-3 h-3 transition-transform ${showOverflow ? 'rotate-180' : ''}`} />
              </button>

              {showOverflow && (
                <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[200px] py-2 z-50">
                  <div className="space-y-1 px-2">
                    {overflowItems.map((option) => renderChip(option, true))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* 설정 버튼 */}
          {settings.length > 0 && (
            <div className="relative">
              <button
                onClick={() => setShowSettings(!showSettings)}
                className={`
                  text-gray-600 hover:text-gray-900 hover:bg-gray-50
                  border border-gray-300 hover:border-gray-400
                  rounded-full
                  transition-all duration-300
                  flex items-center justify-center
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                  w-11 h-11
                  min-w-[2.75rem]
                  p-0
                  bg-white
                  shadow-sm
                `}
                aria-expanded={showSettings}
                aria-haspopup="true"
                aria-label="필터 설정"
              >
                <AdjustmentsHorizontalIcon className="w-5 h-5" />
              </button>

              {showSettings && (
                <div className="absolute top-full right-0 mt-2 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[280px] p-4 z-50">
                  <div className="mb-3">
                    <h3 className="text-sm font-semibold text-gray-900">{settingsTitle}</h3>
                  </div>
                  <div className="space-y-3">
                    {settings.map((setting) => (
                      <div key={setting.key} className="flex items-center justify-between">
                        <label className="text-sm text-gray-700">{setting.label}</label>
                        {setting.type === 'toggle' && (
                          <button
                            onClick={() => setting.onChange(!setting.value)}
                            className={`
                              w-10 h-6 rounded-full transition-colors relative
                              ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
                            `}
                          >
                            <div className={`
                              w-4 h-4 bg-white rounded-full absolute top-1 transition-transform
                              ${setting.value ? 'translate-x-5' : 'translate-x-1'}
                            `} />
                          </button>
                        )}
                        {setting.type === 'select' && setting.options && (
                          <select 
                            value={setting.value || ''}
                            onChange={(e) => setting.onChange(e.target.value)}
                            className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
                          >
                            {setting.options.map((option) => (
                              <option key={option} value={option}>
                                {getOptionLabel(option)}
                              </option>
                            ))}
                          </select>
                        )}
                        {setting.type === 'multi-select' && setting.options && (
                          <div className="relative">
                            <select 
                              multiple
                              value={setting.value || []}
                              onChange={(e) => {
                                const values = Array.from(e.target.selectedOptions, option => option.value)
                                setting.onChange(values)
                              }}
                              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 min-h-[80px]"
                            >
                              {setting.options.map((option) => (
                                <option key={option} value={option}>
                                  {getOptionLabel(option)}
                                </option>
                              ))}
                            </select>
                          </div>
                        )}
                        {setting.type === 'range' && (
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              placeholder="최소"
                              value={setting.value?.[0] || ''}
                              onChange={(e) => {
                                const newValue = [parseInt(e.target.value) || 0, setting.value?.[1] || 100]
                                setting.onChange(newValue)
                              }}
                              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 w-16"
                            />
                            <span className="text-gray-400">~</span>
                            <input
                              type="number"
                              placeholder="최대"
                              value={setting.value?.[1] || ''}
                              onChange={(e) => {
                                const newValue = [setting.value?.[0] || 0, parseInt(e.target.value) || 100]
                                setting.onChange(newValue)
                              }}
                              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 w-16"
                            />
                          </div>
                        )}
                        {setting.type === 'tag-selector' && setting.options && (
                          <div className="flex flex-wrap gap-1 max-w-[200px]">
                            {setting.options.map((option) => {
                              const isSelected = setting.value?.includes(option)
                              return (
                                <button
                                  key={option}
                                  onClick={() => {
                                    const currentValue = setting.value || []
                                    const newValue = isSelected 
                                      ? currentValue.filter((v: string) => v !== option)
                                      : [...currentValue, option]
                                    setting.onChange(newValue)
                                  }}
                                  className={`
                                    px-2 py-1 text-xs rounded-full border transition-colors
                                    ${isSelected 
                                      ? 'bg-blue-100 border-blue-300 text-blue-700' 
                                      : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                                    }
                                  `}
                                >
                                  {getOptionLabel(option)}
                                </button>
                              )
                            })}
                          </div>
                        )}
                        {setting.type === 'date-range' && (
                          <div className="flex items-center gap-2">
                            <input
                              type="date"
                              value={setting.value?.[0] || ''}
                              onChange={(e) => {
                                const newValue = [e.target.value, setting.value?.[1] || '']
                                setting.onChange(newValue)
                              }}
                              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
                            />
                            <span className="text-gray-400">~</span>
                            <input
                              type="date"
                              value={setting.value?.[1] || ''}
                              onChange={(e) => {
                                const newValue = [setting.value?.[0] || '', e.target.value]
                                setting.onChange(newValue)
                              }}
                              className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
                            />
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* 모바일 */}
      <div className="md:hidden">
        <div className="absolute left-0 top-0 bottom-0 w-6 bg-gradient-to-r from-gray-50 via-gray-50/80 to-transparent pointer-events-none z-10" />
        <div className="absolute right-0 top-0 bottom-0 w-6 bg-gradient-to-l from-white via-white/80 to-transparent pointer-events-none z-10" />
        
        <div className="flex items-center gap-3">
          <div 
            ref={scrollContainerRef}
            className="flex space-x-3 overflow-x-auto scrollbar-hide px-5 py-3 flex-1"
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {options.map((option) => renderChip(option))}
          </div>
          
          {/* 모바일 설정 버튼 */}
          {settings.length > 0 && (
            <div className="pr-4">
              <button
                onClick={() => setShowSettings(!showSettings)}
                className={`
                  text-gray-600 hover:text-gray-900 hover:bg-gray-50
                  border border-gray-300 hover:border-gray-400
                  rounded-full
                  transition-all duration-300
                  flex items-center justify-center
                  hover:scale-105 active:scale-95
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:ring-offset-2
                  w-11 h-11
                  min-w-[2.75rem]
                  p-0
                  bg-white
                  shadow-sm
                `}
                aria-expanded={showSettings}
                aria-haspopup="true"
                aria-label="필터 설정"
              >
                <AdjustmentsHorizontalIcon className="w-5 h-5" />
              </button>
            </div>
          )}
        </div>
      </div>
      
      {/* 모바일 바텀시트 설정 모달 */}
      {settings.length > 0 && showSettings && (
        <div className="md:hidden fixed inset-0 z-[60] flex items-end">
          <div 
            className="absolute inset-0 bg-black bg-opacity-25" 
            onClick={() => setShowSettings(false)}
          />
          <div className="relative bg-white w-full max-h-[70vh] rounded-t-xl shadow-xl">
            {/* 모달 헤더 */}
            <div className="flex items-center justify-between p-4 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-900">{settingsTitle}</h3>
              <button
                onClick={() => setShowSettings(false)}
                className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-gray-100"
              >
                <XMarkIcon className="w-5 h-5 text-gray-400" />
              </button>
            </div>
            
            {/* 모달 콘텐츠 */}
            <div className="p-4 space-y-4 max-h-[50vh] overflow-y-auto">
              {settings.map((setting) => (
                <div key={setting.key} className="flex items-center justify-between py-2">
                  <label className="text-sm font-medium text-gray-700">{setting.label}</label>
                  {setting.type === 'toggle' && (
                    <button
                      onClick={() => setting.onChange(!setting.value)}
                      className={`
                        w-12 h-7 rounded-full transition-colors relative
                        ${setting.value ? 'bg-blue-600' : 'bg-gray-300'}
                      `}
                    >
                      <div className={`
                        w-5 h-5 bg-white rounded-full absolute top-1 transition-transform
                        ${setting.value ? 'translate-x-6' : 'translate-x-1'}
                      `} />
                    </button>
                  )}
                  {setting.type === 'select' && setting.options && (
                    <select 
                      value={setting.value || ''}
                      onChange={(e) => setting.onChange(e.target.value)}
                      className="text-sm border border-gray-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-[120px]"
                    >
                      {setting.options.map((option) => (
                        <option key={option} value={option}>
                          {getOptionLabel(option)}
                        </option>
                      ))}
                    </select>
                  )}
                  {setting.type === 'multi-select' && setting.options && (
                    <div className="relative">
                      <select 
                        multiple
                        value={setting.value || []}
                        onChange={(e) => {
                          const values = Array.from(e.target.selectedOptions, option => option.value)
                          setting.onChange(values)
                        }}
                        className="text-sm border border-gray-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-[120px] min-h-[100px]"
                      >
                        {setting.options.map((option) => (
                          <option key={option} value={option}>
                            {getOptionLabel(option)}
                          </option>
                        ))}
                      </select>
                    </div>
                  )}
                  {setting.type === 'range' && (
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        placeholder="최소"
                        value={setting.value?.[0] || ''}
                        onChange={(e) => {
                          const newValue = [parseInt(e.target.value) || 0, setting.value?.[1] || 100]
                          setting.onChange(newValue)
                        }}
                        className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500 w-16"
                      />
                      <span className="text-gray-400">~</span>
                      <input
                        type="number"
                        placeholder="최대"
                        value={setting.value?.[1] || ''}
                        onChange={(e) => {
                          const newValue = [setting.value?.[0] || 0, parseInt(e.target.value) || 100]
                          setting.onChange(newValue)
                        }}
                        className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500 w-16"
                      />
                    </div>
                  )}
                  {setting.type === 'tag-selector' && setting.options && (
                    <div className="flex flex-wrap gap-1 max-w-[240px]">
                      {setting.options.map((option) => {
                        const isSelected = setting.value?.includes(option)
                        return (
                          <button
                            key={option}
                            onClick={() => {
                              const currentValue = setting.value || []
                              const newValue = isSelected 
                                ? currentValue.filter((v: string) => v !== option)
                                : [...currentValue, option]
                              setting.onChange(newValue)
                            }}
                            className={`
                              px-3 py-1.5 text-xs rounded-full border transition-colors
                              ${isSelected 
                                ? 'bg-blue-100 border-blue-300 text-blue-700' 
                                : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                              }
                            `}
                          >
                            {getOptionLabel(option)}
                          </button>
                        )
                      })}
                    </div>
                  )}
                  {setting.type === 'date-range' && (
                    <div className="flex items-center gap-2">
                      <input
                        type="date"
                        value={setting.value?.[0] || ''}
                        onChange={(e) => {
                          const newValue = [e.target.value, setting.value?.[1] || '']
                          setting.onChange(newValue)
                        }}
                        className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                      <span className="text-gray-400">~</span>
                      <input
                        type="date"
                        value={setting.value?.[1] || ''}
                        onChange={(e) => {
                          const newValue = [setting.value?.[0] || '', e.target.value]
                          setting.onChange(newValue)
                        }}
                        className="text-sm border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>
                  )}
                </div>
              ))}
            </div>
            
            {/* 모달 푸터 */}
            <div className="p-4 border-t border-gray-200">
              <button
                onClick={() => setShowSettings(false)}
                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
              >
                적용
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/src/lib/api.ts">
/**
 * API 클라이언트 유틸리티
 * JWT 토큰을 자동으로 포함하여 백엔드와 통신
 */

interface ApiOptions extends Omit<RequestInit, 'priority'> {
  requireAuth?: boolean;
}

interface ApiError extends Error {
  status?: number;
  statusText?: string;
}

class ApiClient {
  private baseUrl: string;

  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';
  }

  /**
   * API 요청을 보내는 기본 메서드
   */
  private async request<T>(
    endpoint: string, 
    options: ApiOptions = {}
  ): Promise<T> {
    const { requireAuth = true, ...requestOptions } = options;
    
    const url = `${this.baseUrl}${endpoint}`;
    
    // 기본 헤더 설정
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    
    // 추가 헤더가 있는 경우 병합
    if (requestOptions.headers) {
      Object.assign(headers, requestOptions.headers);
    }

    // 인증이 필요한 경우 토큰 추가
    if (requireAuth) {
      const accessToken = this.getAccessToken();
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }
    }

    try {
      const response = await fetch(url, {
        ...requestOptions,
        headers,
      });

      // 401 에러인 경우 토큰 갱신 시도
      if (response.status === 401 && requireAuth) {
        const refreshed = await this.refreshToken();
        if (refreshed) {
          // 토큰 갱신 성공 시 재시도
          const accessToken = this.getAccessToken();
          if (accessToken) {
            headers['Authorization'] = `Bearer ${accessToken}`;
          }
          
          const retryResponse = await fetch(url, {
            ...requestOptions,
            headers,
          });
          
          return this.handleResponse<T>(retryResponse);
        } else {
          // 토큰 갱신 실패 시 로그인 페이지로 리다이렉트
          this.handleAuthFailure();
          throw new Error('Authentication failed');
        }
      }

      return this.handleResponse<T>(response);
    } catch (error) {
      console.error('API 요청 오류:', error);
      throw error;
    }
  }

  /**
   * 응답 처리
   */
  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      const error: ApiError = new Error(`HTTP ${response.status}: ${response.statusText}`);
      error.status = response.status;
      error.statusText = response.statusText;
      
      // 에러 메시지가 있는 경우 포함
      try {
        const errorData = await response.json();
        if (errorData.message) {
          error.message = errorData.message;
        }
      } catch {
        // JSON 파싱 실패 시 기본 에러 메시지 사용
      }
      
      throw error;
    }

    // 응답이 비어있는 경우 처리
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    } else {
      return response.text() as unknown as T;
    }
  }

  /**
   * GET 요청
   */
  async get<T>(endpoint: string, params?: Record<string, any>, options?: ApiOptions): Promise<T> {
    let url = endpoint;
    
    // 쿼리 파라미터가 있는 경우 URL에 추가
    if (params && Object.keys(params).length > 0) {
      const searchParams = new URLSearchParams();
      
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          searchParams.append(key, String(value));
        }
      });
      
      if (searchParams.toString()) {
        url += `?${searchParams.toString()}`;
      }
    }
    
    return this.request<T>(url, { ...options, method: 'GET' });
  }

  /**
   * POST 요청
   */
  async post<T>(endpoint: string, data?: any, options?: ApiOptions): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  /**
   * PUT 요청
   */
  async put<T>(endpoint: string, data?: any, options?: ApiOptions): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  /**
   * DELETE 요청
   */
  async delete<T>(endpoint: string, options?: ApiOptions): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }

  /**
   * 액세스 토큰 가져오기
   */
  private getAccessToken(): string | null {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('accessToken');
    }
    return null;
  }

  /**
   * 리프레시 토큰 가져오기
   */
  private getRefreshToken(): string | null {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('refreshToken');
    }
    return null;
  }

  /**
   * 토큰 갱신
   */
  private async refreshToken(): Promise<boolean> {
    try {
      const refreshToken = this.getRefreshToken();
      if (!refreshToken) {
        return false;
      }

      const response = await fetch(`${this.baseUrl}/auth/refresh`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken }),
      });

      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('accessToken', data.accessToken);
        return true;
      }

      return false;
    } catch (error) {
      console.error('토큰 갱신 오류:', error);
      return false;
    }
  }

  /**
   * 인증 실패 처리
   */
  private handleAuthFailure(): void {
    // 토큰 제거
    if (typeof window !== 'undefined') {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
      
      // 로그인 페이지로 리다이렉트
      window.location.href = '/auth/login?error=session_expired';
    }
  }

  /**
   * 수동 로그아웃
   */
  logout(): void {
    this.handleAuthFailure();
  }
}

// 싱글톤 인스턴스 생성
export const apiClient = new ApiClient();

// 편의를 위한 직접 내보내기
export const api = {
  get: <T>(endpoint: string, params?: Record<string, any>, options?: ApiOptions) => apiClient.get<T>(endpoint, params, options),
  post: <T>(endpoint: string, data?: any, options?: ApiOptions) => apiClient.post<T>(endpoint, data, options),
  put: <T>(endpoint: string, data?: any, options?: ApiOptions) => apiClient.put<T>(endpoint, data, options),
  delete: <T>(endpoint: string, options?: ApiOptions) => apiClient.delete<T>(endpoint, options),
  logout: () => apiClient.logout(),
};

export default apiClient;
</file>

<file path="frontend/Dockerfile">
# Frontend Dockerfile
FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /root

# Copy all package files
COPY package*.json ./
COPY shared/package*.json ./shared/
COPY frontend/package*.json ./frontend/

# Install all dependencies
RUN npm ci

# Build shared module first
FROM base AS shared-builder
WORKDIR /root
COPY --from=deps /root/node_modules ./node_modules
COPY shared ./shared
WORKDIR /root/shared
RUN npm run build

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /root/frontend
COPY --from=deps /root/node_modules ../node_modules
COPY --from=deps /root/package-lock.json ../package-lock.json
COPY --from=shared-builder /root/shared ../shared
COPY frontend ./

# Create public directory if it doesn't exist
RUN mkdir -p public

# Build frontend
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /root/frontend/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /root/frontend/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /root/frontend/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/shared/*": ["../shared/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="shared/constants/api-endpoints.ts">
// API 기본 설정
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001'
export const API_VERSION = 'v1'
export const API_PREFIX = `/api/${API_VERSION}`

// 인증 관련 엔드포인트
export const AUTH_ENDPOINTS = {
  LOGIN: `${API_PREFIX}/auth/login`,
  REGISTER: `${API_PREFIX}/auth/register`,
  LOGOUT: `${API_PREFIX}/auth/logout`,
  REFRESH: `${API_PREFIX}/auth/refresh`,
  PROFILE: `${API_PREFIX}/auth/profile`,
  GOOGLE: `${API_PREFIX}/auth/google`,
  GOOGLE_CALLBACK: `${API_PREFIX}/auth/google/callback`,
} as const

// 사용자 관련 엔드포인트
export const USER_ENDPOINTS = {
  BASE: `${API_PREFIX}/users`,
  BY_ID: (id: string) => `${API_PREFIX}/users/${id}`,
  UPDATE_PROFILE: (id: string) => `${API_PREFIX}/users/${id}/profile`,
  CHANGE_PASSWORD: (id: string) => `${API_PREFIX}/users/${id}/password`,
  UPLOAD_AVATAR: (id: string) => `${API_PREFIX}/users/${id}/avatar`,
} as const

// 프로젝트 관련 엔드포인트
export const PROJECT_ENDPOINTS = {
  BASE: `${API_PREFIX}/projects`,
  BY_ID: (id: string) => `${API_PREFIX}/projects/${id}`,
  MEMBERS: (id: string) => `${API_PREFIX}/projects/${id}/members`,
  ADD_MEMBER: (id: string) => `${API_PREFIX}/projects/${id}/members`,
  REMOVE_MEMBER: (projectId: string, userId: string) => 
    `${API_PREFIX}/projects/${projectId}/members/${userId}`,
  TASKS: (id: string) => `${API_PREFIX}/projects/${id}/tasks`,
} as const

// 업무 관련 엔드포인트
export const TASK_ENDPOINTS = {
  BASE: `${API_PREFIX}/tasks`,
  BY_ID: (id: string) => `${API_PREFIX}/tasks/${id}`,
  BY_PROJECT: (projectId: string) => `${API_PREFIX}/projects/${projectId}/tasks`,
  BY_USER: (userId: string) => `${API_PREFIX}/users/${userId}/tasks`,
  ASSIGN: (id: string) => `${API_PREFIX}/tasks/${id}/assign`,
  STATUS: (id: string) => `${API_PREFIX}/tasks/${id}/status`,
  COMMENTS: (id: string) => `${API_PREFIX}/tasks/${id}/comments`,
} as const

// 게시판 관련 엔드포인트
export const BOARD_ENDPOINTS = {
  POSTS: `${API_PREFIX}/board/posts`,
  POST_BY_ID: (id: string) => `${API_PREFIX}/board/posts/${id}`,
  POST_COMMENTS: (id: string) => `${API_PREFIX}/board/posts/${id}/comments`,
  POST_LIKE: (id: string) => `${API_PREFIX}/board/posts/${id}/like`,
  POST_UNLIKE: (id: string) => `${API_PREFIX}/board/posts/${id}/unlike`,
  COMMENTS: `${API_PREFIX}/board/comments`,
  COMMENT_BY_ID: (id: string) => `${API_PREFIX}/board/comments/${id}`,
} as const

// 파일 관련 엔드포인트
export const FILE_ENDPOINTS = {
  UPLOAD: `${API_PREFIX}/files/upload`,
  UPLOAD_MULTIPLE: `${API_PREFIX}/files/upload/multiple`,
  BY_ID: (id: string) => `${API_PREFIX}/files/${id}`,
  DOWNLOAD: (id: string) => `${API_PREFIX}/files/${id}/download`,
  DELETE: (id: string) => `${API_PREFIX}/files/${id}`,
  BY_USER: (userId: string) => `${API_PREFIX}/users/${userId}/files`,
  BY_PROJECT: (projectId: string) => `${API_PREFIX}/projects/${projectId}/files`,
} as const

// 알림 관련 엔드포인트
export const NOTIFICATION_ENDPOINTS = {
  BASE: `${API_PREFIX}/notifications`,
  BY_ID: (id: string) => `${API_PREFIX}/notifications/${id}`,
  MARK_READ: (id: string) => `${API_PREFIX}/notifications/${id}/read`,
  MARK_ALL_READ: `${API_PREFIX}/notifications/read-all`,
  UNREAD_COUNT: `${API_PREFIX}/notifications/unread-count`,
} as const

// 대시보드 관련 엔드포인트
export const DASHBOARD_ENDPOINTS = {
  STATS: `${API_PREFIX}/dashboard/stats`,
  RECENT_TASKS: `${API_PREFIX}/dashboard/recent-tasks`,
  RECENT_PROJECTS: `${API_PREFIX}/dashboard/recent-projects`,
  ACTIVITIES: `${API_PREFIX}/dashboard/activities`,
} as const

// 목표 관련 엔드포인트 (워클리 방법론)
export const GOAL_ENDPOINTS = {
  BASE: `${API_PREFIX}/goals`,
  BY_ID: (id: string) => `${API_PREFIX}/goals/${id}`,
  PROJECTS: (id: string) => `${API_PREFIX}/goals/${id}/projects`,
  METRICS: (id: string) => `${API_PREFIX}/goals/${id}/metrics`,
  UPDATE_PROGRESS: (id: string) => `${API_PREFIX}/goals/${id}/progress`,
  ACTIVITIES: (id: string) => `${API_PREFIX}/goals/${id}/activities`,
  DASHBOARD: (id: string) => `${API_PREFIX}/goals/${id}/dashboard`,
} as const

// 수집함 관련 엔드포인트 (워클리 방법론)
export const INBOX_ENDPOINTS = {
  BASE: `${API_PREFIX}/inbox`,
  BY_ID: (id: string) => `${API_PREFIX}/inbox/${id}`,
  QUICK_CAPTURE: `${API_PREFIX}/inbox/quick-capture`,
  BATCH_PROCESS: `${API_PREFIX}/inbox/batch-process`,
  STATS: `${API_PREFIX}/inbox/stats`,
  DASHBOARD: `${API_PREFIX}/inbox/dashboard`,
  ACTIVITIES: `${API_PREFIX}/inbox/activities`,
  ORGANIZE: (id: string) => `${API_PREFIX}/inbox/${id}/organize`,
  CLARIFY: (id: string) => `${API_PREFIX}/inbox/${id}/clarify`,
} as const

// CPER 워크플로우 관련 엔드포인트
export const WORKFLOW_ENDPOINTS = {
  CAPTURE: `${API_PREFIX}/workflow/capture`,
  PLAN: `${API_PREFIX}/workflow/plan`,
  EXECUTE: `${API_PREFIX}/workflow/execute`,
  REVIEW: `${API_PREFIX}/workflow/review`,
  STATUS: `${API_PREFIX}/workflow/status`,
  INSIGHTS: `${API_PREFIX}/workflow/insights`,
} as const

// 네비게이션 관련 엔드포인트
export const NAVIGATION_ENDPOINTS = {
  STATS: `${API_PREFIX}/navigation/stats`,
  QUICK_STATS: `${API_PREFIX}/navigation/quick-stats`,
  PREFERENCES: `${API_PREFIX}/navigation/preferences`,
} as const

// 검색 관련 엔드포인트
export const SEARCH_ENDPOINTS = {
  GLOBAL: `${API_PREFIX}/search`,
  USERS: `${API_PREFIX}/search/users`,
  PROJECTS: `${API_PREFIX}/search/projects`,
  TASKS: `${API_PREFIX}/search/tasks`,
  GOALS: `${API_PREFIX}/search/goals`,
  INBOX: `${API_PREFIX}/search/inbox`,
  POSTS: `${API_PREFIX}/search/posts`,
} as const
</file>

<file path="shared/src/index.ts">
// Types
export * from '../types/api.types';
export * from '../types/socket.types';
export * from '../types/admin.types';
export * from '../types/goal.types';
export * from '../types/inbox.types';
export * from '../types/navigation.types';
export * from '../types/workly-core.types';

// Constants
export * from '../constants/api-endpoints';
export * from '../constants/socket-events';

// Utils
export * from '../utils/hierarchy.utils';

// Index export from types/index.ts for completeness
export * from '../types/index';
</file>

<file path="shared/types/admin.types.ts">
/**
 * 워클리 어드민 패널 타입 정의
 * 관리자 전용 인터페이스 및 데이터 구조
 */

// ==================== 권한 및 역할 ====================

export enum AdminRole {
  SUPER_ADMIN = 'super_admin',    // 모든 권한
  ADMIN = 'admin',                // 사용자/콘텐츠 관리
  MODERATOR = 'moderator',        // 콘텐츠 모더레이션만
  SUPPORT = 'support',            // 사용자 지원 (읽기 전용 + 기본 사용자 관리)
}

export interface AdminPermissions {
  users: {
    read: boolean;
    create: boolean;
    update: boolean;
    delete: boolean;
    changeRole: boolean;
  };
  content: {
    read: boolean;
    moderate: boolean;
    delete: boolean;
  };
  projects: {
    read: boolean;
    moderate: boolean;
    close: boolean;
    featured: boolean;
  };
  system: {
    read: boolean;
    configure: boolean;
    maintenance: boolean;
    monitoring: boolean;
  };
}

// ==================== 대시보드 ====================

export interface DashboardKPIs {
  totalUsers: number;
  activeUsers: number;
  newUsersThisWeek: number;
  totalProjects: number;
  activeProjects: number;
  completedProjects: number;
  totalTasks: number;
  completedTasks: number;
  systemHealth: 'healthy' | 'warning' | 'critical';
  lastUpdated: string;
}

export interface TimeSeriesData {
  date: string;
  value: number;
  label?: string;
}

export interface PieChartData {
  name: string;
  value: number;
  color: string;
}

export interface MetricsData {
  cpu: number;
  memory: number;
  disk: number;
  network: {
    incoming: number;
    outgoing: number;
  };
  database: {
    connections: number;
    queryTime: number;
  };
}

export interface ActivityLog {
  id: string;
  type: 'user_registered' | 'project_created' | 'task_completed' | 'error_occurred';
  title: string;
  description: string;
  userId?: string;
  userEmail?: string;
  metadata?: Record<string, any>;
  timestamp: string;
  severity: 'info' | 'warning' | 'error';
}

export interface DashboardData {
  kpis: DashboardKPIs;
  charts: {
    userGrowth: TimeSeriesData[];
    taskCompletion: TimeSeriesData[];
    projectStatus: PieChartData[];
    serverMetrics: MetricsData;
  };
  recentActivity: ActivityLog[];
}

// ==================== 사용자 관리 ====================

export interface UserWithStats {
  id: string;
  email: string;
  name: string;
  role: string;
  status: string;
  avatar?: string;
  createdAt: string;
  lastLoginAt?: string;
  emailVerifiedAt?: string;
  
  // 통계 정보
  stats: {
    totalProjects: number;
    completedTasks: number;
    activeProjects: number;
    collaborations: number;
  };
}

export interface UserManagementFilters {
  role?: string[];
  status?: string[];
  registrationDate?: {
    start: string;
    end: string;
  };
  lastActivity?: {
    start: string;
    end: string;
  };
  search?: string;
}

export interface BulkUserAction {
  userIds: string[];
  action: 'activate' | 'deactivate' | 'suspend' | 'delete' | 'send_email';
  params?: Record<string, any>;
}

// ==================== 프로젝트 관리 ====================

export interface ProjectWithMetrics {
  id: string;
  name: string;
  description?: string;
  status: string;
  progress: number;
  memberCount: number;
  taskCount: number;
  completedTaskCount: number;
  createdAt: string;
  updatedAt: string;
  ownerId: string;
  ownerName: string;
  
  // 메트릭스
  metrics: {
    averageTaskCompletionTime: number;
    memberEngagement: number;
    messagesCount: number;
    filesCount: number;
    lastActivity: string;
  };
  
  // 위험 지표
  riskFlags: {
    inactive: boolean;
    overdue: boolean;
    lowEngagement: boolean;
    reported: boolean;
  };
}

export interface ProjectAnalytics {
  successRate: number;
  averageCompletionTime: number;
  popularSkills: Array<{
    skill: string;
    count: number;
    successRate: number;
  }>;
  teamSizeDistribution: Array<{
    size: string;
    count: number;
    successRate: number;
  }>;
  monthlyTrends: {
    created: TimeSeriesData[];
    completed: TimeSeriesData[];
    cancelled: TimeSeriesData[];
  };
}

// ==================== 업무 관리 ====================

export interface TaskWithContext {
  id: string;
  title: string;
  description?: string;
  status: string;
  priority: string;
  dueDate?: string;
  createdAt: string;
  assigneeId?: string;
  assigneeName?: string;
  projectId?: string;
  projectName?: string;
  
  // 컨텍스트 정보
  labels: string[];
  commentsCount: number;
  attachmentsCount: number;
  dependenciesCount: number;
  
  // 품질 지표
  qualityFlags: {
    hasDescription: boolean;
    hasLabels: boolean;
    hasAssignee: boolean;
    hasDueDate: boolean;
    isOverdue: boolean;
  };
}

export interface TaskCategories {
  uncategorized: number;
  blocked: number;
  overdue: number;
  highPriority: number;
  noDueDate: number;
  noAssignee: number;
}

export interface TaskAutomationSettings {
  autoLabeling: boolean;
  duplicateDetection: boolean;
  spamFilter: boolean;
  overduNotifications: boolean;
  priorityAutoEscalation: boolean;
}

// ==================== 콘텐츠 관리 ====================

export interface ContentReport {
  id: string;
  reporterId: string;
  reporterName: string;
  contentType: 'project' | 'task' | 'comment' | 'message';
  contentId: string;
  contentTitle?: string;
  reason: ReportReason;
  description: string;
  status: 'pending' | 'reviewed' | 'resolved' | 'dismissed';
  reviewedBy?: string;
  reviewedByName?: string;
  reviewedAt?: string;
  action?: 'no_action' | 'warning' | 'content_removed' | 'user_suspended';
  createdAt: string;
  
  // 콘텐츠 스니펫
  contentPreview: string;
  contentAuthorId: string;
  contentAuthorName: string;
}

export enum ReportReason {
  SPAM = 'spam',
  HARASSMENT = 'harassment',
  INAPPROPRIATE_CONTENT = 'inappropriate_content',
  COPYRIGHT_VIOLATION = 'copyright_violation',
  FAKE_INFORMATION = 'fake_information',
  VIOLENCE = 'violence',
  HATE_SPEECH = 'hate_speech',
  OTHER = 'other'
}

export interface ContentModerationAction {
  reportId: string;
  action: 'dismiss' | 'warn_user' | 'remove_content' | 'suspend_user';
  reason: string;
  duration?: number; // 정지 기간 (일)
  notifyUser: boolean;
}

// ==================== 시스템 설정 ====================

export interface SystemSettings {
  app: {
    maintenanceMode: boolean;
    newUserRegistration: boolean;
    projectCreation: boolean;
    fileUpload: boolean;
    maxFileSize: number; // MB
    maxProjectMembers: number;
    taskDeadlineWarningDays: number;
  };
  notifications: {
    emailEnabled: boolean;
    pushEnabled: boolean;
    dailyDigestEnabled: boolean;
    weeklyReportEnabled: boolean;
  };
  security: {
    passwordMinLength: number;
    passwordRequireSpecialChar: boolean;
    sessionTimeoutMinutes: number;
    maxLoginAttempts: number;
    twoFactorRequired: boolean;
  };
  features: {
    realTimeChat: boolean;
    fileSharing: boolean;
    integrations: boolean;
    analytics: boolean;
    apiAccess: boolean;
  };
}

export interface EmailTemplate {
  id: string;
  name: string;
  subject: string;
  content: string;
  type: 'welcome' | 'password_reset' | 'project_invitation' | 'task_reminder' | 'weekly_digest';
  variables: string[]; // 사용 가능한 변수들
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

// ==================== 시스템 모니터링 ====================

export interface ServerMetrics {
  cpu: {
    usage: number;
    cores: number;
    loadAverage: number[];
  };
  memory: {
    total: number;
    used: number;
    free: number;
    usage: number;
  };
  disk: {
    total: number;
    used: number;
    free: number;
    usage: number;
  };
  network: {
    bytesIn: number;
    bytesOut: number;
    packetsIn: number;
    packetsOut: number;
  };
}

export interface DatabaseMetrics {
  connections: {
    active: number;
    idle: number;
    total: number;
    max: number;
  };
  queries: {
    total: number;
    slow: number;
    failed: number;
    averageTime: number;
  };
  size: {
    total: number;
    tables: Array<{
      name: string;
      size: number;
      rows: number;
    }>;
  };
}

export interface APIMetrics {
  requests: {
    total: number;
    successful: number;
    failed: number;
    averageResponseTime: number;
  };
  endpoints: Array<{
    path: string;
    method: string;
    calls: number;
    averageTime: number;
    errorRate: number;
  }>;
  statusCodes: Record<string, number>;
}

export interface ErrorLog {
  id: string;
  level: 'error' | 'warning' | 'info';
  message: string;
  stack?: string;
  context: Record<string, any>;
  userId?: string;
  endpoint?: string;
  timestamp: string;
  resolved: boolean;
}

export interface Alert {
  id: string;
  type: 'cpu_high' | 'memory_high' | 'disk_full' | 'api_slow' | 'error_rate_high';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  value: number;
  threshold: number;
  timestamp: string;
  acknowledged: boolean;
  acknowledgedBy?: string;
  resolvedAt?: string;
}

// ==================== 감사 로그 ====================

export interface AuditLog {
  id: string;
  adminId: string;
  adminName: string;
  action: string;
  targetType: 'user' | 'project' | 'task' | 'system' | 'settings';
  targetId?: string;
  targetName?: string;
  changes: {
    before?: Record<string, any>;
    after?: Record<string, any>;
  };
  ipAddress: string;
  userAgent: string;
  timestamp: string;
  success: boolean;
  errorMessage?: string;
}

// ==================== 어드민 전용 API 응답 타입 ====================

export interface AdminPaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export interface AdminApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: Array<{
    field?: string;
    message: string;
  }>;
}

// ==================== 통계 및 분석 ====================

export interface UserGrowthStats {
  period: 'daily' | 'weekly' | 'monthly';
  data: Array<{
    date: string;
    newUsers: number;
    activeUsers: number;
    retentionRate: number;
  }>;
}

export interface ProjectSuccessStats {
  totalProjects: number;
  completedProjects: number;
  cancelledProjects: number;
  successRate: number;
  averageCompletionDays: number;
  topReasons: Array<{
    reason: string;
    count: number;
  }>;
}

export interface PlatformHealthScore {
  overall: number; // 0-100
  components: {
    userEngagement: number;
    systemPerformance: number;
    contentQuality: number;
    errorRate: number;
  };
  trends: {
    lastWeek: number;
    lastMonth: number;
  };
}
</file>

<file path="shared/types/index.ts">
/**
 * 워클리 고유 방법론 - 통합 타입 익스포트
 * 모든 핵심 타입을 중앙에서 관리
 */

// 기존 타입들
export * from './api.types';
export * from './socket.types';

// 워클리 방법론 새로운 타입들
export * from './goal.types';
export * from './inbox.types';
export * from './navigation.types';

// 어드민 패널 타입들
export * from './admin.types';

// 워클리 방법론 핵심 상수
export const WORKLY_METHODOLOGY = {
  name: 'Workly Unique Methodology',
  version: '1.0.0',
  hierarchy: ['Goal', 'Project', 'Task'] as const,
  workflow: ['Capture', 'Plan', 'Execute', 'Review'] as const,
  navigation: ['Tasks', 'Projects', 'Inbox', 'Goals', 'Profile'] as const,
} as const;

// CPER 워크플로우 단계별 색상 테마
export const CPER_THEME = {
  capture: {
    primary: '#3B82F6',   // Blue
    secondary: '#DBEAFE',
    accent: '#1D4ED8',
  },
  plan: {
    primary: '#10B981',   // Green
    secondary: '#D1FAE5',
    accent: '#059669',
  },
  execute: {
    primary: '#F59E0B',   // Amber
    secondary: '#FEF3C7',
    accent: '#D97706',
  },
  review: {
    primary: '#8B5CF6',   // Purple
    secondary: '#EDE9FE',
    accent: '#7C3AED',
  },
} as const;

// 네비게이션 항목별 색상 및 아이콘
export const NAVIGATION_CONFIG = {
  tasks: {
    icon: 'CheckSquare',
    color: '#3B82F6',
    label: '업무',
  },
  projects: {
    icon: 'Folder',
    color: '#10B981',
    label: '프로젝트',
  },
  inbox: {
    icon: 'Inbox',
    color: '#F59E0B',
    label: '수집함',
    isCenter: true,
    isEmphasized: true,
  },
  goals: {
    icon: 'Target',
    color: '#8B5CF6',
    label: '목표',
  },
  profile: {
    icon: 'User',
    color: '#6B7280',
    label: '프로필',
  },
} as const;
</file>

<file path="shared/types/workly-core.types.ts">
/**
 * 워클리 고유 방법론 - 핵심 계층구조 및 독립성 로직
 * 업무 중심의 유연한 계층구조 구현
 */

// 계층구조 타입
export enum HierarchyType {
  INDEPENDENT = 'independent',    // 독립적 업무
  PROJECT_ONLY = 'project_only',  // 프로젝트에만 속함 (목표 없음)
  GOAL_DIRECT = 'goal_direct',    // 목표에 직접 속함 (프로젝트 없음)
  FULL_HIERARCHY = 'full_hierarchy' // 완전한 계층 (업무 -> 프로젝트 -> 목표)
}

// 계층구조 선택 옵션
export interface HierarchyChoice {
  type: HierarchyType
  projectId?: string    // 기존 프로젝트 선택
  goalId?: string      // 기존 목표 선택
  createProject?: {    // 새 프로젝트 생성
    title: string
    description?: string
    goalId?: string    // 상위 목표 연결
  }
  createGoal?: {       // 새 목표 생성
    title: string
    description?: string
  }
}

// CPER 단계별 상태
export enum CPERStage {
  CAPTURED = 'captured',     // 수집됨
  PLANNED = 'planned',       // 계획됨
  EXECUTING = 'executing',   // 실행 중
  COMPLETED = 'completed',   // 완료됨
  REVIEWED = 'reviewed'      // 검토됨
}

// CPER 워크플로우 데이터
export interface CPERWorkflowData {
  stage: CPERStage
  capturedAt: string
  plannedAt?: string
  executionStartedAt?: string
  completedAt?: string
  reviewedAt?: string
  
  // 계획 단계 데이터
  planningData?: {
    isActionable: boolean
    canComplete2Minutes: boolean
    timeEstimate: number        // 분 단위
    priorityReasoning: string
    hierarchyChoice: HierarchyChoice
    nextAction?: string
  }
  
  // 실행 단계 데이터
  executionData?: {
    isToday: boolean
    isFocused: boolean
    startedAt?: string
    pausedAt?: string
    actualTimeSpent: number     // 분 단위
    progressNotes: string[]
  }
  
  // 검토 단계 데이터
  reviewData?: {
    lessonsLearned: string[]
    improvements: string[]
    goalContribution: number    // 0-100 (목표 기여도)
    projectContribution: number // 0-100 (프로젝트 기여도)
    satisfaction: number        // 1-5 (만족도)
    wouldDoAgain: boolean
  }
}

// 확장된 업무 인터페이스 (기존 Task 확장)
export interface WorklyTask {
  // 기본 정보 (기존 Task 인터페이스와 호환)
  id: string
  title: string
  description?: string
  status: TaskStatus
  priority: TaskPriority
  type: TaskType
  
  // 날짜 관련
  dueDate?: string
  startDate?: string
  completedAt?: string
  
  // 계층구조 (핵심!)
  hierarchyType: HierarchyType
  projectId?: string      // 프로젝트 연결 (선택적)
  goalId?: string         // 목표 연결 (선택적, 직접 연결 또는 프로젝트 통해 간접 연결)
  
  // CPER 워크플로우
  cperWorkflow: CPERWorkflowData
  
  // 실행 관련
  isToday: boolean
  isFocused: boolean
  nextAction?: string
  estimatedMinutes: number
  actualMinutes: number
  
  // 관계 및 소유자
  assigneeId: string
  assignee: {
    id: string
    name: string
    email: string
  }
  
  // 태그 및 분류
  tags: string[]
  
  // 메타데이터
  createdAt: string
  updatedAt: string
  
  // 계산된 속성
  isOverdue?: boolean
  isDueSoon?: boolean
  hierarchyPath?: string  // "목표명 > 프로젝트명" 또는 "독립적 업무"
}

// 계층구조 관계 인터페이스
export interface HierarchyRelation {
  taskId: string
  projectId?: string
  goalId?: string
  relationshipType: HierarchyType
  establishedAt: string
  establishedBy: string
}

// 계층구조 변경 요청
export interface HierarchyChangeRequest {
  taskId: string
  fromHierarchy: {
    type: HierarchyType
    projectId?: string
    goalId?: string
  }
  toHierarchy: HierarchyChoice
  reason?: string
}

// 계층구조 검증 규칙
export interface HierarchyValidation {
  isValid: boolean
  errors: string[]
  warnings: string[]
  suggestions: string[]
}

// 계층구조 분석 데이터
export interface HierarchyAnalytics {
  taskId: string
  hierarchyType: HierarchyType
  
  // 연결 관계 분석
  connections: {
    projectConnection?: {
      projectId: string
      projectTitle: string
      projectProgress: number
      contributionPercentage: number
    }
    goalConnection?: {
      goalId: string
      goalTitle: string
      goalProgress: number
      contributionPercentage: number
      isDirectConnection: boolean  // 직접 연결 vs 프로젝트 통한 간접 연결
    }
  }
  
  // 영향도 분석
  impact: {
    onProject?: number      // 0-100 (프로젝트에 미치는 영향)
    onGoal?: number        // 0-100 (목표에 미치는 영향)
    independence: number    // 0-100 (독립성 점수)
  }
  
  // 추천사항
  recommendations: {
    shouldMoveToProject?: string
    shouldConnectToGoal?: string
    shouldBecomeIndependent?: string
  }
}

// 유틸리티 함수들을 위한 인터페이스
export interface HierarchyUtils {
  // 계층구조 경로 생성
  getHierarchyPath(task: WorklyTask, project?: Project, goal?: Goal): string
  
  // 계층구조 변경 가능 여부 확인
  canChangeHierarchy(task: WorklyTask, newHierarchy: HierarchyChoice): HierarchyValidation
  
  // 계층구조 분석
  analyzeHierarchy(task: WorklyTask): HierarchyAnalytics
  
  // 독립적 업무 여부 확인
  isIndependentTask(task: WorklyTask): boolean
  
  // 프로젝트를 통한 목표 연결 확인
  isGoalConnectedThroughProject(task: WorklyTask): boolean
  
  // 직접 목표 연결 확인
  isDirectlyConnectedToGoal(task: WorklyTask): boolean
}

// 홈화면 "오늘 할 일" 최적화를 위한 인터페이스
export interface TodayTasksOptimized {
  // 집중 업무 (최우선)
  focusedTasks: WorklyTask[]
  
  // 긴급 업무
  urgentTasks: WorklyTask[]
  
  // 일반 오늘 업무
  todayTasks: WorklyTask[]
  
  // 다음 액션이 명확한 업무
  readyToStartTasks: WorklyTask[]
  
  // 계층구조별 그룹화
  groupedByHierarchy: {
    independent: WorklyTask[]
    byProject: {
      projectId: string
      projectTitle: string
      tasks: WorklyTask[]
    }[]
    byGoal: {
      goalId: string
      goalTitle: string
      directTasks: WorklyTask[]  // 목표에 직접 연결된 업무
      projectTasks: {
        projectId: string
        projectTitle: string
        tasks: WorklyTask[]
      }[]
    }[]
  }
  
  // 시간 관리 정보
  timeAnalysis: {
    totalEstimatedMinutes: number
    focusedTasksMinutes: number
    averageTaskMinutes: number
    recommendedDailyLimit: number
  }
}

// CPER 단계별 액션 정의
export interface CPERActions {
  // Capture 단계
  capture: {
    quickCapture(content: string): Promise<string> // InboxItem ID 반환
    structuredCapture(data: CreateInboxItemDto): Promise<string>
  }
  
  // Plan 단계
  plan: {
    clarifyItem(inboxItemId: string, clarification: CPERWorkflowData['planningData']): Promise<void>
    convertToTask(inboxItemId: string, hierarchyChoice: HierarchyChoice): Promise<string> // Task ID 반환
  }
  
  // Execute 단계
  execute: {
    setTodayTasks(taskIds: string[]): Promise<void>
    setFocusedTask(taskId: string): Promise<void>
    startExecution(taskId: string): Promise<void>
    updateProgress(taskId: string, progressNote: string): Promise<void>
    completeTask(taskId: string): Promise<void>
  }
  
  // Review 단계
  review: {
    addReview(taskId: string, reviewData: CPERWorkflowData['reviewData']): Promise<void>
    getInsights(taskId: string): Promise<HierarchyAnalytics>
  }
}

// 타입 가드 함수들
export const TypeGuards = {
  isWorklyTask: (obj: any): obj is WorklyTask => {
    return obj && typeof obj.hierarchyType === 'string' && obj.cperWorkflow
  },
  
  isIndependentTask: (task: WorklyTask): boolean => {
    return task.hierarchyType === HierarchyType.INDEPENDENT
  },
  
  hasProjectConnection: (task: WorklyTask): boolean => {
    return task.hierarchyType === HierarchyType.PROJECT_ONLY || 
           task.hierarchyType === HierarchyType.FULL_HIERARCHY
  },
  
  hasGoalConnection: (task: WorklyTask): boolean => {
    return task.hierarchyType === HierarchyType.GOAL_DIRECT || 
           task.hierarchyType === HierarchyType.FULL_HIERARCHY
  }
}

// 기존 타입들 import (순환 참조 방지)
import { TaskStatus, Priority as TaskPriority, TaskType, Project } from './api.types'
import { Goal } from './goal.types'
import { CreateInboxItemDto } from './inbox.types'
</file>

<file path="shared/utils/hierarchy.utils.ts">
/**
 * 워클리 계층구조 관리 유틸리티
 * 업무-프로젝트-목표 간의 관계를 관리하고 독립성을 지원
 */

import { 
  WorklyTask, 
  HierarchyType, 
  HierarchyChoice, 
  HierarchyValidation, 
  HierarchyAnalytics,
  TodayTasksOptimized,
  CPERStage
} from '../types/workly-core.types'
import { Goal } from '../types/goal.types'
import { Project } from '../types/api.types'

export class HierarchyManager {
  
  /**
   * 계층구조 경로 생성
   * 예: "워클리 플랫폼 완성 > MVP 개발" 또는 "독립적 업무"
   */
  static getHierarchyPath(
    task: WorklyTask, 
    project?: Project, 
    goal?: Goal
  ): string {
    switch (task.hierarchyType) {
      case HierarchyType.INDEPENDENT:
        return '독립적 업무'
        
      case HierarchyType.PROJECT_ONLY:
        return project ? project.title : '프로젝트 미확인'
        
      case HierarchyType.GOAL_DIRECT:
        return goal ? goal.title : '목표 미확인'
        
      case HierarchyType.FULL_HIERARCHY:
        const goalTitle = goal?.title || '목표 미확인'
        const projectTitle = project?.title || '프로젝트 미확인'
        return `${goalTitle} > ${projectTitle}`
        
      default:
        return '알 수 없음'
    }
  }

  /**
   * 계층구조 변경 가능 여부 확인
   */
  static canChangeHierarchy(
    task: WorklyTask, 
    newHierarchy: HierarchyChoice
  ): HierarchyValidation {
    const errors: string[] = []
    const warnings: string[] = []
    const suggestions: string[] = []

    // 기본 검증
    if (task.cperWorkflow.stage === CPERStage.EXECUTING) {
      warnings.push('실행 중인 업무의 계층구조 변경은 신중하게 고려하세요.')
    }

    if (task.cperWorkflow.stage === CPERStage.COMPLETED) {
      errors.push('완료된 업무의 계층구조는 변경할 수 없습니다.')
    }

    // 순환 참조 검증 (프로젝트 -> 목표)
    if (newHierarchy.type === HierarchyType.FULL_HIERARCHY) {
      if (newHierarchy.projectId && newHierarchy.goalId) {
        // TODO: 실제로는 프로젝트가 해당 목표에 속하는지 확인 필요
        // if (!this.isProjectBelongsToGoal(newHierarchy.projectId, newHierarchy.goalId)) {
        //   errors.push('선택한 프로젝트가 해당 목표에 속하지 않습니다.')
        // }
      }
    }

    // 독립성 검증
    if (newHierarchy.type === HierarchyType.INDEPENDENT) {
      if (task.cperWorkflow.executionData?.isFocused) {
        warnings.push('집중 업무를 독립적으로 변경하면 프로젝트 진행에 영향을 줄 수 있습니다.')
      }
    }

    // 제안사항
    if (task.hierarchyType === HierarchyType.INDEPENDENT && 
        newHierarchy.type !== HierarchyType.INDEPENDENT) {
      suggestions.push('독립적 업무를 계층구조에 포함시키면 목표 달성을 더 체계적으로 추적할 수 있습니다.')
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      suggestions
    }
  }

  /**
   * 계층구조 분석
   */
  static analyzeHierarchy(
    task: WorklyTask,
    project?: Project,
    goal?: Goal
  ): HierarchyAnalytics {
    const analysis: HierarchyAnalytics = {
      taskId: task.id,
      hierarchyType: task.hierarchyType,
      connections: {},
      impact: {
        independence: 0
      },
      recommendations: {}
    }

    // 연결 관계 분석
    if (project && task.projectId) {
      analysis.connections.projectConnection = {
        projectId: project.id,
        projectTitle: project.title,
        projectProgress: project.progress,
        contributionPercentage: this.calculateProjectContribution(task, project)
      }
    }

    if (goal) {
      const isDirectConnection = task.hierarchyType === HierarchyType.GOAL_DIRECT
      analysis.connections.goalConnection = {
        goalId: goal.id,
        goalTitle: goal.title,
        goalProgress: goal.progress,
        contributionPercentage: this.calculateGoalContribution(task, goal),
        isDirectConnection
      }
    }

    // 독립성 점수 계산
    analysis.impact.independence = this.calculateIndependenceScore(task)

    // 프로젝트/목표 영향도 계산
    if (analysis.connections.projectConnection) {
      analysis.impact.onProject = analysis.connections.projectConnection.contributionPercentage
    }
    if (analysis.connections.goalConnection) {
      analysis.impact.onGoal = analysis.connections.goalConnection.contributionPercentage
    }

    // 추천사항 생성
    analysis.recommendations = this.generateRecommendations(task, analysis)

    return analysis
  }

  /**
   * 프로젝트 기여도 계산
   */
  private static calculateProjectContribution(task: WorklyTask, project: Project): number {
    // 간단한 계산: 프로젝트 내 업무 수 대비 이 업무의 가중치
    // 실제로는 업무의 우선순위, 소요시간, 복잡도 등을 고려해야 함
    const baseContribution = 100 / (project.tasksCount || 1)
    
    // 우선순위에 따른 가중치
    const priorityWeight = this.getPriorityWeight(task.priority)
    
    // 예상 소요시간에 따른 가중치  
    const timeWeight = Math.min(task.estimatedMinutes / 480, 2) // 8시간 기준, 최대 2배
    
    return Math.min(baseContribution * priorityWeight * timeWeight, 100)
  }

  /**
   * 목표 기여도 계산
   */
  private static calculateGoalContribution(task: WorklyTask, goal: Goal): number {
    // 목표에 직접 연결된 업무인지, 프로젝트를 통해 간접 연결된 업무인지에 따라 다르게 계산
    const isDirectConnection = task.hierarchyType === HierarchyType.GOAL_DIRECT
    
    let baseContribution: number
    
    if (isDirectConnection) {
      // 직접 연결: 목표 내 직접 업무 수 대비
      baseContribution = 100 / Math.max(goal.projectCount * 3, 1) // 가정: 프로젝트당 평균 3개 업무
    } else {
      // 간접 연결: 프로젝트를 통한 기여
      baseContribution = 100 / Math.max(goal.projectCount * 10, 1) // 가정: 프로젝트당 평균 10개 업무
    }
    
    const priorityWeight = this.getPriorityWeight(task.priority)
    
    return Math.min(baseContribution * priorityWeight, 100)
  }

  /**
   * 독립성 점수 계산
   */
  private static calculateIndependenceScore(task: WorklyTask): number {
    switch (task.hierarchyType) {
      case HierarchyType.INDEPENDENT:
        return 100
      case HierarchyType.PROJECT_ONLY:
        return 30
      case HierarchyType.GOAL_DIRECT:
        return 20
      case HierarchyType.FULL_HIERARCHY:
        return 0
      default:
        return 50
    }
  }

  /**
   * 우선순위 가중치 계산
   */
  private static getPriorityWeight(priority: string): number {
    switch (priority) {
      case 'urgent': return 2.0
      case 'high': return 1.5
      case 'medium': return 1.0
      case 'low': return 0.7
      default: return 1.0
    }
  }

  /**
   * 추천사항 생성
   */
  private static generateRecommendations(
    task: WorklyTask, 
    analysis: HierarchyAnalytics
  ): HierarchyAnalytics['recommendations'] {
    const recommendations: HierarchyAnalytics['recommendations'] = {}

    // 독립적 업무를 프로젝트로 이동 추천
    if (task.hierarchyType === HierarchyType.INDEPENDENT && 
        task.estimatedMinutes > 120) { // 2시간 이상 소요 예상
      recommendations.shouldMoveToProject = 
        '이 업무는 2시간 이상 소요가 예상되므로 프로젝트로 관리하는 것이 좋겠습니다.'
    }

    // 프로젝트 업무를 목표와 연결 추천
    if (task.hierarchyType === HierarchyType.PROJECT_ONLY &&
        task.priority === 'high') {
      recommendations.shouldConnectToGoal = 
        '중요한 업무이므로 상위 목표와 연결하여 목표 달성도를 추적해보세요.'
    }

    // 복잡한 계층을 단순화 추천
    if (task.hierarchyType === HierarchyType.FULL_HIERARCHY &&
        analysis.impact.independence > 80) {
      recommendations.shouldBecomeIndependent = 
        '이 업무는 독립적으로 수행 가능해 보이므로 단순화를 고려해보세요.'
    }

    return recommendations
  }

  /**
   * 오늘 할 일 최적화
   */
  static optimizeTodayTasks(
    tasks: WorklyTask[],
    projects: Project[] = [],
    goals: Goal[] = []
  ): TodayTasksOptimized {
    const todayTasks = tasks.filter(task => 
      task.isToday && 
      task.cperWorkflow.stage === CPERStage.EXECUTING
    )

    // 우선순위별 분류
    const focusedTasks = todayTasks.filter(task => task.isFocused)
    const urgentTasks = todayTasks.filter(task => 
      task.priority === 'urgent' && !task.isFocused
    )
    const readyToStartTasks = todayTasks.filter(task => 
      task.nextAction && task.nextAction.trim().length > 0
    )
    const remainingTasks = todayTasks.filter(task => 
      !task.isFocused && 
      task.priority !== 'urgent' && 
      (!task.nextAction || task.nextAction.trim().length === 0)
    )

    // 계층구조별 그룹화
    const independent = todayTasks.filter(task => 
      task.hierarchyType === HierarchyType.INDEPENDENT
    )

    const byProject = this.groupTasksByProject(todayTasks, projects)
    const byGoal = this.groupTasksByGoal(todayTasks, projects, goals)

    // 시간 분석
    const totalEstimatedMinutes = todayTasks.reduce(
      (sum, task) => sum + task.estimatedMinutes, 0
    )
    const focusedTasksMinutes = focusedTasks.reduce(
      (sum, task) => sum + task.estimatedMinutes, 0
    )

    return {
      focusedTasks,
      urgentTasks,
      todayTasks: remainingTasks,
      readyToStartTasks,
      groupedByHierarchy: {
        independent,
        byProject,
        byGoal
      },
      timeAnalysis: {
        totalEstimatedMinutes,
        focusedTasksMinutes,
        averageTaskMinutes: totalEstimatedMinutes / Math.max(todayTasks.length, 1),
        recommendedDailyLimit: 480 // 8시간
      }
    }
  }

  /**
   * 프로젝트별 업무 그룹화
   */
  private static groupTasksByProject(
    tasks: WorklyTask[], 
    projects: Project[]
  ): TodayTasksOptimized['groupedByHierarchy']['byProject'] {
    const projectGroups: { [projectId: string]: WorklyTask[] } = {}

    tasks.forEach(task => {
      if (task.projectId && 
          (task.hierarchyType === HierarchyType.PROJECT_ONLY || 
           task.hierarchyType === HierarchyType.FULL_HIERARCHY)) {
        if (!projectGroups[task.projectId]) {
          projectGroups[task.projectId] = []
        }
        projectGroups[task.projectId].push(task)
      }
    })

    return Object.entries(projectGroups).map(([projectId, tasks]) => {
      const project = projects.find(p => p.id === projectId)
      return {
        projectId,
        projectTitle: project?.title || '프로젝트 미확인',
        tasks
      }
    })
  }

  /**
   * 목표별 업무 그룹화
   */
  private static groupTasksByGoal(
    tasks: WorklyTask[], 
    projects: Project[], 
    goals: Goal[]
  ): TodayTasksOptimized['groupedByHierarchy']['byGoal'] {
    const goalGroups: { [goalId: string]: {
      directTasks: WorklyTask[]
      projectTasks: { [projectId: string]: WorklyTask[] }
    }} = {}

    tasks.forEach(task => {
      let goalId: string | undefined

      // 목표 ID 확인
      if (task.hierarchyType === HierarchyType.GOAL_DIRECT) {
        goalId = task.goalId
      } else if (task.hierarchyType === HierarchyType.FULL_HIERARCHY) {
        goalId = task.goalId
      }

      if (goalId) {
        if (!goalGroups[goalId]) {
          goalGroups[goalId] = {
            directTasks: [],
            projectTasks: {}
          }
        }

        if (task.hierarchyType === HierarchyType.GOAL_DIRECT) {
          goalGroups[goalId].directTasks.push(task)
        } else if (task.projectId) {
          if (!goalGroups[goalId].projectTasks[task.projectId]) {
            goalGroups[goalId].projectTasks[task.projectId] = []
          }
          goalGroups[goalId].projectTasks[task.projectId].push(task)
        }
      }
    })

    return Object.entries(goalGroups).map(([goalId, groupData]) => {
      const goal = goals.find(g => g.id === goalId)
      
      const projectTasks = Object.entries(groupData.projectTasks).map(([projectId, tasks]) => {
        const project = projects.find(p => p.id === projectId)
        return {
          projectId,
          projectTitle: project?.title || '프로젝트 미확인',
          tasks
        }
      })

      return {
        goalId,
        goalTitle: goal?.title || '목표 미확인',
        directTasks: groupData.directTasks,
        projectTasks
      }
    })
  }

  /**
   * 계층구조 변경 실행
   */
  static async changeHierarchy(
    taskId: string,
    newHierarchy: HierarchyChoice,
    currentTask: WorklyTask
  ): Promise<WorklyTask> {
    // 검증
    const validation = this.canChangeHierarchy(currentTask, newHierarchy)
    if (!validation.isValid) {
      throw new Error(`계층구조 변경 불가: ${validation.errors.join(', ')}`)
    }

    // 새로운 계층구조로 업무 업데이트
    const updatedTask: WorklyTask = {
      ...currentTask,
      hierarchyType: newHierarchy.type,
      projectId: newHierarchy.projectId,
      goalId: newHierarchy.goalId,
      updatedAt: new Date().toISOString()
    }

    // TODO: 실제 구현에서는 여기서 API 호출
    // await taskApi.updateTask(taskId, updatedTask)

    return updatedTask
  }

  /**
   * 독립적 업무 여부 확인
   */
  static isIndependentTask(task: WorklyTask): boolean {
    return task.hierarchyType === HierarchyType.INDEPENDENT
  }

  /**
   * 프로젝트를 통한 목표 연결 확인
   */
  static isGoalConnectedThroughProject(task: WorklyTask): boolean {
    return task.hierarchyType === HierarchyType.FULL_HIERARCHY
  }

  /**
   * 직접 목표 연결 확인
   */
  static isDirectlyConnectedToGoal(task: WorklyTask): boolean {
    return task.hierarchyType === HierarchyType.GOAL_DIRECT
  }
}
</file>

<file path=".env.example">
# Database
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_NAME=workly
DATABASE_USERNAME=workly_user
DATABASE_PASSWORD=workly_password

# JWT
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# Google OAuth
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Frontend URL
FRONTEND_URL=http://localhost:3000

# Backend URL
BACKEND_URL=http://localhost:3001

# Redis (for production)
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# File Storage
STORAGE_TYPE=local # local or s3
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=
AWS_S3_BUCKET=

# Email (for notifications)
SMTP_HOST=
SMTP_PORT=
SMTP_USER=
SMTP_PASS=
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  env: {
    browser: true,
    es2020: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
  ],
  ignorePatterns: [
    'dist',
    '.eslintrc.js',
    'node_modules',
    '**/*.d.ts',
  ],
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  rules: {
    'prefer-const': 'error',
    'no-var': 'error',
    'no-console': 'warn',
    'no-debugger': 'warn',
  },
  overrides: [
    {
      files: ['**/*.test.ts', '**/*.test.tsx', '**/*.spec.ts', '**/*.spec.tsx'],
      env: {
        jest: true,
      },
      rules: {
        'no-console': 'off',
      },
    },
  ],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["DOM", "DOM.Iterable", "ES2020"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["shared/*"]
    }
  },
  "include": ["shared/**/*"],
  "exclude": ["node_modules"],
  "references": [
    {
      "path": "./frontend"
    },
    {
      "path": "./backend"
    },
    {
      "path": "./shared"
    }
  ]
}
</file>

<file path=".taskmaster/tasks/tasks.json">
{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Monorepo & CI/CD Pipeline",
        "description": "Set up the monorepo structure for frontend (Next.js) and backend (NestJS), configure Docker for development and production environments, and establish CI/CD pipelines (e.g., GitHub Actions) for automated testing and deployment.",
        "details": "Frontend: Next.js 14+ (App Router), TypeScript, Tailwind CSS. Backend: NestJS, TypeScript. Infrastructure: Docker, Docker Compose. CI/CD: Automated build, test, and deployment workflows.",
        "testStrategy": "Verify successful Docker container builds, local environment setup, and initial CI/CD pipeline runs for both frontend and backend.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Monorepo Structure",
            "description": "Set up the foundational monorepo workspace using a tool like Turborepo or Nx, defining separate applications for Next.js frontend and NestJS backend, and configuring shared tooling.",
            "dependencies": [],
            "details": "Configure `package.json` at the root, create `apps/frontend` and `apps/backend` directories, add basic configuration files for each application (e.g., `tsconfig.json`), and set up a monorepo manager (e.g., Turborepo).",
            "status": "pending",
            "testStrategy": "Verify that `pnpm install` (or npm/yarn) runs successfully at the root, and that both frontend and backend applications can be started independently using monorepo commands (e.g., `pnpm dev`)."
          },
          {
            "id": 2,
            "title": "Dockerize Development Environment",
            "description": "Create Dockerfiles and Docker Compose configurations for both the Next.js frontend and NestJS backend to enable a consistent and isolated local development environment.",
            "dependencies": [],
            "details": "Develop `Dockerfile.dev` for Next.js and NestJS, and a `docker-compose.dev.yml` to orchestrate services, including hot-reloading and volume mounts for code changes.",
            "status": "pending",
            "testStrategy": "Verify that `docker-compose -f docker-compose.dev.yml up` successfully builds and runs both frontend and backend containers, and that applications are accessible locally with live code changes reflected."
          },
          {
            "id": 3,
            "title": "Dockerize Production Environment",
            "description": "Optimize Dockerfiles for production environments, focusing on smaller image sizes and efficient builds for both Next.js and NestJS applications.",
            "dependencies": [],
            "details": "Create multi-stage `Dockerfile`s for Next.js and NestJS, ensuring minimal dependencies, optimized layers, and production-ready configurations.",
            "status": "pending",
            "testStrategy": "Verify that production Docker images can be built successfully using `docker build -f Dockerfile -t <image-name> .` for both apps, and confirm image sizes are optimized."
          },
          {
            "id": 4,
            "title": "Implement CI/CD for Build & Test",
            "description": "Establish GitHub Actions workflows to automate the build and test processes for both the Next.js frontend and NestJS backend within the monorepo.",
            "dependencies": [],
            "details": "Create a `.github/workflows/ci.yml` file to define a workflow that triggers on push/PR, installs monorepo dependencies, builds both applications, and runs unit/integration tests for each.",
            "status": "pending",
            "testStrategy": "Push a commit to a feature branch and verify that the CI pipeline runs successfully, building both applications and passing all configured tests."
          },
          {
            "id": 5,
            "title": "Implement CI/CD for Automated Deployment",
            "description": "Extend the CI/CD pipeline to include automated deployment steps for both the Next.js frontend and NestJS backend, leveraging the production Docker images.",
            "dependencies": [],
            "details": "Add deployment jobs to the GitHub Actions workflow, potentially pushing built Docker images to a container registry and then deploying them to a target environment (e.g., a staging server or cloud platform).",
            "status": "pending",
            "testStrategy": "Trigger a deployment (e.g., on merge to main or a specific tag) and verify that the applications are successfully deployed and accessible in the target environment."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Google OAuth & JWT Authentication",
        "description": "Develop the user authentication system using Google OAuth 2.0 for sign-in and JWT for secure session management. This includes user registration/login flow and protected API routes.",
        "details": "Backend: NestJS, @nestjs/jwt, passport-google-oauth20. Frontend: Integrate Google login button, handle OAuth callback, store JWT securely. API: POST /auth/google, GET /auth/me.",
        "testStrategy": "Unit tests for JWT generation/validation. Integration tests for Google OAuth flow, successful user creation/login, and access to protected routes.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Backend Google OAuth Strategy & Token Exchange Endpoint",
            "description": "Implement the NestJS Passport Google OAuth strategy and create the backend endpoint (`POST /auth/google`) to receive the Google authorization code or ID token from the frontend, exchange it with Google for user data, and initiate the authentication process.",
            "dependencies": [],
            "details": "Configure `passport-google-oauth20`, define `GoogleStrategy`, create `POST /auth/google` endpoint to handle incoming Google tokens/codes and perform Google API calls for user info.",
            "status": "done",
            "testStrategy": "Unit tests for GoogleStrategy configuration and token exchange logic with mock Google responses."
          },
          {
            "id": 2,
            "title": "Backend JWT Generation & User Persistence",
            "description": "Develop the backend logic to generate JSON Web Tokens (JWT) upon successful Google authentication and persist user data in the database. This includes creating new user records or updating existing ones based on Google profile information.",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement user service for `findOrCreate` based on Google profile (email, name, avatar), use `@nestjs/jwt` to sign and issue access tokens and refresh tokens. Define JWT payload structure.",
            "status": "done",
            "testStrategy": "Unit tests for JWT generation and validation logic, including token expiration and refresh token mechanisms. Unit tests for user creation/update logic."
          },
          {
            "id": 3,
            "title": "Frontend Google Sign-In Button & OAuth Flow Initiation",
            "description": "Integrate the Google Sign-In button into the frontend UI and implement the client-side logic to initiate the Google OAuth flow, obtaining the necessary authorization code or ID token from Google.",
            "dependencies": [],
            "details": "Integrate Google Identity Services JS SDK (or similar), display Google login button on the sign-in page, configure client-side OAuth flow to get authorization code or ID token upon user consent.",
            "status": "done",
            "testStrategy": "Manual testing of Google login button display and initial OAuth redirect/popup functionality. Verify successful acquisition of Google token/code."
          },
          {
            "id": 4,
            "title": "Frontend Token Transmission, Storage & API Integration",
            "description": "Implement the frontend logic to send the obtained Google token/code to the backend's authentication endpoint (`POST /auth/google`), securely store the received JWT, and configure the application to include this token in headers for all subsequent authenticated API requests.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Send Google token/code to `POST /auth/google` endpoint. Securely store the returned JWT (e.g., HttpOnly cookies, localStorage with appropriate security measures). Implement an Axios interceptor or similar to attach the JWT to `Authorization: Bearer <token>` header for all authenticated API calls.",
            "status": "done",
            "testStrategy": "Integration tests to verify successful token transmission to backend, secure storage of JWT, and correct inclusion of JWT in subsequent API requests. Test token refresh if applicable."
          },
          {
            "id": 5,
            "title": "Backend Protected Routes & Session Validation Endpoint",
            "description": "Implement JWT authentication guards on the backend to protect specific API routes and develop an endpoint (`GET /auth/me`) to validate the current user's session and retrieve their profile information based on the provided JWT.",
            "dependencies": [
              "2.2",
              "2.4"
            ],
            "details": "Create NestJS `AuthGuard` using `@nestjs/jwt` to validate incoming JWTs. Apply guards to routes requiring authentication, including `GET /auth/me` to return authenticated user details. Implement error handling for invalid or expired tokens.",
            "status": "done",
            "testStrategy": "Integration tests for successful access to protected routes using a valid JWT. Integration tests for rejection of requests with invalid, expired, or missing tokens. Unit tests for `AuthGuard` logic."
          }
        ]
      },
      {
        "id": 3,
        "title": "Design & Implement Core Data Models (PostgreSQL, TypeORM)",
        "description": "Set up PostgreSQL database, configure TypeORM, and define the initial core data models: User, Task, and Project entities with their respective relationships and fields as specified in the PRD.",
        "details": "Database: PostgreSQL. ORM: TypeORM. Entities: User (id, email, profile, xp, level, createdAt), Task (id, title, description, status, project_id, assignee_id), Project (id, title, members, workspace_id?). Migrations: Create initial database schema migrations.",
        "testStrategy": "Unit tests for TypeORM entities and repositories. Integration tests to verify successful database connection, schema creation, and basic CRUD operations for each entity.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up PostgreSQL Database",
            "description": "Install and configure a local PostgreSQL instance, create the necessary database, and ensure it's accessible for connection.",
            "dependencies": [],
            "details": "Install PostgreSQL. Create a dedicated database (e.g., `task_manager_db`). Configure user credentials and permissions.",
            "status": "done",
            "testStrategy": "Manually verify database accessibility using a client tool (e.g., `psql`, DBeaver) and ensure connection can be established."
          },
          {
            "id": 2,
            "title": "Configure TypeORM and Database Connection",
            "description": "Install TypeORM and related packages, set up the `DataSource` configuration, and establish the initial connection to the PostgreSQL database from the application.",
            "dependencies": [
              "3.1"
            ],
            "details": "Install `typeorm`, `@nestjs/typeorm`, `pg`. Create `data-source.ts` or `ormconfig.ts` with connection details. Integrate `TypeOrmModule.forRoot()` in NestJS application module.",
            "status": "done",
            "testStrategy": "Integration test to verify successful database connection on application startup and TypeORM initialization."
          },
          {
            "id": 3,
            "title": "Define User and Project Entities with Basic Fields",
            "description": "Create the TypeORM `User` entity (id, email, profile, xp, level, createdAt) and `Project` entity (id, title, members, workspace_id?) with their basic fields and primary keys.",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement `@Entity()`, `@PrimaryGeneratedColumn()`, and `@Column()` decorators for User and Project entities. Define appropriate data types for each field.",
            "status": "done",
            "testStrategy": "Unit tests for User and Project entity structures, ensuring correct column mapping and primary key definition."
          },
          {
            "id": 4,
            "title": "Define Task Entity and Establish All Entity Relationships",
            "description": "Create the TypeORM `Task` entity (id, title, description, status, project_id, assignee_id) and define all necessary relationships between User, Task, and Project entities (e.g., Task to Project, Task to User (assignee), Project to User (members)).",
            "dependencies": [
              "3.2",
              "3.3"
            ],
            "details": "Implement `@ManyToOne()`, `@OneToMany()`, `@ManyToMany()`, `@JoinColumn()`, and `@JoinTable()` decorators to establish foreign key relationships and many-to-many associations (e.g., Project members).",
            "status": "done",
            "testStrategy": "Unit tests for Task entity structure and all defined relationships. Integration tests to verify relationship loading and cascading behavior (if applicable)."
          },
          {
            "id": 5,
            "title": "Generate and Apply Initial Database Migrations",
            "description": "Generate the initial TypeORM migration script based on the defined entities and apply it to the PostgreSQL database to create the schema.",
            "dependencies": [
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "Use TypeORM CLI commands (`typeorm migration:generate`, `typeorm migration:run`) to create and apply the initial schema. Ensure all tables and relationships are correctly generated.",
            "status": "done",
            "testStrategy": "Integration tests to verify successful schema creation after migration. Perform basic CRUD operations for each entity to confirm table and column integrity."
          }
        ]
      },
      {
        "id": 4,
        "title": "Configure Socket.io for Real-time Updates",
        "description": "Set up and configure Socket.io on the NestJS backend and integrate it with the Next.js frontend to enable real-time communication channels for chat and general application updates.",
        "details": "Backend: NestJS, socket.io. Frontend: Socket.io client integration. Initial events: project:join, project:leave.",
        "testStrategy": "Unit tests for Socket.io event handlers. Integration tests to verify successful WebSocket connection, joining/leaving channels, and basic message exchange.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Core UI/UX & Mobile-First Layout",
        "description": "Implement the foundational UI/UX elements including global styles using Tailwind CSS, responsive layout for mobile-first design, navigation components (header, sidebar), and a consistent visual language.",
        "details": "Framework: Next.js 14+ (App Router). Styling: Tailwind CSS. UI Components: Headless UI + custom components for basic layout, buttons, inputs. Principles: Progressive disclosure, consistency, immediate feedback, mobile-first.",
        "testStrategy": "Visual regression tests for key pages. Manual testing across various screen sizes and devices to ensure responsiveness and usability.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Tailwind CSS & Global Styles",
            "description": "Configure Tailwind CSS in the Next.js project, define base styles, typography, color palette, and any global CSS resets or utility classes. Establish the initial `layout.tsx` for the root application structure.",
            "dependencies": [],
            "details": "Framework: Next.js 14+ (App Router). Styling: Tailwind CSS configuration (`tailwind.config.js`, `globals.css`). Initial `layout.tsx` setup.",
            "status": "done",
            "testStrategy": "Verify Tailwind classes are applied correctly; inspect global styles and typography in browser developer tools."
          },
          {
            "id": 2,
            "title": "Implement Mobile-First Responsive Layout Structure",
            "description": "Design and implement the core responsive layout using CSS Grid or Flexbox, ensuring a mobile-first approach. This includes defining breakpoints and creating a flexible container system that adapts to various screen sizes.",
            "dependencies": [
              "5.1"
            ],
            "details": "Next.js layout components. Utilize Tailwind's responsive utility classes (e.g., `sm:`, `md:`, `lg:`). Focus on `min-width` breakpoints for mobile-first design.",
            "status": "done",
            "testStrategy": "Manual testing across various screen sizes (mobile, tablet, desktop) using browser developer tools and device emulation to ensure layout responsiveness."
          },
          {
            "id": 3,
            "title": "Develop Header & Sidebar Navigation Components",
            "description": "Create the primary navigation components: a responsive header (top bar) and a collapsible/expandable sidebar. These components should integrate with the mobile-first layout and provide consistent navigation across the application.",
            "dependencies": [
              "5.2"
            ],
            "details": "Next.js components for Header and Sidebar. Styling with Tailwind CSS. Utilize Headless UI components (e.g., Disclosure for sidebar toggle) for accessibility and interactivity.",
            "status": "done",
            "testStrategy": "Manual testing of navigation links, responsiveness of header/sidebar across breakpoints, and accessibility features (keyboard navigation, ARIA attributes)."
          },
          {
            "id": 4,
            "title": "Build Core UI Elements (Buttons, Inputs, Forms)",
            "description": "Develop a set of foundational, reusable UI components such as buttons, text inputs, text areas, and basic form structures. These components should adhere to the defined visual language and be styled consistently using Tailwind CSS.",
            "dependencies": [
              "5.1"
            ],
            "details": "Next.js components for `Button`, `Input`, `Textarea`. Styling with Tailwind CSS. Ensure consistency in states (hover, focus, active, disabled). Consider Headless UI for accessibility where applicable.",
            "status": "done",
            "testStrategy": "Visual inspection of components for consistency across different states. Manual testing of interactive elements for correct behavior and accessibility."
          },
          {
            "id": 5,
            "title": "Integrate & Refine Visual Language & Accessibility",
            "description": "Integrate all developed UI components and navigation into a cohesive visual system. Conduct a thorough review to ensure consistency in visual language, adherence to mobile-first principles, and basic accessibility standards (e.g., focus states, semantic HTML).",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "Review and refine global styles, component usage, and layout structures. Focus on `layout.tsx` and `page.tsx` files. Implement any necessary accessibility improvements.",
            "status": "done",
            "testStrategy": "Visual regression tests for key pages (if setup). Manual testing across various screen sizes and devices to ensure responsiveness and usability. Basic accessibility audit using browser extensions (e.g., Lighthouse, Axe DevTools)."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement User Profile & XP/Level System",
        "description": "Develop the user profile page to display XP and level. Implement the backend logic to award XP for positive actions (e.g., task completion) and calculate level progression based on accumulated XP.",
        "details": "Backend: Update User model with xp, level fields. Logic for xp:gained event. Frontend: User profile UI, display XP bar and current level. Gamification: XP acquisition for '일일 업무 완료' (10 XP).",
        "testStrategy": "Unit tests for XP calculation and level-up logic. Integration tests to verify XP gain upon task completion and correct profile display.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop GTD-based Task Management System",
        "description": "Implement the full GTD 5-step sequential process for task creation. Develop CRUD operations for tasks and implement smart filtering for 'Today', 'Completed', and 'All' tasks.",
        "details": "Backend: POST /tasks (GTD flow), GET /tasks (filtering), PUT /tasks/:id, DELETE /tasks/:id. Frontend: UI for GTD task creation wizard, task list display, and filter toggles. Task fields: id, title, description, status, priority, project_id, assignee_id, due_date.",
        "testStrategy": "Unit tests for task service logic. Integration tests for all task API endpoints, ensuring correct data persistence and filtering. End-to-end tests for the GTD creation flow.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Task Data Model & Basic CRUD Backend",
            "description": "Define the task data model with specified fields and implement the backend API endpoints for updating (PUT), deleting (DELETE), and retrieving all tasks (GET without specific filters). This forms the foundational layer for task management.",
            "dependencies": [],
            "details": "Backend: Define task schema/model (id, title, description, status, priority, project_id, assignee_id, due_date). Implement PUT /tasks/:id for updating task details, DELETE /tasks/:id for removing tasks, and a basic GET /tasks endpoint to retrieve all tasks without specific filtering logic.",
            "status": "done",
            "testStrategy": "Unit tests for task service logic (update, delete, retrieve all). Integration tests for PUT /tasks/:id, DELETE /tasks/:id, and basic GET /tasks endpoints, ensuring correct data persistence and retrieval."
          },
          {
            "id": 2,
            "title": "Develop GTD 5-Step Task Creation Backend",
            "description": "Implement the backend logic for the Getting Things Done (GTD) 5-step sequential process for task creation, handling the initial intake and processing of new tasks.",
            "dependencies": [
              "7.1"
            ],
            "details": "Backend: Implement the POST /tasks endpoint to encapsulate the GTD 5-step flow (Capture, Clarify, Organize, Reflect, Engage). This involves processing incoming task data, assigning initial status/priority based on GTD principles, and persisting the task.",
            "status": "done",
            "testStrategy": "Unit tests for the GTD processing logic within the task service. Integration tests for the POST /tasks endpoint, ensuring correct task creation and adherence to GTD principles."
          },
          {
            "id": 3,
            "title": "Implement Smart Task Filtering Backend",
            "description": "Enhance the backend task retrieval API to support smart filtering for 'Today', 'Completed', and 'All' tasks, providing the necessary data for the frontend display.",
            "dependencies": [
              "7.1"
            ],
            "details": "Backend: Extend the GET /tasks endpoint to accept query parameters for filtering tasks by 'Today' (tasks due today or overdue), 'Completed' (tasks with status 'completed'), and 'All' (all tasks, default). This requires logic to interpret due_date and status fields.",
            "status": "done",
            "testStrategy": "Integration tests for the GET /tasks endpoint with various filter parameters, ensuring accurate retrieval of 'Today', 'Completed', and 'All' tasks."
          },
          {
            "id": 4,
            "title": "Develop GTD Task Creation Frontend Wizard",
            "description": "Create the user interface for the GTD 5-step sequential task creation process, guiding the user through capturing and processing new tasks.",
            "dependencies": [
              "7.2"
            ],
            "details": "Frontend: Develop a multi-step UI wizard for task creation, aligning with the GTD 5-step process. This includes input fields for title, description, and potentially guiding questions for clarification, organization, etc., culminating in a call to the POST /tasks API.",
            "status": "done",
            "testStrategy": "End-to-end tests for the GTD creation flow, verifying user interaction, data submission, and successful task creation."
          },
          {
            "id": 5,
            "title": "Develop Task List Display & Filtering Frontend",
            "description": "Build the frontend UI to display the list of tasks and provide interactive toggles for 'Today', 'Completed', and 'All' smart filters.",
            "dependencies": [
              "7.1",
              "7.3"
            ],
            "details": "Frontend: Implement the task list display component, rendering tasks retrieved from the GET /tasks API. Develop UI elements (buttons/toggles) for 'Today', 'Completed', and 'All' filters, which trigger calls to the filtered GET /tasks endpoint and update the displayed list.",
            "status": "done",
            "testStrategy": "End-to-end tests for the task list display and filter toggles, ensuring correct task rendering and accurate filtering based on user selection."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Project Creation & Basic Collaboration",
        "description": "Enable users to create new projects, manage project details, and invite/manage members. This includes basic project listing and viewing.",
        "details": "Backend: POST /projects, GET /projects, PUT /projects/:id. Frontend: UI for project creation form, project list, and project detail view. Project fields: id, title, objectives[], key_results[], members[].",
        "testStrategy": "Unit tests for project service logic. Integration tests for project API endpoints. End-to-end tests for project creation and member management.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Core Project API & Data Model",
            "description": "Implement backend endpoints for creating, retrieving (list and single), and updating project core details (title, objectives, key results). Define the project data model.",
            "dependencies": [],
            "details": "Backend: POST /projects, GET /projects, GET /projects/:id, PUT /projects/:id (for core fields). Project fields: id, title, objectives[], key_results[].",
            "status": "done",
            "testStrategy": "Unit tests for project service logic. Integration tests for project API endpoints (CRUD for core fields)."
          },
          {
            "id": 2,
            "title": "Implement Project Listing & Creation UI",
            "description": "Develop the frontend UI for displaying a list of projects and a form for creating new projects.",
            "dependencies": [],
            "details": "Frontend: UI for project list (GET /projects) and project creation form (POST /projects).",
            "status": "done",
            "testStrategy": "End-to-end tests for project creation flow and project list display."
          },
          {
            "id": 3,
            "title": "Implement Project Detail & Editing UI",
            "description": "Develop the frontend UI for viewing detailed project information and editing existing project details.",
            "dependencies": [],
            "details": "Frontend: UI for project detail view (GET /projects/:id) and project editing form (PUT /projects/:id).",
            "status": "done",
            "testStrategy": "End-to-end tests for project detail viewing and editing flow."
          },
          {
            "id": 4,
            "title": "Develop Project Member Management Backend",
            "description": "Implement backend logic and API endpoints to add, remove, and manage members associated with a project. This includes updating the members[] field.",
            "dependencies": [],
            "details": "Backend: Extend PUT /projects/:id or add new endpoints (e.g., POST /projects/:id/members, DELETE /projects/:id/members/:memberId) to manage the members[] array. This involves linking users (from Task 2) to projects.",
            "status": "done",
            "testStrategy": "Unit tests for member management logic. Integration tests for member management API endpoints."
          },
          {
            "id": 5,
            "title": "Implement Project Member Management UI",
            "description": "Develop the frontend UI within the project detail view to invite, list, and manage project members.",
            "dependencies": [],
            "details": "Frontend: UI components for inviting new members, displaying current members, and removing members within the project detail view.",
            "status": "done",
            "testStrategy": "End-to-end tests for inviting and managing project members."
          }
        ]
      },
      {
        "id": 9,
        "title": "Develop Real-time Project Chat with Slash Commands",
        "description": "Integrate real-time chat functionality within project channels using Socket.io. Implement basic slash commands like /add-task to create tasks directly from chat.",
        "details": "Backend: Socket.io event handling for project:message. Logic to parse /add-task command and create a task via the task service. Frontend: Chat UI within project view, message input, display of real-time messages. API: GET /projects/:id/chat for message history.",
        "testStrategy": "Integration tests for real-time message delivery and display. End-to-end tests for /add-task command functionality.",
        "priority": "medium",
        "dependencies": [
          4,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Momentum Score & Advanced Task Filtering",
        "description": "Develop the RICE model-based momentum score algorithm for automatic task prioritization. Extend task filtering to include 'Later' and intuitive search across all projects.",
        "details": "Backend: Algorithm for momentum_score calculation (RICE model: Reach, Impact, Confidence, Effort). Update Task model. Frontend: Display momentum score on tasks, implement 'Later' filter and global search input. API: Enhance GET /tasks with sorting by momentum score and search capabilities.",
        "testStrategy": "Unit tests for momentum score calculation logic. Integration tests for advanced filtering and search queries.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Integrate Google Calendar for Due Date Sync",
        "description": "Implement the integration with Google Calendar API to synchronize task due dates, allowing users to see their Workly tasks directly in their Google Calendar.",
        "details": "Backend: Google Calendar API integration for creating/updating events. Frontend: UI for connecting Google Calendar account and enabling sync. Scope: One-way sync from Workly to Google Calendar for task due dates.",
        "testStrategy": "Integration tests for successful authentication with Google Calendar API and correct event creation/update.",
        "priority": "low",
        "dependencies": [
          2,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Establish Comprehensive Testing & Monitoring",
        "description": "Implement a robust testing suite including unit, integration, and end-to-end tests for critical functionalities. Set up Sentry for error tracking and establish basic application performance monitoring.",
        "details": "Testing Frameworks: Jest (unit/integration), Playwright/Cypress (E2E). Monitoring: Sentry DSN configuration, basic logging. Coverage: Aim for high test coverage on core logic.",
        "testStrategy": "Run all test suites. Verify Sentry error reporting for simulated errors.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Notion-Style Task Detail Modal with Markdown Editor",
        "description": "Develop a comprehensive task detail view within a Notion-style modal, featuring a markdown editor for descriptions, checklists, task relationships, wiki references, and time management functionalities.",
        "details": "Frontend:\n- Create a reusable modal component for displaying and editing task details, adhering to a Notion-style aesthetic.\n- Integrate a markdown editor (evaluate MDXEditor or @uiw/react-md-editor for features, performance, and ease of use) for the task description field.\n- Implement dedicated UI components for:\n  - Checklists: Allow adding, editing, deleting, and marking checklist items as complete.\n  - Task Relationships: Enable linking tasks (e.g., parent/child, blocking/blocked by, related) with a task search/picker.\n  - Wiki References: Provide fields for adding and displaying links to external wiki pages or internal documentation.\n  - Time Management: Include functionalities for estimated time, logged time, and potentially a simple time tracking mechanism (start/stop).\n- Ensure data binding and debounced saving for all editable fields to provide a smooth user experience.\n- Focus on responsive design and accessibility for the modal and its contents.\n\nBackend (API Extensions):\n- Extend the existing Task data model to accommodate new fields:\n  - `description_markdown`: String for markdown content.\n  - `checklist`: Array of objects (e.g., `{id: string, text: string, completed: boolean}`).\n  - `relationships`: Array of objects (e.g., `{target_task_id: number, type: 'parent' | 'subtask' | 'blocks' | 'related'}`).\n  - `wiki_references`: Array of objects (e.g., `{title: string, url: string}`).\n  - `estimated_time_minutes`: Number.\n  - `logged_time_minutes`: Number.\n- Enhance `GET /tasks/:id` to return all new detailed fields.\n- Implement/extend `PUT /tasks/:id` to allow updating all new detailed fields, ensuring proper validation and data integrity.",
        "testStrategy": "Unit Tests:\n- Test the markdown editor component's rendering, input handling, and content parsing.\n- Verify the logic for adding, removing, and toggling checklist items.\n- Test the task relationship component's ability to add/remove links and handle invalid task IDs.\n- Test time management component's input validation and calculation logic.\n\nIntegration Tests:\n- Verify that `GET /tasks/:id` successfully retrieves tasks with all new detailed fields (markdown, checklist, relationships, time data).\n- Confirm that `PUT /tasks/:id` correctly updates all new detailed fields in the database and that changes persist.\n- Test the interaction between the frontend components and the backend API for saving and loading data.\n\nEnd-to-End Tests (using Playwright/Cypress):\n- Open the task detail modal for an existing task and verify its Notion-style appearance.\n- Edit the markdown description, add/remove checklist items, establish task relationships, and log time.\n- Save the changes and verify they are correctly displayed upon re-opening the modal or refreshing the page.\n- Test various scenarios: empty fields, large markdown content, multiple checklist items, and complex relationship structures.\n- Verify the modal's opening/closing animations and overall user experience.",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Notion-Style Task Detail Modal UI",
            "description": "Create the foundational reusable modal component for displaying task details, adhering to a Notion-style aesthetic, focusing on responsive design and accessibility. [Updated: 8/2/2025]",
            "dependencies": [],
            "details": "Create a reusable modal component for displaying and editing task details, adhering to a Notion-style aesthetic. Ensure responsive design and accessibility for the modal and its contents.\n<info added on 2025-08-01T15:20:44.829Z>\nTypeScript type definitions have been completed. Implementation of the modal component has started, focusing on the basic layout and a full-screen toggle feature.\n</info added on 2025-08-01T15:20:44.829Z>",
            "status": "done",
            "testStrategy": "Unit tests for modal rendering, opening/closing behavior, and responsiveness."
          },
          {
            "id": 2,
            "title": "Integrate Markdown Editor for Task Description",
            "description": "Integrate a chosen markdown editor into the task description field within the Notion-style modal.",
            "dependencies": [
              "13.1"
            ],
            "details": "Integrate a markdown editor (evaluate MDXEditor or @uiw/react-md-editor for features, performance, and ease of use) for the task description field.",
            "status": "done",
            "testStrategy": "Unit tests for the markdown editor component's rendering, input handling, and content parsing."
          },
          {
            "id": 3,
            "title": "Implement Checklist Functionality",
            "description": "Develop dedicated UI components and logic for adding, editing, deleting, and marking checklist items as complete within the task detail modal.",
            "dependencies": [
              "13.1"
            ],
            "details": "Implement dedicated UI components for Checklists: Allow adding, editing, deleting, and marking checklist items as complete.",
            "status": "done",
            "testStrategy": "Unit tests for the logic for adding, removing, and toggling checklist items."
          },
          {
            "id": 4,
            "title": "Implement Task Relationship Management",
            "description": "Develop UI components and logic to enable linking tasks (e.g., parent/child, blocking/blocked by, related) with a task search/picker within the modal.",
            "dependencies": [
              "13.1"
            ],
            "details": "Implement dedicated UI components for Task Relationships: Enable linking tasks (e.g., parent/child, blocking/blocked by, related) with a task search/picker.",
            "status": "done",
            "testStrategy": "Unit tests for the task relationship component's ability to add/remove links and handle invalid task IDs."
          },
          {
            "id": 5,
            "title": "Implement Time Management Features",
            "description": "Develop UI components for estimated time, logged time, and potentially a simple time tracking mechanism within the task detail modal.",
            "dependencies": [
              "13.1"
            ],
            "details": "Implement dedicated UI components for Time Management: Include functionalities for estimated time, logged time, and potentially a simple time tracking mechanism (start/stop).",
            "status": "done",
            "testStrategy": "Unit tests for time management component's input validation and display logic."
          },
          {
            "id": 6,
            "title": "Implement Wiki References Management",
            "description": "Develop UI components for adding and displaying links to external wiki pages or internal documentation within the task detail modal.",
            "dependencies": [
              "13.1"
            ],
            "details": "Implement dedicated UI components for Wiki References: Provide fields for adding and displaying links to external wiki pages or internal documentation.",
            "status": "done",
            "testStrategy": "Unit tests for wiki reference component's input handling and link display."
          },
          {
            "id": 7,
            "title": "Extend Task Data Model and API",
            "description": "Extend the backend Task data model to accommodate new fields for description, checklists, relationships, wiki references, and time management, and update the API endpoints for retrieval and update.",
            "dependencies": [],
            "details": "Extend the existing Task data model to accommodate new fields: `description_markdown`, `checklist`, `relationships`, `wiki_references`, `estimated_time_minutes`, `logged_time_minutes`. Enhance `GET /tasks/:id` to return all new detailed fields. Implement/extend `PUT /tasks/:id` to allow updating all new detailed fields, ensuring proper validation and data integrity.",
            "status": "done",
            "testStrategy": "Unit tests for data model validation and API endpoint logic. Integration tests for data persistence and retrieval."
          },
          {
            "id": 8,
            "title": "Integrate Frontend with Backend and Conduct Comprehensive Testing",
            "description": "Connect all implemented frontend UI components with the extended backend API, ensuring data binding, debounced saving, and conducting comprehensive integration and end-to-end tests.",
            "dependencies": [
              "13.2",
              "13.3",
              "13.4",
              "13.5",
              "13.6",
              "13.7"
            ],
            "details": "Ensure data binding and debounced saving for all editable fields to provide a smooth user experience. Conduct comprehensive integration tests to ensure all implemented features work correctly with the backend API for data persistence and retrieval.",
            "status": "done",
            "testStrategy": "End-to-end tests for the entire task detail modal flow, including data creation, update, and retrieval. Verify debounced saving and data integrity across sessions."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-25T13:37:36.448Z",
      "updated": "2025-08-02T07:23:05.526Z",
      "description": "Tasks for master context"
    }
  }
}
</file>

<file path="backend/src/database/entities/task.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  OneToMany,
  ManyToMany,
  JoinTable,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import { 
  TaskStatus, 
  Priority, 
  TaskType,
  WorkflowStage
} from '@workly/shared';
import { User } from './user.entity';
import { Project } from './project.entity';
import { TaskLabel } from './task-label.entity';
import { TaskComment } from './task-comment.entity';
import { TaskDependency } from './task-dependency.entity';
import { TimeEntry } from './time-entry.entity';

@Entity('tasks')
@Index(['title'])
@Index(['status'])
@Index(['priority'])
@Index(['type'])
@Index(['projectId'])
@Index(['assigneeId'])
@Index(['reporterId'])
@Index(['parentTaskId'])
@Index(['dueDate'])
@Index(['createdAt'])
@Index(['workflowStageId'])
export class Task {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column('text', { nullable: true })
  description?: string;

  @Column('text', { nullable: true })
  descriptionMarkdown?: string;

  @Column({
    type: 'enum',
    enum: TaskStatus,
    default: TaskStatus.TODO,
  })
  status: TaskStatus;

  @Column({
    type: 'enum',
    enum: Priority,
    default: Priority.MEDIUM,
  })
  priority: Priority;

  @Column({
    type: 'enum',
    enum: TaskType,
    default: TaskType.TASK,
  })
  type: TaskType;

  @Column({ type: 'timestamp', nullable: true })
  dueDate?: Date;

  @Column({ type: 'timestamp', nullable: true })
  startDate?: Date;

  @Column({ type: 'timestamp', nullable: true })
  completedAt?: Date;

  @Column({ nullable: true })
  projectId?: string;

  @Column({ nullable: true })
  assigneeId?: string;

  @Column()
  reporterId: string;

  @Column({ nullable: true })
  parentTaskId?: string;

  @Column({ type: 'decimal', precision: 8, scale: 2, nullable: true })
  estimatedHours?: number;

  @Column({ type: 'decimal', precision: 8, scale: 2, default: 0 })
  actualHours: number;

  @Column({ type: 'int', default: 0 })
  progress: number;

  @Column({ nullable: true })
  workflowStageId?: string;

  @Column('simple-array', { default: [] })
  tags: string[];

  @Column('jsonb', { default: {} })
  customFields: { [key: string]: any };

  @Column('jsonb', { default: [] })
  checklist: Array<{
    id: string;
    text: string;
    completed: boolean;
    order: number;
  }>;

  @Column('jsonb', { default: [] })
  relationships: Array<{
    id: string;
    targetTaskId: string;
    type: 'blocks' | 'blocked_by' | 'related' | 'parent' | 'child';
  }>;

  @Column('jsonb', { default: [] })
  wikiReferences: Array<{
    id: string;
    title: string;
    url: string;
    description?: string;
  }>;

  @Column({ type: 'int', nullable: true })
  estimatedTimeMinutes?: number;

  @Column({ type: 'int', default: 0 })
  loggedTimeMinutes: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정
  @ManyToOne(() => Project, project => project.tasks, {
    onDelete: 'CASCADE'
  })
  project?: Project;

  @ManyToOne(() => User, { eager: true })
  assignee?: User;

  @ManyToOne(() => User, { eager: true })
  reporter: User;

  @ManyToOne(() => Task, task => task.subtasks, {
    onDelete: 'CASCADE'
  })
  parentTask?: Task;

  @OneToMany(() => Task, task => task.parentTask)
  subtasks: Task[];

  @ManyToMany(() => TaskLabel)
  @JoinTable({
    name: 'task_labels_mapping',
    joinColumn: { name: 'taskId', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'labelId', referencedColumnName: 'id' }
  })
  labels: TaskLabel[];

  @OneToMany(() => TaskComment, comment => comment.task)
  comments: TaskComment[];

  @OneToMany(() => TaskDependency, dependency => dependency.dependentTask)
  dependencies: TaskDependency[];

  @OneToMany(() => TaskDependency, dependency => dependency.dependsOnTask)
  dependents: TaskDependency[];

  @OneToMany(() => TimeEntry, timeEntry => timeEntry.task)
  timeEntries: TimeEntry[];

  @ManyToMany(() => User)
  @JoinTable({
    name: 'task_watchers',
    joinColumn: { name: 'taskId', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'userId', referencedColumnName: 'id' }
  })
  watchers: User[];

  // 기본값 설정
  @BeforeInsert()
  setDefaultValues() {
    if (!this.tags) {
      this.tags = [];
    }
    if (!this.customFields) {
      this.customFields = {};
    }
    if (!this.checklist) {
      this.checklist = [];
    }
    if (!this.relationships) {
      this.relationships = [];
    }
    if (!this.wikiReferences) {
      this.wikiReferences = [];
    }
    if (this.actualHours === undefined) {
      this.actualHours = 0;
    }
    if (this.loggedTimeMinutes === undefined) {
      this.loggedTimeMinutes = 0;
    }
  }

  // 상태 변경 시 처리
  @BeforeUpdate()
  handleStatusUpdate() {
    if (this.status === TaskStatus.COMPLETED && !this.completedAt) {
      this.completedAt = new Date();
      this.progress = 100;
    } else if (this.status !== TaskStatus.COMPLETED) {
      this.completedAt = undefined;
    }
  }

  // 태스크 완료 처리
  complete(): void {
    this.status = TaskStatus.COMPLETED;
    this.completedAt = new Date();
    this.progress = 100;
  }

  // 태스크 시작
  start(): void {
    if (this.status === TaskStatus.TODO) {
      this.status = TaskStatus.IN_PROGRESS;
      if (!this.startDate) {
        this.startDate = new Date();
      }
    }
  }

  // 태스크 차단
  block(): void {
    this.status = TaskStatus.BLOCKED;
  }

  // 태스크 검토 요청
  requestReview(): void {
    this.status = TaskStatus.IN_REVIEW;
  }

  // 태스크 취소
  cancel(): void {
    this.status = TaskStatus.CANCELLED;
    this.completedAt = new Date();
  }

  // 담당자 할당
  assignTo(userId: string): void {
    this.assigneeId = userId;
  }

  // 담당자 해제
  unassign(): void {
    this.assigneeId = undefined;
  }

  // 우선순위 설정
  setPriority(priority: Priority): void {
    this.priority = priority;
  }

  // 마감일 설정
  setDueDate(dueDate: Date): void {
    this.dueDate = dueDate;
  }

  // 진행률 업데이트
  updateProgress(progress: number): void {
    this.progress = Math.max(0, Math.min(100, progress));
    
    if (progress === 100 && this.status !== TaskStatus.COMPLETED) {
      this.complete();
    } else if (progress === 0 && this.status !== TaskStatus.TODO) {
      this.status = TaskStatus.TODO;
    } else if (progress > 0 && progress < 100 && this.status === TaskStatus.TODO) {
      this.start();
    }
  }

  // 예상 시간 업데이트
  updateEstimatedHours(hours: number): void {
    this.estimatedHours = Math.max(0, hours);
  }

  // 실제 시간 업데이트 (시간 추적에서 자동 계산)
  recalculateActualHours(): void {
    if (this.timeEntries && this.timeEntries.length > 0) {
      this.actualHours = this.timeEntries.reduce((total, entry) => {
        return total + (entry.duration / 60); // 분을 시간으로 변환
      }, 0);
    }
  }

  // 마감일 체크
  isOverdue(): boolean {
    if (!this.dueDate) return false;
    return new Date() > this.dueDate && this.status !== TaskStatus.COMPLETED;
  }

  // 곧 마감되는지 체크 (24시간 이내)
  isDueSoon(): boolean {
    if (!this.dueDate) return false;
    const twentyFourHoursFromNow = new Date();
    twentyFourHoursFromNow.setHours(twentyFourHoursFromNow.getHours() + 24);
    return this.dueDate <= twentyFourHoursFromNow && !this.isOverdue();
  }

  // 완료 여부 체크
  isCompleted(): boolean {
    return this.status === TaskStatus.COMPLETED;
  }

  // 진행 중 여부 체크
  isInProgress(): boolean {
    return this.status === TaskStatus.IN_PROGRESS;
  }

  // 차단됨 여부 체크
  isBlocked(): boolean {
    return this.status === TaskStatus.BLOCKED;
  }

  // 서브태스크 여부 체크
  isSubtask(): boolean {
    return this.parentTaskId !== null;
  }

  // 상위 태스크 여부 체크
  hasSubtasks(): boolean {
    return this.subtasks && this.subtasks.length > 0;
  }

  // 의존성 확인
  hasDependencies(): boolean {
    return this.dependencies && this.dependencies.length > 0;
  }

  // 차단된 의존성이 있는지 확인
  hasBlockingDependencies(): boolean {
    return this.dependencies?.some(dep => 
      dep.dependsOnTask.status !== TaskStatus.COMPLETED
    ) || false;
  }

  // 담당자 확인
  isAssignedTo(userId: string): boolean {
    return this.assigneeId === userId;
  }

  // 생성자 확인
  isReportedBy(userId: string): boolean {
    return this.reporterId === userId;
  }

  // 관찰자 확인
  isWatchedBy(userId: string): boolean {
    return this.watchers?.some(watcher => watcher.id === userId) || false;
  }

  // 권한 확인 - 편집 가능한지
  canEdit(userId: string): boolean {
    return this.isAssignedTo(userId) || this.isReportedBy(userId);
  }

  // 권한 확인 - 삭제 가능한지
  canDelete(userId: string): boolean {
    return this.isReportedBy(userId);
  }

  // 태그 추가
  addTag(tag: string): void {
    if (!this.tags.includes(tag)) {
      this.tags.push(tag);
    }
  }

  // 태그 제거
  removeTag(tag: string): void {
    this.tags = this.tags.filter(t => t !== tag);
  }

  // 관찰자 추가
  addWatcher(user: User): void {
    if (!this.isWatchedBy(user.id)) {
      if (!this.watchers) this.watchers = [];
      this.watchers.push(user);
    }
  }

  // 관찰자 제거
  removeWatcher(userId: string): void {
    if (this.watchers) {
      this.watchers = this.watchers.filter(watcher => watcher.id !== userId);
    }
  }

  // 소요 시간 계산 (생성부터 완료까지)
  getTotalDuration(): number | null {
    if (!this.completedAt) return null;
    const startTime = this.startDate || this.createdAt;
    const diffTime = Math.abs(this.completedAt.getTime() - startTime.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // 일 단위
  }

  // 예상 대비 실제 시간 비율
  getTimeEfficiencyRatio(): number | null {
    if (!this.estimatedHours || this.actualHours === 0) return null;
    return this.actualHours / this.estimatedHours;
  }

  // 체크리스트 관련 메서드
  addChecklistItem(text: string): void {
    const newItem = {
      id: `checklist-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      text: text.trim(),
      completed: false,
      order: this.checklist.length
    };
    this.checklist.push(newItem);
  }

  updateChecklistItem(itemId: string, updates: Partial<{ text: string; completed: boolean; order: number }>): void {
    const itemIndex = this.checklist.findIndex(item => item.id === itemId);
    if (itemIndex !== -1) {
      this.checklist[itemIndex] = { ...this.checklist[itemIndex], ...updates };
    }
  }

  removeChecklistItem(itemId: string): void {
    this.checklist = this.checklist.filter(item => item.id !== itemId);
  }

  getChecklistProgress(): { completed: number; total: number; percentage: number } {
    const total = this.checklist.length;
    const completed = this.checklist.filter(item => item.completed).length;
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    return { completed, total, percentage };
  }

  // 관계 관련 메서드
  addRelationship(targetTaskId: string, type: 'blocks' | 'blocked_by' | 'related' | 'parent' | 'child'): void {
    const relationship = {
      id: `rel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      targetTaskId,
      type
    };
    this.relationships.push(relationship);
  }

  removeRelationship(relationshipId: string): void {
    this.relationships = this.relationships.filter(rel => rel.id !== relationshipId);
  }

  hasRelationshipWith(taskId: string): boolean {
    return this.relationships.some(rel => rel.targetTaskId === taskId);
  }

  // 위키 레퍼런스 관련 메서드
  addWikiReference(title: string, url: string, description?: string): void {
    const wikiRef = {
      id: `wiki-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title: title.trim(),
      url: url.trim(),
      description: description?.trim()
    };
    this.wikiReferences.push(wikiRef);
  }

  updateWikiReference(wikiId: string, updates: Partial<{ title: string; url: string; description: string }>): void {
    const wikiIndex = this.wikiReferences.findIndex(wiki => wiki.id === wikiId);
    if (wikiIndex !== -1) {
      this.wikiReferences[wikiIndex] = { ...this.wikiReferences[wikiIndex], ...updates };
    }
  }

  removeWikiReference(wikiId: string): void {
    this.wikiReferences = this.wikiReferences.filter(wiki => wiki.id !== wikiId);
  }

  // 시간 관리 메서드
  updateEstimatedTimeMinutes(minutes: number): void {
    this.estimatedTimeMinutes = Math.max(0, minutes);
  }

  addLoggedTime(minutes: number): void {
    this.loggedTimeMinutes += Math.max(0, minutes);
  }

  getTimeEfficiency(): number | null {
    if (!this.estimatedTimeMinutes || this.loggedTimeMinutes === 0) return null;
    return this.loggedTimeMinutes / this.estimatedTimeMinutes;
  }

  // JSON 직렬화
  toJSON() {
    const checklistProgress = this.getChecklistProgress();
    return {
      ...this,
      isOverdue: this.isOverdue(),
      isDueSoon: this.isDueSoon(),
      hasSubtasks: this.hasSubtasks(),
      hasDependencies: this.hasDependencies(),
      hasBlockingDependencies: this.hasBlockingDependencies(),
      checklistProgress,
      timeEfficiency: this.getTimeEfficiency(),
    };
  }
}
</file>

<file path="backend/src/modules/auth/strategies/jwt.strategy.ts">
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { AuthService } from '../auth.service';
import { getAuthConfig } from '../../../config/auth.config';
import { JwtPayload } from '@workly/shared';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private authService: AuthService,
  ) {
    const authConfig = getAuthConfig(configService);
    
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: authConfig.jwt.secret,
      passReqToCallback: true, // request 객체를 validate 메서드에 전달
    });
  }

  async validate(request: any, payload?: JwtPayload) {
    // 개발 환경에서 dev-admin-token 처리
    if (process.env.NODE_ENV === 'development') {
      const authHeader = request.headers.authorization;
      if (authHeader === 'Bearer dev-admin-token') {
        // 개발용 관리자 사용자 객체 반환
        return {
          id: 'dev-admin-1',
          name: '워클리 개발 관리자',
          email: 'dev-admin@workly.com',
          adminRole: 'super_admin',
          adminPermissions: ['*'],
          status: 'active',
          isAdminUser: () => true,
          isSuperAdmin: () => true,
          hasAllAdminPermissions: () => true,
          updateLastAdminLogin: () => {},
          lastAdminLogin: new Date(),
          twoFactorEnabled: false,
          allowedIPs: ['*']
        };
      }
    }

    // 일반 JWT 토큰 처리
    if (!payload) {
      throw new UnauthorizedException('Invalid token');
    }

    const user = await this.authService.validateUserById(payload.sub);
    
    if (!user) {
      throw new UnauthorizedException('Invalid token');
    }

    // 사용자 상태 확인
    if (user.status !== 'active') {
      throw new UnauthorizedException('Account is not active');
    }

    return user;
  }
}
</file>

<file path="backend/src/modules/auth/auth.service.ts">
import { 
  Injectable, 
  UnauthorizedException, 
  ConflictException,
  NotFoundException,
  BadRequestException 
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcryptjs';
import { v4 as uuidv4 } from 'uuid';

import { User } from '../../database/entities/user.entity';
import { getAuthConfig } from '../../config/auth.config';
import { JwtPayload, RefreshTokenPayload } from '@workly/shared';
import { 
  LoginDto, 
  RegisterDto, 
  GoogleAuthDto,
  RefreshTokenDto,
  ChangePasswordDto,
  ForgotPasswordDto,
  ResetPasswordDto,
  VerifyEmailDto,
  ResendVerificationDto
} from './dto/auth.dto';
import { 
  AuthResponse, 
  LoginResponse, 
  UserRole, 
  UserStatus 
} from '@workly/shared';

@Injectable()
export class AuthService {
  private authConfig;

  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {
    this.authConfig = getAuthConfig(configService);
  }

  // 일반 로그인
  async login(loginDto: LoginDto): Promise<LoginResponse> {
    const { email, password, rememberMe } = loginDto;

    const user = await this.userRepository.findOne({
      where: { email },
      select: ['id', 'email', 'password', 'firstName', 'lastName', 'role', 'status', 'emailVerifiedAt'],
    });

    if (!user) {
      throw new UnauthorizedException('이메일 또는 비밀번호가 올바르지 않습니다.');
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('이메일 또는 비밀번호가 올바르지 않습니다.');
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new UnauthorizedException('계정이 활성화되지 않았습니다.');
    }

    if (!user.emailVerifiedAt) {
      throw new UnauthorizedException('이메일 인증이 필요합니다.');
    }

    // 마지막 로그인 시간 업데이트
    await this.userRepository.update(user.id, {
      lastLoginAt: new Date(),
    });

    const tokens = await this.generateTokens(user, rememberMe);

    return {
      user: this.sanitizeUser(user),
      ...tokens,
    };
  }

  // 회원가입
  async register(registerDto: RegisterDto): Promise<AuthResponse> {
    const { email, password, firstName, lastName, agreeToTerms, agreeToPrivacy } = registerDto;

    // 이메일 중복 확인
    const existingUser = await this.userRepository.findOne({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('이미 존재하는 이메일입니다.');
    }

    // 동의 확인
    if (!agreeToTerms || !agreeToPrivacy) {
      throw new BadRequestException('서비스 이용약관 및 개인정보 처리방침에 동의해야 합니다.');
    }

    // 비밀번호 해싱
    const hashedPassword = await bcrypt.hash(password, this.authConfig.bcrypt.saltRounds);

    // 이메일 인증 토큰 생성
    const emailVerificationToken = uuidv4();

    // 사용자 생성
    const user = this.userRepository.create({
      email,
      password: hashedPassword,
      name: `${firstName} ${lastName}`,
      firstName,
      lastName,
      emailVerificationToken,
      profile: {
        firstName,
        lastName,
        timezone: 'Asia/Seoul',
        language: 'ko',
      },
      preferences: {
        theme: 'system',
        language: 'ko',
        timezone: 'Asia/Seoul',
        notifications: {
          email: true,
          push: true,
          desktop: true,
          taskAssigned: true,
          taskCompleted: true,
          taskDue: true,
          projectUpdates: true,
          mentions: true,
          weeklyDigest: true,
          dailyReminder: false,
        },
        workingHours: {
          enabled: true,
          startTime: '09:00',
          endTime: '18:00',
          timezone: 'Asia/Seoul',
          workingDays: [1, 2, 3, 4, 5],
          breakTime: {
            enabled: true,
            startTime: '12:00',
            endTime: '13:00',
          },
        },
        dashboard: {
          layout: 'grid',
          widgets: {
            myTasks: true,
            recentProjects: true,
            teamActivity: true,
            notifications: true,
            calendar: true,
            quickStats: true,
          },
          defaultView: 'dashboard',
        },
      },
    });

    const savedUser = await this.userRepository.save(user);

    // TODO: 이메일 인증 메일 발송
    // await this.emailService.sendVerificationEmail(savedUser.email, emailVerificationToken);

    return {
      message: '회원가입이 완료되었습니다. 이메일 인증을 완료해주세요.',
      user: this.sanitizeUser(savedUser),
    };
  }

  // Google OAuth 로그인
  async googleLogin(googleAuthDto: GoogleAuthDto): Promise<LoginResponse> {
    // TODO: Google OAuth 코드 검증 및 사용자 정보 가져오기
    // 현재는 기본 구현만 제공
    throw new BadRequestException('Google OAuth 기능은 아직 구현 중입니다.');
  }

  // Google 사용자 검증 (Passport Strategy에서 사용)
  async validateGoogleUser(googleUser: any): Promise<User> {
    const { googleId, email, firstName, lastName, avatar, emailVerified } = googleUser;

    // 기존 Google 사용자 찾기
    let user = await this.userRepository.findOne({
      where: { googleId },
    });

    if (user) {
      // 기존 사용자 정보 업데이트
      user.lastLoginAt = new Date();
      if (avatar && !user.avatar) {
        user.avatar = avatar;
      }
      return this.userRepository.save(user);
    }

    // 이메일로 기존 사용자 찾기
    user = await this.userRepository.findOne({
      where: { email },
    });

    if (user) {
      // 기존 사용자에 Google ID 연결
      user.googleId = googleId;
      user.lastLoginAt = new Date();
      if (avatar && !user.avatar) {
        user.avatar = avatar;
      }
      if (emailVerified && !user.emailVerifiedAt) {
        user.emailVerifiedAt = new Date();
        user.status = UserStatus.ACTIVE;
      }
      return this.userRepository.save(user);
    }

    // 새 사용자 생성
    const newUser = this.userRepository.create({
      email,
      name: `${firstName} ${lastName}`,
      googleId,
      firstName,
      lastName,
      avatar,
      password: '', // Google 사용자는 비밀번호 불필요
      status: emailVerified ? UserStatus.ACTIVE : UserStatus.PENDING_VERIFICATION,
      emailVerifiedAt: emailVerified ? new Date() : undefined,
      lastLoginAt: new Date(),
      profile: {
        firstName,
        lastName,
        timezone: 'Asia/Seoul',
        language: 'ko',
      },
      preferences: {
        theme: 'system',
        language: 'ko',
        timezone: 'Asia/Seoul',
        notifications: {
          email: true,
          push: true,
          desktop: true,
          taskAssigned: true,
          taskCompleted: true,
          taskDue: true,
          projectUpdates: true,
          mentions: true,
          weeklyDigest: true,
          dailyReminder: false,
        },
        workingHours: {
          enabled: true,
          startTime: '09:00',
          endTime: '18:00',
          timezone: 'Asia/Seoul',
          workingDays: [1, 2, 3, 4, 5],
          breakTime: {
            enabled: true,
            startTime: '12:00',
            endTime: '13:00',
          },
        },
        dashboard: {
          layout: 'grid',
          widgets: {
            myTasks: true,
            recentProjects: true,
            teamActivity: true,
            notifications: true,
            calendar: true,
            quickStats: true,
          },
          defaultView: 'dashboard',
        },
      },
    });

    return this.userRepository.save(newUser);
  }

  // JWT로 사용자 검증
  async validateUserById(userId: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { id: userId },
      select: [
        'id', 'email', 'name', 'firstName', 'lastName', 'avatar',
        'role', 'status', 'profile', 'preferences',
        'adminRole', 'adminPermissions', 'lastAdminLogin', 
        'twoFactorEnabled', 'allowedIPs',
        'lastLoginAt', 'emailVerifiedAt', 'googleId',
        'createdAt', 'updatedAt'
      ]
    });
  }

  // 토큰 새로고침
  async refreshToken(refreshTokenDto: RefreshTokenDto): Promise<{ accessToken: string }> {
    const { refreshToken } = refreshTokenDto;

    try {
      const payload = this.jwtService.verify(refreshToken, {
        secret: this.authConfig.jwt.secret,
      }) as RefreshTokenPayload;

      const user = await this.validateUserById(payload.sub);
      if (!user) {
        throw new UnauthorizedException('Invalid refresh token');
      }

      const accessToken = await this.generateAccessToken(user);
      return { accessToken };
    } catch (error) {
      throw new UnauthorizedException('Invalid refresh token');
    }
  }

  // 비밀번호 변경
  async changePassword(userId: string, changePasswordDto: ChangePasswordDto): Promise<AuthResponse> {
    const { currentPassword, newPassword, confirmPassword } = changePasswordDto;

    if (newPassword !== confirmPassword) {
      throw new BadRequestException('새 비밀번호가 일치하지 않습니다.');
    }

    const user = await this.userRepository.findOne({
      where: { id: userId },
      select: ['id', 'email', 'password'],
    });

    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다.');
    }

    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isCurrentPasswordValid) {
      throw new UnauthorizedException('현재 비밀번호가 올바르지 않습니다.');
    }

    const hashedNewPassword = await bcrypt.hash(newPassword, this.authConfig.bcrypt.saltRounds);
    await this.userRepository.update(userId, {
      password: hashedNewPassword,
    });

    return {
      message: '비밀번호가 성공적으로 변경되었습니다.',
    };
  }

  // 비밀번호 재설정 요청
  async forgotPassword(forgotPasswordDto: ForgotPasswordDto): Promise<AuthResponse> {
    const { email } = forgotPasswordDto;

    const user = await this.userRepository.findOne({
      where: { email },
    });

    if (!user) {
      // 보안상 이유로 사용자가 존재하지 않아도 성공 메시지 반환
      return {
        message: '비밀번호 재설정 링크가 이메일로 전송되었습니다.',
      };
    }

    const resetToken = uuidv4();
    const resetExpiresAt = new Date();
    resetExpiresAt.setHours(resetExpiresAt.getHours() + 1); // 1시간 후 만료

    await this.userRepository.update(user.id, {
      resetPasswordToken: resetToken,
      resetPasswordExpiresAt: resetExpiresAt,
    });

    // TODO: 비밀번호 재설정 이메일 발송
    // await this.emailService.sendPasswordResetEmail(user.email, resetToken);

    return {
      message: '비밀번호 재설정 링크가 이메일로 전송되었습니다.',
    };
  }

  // 비밀번호 재설정
  async resetPassword(resetPasswordDto: ResetPasswordDto): Promise<AuthResponse> {
    const { token, newPassword, confirmPassword } = resetPasswordDto;

    if (newPassword !== confirmPassword) {
      throw new BadRequestException('새 비밀번호가 일치하지 않습니다.');
    }

    const user = await this.userRepository.findOne({
      where: { 
        resetPasswordToken: token,
      },
    });

    if (!user || !user.resetPasswordExpiresAt || user.resetPasswordExpiresAt < new Date()) {
      throw new UnauthorizedException('유효하지 않거나 만료된 토큰입니다.');
    }

    const hashedPassword = await bcrypt.hash(newPassword, this.authConfig.bcrypt.saltRounds);

    await this.userRepository.update(user.id, {
      password: hashedPassword,
      resetPasswordToken: undefined,
      resetPasswordExpiresAt: undefined,
    });

    return {
      message: '비밀번호가 성공적으로 재설정되었습니다.',
    };
  }

  // 이메일 인증
  async verifyEmail(verifyEmailDto: VerifyEmailDto): Promise<AuthResponse> {
    const { token } = verifyEmailDto;

    const user = await this.userRepository.findOne({
      where: { emailVerificationToken: token },
    });

    if (!user) {
      throw new UnauthorizedException('유효하지 않은 인증 토큰입니다.');
    }

    if (user.emailVerifiedAt) {
      throw new BadRequestException('이미 인증된 이메일입니다.');
    }

    await this.userRepository.update(user.id, {
      emailVerifiedAt: new Date(),
      status: UserStatus.ACTIVE,
      emailVerificationToken: undefined,
    });

    return {
      message: '이메일 인증이 완료되었습니다.',
      user: this.sanitizeUser(user),
    };
  }

  // 인증 이메일 재발송
  async resendVerification(resendVerificationDto: ResendVerificationDto): Promise<AuthResponse> {
    const { email } = resendVerificationDto;

    const user = await this.userRepository.findOne({
      where: { email },
    });

    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다.');
    }

    if (user.emailVerifiedAt) {
      throw new BadRequestException('이미 인증된 이메일입니다.');
    }

    const emailVerificationToken = uuidv4();
    await this.userRepository.update(user.id, {
      emailVerificationToken,
    });

    // TODO: 인증 이메일 재발송
    // await this.emailService.sendVerificationEmail(user.email, emailVerificationToken);

    return {
      message: '인증 이메일이 재발송되었습니다.',
    };
  }

  // 외부에서 사용할 수 있는 토큰 생성 메서드
  async generateTokensForUser(user: User, rememberMe?: boolean): Promise<{ accessToken: string; refreshToken: string }> {
    return this.generateTokens(user, rememberMe);
  }

  // 토큰 생성
  private async generateTokens(user: User, rememberMe?: boolean): Promise<{ accessToken: string; refreshToken: string }> {
    const accessToken = await this.generateAccessToken(user);
    const refreshToken = await this.generateRefreshToken(user, rememberMe);

    return {
      accessToken,
      refreshToken,
    };
  }

  // Access Token 생성
  private async generateAccessToken(user: User): Promise<string> {
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
    };

    return this.jwtService.signAsync(payload, {
      secret: this.authConfig.jwt.secret,
      expiresIn: this.authConfig.jwt.expiresIn,
    });
  }

  // Refresh Token 생성
  private async generateRefreshToken(user: User, rememberMe?: boolean): Promise<string> {
    const payload: RefreshTokenPayload = {
      sub: user.id,
      tokenId: uuidv4(),
    };

    const expiresIn = rememberMe 
      ? this.authConfig.jwt.refreshExpiresIn 
      : '7d'; // 기본 7일

    return this.jwtService.signAsync(payload, {
      secret: this.authConfig.jwt.secret,
      expiresIn,
    });
  }

  // 사용자 정보 정제 (민감한 정보 제거)
  private sanitizeUser(user: User): any {
    const { password, resetPasswordToken, emailVerificationToken, ...sanitizedUser } = user;
    return sanitizedUser;
  }
}
</file>

<file path="backend/src/modules/tasks/dto/task.dto.ts">
import {
  IsString,
  IsOptional,
  IsEnum,
  IsUUID,
  IsArray,
  IsNumber,
  IsObject,
  IsDateString,
  IsBoolean,
  Min,
  Max,
  MaxLength,
  MinLength,
  IsInt,
} from 'class-validator';
import { Type, Transform } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { 
  TaskStatus, 
  Priority, 
  TaskType 
} from '@workly/shared';

export class CreateTaskDto {
  @ApiProperty({
    description: '태스크 제목',
    example: '로그인 기능 구현',
    minLength: 1,
    maxLength: 200,
  })
  @IsString()
  @MinLength(1, { message: '태스크 제목은 필수입니다.' })
  @MaxLength(200, { message: '태스크 제목은 200자를 초과할 수 없습니다.' })
  title: string;

  @ApiPropertyOptional({
    description: '태스크 설명',
    example: 'JWT를 사용한 로그인 기능을 구현합니다.',
  })
  @IsOptional()
  @IsString()
  @MaxLength(2000, { message: '태스크 설명은 2000자를 초과할 수 없습니다.' })
  description?: string;

  @ApiPropertyOptional({
    description: '프로젝트 ID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 프로젝트 ID를 입력해주세요.' })
  projectId?: string;

  @ApiPropertyOptional({
    description: '담당자 ID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 담당자 ID를 입력해주세요.' })
  assigneeId?: string;

  @ApiPropertyOptional({
    description: '부모 태스크 ID (서브태스크인 경우)',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 부모 태스크 ID를 입력해주세요.' })
  parentTaskId?: string;

  @ApiPropertyOptional({
    description: '태스크 우선순위',
    enum: Priority,
    example: 'medium',
  })
  @IsOptional()
  @IsEnum(Priority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: Priority;

  @ApiPropertyOptional({
    description: '태스크 타입',
    enum: TaskType,
    example: 'task',
  })
  @IsOptional()
  @IsEnum(TaskType, { message: '유효한 태스크 타입을 선택해주세요.' })
  type?: TaskType;

  @ApiPropertyOptional({
    description: '마감일',
    example: '2024-02-01T23:59:59.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  dueDate?: string;

  @ApiPropertyOptional({
    description: '시작일',
    example: '2024-01-15T09:00:00.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  startDate?: string;

  @ApiPropertyOptional({
    description: '예상 소요 시간 (시간 단위)',
    example: 8.5,
    minimum: 0,
  })
  @IsOptional()
  @IsNumber({}, { message: '유효한 숫자를 입력해주세요.' })
  @Min(0, { message: '예상 소요 시간은 0 이상이어야 합니다.' })
  estimatedHours?: number;

  @ApiPropertyOptional({
    description: '태그 목록',
    example: ['frontend', 'authentication'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: '레이블 ID 목록',
    example: ['123e4567-e89b-12d3-a456-426614174000'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsUUID(4, { each: true, message: '유효한 레이블 ID를 입력해주세요.' })
  labelIds?: string[];

  @ApiPropertyOptional({
    description: '커스텀 필드',
    example: { category: 'development', client: 'internal' },
  })
  @IsOptional()
  @IsObject()
  customFields?: Record<string, any>;
}

export class UpdateTaskDto {
  @ApiPropertyOptional({
    description: '태스크 제목',
    example: '로그인 기능 구현 완료',
    maxLength: 200,
  })
  @IsOptional()
  @IsString()
  @MaxLength(200, { message: '태스크 제목은 200자를 초과할 수 없습니다.' })
  title?: string;

  @ApiPropertyOptional({
    description: '태스크 설명',
    example: 'JWT를 사용한 로그인 기능 구현이 완료되었습니다.',
  })
  @IsOptional()
  @IsString()
  @MaxLength(2000, { message: '태스크 설명은 2000자를 초과할 수 없습니다.' })
  description?: string;

  @ApiPropertyOptional({
    description: '태스크 상태',
    enum: TaskStatus,
    example: 'in_progress',
  })
  @IsOptional()
  @IsEnum(TaskStatus, { message: '유효한 태스크 상태를 선택해주세요.' })
  status?: TaskStatus;

  @ApiPropertyOptional({
    description: '태스크 우선순위',
    enum: Priority,
    example: 'high',
  })
  @IsOptional()
  @IsEnum(Priority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: Priority;

  @ApiPropertyOptional({
    description: '태스크 타입',
    enum: TaskType,
    example: 'feature',
  })
  @IsOptional()
  @IsEnum(TaskType, { message: '유효한 태스크 타입을 선택해주세요.' })
  type?: TaskType;

  @ApiPropertyOptional({
    description: '마감일',
    example: '2024-02-01T23:59:59.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  dueDate?: string;

  @ApiPropertyOptional({
    description: '시작일',
    example: '2024-01-15T09:00:00.000Z',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  startDate?: string;

  @ApiPropertyOptional({
    description: '예상 소요 시간 (시간 단위)',
    example: 10,
    minimum: 0,
  })
  @IsOptional()
  @IsNumber({}, { message: '유효한 숫자를 입력해주세요.' })
  @Min(0, { message: '예상 소요 시간은 0 이상이어야 합니다.' })
  estimatedHours?: number;

  @ApiPropertyOptional({
    description: '진행률 (0-100)',
    example: 75,
    minimum: 0,
    maximum: 100,
  })
  @IsOptional()
  @IsInt({ message: '진행률은 정수여야 합니다.' })
  @Min(0, { message: '진행률은 0 이상이어야 합니다.' })
  @Max(100, { message: '진행률은 100 이하여야 합니다.' })
  progress?: number;

  @ApiPropertyOptional({
    description: '태그 목록',
    example: ['frontend', 'authentication', 'completed'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: '레이블 ID 목록',
    example: ['123e4567-e89b-12d3-a456-426614174000'],
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsUUID(4, { each: true, message: '유효한 레이블 ID를 입력해주세요.' })
  labelIds?: string[];

  @ApiPropertyOptional({
    description: '커스텀 필드',
    example: { category: 'development', reviewStatus: 'approved' },
  })
  @IsOptional()
  @IsObject()
  customFields?: Record<string, any>;
}

export class TaskQueryDto {
  @ApiPropertyOptional({
    description: '페이지 번호',
    example: 1,
    minimum: 1,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '페이지 번호는 정수여야 합니다.' })
  @Min(1, { message: '페이지 번호는 1 이상이어야 합니다.' })
  page?: number;

  @ApiPropertyOptional({
    description: '페이지 크기',
    example: 20,
    minimum: 1,
    maximum: 100,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '페이지 크기는 정수여야 합니다.' })
  @Min(1, { message: '페이지 크기는 1 이상이어야 합니다.' })
  @Max(100, { message: '페이지 크기는 100 이하여야 합니다.' })
  limit?: number;

  @ApiPropertyOptional({
    description: '태스크 상태 필터',
    enum: TaskStatus,
    example: 'in_progress',
  })
  @IsOptional()
  @IsEnum(TaskStatus, { message: '유효한 태스크 상태를 선택해주세요.' })
  status?: TaskStatus;

  @ApiPropertyOptional({
    description: '우선순위 필터',
    enum: Priority,
    example: 'high',
  })
  @IsOptional()
  @IsEnum(Priority, { message: '유효한 우선순위를 선택해주세요.' })
  priority?: Priority;

  @ApiPropertyOptional({
    description: '태스크 타입 필터',
    enum: TaskType,
    example: 'feature',
  })
  @IsOptional()
  @IsEnum(TaskType, { message: '유효한 태스크 타입을 선택해주세요.' })
  type?: TaskType;

  @ApiPropertyOptional({
    description: '프로젝트 ID 필터',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 프로젝트 ID를 입력해주세요.' })
  projectId?: string;

  @ApiPropertyOptional({
    description: '담당자 ID 필터',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 담당자 ID를 입력해주세요.' })
  assigneeId?: string;

  @ApiPropertyOptional({
    description: '생성자 ID 필터',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 생성자 ID를 입력해주세요.' })
  reporterId?: string;

  @ApiPropertyOptional({
    description: '마감일 필터 (YYYY-MM-DD)',
    example: '2024-02-01',
  })
  @IsOptional()
  @IsDateString({}, { message: '유효한 날짜 형식을 입력해주세요.' })
  dueDate?: string;

  @ApiPropertyOptional({
    description: '검색어 (제목, 설명, 태그)',
    example: '로그인',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: '검색어는 100자를 초과할 수 없습니다.' })
  search?: string;

  @ApiPropertyOptional({
    description: '정렬 기준',
    example: 'createdAt',
    enum: ['createdAt', 'updatedAt', 'title', 'priority', 'dueDate', 'status'],
  })
  @IsOptional()
  @IsString()
  sortBy?: string;

  @ApiPropertyOptional({
    description: '정렬 순서',
    example: 'DESC',
    enum: ['ASC', 'DESC'],
  })
  @IsOptional()
  @IsEnum(['ASC', 'DESC'], { message: '정렬 순서는 ASC 또는 DESC여야 합니다.' })
  sortOrder?: 'ASC' | 'DESC';

  @ApiPropertyOptional({
    description: '서브태스크 포함 여부',
    example: false,
  })
  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  includeSubtasks?: boolean;

  @ApiPropertyOptional({
    description: '레이블 ID 필터 목록',
    example: ['123e4567-e89b-12d3-a456-426614174000'],
    type: [String],
  })
  @IsOptional()
  @Transform(({ value }) => Array.isArray(value) ? value : [value])
  @IsArray()
  @IsUUID(4, { each: true, message: '유효한 레이블 ID를 입력해주세요.' })
  labelIds?: string[];

  @ApiPropertyOptional({
    description: '태그 필터 목록',
    example: ['frontend', 'authentication'],
    type: [String],
  })
  @IsOptional()
  @Transform(({ value }) => Array.isArray(value) ? value : [value])
  @IsArray()
  @IsString({ each: true })
  tags?: string[];
}

export class CreateTaskLabelDto {
  @ApiProperty({
    description: '레이블 이름',
    example: 'Bug',
    maxLength: 50,
  })
  @IsString()
  @MinLength(1, { message: '레이블 이름은 필수입니다.' })
  @MaxLength(50, { message: '레이블 이름은 50자를 초과할 수 없습니다.' })
  name: string;

  @ApiProperty({
    description: '레이블 색상 (HEX)',
    example: '#FF0000',
  })
  @IsString()
  @MaxLength(7, { message: '색상은 7자를 초과할 수 없습니다.' })
  color: string;

  @ApiPropertyOptional({
    description: '레이블 설명',
    example: '버그 및 오류 관련 태스크',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200, { message: '레이블 설명은 200자를 초과할 수 없습니다.' })
  description?: string;

  @ApiPropertyOptional({
    description: '프로젝트 ID (프로젝트 전용 레이블인 경우)',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsOptional()
  @IsUUID(4, { message: '유효한 프로젝트 ID를 입력해주세요.' })
  projectId?: string;
}

export class UpdateTaskLabelDto {
  @ApiPropertyOptional({
    description: '레이블 이름',
    example: 'Critical Bug',
    maxLength: 50,
  })
  @IsOptional()
  @IsString()
  @MaxLength(50, { message: '레이블 이름은 50자를 초과할 수 없습니다.' })
  name?: string;

  @ApiPropertyOptional({
    description: '레이블 색상 (HEX)',
    example: '#CC0000',
  })
  @IsOptional()
  @IsString()
  @MaxLength(7, { message: '색상은 7자를 초과할 수 없습니다.' })
  color?: string;

  @ApiPropertyOptional({
    description: '레이블 설명',
    example: '긴급하게 처리해야 할 버그',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200, { message: '레이블 설명은 200자를 초과할 수 없습니다.' })
  description?: string;
}

// 체크리스트 아이템 DTO
export class ChecklistItemDto {
  @ApiProperty({
    description: '체크리스트 아이템 ID',
    example: 'checklist-1706123456789-abc123def',
  })
  @IsString()
  id: string;

  @ApiProperty({
    description: '체크리스트 아이템 텍스트',
    example: '기본 요구사항 검토',
  })
  @IsString()
  @MaxLength(500, { message: '체크리스트 아이템은 500자를 초과할 수 없습니다.' })
  text: string;

  @ApiProperty({
    description: '완료 여부',
    example: false,
  })
  @IsBoolean()
  completed: boolean;

  @ApiProperty({
    description: '정렬 순서',
    example: 0,
  })
  @IsInt()
  @Min(0)
  order: number;
}

// 업무 관계 DTO
export class TaskRelationshipDto {
  @ApiProperty({
    description: '관계 ID',
    example: 'rel-1706123456789-abc123def',
  })
  @IsString()
  id: string;

  @ApiProperty({
    description: '대상 업무 ID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @IsUUID(4, { message: '유효한 업무 ID를 입력해주세요.' })
  targetTaskId: string;

  @ApiProperty({
    description: '관계 타입',
    enum: ['blocks', 'blocked_by', 'related', 'parent', 'child'],
    example: 'blocks',
  })
  @IsEnum(['blocks', 'blocked_by', 'related', 'parent', 'child'], {
    message: '유효한 관계 타입을 선택해주세요.'
  })
  type: 'blocks' | 'blocked_by' | 'related' | 'parent' | 'child';
}

// 위키 레퍼런스 DTO
export class WikiReferenceDto {
  @ApiProperty({
    description: '위키 레퍼런스 ID',
    example: 'wiki-1706123456789-abc123def',
  })
  @IsString()
  id: string;

  @ApiProperty({
    description: '위키 문서 제목',
    example: '워클리 디자인 가이드',
  })
  @IsString()
  @MaxLength(200, { message: '위키 제목은 200자를 초과할 수 없습니다.' })
  title: string;

  @ApiProperty({
    description: '위키 문서 URL',
    example: 'https://wiki.example.com/design-guide',
  })
  @IsString()
  @MaxLength(2000, { message: 'URL은 2000자를 초과할 수 없습니다.' })
  url: string;

  @ApiPropertyOptional({
    description: '위키 문서 설명',
    example: '워클리 UI/UX 디자인 표준',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500, { message: '위키 설명은 500자를 초과할 수 없습니다.' })
  description?: string;
}

// 업무 상세 업데이트 DTO
export class UpdateTaskDetailDto extends UpdateTaskDto {
  @ApiPropertyOptional({
    description: '마크다운 형식의 상세 설명',
    example: '# 로그인 기능 구현\n\n## 요구사항\n- JWT 토큰 사용\n- 소셜 로그인 지원',
  })
  @IsOptional()
  @IsString()
  @MaxLength(10000, { message: '마크다운 설명은 10000자를 초과할 수 없습니다.' })
  descriptionMarkdown?: string;

  @ApiPropertyOptional({
    description: '체크리스트 아이템 목록',
    type: [ChecklistItemDto],
  })
  @IsOptional()
  @IsArray()
  @Type(() => ChecklistItemDto)
  checklist?: ChecklistItemDto[];

  @ApiPropertyOptional({
    description: '업무 관계 목록',
    type: [TaskRelationshipDto],
  })
  @IsOptional()
  @IsArray()
  @Type(() => TaskRelationshipDto)
  relationships?: TaskRelationshipDto[];

  @ApiPropertyOptional({
    description: '위키 레퍼런스 목록',
    type: [WikiReferenceDto],
  })
  @IsOptional()
  @IsArray()
  @Type(() => WikiReferenceDto)
  wikiReferences?: WikiReferenceDto[];

  @ApiPropertyOptional({
    description: '예상 소요 시간 (분 단위)',
    example: 480,
    minimum: 0,
  })
  @IsOptional()
  @IsInt({ message: '예상 시간은 정수여야 합니다.' })
  @Min(0, { message: '예상 시간은 0 이상이어야 합니다.' })
  estimatedTimeMinutes?: number;

  @ApiPropertyOptional({
    description: '기록된 소요 시간 (분 단위)',
    example: 320,
    minimum: 0,
  })
  @IsOptional()
  @IsInt({ message: '기록된 시간은 정수여야 합니다.' })
  @Min(0, { message: '기록된 시간은 0 이상이어야 합니다.' })
  loggedTimeMinutes?: number;
}
</file>

<file path="backend/src/modules/tasks/tasks.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { Throttle } from '@nestjs/throttler';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';

import { TasksService } from './tasks.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { 
  CreateTaskDto, 
  UpdateTaskDto, 
  TaskQueryDto,
  UpdateTaskDetailDto
} from './dto/task.dto';
import { 
  TaskStatus, 
  Priority 
} from '@workly/shared';

@ApiTags('Tasks')
@Controller('tasks')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class TasksController {
  constructor(private readonly tasksService: TasksService) {}

  // 태스크 생성
  @Post()
  @Throttle({ default: { limit: 20, ttl: 60000 } }) // 1분에 20개 생성 제한
  @ApiOperation({ summary: '새 태스크 생성' })
  @ApiResponse({
    status: 201,
    description: '태스크가 성공적으로 생성되었습니다.',
  })
  @ApiResponse({
    status: 400,
    description: '잘못된 요청 데이터',
  })
  @ApiResponse({
    status: 403,
    description: '태스크 생성 권한이 없습니다.',
  })
  async create(
    @Body() createTaskDto: CreateTaskDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.create(createTaskDto, userId);
  }

  // 태스크 목록 조회
  @Get()
  @ApiOperation({ summary: '태스크 목록 조회 (필터링, 정렬, 페이징 지원)' })
  @ApiResponse({
    status: 200,
    description: '태스크 목록이 성공적으로 조회되었습니다.',
  })
  async findAll(
    @Query() query: TaskQueryDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.findAll(query, userId);
  }

  // 내 태스크 조회 (GTD 컨텍스트별)
  @Get('my/:context?')
  @ApiOperation({ summary: '내 태스크 조회 (GTD 컨텍스트별)' })
  @ApiParam({
    name: 'context',
    description: 'GTD 컨텍스트',
    enum: ['inbox', 'next', 'waiting', 'someday'],
    required: false,
  })
  @ApiResponse({
    status: 200,
    description: '내 태스크 목록이 성공적으로 조회되었습니다.',
  })
  async getMyTasks(
    @Param('context') context: 'inbox' | 'next' | 'waiting' | 'someday' | undefined,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.getMyTasks(userId, context);
  }

  // GTD 스마트 필터 기반 태스크 조회
  @Get('filter/:filter')
  @ApiOperation({ summary: 'GTD 스마트 필터 기반 태스크 조회' })
  @ApiParam({
    name: 'filter',
    description: 'GTD 스마트 필터',
    enum: ['today', 'completed', 'all'],
  })
  @ApiResponse({
    status: 200,
    description: '필터링된 태스크 목록이 성공적으로 조회되었습니다.',
  })
  async getSmartFilteredTasks(
    @Param('filter') filter: 'today' | 'completed' | 'all',
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.getSmartFilteredTasks(userId, filter);
  }

  // 특정 태스크 조회
  @Get(':id')
  @ApiOperation({ summary: '특정 태스크 상세 조회' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '태스크 정보가 성공적으로 조회되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '태스크를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '태스크에 접근할 권한이 없습니다.',
  })
  async findOne(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.findOne(id, userId);
  }

  // 태스크 정보 수정
  @Patch(':id')
  @ApiOperation({ summary: '태스크 정보 수정' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '태스크가 성공적으로 수정되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '태스크를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '태스크를 수정할 권한이 없습니다.',
  })
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateTaskDto: UpdateTaskDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.update(id, updateTaskDto, userId);
  }

  // 태스크 상세 정보 수정 (마크다운, 체크리스트, 관계, 위키 레퍼런스, 시간 관리)
  @Patch(':id/detail')
  @ApiOperation({ summary: '태스크 상세 정보 수정 (Notion 스타일 모달용)' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 200,
    description: '태스크 상세 정보가 성공적으로 수정되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '태스크를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '태스크를 수정할 권한이 없습니다.',
  })
  async updateTaskDetail(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateTaskDetailDto: UpdateTaskDetailDto,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.updateTaskDetail(id, updateTaskDetailDto, userId);
  }

  // 태스크 상태 변경
  @Patch(':id/status')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '태스크 상태 변경' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiQuery({
    name: 'status',
    description: '새로운 상태',
    enum: TaskStatus,
  })
  @ApiResponse({
    status: 200,
    description: '태스크 상태가 성공적으로 변경되었습니다.',
  })
  async updateStatus(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('status') status: TaskStatus,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.updateStatus(id, status, userId);
  }

  // 태스크 우선순위 변경
  @Patch(':id/priority')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '태스크 우선순위 변경' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiQuery({
    name: 'priority',
    description: '새로운 우선순위',
    enum: Priority,
  })
  @ApiResponse({
    status: 200,
    description: '태스크 우선순위가 성공적으로 변경되었습니다.',
  })
  async updatePriority(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('priority') priority: Priority,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.updatePriority(id, priority, userId);
  }

  // 태스크 진행률 업데이트
  @Patch(':id/progress')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: '태스크 진행률 업데이트' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiQuery({
    name: 'progress',
    description: '진행률 (0-100)',
    type: 'number',
  })
  @ApiResponse({
    status: 200,
    description: '태스크 진행률이 성공적으로 업데이트되었습니다.',
  })
  async updateProgress(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('progress') progress: number,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.updateProgress(id, progress, userId);
  }

  // 태스크 삭제
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: '태스크 삭제' })
  @ApiParam({
    name: 'id',
    description: '태스크 ID',
    type: 'string',
    format: 'uuid',
  })
  @ApiResponse({
    status: 204,
    description: '태스크가 성공적으로 삭제되었습니다.',
  })
  @ApiResponse({
    status: 404,
    description: '태스크를 찾을 수 없습니다.',
  })
  @ApiResponse({
    status: 403,
    description: '태스크를 삭제할 권한이 없습니다.',
  })
  @ApiResponse({
    status: 400,
    description: '의존성이 있는 태스크는 삭제할 수 없습니다.',
  })
  async remove(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser('id') userId: string,
  ) {
    return this.tasksService.remove(id, userId);
  }
}
</file>

<file path="backend/src/modules/tasks/tasks.service.ts">
import { 
  Injectable, 
  NotFoundException, 
  ForbiddenException,
  BadRequestException,
  Inject,
  forwardRef
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindOptionsWhere, In } from 'typeorm';
import { Task } from '../../database/entities/task.entity';
import { TaskLabel } from '../../database/entities/task-label.entity';
import { TaskDependency } from '../../database/entities/task-dependency.entity';
import { User } from '../../database/entities/user.entity';
import { Project } from '../../database/entities/project.entity';
// import { WebSocketGateway as WSGateway } from '../websocket/websocket.gateway';
import { 
  CreateTaskDto, 
  UpdateTaskDto, 
  TaskQueryDto,
  CreateTaskLabelDto,
  UpdateTaskLabelDto,
  UpdateTaskDetailDto
} from './dto/task.dto';
import { 
  TaskStatus, 
  Priority, 
  TaskType,
  PaginatedResponse 
} from '@workly/shared';

@Injectable()
export class TasksService {
  constructor(
    @InjectRepository(Task)
    private taskRepository: Repository<Task>,
    @InjectRepository(TaskLabel)
    private taskLabelRepository: Repository<TaskLabel>,
    @InjectRepository(TaskDependency)
    private taskDependencyRepository: Repository<TaskDependency>,
    @InjectRepository(Project)
    private projectRepository: Repository<Project>,
    // @Inject(forwardRef(() => WSGateway))
    // private webSocketGateway: WSGateway,
  ) {}

  // 태스크 생성
  async create(createTaskDto: CreateTaskDto, userId: string): Promise<Task> {
    const {
      title,
      description,
      projectId,
      assigneeId,
      parentTaskId,
      priority = 'medium',
      type = 'task',
      dueDate,
      startDate,
      estimatedHours,
      tags = [],
      labelIds = [],
      customFields = {},
    } = createTaskDto;

    // 프로젝트 존재 및 권한 확인
    if (projectId) {
      const project = await this.projectRepository.findOne({
        where: { id: projectId },
        relations: ['members'],
      });

      if (!project) {
        throw new NotFoundException('프로젝트를 찾을 수 없습니다.');
      }

      // 프로젝트 멤버인지 확인
      const isMember = project.members.some(member => member.userId === userId);
      if (!isMember && project.ownerId !== userId) {
        throw new ForbiddenException('해당 프로젝트에 태스크를 생성할 권한이 없습니다.');
      }
    }

    // 부모 태스크 확인
    let parentTask: Task | null = null;
    if (parentTaskId) {
      parentTask = await this.taskRepository.findOne({
        where: { id: parentTaskId },
        relations: ['project'],
      });

      if (!parentTask) {
        throw new NotFoundException('부모 태스크를 찾을 수 없습니다.');
      }

      // 부모 태스크와 같은 프로젝트인지 확인
      if (projectId && parentTask.projectId !== projectId) {
        throw new BadRequestException('부모 태스크와 같은 프로젝트에 속해야 합니다.');
      }
    }

    // 레이블 확인
    let labels: TaskLabel[] = [];
    if (labelIds.length > 0) {
      labels = await this.taskLabelRepository.findBy({
        id: In(labelIds),
      });

      if (labels.length !== labelIds.length) {
        throw new BadRequestException('존재하지 않는 레이블이 포함되어 있습니다.');
      }
    }

    // 태스크 생성
    const task = this.taskRepository.create({
      title,
      description,
      status: 'todo',
      priority,
      type,
      dueDate: dueDate ? new Date(dueDate) : null,
      startDate: startDate ? new Date(startDate) : null,
      projectId,
      assigneeId: assigneeId || userId,
      reporterId: userId,
      parentTaskId,
      estimatedHours,
      tags,
      customFields,
      labels,
    } as any);

    const savedTask = await this.taskRepository.save(task) as unknown as Task;

    // 관계 포함하여 반환
    const newTask = await this.taskRepository.findOne({
      where: { id: savedTask.id },
      relations: [
        'project',
        'assignee',
        'reporter',
        'parentTask',
        'subtasks',
        'labels',
        'comments',
        'dependencies',
        'dependents',
        'watchers',
        'timeEntries'
      ],
    });

    // 실시간 알림 전송
    if (newTask && newTask.projectId) {
      // this.webSocketGateway.broadcastProjectUpdate(
      //   newTask.projectId,
      //   { type: 'task:created', task: newTask },
      //   userId
      // );
    }

    return newTask!;
  }

  // 태스크 목록 조회 (필터링, 정렬, 페이징)
  async findAll(queryDto: TaskQueryDto, userId: string): Promise<PaginatedResponse<Task>> {
    const {
      page = 1,
      limit = 20,
      status,
      priority,
      type,
      projectId,
      assigneeId,
      reporterId,
      dueDate,
      search,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
      includeSubtasks = false,
      labelIds,
      tags,
    } = queryDto;

    const queryBuilder = this.taskRepository.createQueryBuilder('task')
      .leftJoinAndSelect('task.project', 'project')
      .leftJoinAndSelect('task.assignee', 'assignee')
      .leftJoinAndSelect('task.reporter', 'reporter')
      .leftJoinAndSelect('task.parentTask', 'parentTask')
      .leftJoinAndSelect('task.labels', 'labels')
      .leftJoinAndSelect('task.timeEntries', 'timeEntries');

    // 권한 필터링: 할당된 태스크, 생성한 태스크, 또는 참여 중인 프로젝트의 태스크만
    queryBuilder.where(`(
      task.assigneeId = :userId OR 
      task.reporterId = :userId OR 
      project.ownerId = :userId OR
      EXISTS (
        SELECT 1 FROM project_members pm 
        WHERE pm.projectId = task.projectId AND pm.userId = :userId
      )
    )`, { userId });

    // 상태 필터
    if (status) {
      queryBuilder.andWhere('task.status = :status', { status });
    }

    // 우선순위 필터
    if (priority) {
      queryBuilder.andWhere('task.priority = :priority', { priority });
    }

    // 타입 필터
    if (type) {
      queryBuilder.andWhere('task.type = :type', { type });
    }

    // 프로젝트 필터
    if (projectId) {
      queryBuilder.andWhere('task.projectId = :projectId', { projectId });
    }

    // 담당자 필터
    if (assigneeId) {
      queryBuilder.andWhere('task.assigneeId = :assigneeId', { assigneeId });
    }

    // 생성자 필터
    if (reporterId) {
      queryBuilder.andWhere('task.reporterId = :reporterId', { reporterId });
    }

    // 마감일 필터
    if (dueDate) {
      const targetDate = new Date(dueDate);
      const nextDay = new Date(targetDate);
      nextDay.setDate(nextDay.getDate() + 1);
      queryBuilder.andWhere('task.dueDate >= :startDate AND task.dueDate < :endDate', {
        startDate: targetDate,
        endDate: nextDay,
      });
    }

    // 검색 필터
    if (search) {
      queryBuilder.andWhere(`(
        task.title ILIKE :search OR 
        task.description ILIKE :search OR
        array_to_string(task.tags, ' ') ILIKE :search
      )`, { search: `%${search}%` });
    }

    // 레이블 필터
    if (labelIds && labelIds.length > 0) {
      queryBuilder.andWhere('labels.id IN (:...labelIds)', { labelIds });
    }

    // 태그 필터
    if (tags && tags.length > 0) {
      queryBuilder.andWhere('task.tags && :tags', { tags });
    }

    // 서브태스크 제외 (기본값)
    if (!includeSubtasks) {
      queryBuilder.andWhere('task.parentTaskId IS NULL');
    }

    // 정렬
    const allowedSortFields = ['createdAt', 'updatedAt', 'title', 'priority', 'dueDate', 'status'];
    const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'createdAt';
    queryBuilder.orderBy(`task.${sortField}`, sortOrder as 'ASC' | 'DESC');

    // 페이징
    const offset = (page - 1) * limit;
    queryBuilder.skip(offset).take(limit);

    // 실행
    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      success: true,
      data: items,
      items,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // 특정 태스크 조회
  async findOne(id: string, userId: string): Promise<Task> {
    const task = await this.taskRepository.findOne({
      where: { id },
      relations: [
        'project',
        'assignee',
        'reporter',
        'parentTask',
        'subtasks',
        'labels',
        'comments',
        'comments.author',
        'dependencies',
        'dependencies.dependsOnTask',
        'dependents',
        'dependents.dependentTask',
        'watchers',
        'timeEntries',
        'timeEntries.user'
      ],
    });

    if (!task) {
      throw new NotFoundException('태스크를 찾을 수 없습니다.');
    }

    // 권한 확인
    await this.checkTaskAccess(task, userId);

    return task;
  }

  // 태스크 수정
  async update(id: string, updateTaskDto: UpdateTaskDto, userId: string): Promise<Task> {
    const task = await this.findOne(id, userId);

    // 수정 권한 확인 (담당자, 생성자, 프로젝트 소유자만 수정 가능)
    if (task.assigneeId !== userId && task.reporterId !== userId && 
        task.project?.ownerId !== userId) {
      throw new ForbiddenException('태스크를 수정할 권한이 없습니다.');
    }

    const {
      title,
      description,
      status,
      priority,
      type,
      dueDate,
      startDate,
      estimatedHours,
      progress,
      tags,
      customFields,
      labelIds,
    } = updateTaskDto;

    // 업데이트할 필드들
    if (title !== undefined) task.title = title;
    if (description !== undefined) task.description = description;
    if (status !== undefined) {
      task.status = status;
      // 완료 상태 변경 시 완료 시간 설정
      if (status === TaskStatus.COMPLETED && !task.completedAt) {
        task.completedAt = new Date();
      } else if (status !== TaskStatus.COMPLETED) {
        task.completedAt = undefined;
      }
    }
    if (priority !== undefined) task.priority = priority;
    if (type !== undefined) task.type = type;
    if (dueDate !== undefined) task.dueDate = dueDate ? new Date(dueDate) : undefined;
    if (startDate !== undefined) task.startDate = startDate ? new Date(startDate) : undefined;
    if (estimatedHours !== undefined) task.estimatedHours = estimatedHours;
    if (progress !== undefined) task.progress = Math.max(0, Math.min(100, progress));
    if (tags !== undefined) task.tags = tags;
    if (customFields !== undefined) task.customFields = { ...task.customFields, ...customFields };

    // 레이블 업데이트
    if (labelIds !== undefined) {
      const labels = await this.taskLabelRepository.findBy({
        id: In(labelIds),
      });
      task.labels = labels;
    }

    const updatedTask = await this.taskRepository.save(task);
    const finalTask = await this.findOne(updatedTask.id, userId);

    // 실시간 업데이트 알림
    // this.webSocketGateway.broadcastTaskUpdate(
    //   finalTask.id,
    //   { type: 'task:updated', task: finalTask },
    //   userId
    // );

    // 프로젝트 룸에도 알림
    // if (finalTask.projectId) {
    //   this.webSocketGateway.broadcastProjectUpdate(
    //     finalTask.projectId,
    //     { type: 'task:updated', task: finalTask },
    //     userId
    //   );
    // }

    return finalTask;
  }

  // 태스크 상세 정보 업데이트 (마크다운, 체크리스트, 관계, 위키 레퍼런스, 시간 관리)
  async updateTaskDetail(id: string, updateTaskDetailDto: UpdateTaskDetailDto, userId: string): Promise<Task> {
    const task = await this.findOne(id, userId);

    // 수정 권한 확인
    if (task.assigneeId !== userId && task.reporterId !== userId && 
        task.project?.ownerId !== userId) {
      throw new ForbiddenException('태스크를 수정할 권한이 없습니다.');
    }

    const {
      descriptionMarkdown,
      checklist,
      relationships,
      wikiReferences,
      estimatedTimeMinutes,
      loggedTimeMinutes,
      ...basicFields
    } = updateTaskDetailDto;

    // 기본 필드 업데이트 (기존 update 메서드 로직 재사용)
    Object.assign(task, basicFields);

    // 새로운 상세 필드들 업데이트
    if (descriptionMarkdown !== undefined) {
      task.descriptionMarkdown = descriptionMarkdown;
    }

    if (checklist !== undefined) {
      // 체크리스트 아이템들의 ID가 없으면 생성
      task.checklist = checklist.map((item, index) => ({
        id: item.id || `checklist-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        text: item.text,
        completed: item.completed,
        order: item.order !== undefined ? item.order : index
      }));
    }

    if (relationships !== undefined) {
      // 관계들의 ID가 없으면 생성
      task.relationships = relationships.map(rel => ({
        id: rel.id || `rel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        targetTaskId: rel.targetTaskId,
        type: rel.type
      }));
    }

    if (wikiReferences !== undefined) {
      // 위키 레퍼런스들의 ID가 없으면 생성
      task.wikiReferences = wikiReferences.map(wiki => ({
        id: wiki.id || `wiki-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        title: wiki.title,
        url: wiki.url,
        description: wiki.description
      }));
    }

    if (estimatedTimeMinutes !== undefined) {
      task.estimatedTimeMinutes = estimatedTimeMinutes;
    }

    if (loggedTimeMinutes !== undefined) {
      task.loggedTimeMinutes = loggedTimeMinutes;
    }

    // 상태 관련 로직 (기존과 동일)
    if (updateTaskDetailDto.status !== undefined) {
      task.status = updateTaskDetailDto.status;
      if (updateTaskDetailDto.status === TaskStatus.COMPLETED && !task.completedAt) {
        task.completedAt = new Date();
      } else if (updateTaskDetailDto.status !== TaskStatus.COMPLETED) {
        task.completedAt = undefined;
      }
    }

    // 레이블 업데이트 (기존과 동일)
    if (updateTaskDetailDto.labelIds !== undefined) {
      const labels = await this.taskLabelRepository.findBy({
        id: In(updateTaskDetailDto.labelIds),
      });
      task.labels = labels;
    }

    const updatedTask = await this.taskRepository.save(task);
    const finalTask = await this.findOne(updatedTask.id, userId);

    return finalTask;
  }

  // 태스크 삭제
  async remove(id: string, userId: string): Promise<void> {
    const task = await this.findOne(id, userId);

    // 삭제 권한 확인 (생성자, 프로젝트 소유자만 삭제 가능)
    if (task.reporterId !== userId && task.project?.ownerId !== userId) {
      throw new ForbiddenException('태스크를 삭제할 권한이 없습니다.');
    }

    // 의존성이 있는 태스크는 삭제 불가
    if (task.dependents && task.dependents.length > 0) {
      throw new BadRequestException('다른 태스크가 의존하고 있는 태스크는 삭제할 수 없습니다.');
    }

    await this.taskRepository.remove(task);
  }

  // 태스크 상태 변경
  async updateStatus(id: string, status: TaskStatus, userId: string): Promise<Task> {
    return this.update(id, { status }, userId);
  }

  // 태스크 우선순위 변경
  async updatePriority(id: string, priority: Priority, userId: string): Promise<Task> {
    return this.update(id, { priority }, userId);
  }

  // 태스크 진행률 업데이트
  async updateProgress(id: string, progress: number, userId: string): Promise<Task> {
    return this.update(id, { progress }, userId);
  }

  // 내 태스크 조회 (GTD 방식)
  async getMyTasks(userId: string, context?: 'inbox' | 'next' | 'waiting' | 'someday'): Promise<Task[]> {
    const queryBuilder = this.taskRepository.createQueryBuilder('task')
      .leftJoinAndSelect('task.project', 'project')
      .leftJoinAndSelect('task.labels', 'labels')
      .where('task.assigneeId = :userId', { userId })
      .andWhere('task.status != :doneStatus', { doneStatus: 'done' });

    switch (context) {
      case 'inbox':
        // 아직 분류되지 않은 태스크들
        queryBuilder.andWhere('task.status = :todoStatus', { todoStatus: 'todo' })
          .andWhere('task.startDate IS NULL OR task.startDate <= :now', { now: new Date() });
        break;
      
      case 'next':
        // 다음에 처리할 액션 아이템들
        queryBuilder.andWhere('task.status IN (:...nextStatuses)', { 
          nextStatuses: ['todo', 'in_progress'] 
        })
          .andWhere('(task.startDate IS NULL OR task.startDate <= :now)', { now: new Date() })
          .andWhere('task.priority IN (:...priorities)', { priorities: ['high', 'medium'] });
        break;
      
      case 'waiting':
        // 다른 사람이나 외부 요인을 기다리는 태스크들
        queryBuilder.andWhere('task.status = :waitingStatus', { waitingStatus: 'blocked' });
        break;
      
      case 'someday':
        // 언젠가 할 일들 (낮은 우선순위)
        queryBuilder.andWhere('task.priority = :lowPriority', { lowPriority: 'low' })
          .andWhere('(task.dueDate IS NULL OR task.dueDate > :futureDate)', { 
            futureDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30일 후
          });
        break;
    }

    return queryBuilder
      .orderBy('task.priority', 'DESC')
      .addOrderBy('task.dueDate', 'ASC')
      .addOrderBy('task.createdAt', 'ASC')
      .getMany();
  }

  // GTD 스마트 필터 기반 태스크 조회
  async getSmartFilteredTasks(userId: string, filter: 'today' | 'completed' | 'all'): Promise<Task[]> {
    const queryBuilder = this.taskRepository.createQueryBuilder('task')
      .leftJoinAndSelect('task.project', 'project')
      .leftJoinAndSelect('task.assignee', 'assignee')
      .leftJoinAndSelect('task.reporter', 'reporter')
      .leftJoinAndSelect('task.labels', 'labels')
      .where(`(
        task.assigneeId = :userId OR 
        task.reporterId = :userId OR 
        project.ownerId = :userId OR
        EXISTS (
          SELECT 1 FROM project_members pm 
          WHERE pm.projectId = task.projectId AND pm.userId = :userId
        )
      )`, { userId });

    switch (filter) {
      case 'today':
        // 오늘 할 일: 오늘 마감이거나 연체된 미완료 태스크들
        const today = new Date();
        today.setHours(23, 59, 59, 999);
        const startOfToday = new Date();
        startOfToday.setHours(0, 0, 0, 0);
        
        queryBuilder.andWhere('task.status != :completedStatus', { completedStatus: 'done' })
          .andWhere(`(
            (task.dueDate IS NOT NULL AND task.dueDate <= :today) OR
            (task.dueDate IS NULL AND task.status = :inProgressStatus) OR
            (task.priority = :highPriority AND task.status = :todoStatus)
          )`, { 
            today, 
            inProgressStatus: 'in_progress',
            highPriority: 'high',
            todoStatus: 'todo'
          });
        break;
      
      case 'completed':
        // 완료된 태스크들
        queryBuilder.andWhere('task.status = :completedStatus', { completedStatus: 'done' })
          .orderBy('task.completedAt', 'DESC');
        break;
      
      case 'all':
        // 모든 태스크들 (기본 정렬)
        break;
    }

    // 기본 정렬: 우선순위 > 마감일 > 생성일
    if (filter !== 'completed') {
      queryBuilder
        .orderBy('task.priority', 'DESC')
        .addOrderBy('task.dueDate', 'ASC')
        .addOrderBy('task.createdAt', 'ASC');
    }

    return queryBuilder.getMany();
  }

  // 권한 확인 헬퍼 메서드
  private async checkTaskAccess(task: Task, userId: string): Promise<void> {
    const hasAccess = (
      task.assigneeId === userId ||
      task.reporterId === userId ||
      task.project?.ownerId === userId ||
      (task.project && task.projectId && await this.isProjectMember(task.projectId, userId))
    );

    if (!hasAccess) {
      throw new ForbiddenException('태스크에 접근할 권한이 없습니다.');
    }
  }

  // 프로젝트 멤버인지 확인
  private async isProjectMember(projectId: string, userId: string): Promise<boolean> {
    const project = await this.projectRepository.findOne({
      where: { id: projectId },
      relations: ['members'],
    });

    return project?.members.some(member => member.userId === userId) || false;
  }
}
</file>

<file path="backend/src/app.module.ts">
import { Module, MiddlewareConsumer } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ThrottlerModule } from '@nestjs/throttler';
import { APP_GUARD } from '@nestjs/core';

import { getDatabaseConfig } from './config/database.config';
import { AuthModule } from './modules/auth/auth.module';
import { UsersModule } from './modules/users/users.module';
import { ProjectsModule } from './modules/projects/projects.module';
import { TasksModule } from './modules/tasks/tasks.module';
import { WebSocketModule } from './modules/websocket/websocket.module';
import { AdminModule } from './modules/admin/admin.module';
import { AuthGuard } from './modules/auth/guards/auth.guard';
import { CustomThrottlerGuard } from './modules/auth/guards/throttle.guard';
import { AuthMiddleware } from './modules/auth/middleware/auth.middleware';
import { AuditMiddleware } from './modules/auth/middleware/audit.middleware';

@Module({
  imports: [
    // 환경 설정 모듈
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ['.env', '.env.local'],
    }),

    // Rate Limiting 모듈
    ThrottlerModule.forRoot({
      throttlers: [
        {
          name: 'short',
          ttl: 1000, // 1초
          limit: 10, // 10개 요청
        },
        {
          name: 'medium',
          ttl: 60000, // 1분
          limit: 100, // 100개 요청
        },
        {
          name: 'long',
          ttl: 3600000, // 1시간
          limit: 1000, // 1000개 요청
        },
      ],
    }),

    // 데이터베이스 모듈
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: getDatabaseConfig,
      inject: [ConfigService],
    }),

    // 기능 모듈들
    AuthModule,
    UsersModule,
    ProjectsModule,
    TasksModule,
    WebSocketModule,
    AdminModule,
  ],
  controllers: [],
  providers: [
    // 글로벌 가드 설정
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
    {
      provide: APP_GUARD,
      useClass: CustomThrottlerGuard,
    },
  ],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(AuthMiddleware, AuditMiddleware)
      .forRoutes('*'); // 모든 라우트에 적용
  }
}
</file>

<file path="frontend/src/app/auth/callback/page.tsx">
'use client';

export const dynamic = 'force-dynamic'

import React, { useEffect, useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { CheckCircle, XCircle, Loader2 } from 'lucide-react';
import { saveTokens, refreshUserProfile } from '@/lib/auth';

export default function AuthCallbackPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [message, setMessage] = useState<string>('');

  useEffect(() => {
    const handleCallback = async () => {
      try {
        // URL에서 토큰 또는 상태 정보 확인
        const accessToken = searchParams.get('accessToken');
        const refreshToken = searchParams.get('refreshToken');
        const error = searchParams.get('error');
        const callbackStatus = searchParams.get('status');

        if (error) {
          throw new Error(getErrorMessage(error));
        }

        if (accessToken && refreshToken) {
          // 토큰이 URL에 직접 포함된 경우
          saveTokens(
            decodeURIComponent(accessToken),
            decodeURIComponent(refreshToken)
          );
          
          // 사용자 정보 가져오기
          await refreshUserProfile();
          
          setStatus('success');
          setMessage('로그인이 완료되었습니다. 잠시 후 대시보드로 이동합니다.');
          
          // 3초 후 홈페이지로 이동
          setTimeout(() => {
            router.push('/');
          }, 3000);
          
        } else if (callbackStatus === 'success') {
          // OAuth 인증은 성공했지만 토큰이 URL에 없는 경우
          // 백엔드에서 추가 처리 필요
          setStatus('success');
          setMessage('인증이 완료되었습니다. 잠시 후 대시보드로 이동합니다.');
          
          setTimeout(() => {
            router.push('/');
          }, 3000);
          
        } else {
          throw new Error('인증 정보를 찾을 수 없습니다.');
        }
        
      } catch (error) {
        console.error('OAuth 콜백 처리 오류:', error);
        setStatus('error');
        setMessage(error instanceof Error ? error.message : '로그인 처리 중 오류가 발생했습니다.');
        
        // 5초 후 로그인 페이지로 이동
        setTimeout(() => {
          router.push('/auth/login?error=oauth_callback_failed');
        }, 5000);
      }
    };

    handleCallback();
  }, [router, searchParams]);

  const fetchUserInfo = async (accessToken: string) => {
    try {
      const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';
      
      const response = await fetch(`${backendUrl}/auth/profile`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
        },
      });

      if (response.ok) {
        const userData = await response.json();
        localStorage.setItem('user', JSON.stringify(userData.user));
      }
    } catch (error) {
      console.error('사용자 정보 조회 오류:', error);
      // 사용자 정보 조회 실패해도 로그인은 진행
    }
  };

  const getErrorMessage = (error: string): string => {
    switch (error) {
      case 'access_denied':
        return '로그인이 취소되었습니다.';
      case 'invalid_request':
        return '잘못된 요청입니다.';
      case 'server_error':
        return '서버 오류가 발생했습니다.';
      case 'temporarily_unavailable':
        return '일시적으로 사용할 수 없는 서비스입니다.';
      default:
        return '로그인 중 오류가 발생했습니다.';
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 flex items-center justify-center p-4">
      <div className="w-full max-w-md mx-auto">
        <div className="bg-white rounded-2xl shadow-xl p-8 text-center">
          {/* 상태별 아이콘 */}
          <div className="mb-6">
            {status === 'loading' && (
              <div className="inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full">
                <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
              </div>
            )}
            
            {status === 'success' && (
              <div className="inline-flex items-center justify-center w-16 h-16 bg-green-100 rounded-full">
                <CheckCircle className="w-8 h-8 text-green-600" />
              </div>
            )}
            
            {status === 'error' && (
              <div className="inline-flex items-center justify-center w-16 h-16 bg-red-100 rounded-full">
                <XCircle className="w-8 h-8 text-red-600" />
              </div>
            )}
          </div>

          {/* 상태별 제목 */}
          <h1 className="text-2xl font-bold mb-4">
            {status === 'loading' && '로그인 처리 중...'}
            {status === 'success' && '로그인 성공!'}
            {status === 'error' && '로그인 실패'}
          </h1>

          {/* 메시지 */}
          <p className={`text-sm mb-6 ${
            status === 'success' ? 'text-green-600' : 
            status === 'error' ? 'text-red-600' : 
            'text-gray-600'
          }`}>
            {message || (
              status === 'loading' ? '잠시만 기다려주세요...' :
              status === 'success' ? '로그인이 완료되었습니다.' :
              '로그인 중 오류가 발생했습니다.'
            )}
          </p>

          {/* 로딩 상태일 때만 프로그레스 바 표시 */}
          {status === 'loading' && (
            <div className="w-full bg-gray-200 rounded-full h-2 mb-4">
              <div className="bg-blue-600 h-2 rounded-full animate-pulse" style={{ width: '60%' }}></div>
            </div>
          )}

          {/* 에러 상태일 때 수동 이동 버튼 */}
          {status === 'error' && (
            <button
              onClick={() => router.push('/auth/login')}
              className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
            >
              로그인 페이지로 돌아가기
            </button>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/board/page.tsx">
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { X, FileText, Lightbulb, FolderOpen, ClipboardList, BookOpen, Presentation } from 'lucide-react'
import Header from '@/components/layout/Header'
import UnifiedFilter from '@/components/ui/UnifiedFilter'
import MainContainer from '@/components/layout/MainContainer'
import WorklyFloatingActionButton from '@/components/ui/WorklyFloatingActionButton'
import LoginBanner from '@/components/ui/LoginBanner'
import { Button } from '@/components/ui/Button'
import MissionBoard from '@/components/board/MissionBoard'
import KnowledgeWiki from '@/components/board/KnowledgeWiki'
import ProjectShowcase from '@/components/board/ProjectShowcase'

type BoardSection = '임무 게시판' | '지식 위키' | '프로젝트 쇼케이스'

// 게시글 작성 모달 컴포넌트
function PostCreationModal({ 
  isOpen, 
  onClose, 
  section 
}: { 
  isOpen: boolean
  onClose: () => void
  section: BoardSection
}) {
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    category: '',
    tags: ''
  })

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!formData.title.trim()) return

    console.log(`${section}에 새 게시글 작성:`, formData)
    alert(`"${formData.title}" 게시글이 ${section}에 성공적으로 등록되었습니다!`)
    
    // 폼 리셋
    setFormData({ title: '', description: '', category: '', tags: '' })
    onClose()
  }

  if (!isOpen) return null

  const getModalContent = () => {
    switch (section) {
      case '임무 게시판':
        return {
          icon: FileText,
          title: '새 임무 등록',
          description: '프리랜서나 팀원을 위한 새로운 임무를 등록하세요',
          categoryPlaceholder: '개발, 디자인, 마케팅 등',
          titlePlaceholder: '임무 제목을 입력하세요',
          descriptionPlaceholder: '임무에 대한 상세한 설명을 작성하세요'
        }
      case '지식 위키':
        return {
          icon: Lightbulb,
          title: '새 지식 문서 작성',
          description: '팀과 공유할 유용한 지식이나 문서를 작성하세요',
          categoryPlaceholder: 'Frontend, Backend, DevOps 등',
          titlePlaceholder: '문서 제목을 입력하세요',
          descriptionPlaceholder: '지식 내용을 상세히 작성하세요'
        }
      case '프로젝트 쇼케이스':
        return {
          icon: FolderOpen,
          title: '새 프로젝트 쇼케이스',
          description: '완성한 프로젝트를 다른 사람들과 공유하세요',
          categoryPlaceholder: '웹 개발, 모바일 앱, 이커머스 등',
          titlePlaceholder: '프로젝트 제목을 입력하세요',
          descriptionPlaceholder: '프로젝트 설명과 주요 기능을 작성하세요'
        }
      default:
        return {
          icon: FileText,
          title: '새 게시글',
          description: '새로운 게시글을 작성하세요',
          categoryPlaceholder: '카테고리',
          titlePlaceholder: '제목을 입력하세요',
          descriptionPlaceholder: '내용을 작성하세요'
        }
    }
  }

  const content = getModalContent()
  const Icon = content.icon

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="fixed inset-0 bg-black opacity-25" onClick={onClose} />
        <div className="relative bg-white rounded-lg shadow-xl max-w-lg w-full">
          {/* 헤더 */}
          <div className="flex items-center justify-between p-6 border-b border-gray-200">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
                <Icon className="w-5 h-5 text-blue-600" />
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-900">{content.title}</h3>
                <p className="text-sm text-gray-500">{content.description}</p>
              </div>
            </div>
            <button
              onClick={onClose}
              className="w-8 h-8 flex items-center justify-center rounded-lg hover:bg-gray-100"
            >
              <X className="w-5 h-5 text-gray-400" />
            </button>
          </div>
          
          {/* 폼 */}
          <form onSubmit={handleSubmit} className="p-6 space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                제목 *
              </label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                placeholder={content.titlePlaceholder}
                required
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                카테고리
              </label>
              <input
                type="text"
                value={formData.category}
                onChange={(e) => setFormData(prev => ({ ...prev, category: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                placeholder={content.categoryPlaceholder}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                설명 *
              </label>
              <textarea
                value={formData.description}
                onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                placeholder={content.descriptionPlaceholder}
                rows={4}
                required
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                태그 (선택사항)
              </label>
              <input
                type="text"
                value={formData.tags}
                onChange={(e) => setFormData(prev => ({ ...prev, tags: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                placeholder="태그를 쉼표로 구분하여 입력하세요"
              />
            </div>
            
            {/* 버튼 */}
            <div className="flex gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                className="flex-1"
              >
                취소
              </Button>
              <Button
                type="submit"
                variant="default"
                className="flex-1"
                disabled={!formData.title.trim() || !formData.description.trim()}
              >
                등록하기
              </Button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}

export default function BoardPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [activeSection, setActiveSection] = useState<BoardSection>('임무 게시판')
  const [searchQuery, setSearchQuery] = useState('')
  const [isPostModalOpen, setIsPostModalOpen] = useState(false)
  
  // 필터 설정 상태
  const [showOnlyRecent, setShowOnlyRecent] = useState(false)
  const [boardSortOrder, setBoardSortOrder] = useState('latest')
  const [showOnlyMyPosts, setShowOnlyMyPosts] = useState(false)

  // 섹션 옵션 (아이콘 및 색상 추가)
  const sectionOptions = [
    { 
      key: '임무 게시판', 
      label: '임무 게시판', 
      count: 8,
      icon: <ClipboardList className="w-4 h-4" />,
      color: 'blue' as const
    },
    { 
      key: '지식 위키', 
      label: '지식 위키', 
      count: 24,
      icon: <BookOpen className="w-4 h-4" />,
      color: 'green' as const
    },
    { 
      key: '프로젝트 쇼케이스', 
      label: '프로젝트 쇼케이스', 
      count: 12,
      icon: <Presentation className="w-4 h-4" />,
      color: 'purple' as const
    },
  ]

  const handleSectionChange = (section: string) => {
    setActiveSection(section as BoardSection)
  }

  const handlePostCreation = () => {
    setIsPostModalOpen(true)
  }

  // 쿼리 파라미터로 전달된 액션 및 섹션 처리
  useEffect(() => {
    const action = searchParams.get('action')
    const section = searchParams.get('section')
    
    // 섹션 매개변수가 있으면 해당 섹션으로 전환
    if (section && ['임무 게시판', '지식 위키', '프로젝트 쇼케이스'].includes(section)) {
      setActiveSection(section as BoardSection)
    }
    
    // 게시글 작성 액션 처리
    if (action === 'add-post') {
      setIsPostModalOpen(true)
      // URL에서 action 쿼리 파라미터만 제거 (section은 유지)
      const newUrl = new URL(window.location.href)
      newUrl.searchParams.delete('action')
      router.replace(newUrl.pathname + newUrl.search)
    }
  }, [searchParams, router])

  const renderActiveSection = () => {
    switch (activeSection) {
      case '임무 게시판':
        return <MissionBoard searchQuery={searchQuery} />
      case '지식 위키':
        return <KnowledgeWiki searchQuery={searchQuery} />
      case '프로젝트 쇼케이스':
        return <ProjectShowcase searchQuery={searchQuery} />
      default:
        return <MissionBoard searchQuery={searchQuery} />
    }
  }

  return (
    <div className="min-h-screen">
      {/* 헤더 */}
      <Header 
        title={activeSection}
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
      />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 필터 칩 */}
        <div className="mb-0">
          <UnifiedFilter
            options={sectionOptions}
            activeFilter={activeSection}
            onFilterChange={handleSectionChange}
            variant="comfortable"
            style="modern"
            maxVisibleItems={3}
            settingsTitle="게시판 필터 설정"
            settings={[
              {
                key: 'recent',
                label: '최근 7일 게시글만',
                type: 'toggle',
                value: showOnlyRecent,
                onChange: setShowOnlyRecent
              },
              {
                key: 'sort',
                label: '정렬 기준',
                type: 'select',
                value: boardSortOrder,
                options: ['latest', 'popular', 'comments', 'views'],
                onChange: setBoardSortOrder
              },
              {
                key: 'myPosts',
                label: '내가 작성한 게시글만',
                type: 'toggle',
                value: showOnlyMyPosts,
                onChange: setShowOnlyMyPosts
              },
              // 섹션별 특화 설정
              ...(activeSection === '임무 게시판' ? [
                {
                  key: 'budget',
                  label: '예산 범위',
                  type: 'range',
                  value: [0, 500],
                  onChange: (value: [number, number]) => console.log('예산 필터:', value)
                },
                {
                  key: 'skills',
                  label: '필요 기술',
                  type: 'tag-selector',
                  value: [],
                  options: ['React', 'Node.js', 'Python', 'Design', 'Marketing'],
                  onChange: (value: string[]) => console.log('기술 필터:', value)
                },
                {
                  key: 'paymentType',
                  label: '결제 방식',
                  type: 'select',
                  value: 'all',
                  options: ['all', 'fixed', 'hourly'],
                  onChange: (value: string) => console.log('결제 방식:', value)
                }
              ] : []),
              ...(activeSection === '지식 위키' ? [
                {
                  key: 'difficulty',
                  label: '난이도',
                  type: 'select',
                  value: 'all',
                  options: ['all', 'beginner', 'intermediate', 'advanced'],
                  onChange: (value: string) => console.log('난이도 필터:', value)
                },
                {
                  key: 'category',
                  label: '카테고리',
                  type: 'tag-selector',
                  value: [],
                  options: ['Frontend', 'Backend', 'DevOps', 'Design', 'Product'],
                  onChange: (value: string[]) => console.log('카테고리 필터:', value)
                },
                {
                  key: 'docType',
                  label: '문서 타입',
                  type: 'select',
                  value: 'all',
                  options: ['all', 'tutorial', 'guide', 'reference', 'template'],
                  onChange: (value: string) => console.log('문서 타입:', value)
                }
              ] : []),
              ...(activeSection === '프로젝트 쇼케이스' ? [
                {
                  key: 'projectType',
                  label: '프로젝트 종류',
                  type: 'tag-selector',
                  value: [],
                  options: ['웹', '모바일', '데이터', '디자인', 'AI/ML'],
                  onChange: (value: string[]) => console.log('프로젝트 종류:', value)
                },
                {
                  key: 'teamSize',
                  label: '팀 구성',
                  type: 'select',
                  value: 'all',
                  options: ['all', 'individual', 'small', 'large'],
                  onChange: (value: string) => console.log('팀 구성:', value)
                },
                {
                  key: 'completeness',
                  label: '완성도',
                  type: 'select',
                  value: 'all',
                  options: ['all', 'prototype', 'mvp', 'complete'],
                  onChange: (value: string) => console.log('완성도:', value)
                }
              ] : [])
            ] as any}
          />
        </div>
        {renderActiveSection()}
      </MainContainer>
      
      {/* 플로팅 액션 버튼 */}
      <WorklyFloatingActionButton 
        onAddTask={() => console.log('업무 추가')}
        onAddProject={() => console.log('프로젝트 추가')}
        onAddGoal={() => console.log('목표 추가')}
      />

      {/* 게시글 작성 모달 */}
      <PostCreationModal
        isOpen={isPostModalOpen}
        onClose={() => setIsPostModalOpen(false)}
        section={activeSection}
      />
    </div>
  )
}
</file>

<file path="frontend/src/app/search/page.tsx">
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { MagnifyingGlassIcon, ArrowLeftIcon, ClockIcon } from '@heroicons/react/24/outline'
import { 
  CheckCircleIcon as TaskIcon, 
  FolderIcon as ProjectIcon, 
  DocumentTextIcon as PostIcon,
  UserIcon
} from '@heroicons/react/24/solid'

interface SearchResult {
  id: string
  type: 'task' | 'project' | 'post' | 'user'
  title: string
  description?: string
  url: string
  category?: string
  timestamp?: string
  status?: string
}

// 목업 검색 결과 데이터
const mockSearchResults: SearchResult[] = [
  {
    id: '1',
    type: 'task',
    title: '프로젝트 기획서 작성',
    description: '새로운 프로젝트의 기획서를 작성하고 팀과 공유',
    url: '/tasks/1',
    category: '업무',
    timestamp: '6시간 후 마감',
    status: '진행중'
  },
  {
    id: '2',
    type: 'project',
    title: '워클리 MVP 개발',
    description: '비즈니스 성공을 위한 웹 애플리케이션 MVP 버전 개발',
    url: '/projects/1',
    category: '프로젝트',
    status: '활성'
  },
  {
    id: '3',
    type: 'task',
    title: 'API 문서 검토',
    description: '백엔드 API 문서를 검토하고 피드백 제공',
    url: '/tasks/3',
    category: '업무',
    status: '완료'
  },
  {
    id: '4',
    type: 'project',
    title: 'AI 챗봇 개발',
    description: '고객 지원을 위한 AI 기반 챗봇 시스템 구축',
    url: '/projects/2',
    category: '프로젝트',
    status: '활성'
  },
  {
    id: '5',
    type: 'post',
    title: '워클리 런칭 공지',
    description: '워클리 플랫폼이 드디어 베타 버전으로 출시되었습니다!',
    url: '/board/5',
    category: '공지사항',
    timestamp: '2일 전'
  }
]

// 최근 검색어 (로컬스토리지에서 관리)
const getRecentSearches = (): string[] => {
  if (typeof window === 'undefined') return []
  const saved = localStorage.getItem('workly-recent-searches')
  return saved ? JSON.parse(saved) : []
}

const saveRecentSearch = (query: string) => {
  if (typeof window === 'undefined' || !query.trim()) return
  
  const current = getRecentSearches()
  const updated = [query, ...current.filter(item => item !== query)].slice(0, 5)
  localStorage.setItem('workly-recent-searches', JSON.stringify(updated))
}

function SearchResultItem({ result }: { result: SearchResult }) {
  const router = useRouter()
  
  const getIcon = () => {
    switch (result.type) {
      case 'task':
        return <TaskIcon className="w-5 h-5 text-blue-600" />
      case 'project':
        return <ProjectIcon className="w-5 h-5 text-green-600" />
      case 'post':
        return <PostIcon className="w-5 h-5 text-purple-600" />
      case 'user':
        return <UserIcon className="w-5 h-5 text-blue-600" />
      default:
        return <MagnifyingGlassIcon className="w-5 h-5 text-gray-400" />
    }
  }

  const getStatusColor = () => {
    switch (result.status) {
      case '완료':
        return 'bg-green-100 text-green-800'
      case '진행중':
        return 'bg-blue-100 text-blue-800'
      case '활성':
        return 'bg-green-100 text-green-800'
      default:
        return 'bg-gray-100 text-gray-800'
    }
  }

  return (
    <div 
      className="p-4 hover:bg-gray-50 cursor-pointer border-b border-gray-100 last:border-b-0"
      onClick={() => router.push(result.url)}
    >
      <div className="flex items-start space-x-3">
        <div className="flex-shrink-0 mt-0.5">
          {getIcon()}
        </div>
        <div className="flex-1 min-w-0">
          <div className="flex items-center space-x-2 mb-1">
            <h3 className="text-sm font-medium text-gray-900 truncate">
              {result.title}
            </h3>
            <span className="text-xs text-gray-500">{result.category}</span>
            {result.status && (
              <span className={`text-xs px-2 py-1 rounded-full font-medium ${getStatusColor()}`}>
                {result.status}
              </span>
            )}
          </div>
          {result.description && (
            <p className="text-sm text-gray-600 line-clamp-2 mb-2">
              {result.description}
            </p>
          )}
          {result.timestamp && (
            <div className="flex items-center space-x-1 text-xs text-gray-500">
              <ClockIcon className="w-3 h-3" />
              <span>{result.timestamp}</span>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

export default function SearchPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [recentSearches, setRecentSearches] = useState<string[]>([])

  useEffect(() => {
    // URL 파라미터에서 검색어 가져오기
    const q = searchParams.get('q')
    if (q) {
      setQuery(q)
      performSearch(q)
    }
    
    // 최근 검색어 로드
    setRecentSearches(getRecentSearches())
  }, [searchParams])

  const performSearch = async (searchQuery: string) => {
    if (!searchQuery.trim()) {
      setResults([])
      return
    }

    setIsLoading(true)
    
    // 실제로는 API 호출
    // const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`)
    // const data = await response.json()
    
    // 목업 검색 시뮬레이션
    await new Promise(resolve => setTimeout(resolve, 500))
    
    // 간단한 필터링 로직
    const filtered = mockSearchResults.filter(item =>
      item.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      item.description?.toLowerCase().includes(searchQuery.toLowerCase())
    )
    
    setResults(filtered)
    setIsLoading(false)
    
    // 최근 검색어에 추가
    saveRecentSearch(searchQuery)
    setRecentSearches(getRecentSearches())
  }

  const handleSearch = (searchQuery: string) => {
    setQuery(searchQuery)
    performSearch(searchQuery)
    
    // URL 업데이트
    const params = new URLSearchParams()
    if (searchQuery.trim()) {
      params.set('q', searchQuery)
    }
    router.replace(`/search?${params.toString()}`)
  }

  const handleRecentSearchClick = (recentQuery: string) => {
    handleSearch(recentQuery)
  }

  const clearRecentSearches = () => {
    localStorage.removeItem('workly-recent-searches')
    setRecentSearches([])
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 모바일 헤더 */}
      <div className="bg-white border-b border-gray-200 px-4 py-3">
        <div className="flex items-center space-x-3">
          <button
            onClick={() => router.back()}
            className="flex items-center justify-center w-8 h-8 text-gray-500 hover:text-gray-700"
          >
            <ArrowLeftIcon className="w-5 h-5" />
          </button>
          
          <div className="flex-1 relative">
            <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleSearch(query)}
              placeholder="업무, 프로젝트, 게시글 검색..."
              className="w-full pl-10 pr-4 py-2 text-sm bg-gray-50 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              autoFocus
            />
          </div>
          
          <button
            onClick={() => handleSearch(query)}
            className="px-4 py-2 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700"
          >
            검색
          </button>
        </div>
      </div>

      {/* 메인 콘텐츠 */}
      <div className="w-full max-w-[720px] mx-auto">
        {!query.trim() && recentSearches.length > 0 && (
          <div className="bg-white border-b border-gray-200 p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-sm font-medium text-gray-900">최근 검색어</h3>
              <button
                onClick={clearRecentSearches}
                className="text-xs text-gray-500 hover:text-gray-700"
              >
                전체 삭제
              </button>
            </div>
            <div className="flex flex-wrap gap-2">
              {recentSearches.map((recent, index) => (
                <button
                  key={index}
                  onClick={() => handleRecentSearchClick(recent)}
                  className="inline-flex items-center px-3 py-1 text-sm bg-gray-100 text-gray-700 rounded-full hover:bg-gray-200"
                >
                  <ClockIcon className="w-3 h-3 mr-1" />
                  {recent}
                </button>
              ))}
            </div>
          </div>
        )}

        {!query.trim() && (
          <div className="bg-white p-8 text-center">
            <MagnifyingGlassIcon className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-gray-900 mb-2">통합검색</h3>
            <p className="text-gray-500 mb-4">
              업무, 프로젝트, 게시글을 한 번에 검색하세요
            </p>
            <div className="space-y-2 text-sm text-gray-600">
              <div className="flex items-center justify-center space-x-2">
                <TaskIcon className="w-4 h-4 text-blue-600" />
                <span>업무</span>
                <ProjectIcon className="w-4 h-4 text-green-600 ml-4" />
                <span>프로젝트</span>
                <PostIcon className="w-4 h-4 text-purple-600 ml-4" />
                <span>게시글</span>
              </div>
            </div>
          </div>
        )}

        {isLoading && (
          <div className="bg-white p-8 text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-500">검색 중...</p>
          </div>
        )}

        {query.trim() && !isLoading && results.length === 0 && (
          <div className="bg-white p-8 text-center">
            <MagnifyingGlassIcon className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-gray-900 mb-2">검색 결과 없음</h3>
            <p className="text-gray-500">
              '{query}'에 대한 검색 결과가 없습니다.
            </p>
          </div>
        )}

        {results.length > 0 && (
          <div className="bg-white">
            <div className="p-4 border-b border-gray-200">
              <h3 className="text-sm font-medium text-gray-900">
                '{query}' 검색 결과 {results.length}개
              </h3>
            </div>
            <div className="divide-y divide-gray-100">
              {results.map((result) => (
                <SearchResultItem key={result.id} result={result} />
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import ConditionalLayout from '@/components/layout/ConditionalLayout'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: '워클리 - 업무 관리 플랫폼',
  description: '효율적인 업무 관리와 팀 협업을 위한 올인원 플랫폼',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ko">
      <body className={inter.className} suppressHydrationWarning={true}>
        <ConditionalLayout>
          {children}
        </ConditionalLayout>
      </body>
    </html>
  )
}
</file>

<file path="frontend/src/components/layout/ConditionalLayout.tsx">
'use client'

import { usePathname } from 'next/navigation'
import LeftNavigation from '@/components/navigation/LeftNavigation'
import MobileNavigation from '@/components/navigation/MobileNavigation'

interface ConditionalLayoutProps {
  children: React.ReactNode
}

export default function ConditionalLayout({ children }: ConditionalLayoutProps) {
  const pathname = usePathname()
  
  // 인증 관련 페이지에서는 네비게이션을 숨김
  const isAuthPage = pathname?.startsWith('/auth')
  
  // 프로젝트 상세 페이지에서는 네비게이션을 숨김
  const isProjectDetailPage = pathname?.match(/^\/projects\/[^\/]+$/)
  
  if (isAuthPage) {
    return (
      <div className="min-h-screen bg-background">
        {children}
      </div>
    )
  }
  
  return (
    <div className="min-h-screen bg-background">
      {/* 데스크톱 좌측 네비게이션 */}
      {!isProjectDetailPage && <LeftNavigation />}
      
      {/* 메인 콘텐츠 */}
      <div className="md:ml-[76px]">
        {children}
      </div>
      
      {/* 모바일 하단 네비게이션 */}
      {!isProjectDetailPage && <MobileNavigation />}
    </div>
  )
}
</file>

<file path="frontend/src/components/tasks/TaskCreationWizard.tsx">
'use client'

import React, { useState } from 'react'
import { 
  TaskWizardStep, 
  TaskWizardData, 
  TaskPriority, 
  CreateTaskDto
} from '@/types/task.types'
import { X, ArrowLeft, ArrowRight, CheckCircle, Clock, Users } from 'lucide-react'

interface TaskCreationWizardProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (taskData: CreateTaskDto) => void
  projects?: Array<{ id: string; name: string }>
}

export default function TaskCreationWizard({
  isOpen,
  onClose,
  onSubmit,
  projects = []
}: TaskCreationWizardProps) {
  const [wizardData, setWizardData] = useState<TaskWizardData>({
    step: 'collect',
    title: '',
    isActionable: undefined,
    canComplete2Minutes: undefined,
    belongsToProject: undefined,
    projectId: undefined,
    priority: undefined,
    dueDate: undefined,
    estimatedHours: undefined,
    assigneeId: undefined
  })

  const steps: { key: TaskWizardStep; title: string; subtitle: string }[] = [
    { key: 'collect', title: '수집', subtitle: '무엇이 마음에 걸리나요?' },
    { key: 'clarify', title: '명료화', subtitle: '실행 가능한 일인가요?' },
    { key: 'organize', title: '정리', subtitle: '세부 정보를 정리해보세요' },
    { key: 'execute', title: '실행', subtitle: '실행 준비가 완료됩니다' }
  ]

  const currentStepIndex = steps.findIndex(s => s.key === wizardData.step)
  const currentStep = steps[currentStepIndex]

  const updateWizardData = (updates: Partial<TaskWizardData>) => {
    setWizardData(prev => ({ ...prev, ...updates }))
  }

  const goToNextStep = () => {
    const nextIndex = currentStepIndex + 1
    if (nextIndex < steps.length) {
      updateWizardData({ step: steps[nextIndex].key })
    }
  }

  const goToPrevStep = () => {
    const prevIndex = currentStepIndex - 1
    if (prevIndex >= 0) {
      updateWizardData({ step: steps[prevIndex].key })
    }
  }

  const canProceedFromCurrentStep = () => {
    switch (wizardData.step) {
      case 'collect':
        return wizardData.title.trim().length > 0
      case 'clarify':
        return wizardData.isActionable !== undefined
      case 'organize':
        return true // 모든 필드 선택사항
      case 'execute':
        return true
      default:
        return false
    }
  }

  const handleSubmit = () => {
    if (wizardData.step === 'execute') {
      const taskData: CreateTaskDto = {
        title: wizardData.title,
        projectId: wizardData.projectId,
        priority: wizardData.priority || TaskPriority.MEDIUM,
        dueDate: wizardData.dueDate,
        estimatedHours: wizardData.estimatedHours,
        assigneeId: wizardData.assigneeId,
        tags: []
      }
      
      onSubmit(taskData)
      handleClose()
    }
  }

  const handleClose = () => {
    setWizardData({
      step: 'collect',
      title: '',
      isActionable: undefined,
      canComplete2Minutes: undefined,
      belongsToProject: undefined,
      projectId: undefined,
      priority: undefined,
      dueDate: undefined,
      estimatedHours: undefined,
      assigneeId: undefined
    })
    onClose()
  }

  // 2분 규칙 즉시 처리
  const handle2MinuteRule = () => {
    const quickTask: CreateTaskDto = {
      title: wizardData.title,
      priority: TaskPriority.LOW,
      estimatedHours: 0.1,
      tags: ['2분규칙']
    }
    onSubmit(quickTask)
    handleClose()
  }

  if (!isOpen) return null

  const renderStepIndicator = () => (
    <div className="flex items-center justify-between mb-6">
      {steps.map((step, index) => (
        <div key={step.key} className="flex items-center">
          <div 
            className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
              index <= currentStepIndex
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 text-gray-500'
            }`}
          >
            {index < currentStepIndex ? (
              <CheckCircle className="w-5 h-5" />
            ) : (
              index + 1
            )}
          </div>
          {index < steps.length - 1 && (
            <div 
              className={`w-16 h-1 mx-2 ${
                index < currentStepIndex ? 'bg-blue-600' : 'bg-gray-200'
              }`}
            />
          )}
        </div>
      ))}
    </div>
  )

  const renderCollectStep = () => (
    <div className="space-y-6">
      <div className="text-center">
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          무엇이 마음에 걸리나요?
        </h3>
        <p className="text-gray-600 text-sm">
          머릿속에 있는 것을 자유롭게 적어보세요. 나중에 정리할 수 있습니다.
        </p>
      </div>
      
      <div>
        <textarea
          value={wizardData.title}
          onChange={(e) => updateWizardData({ title: e.target.value })}
          placeholder="예: 프로젝트 회의 준비하기, 엄마께 안부 전화드리기..."
          className="w-full h-32 p-4 border border-gray-200 rounded-lg 
                   focus:ring-2 focus:ring-blue-500 focus:border-transparent
                   resize-none text-gray-900 placeholder-gray-500"
          autoFocus
        />
        <div className="text-right text-sm text-gray-500 mt-2">
          {wizardData.title.length}/200
        </div>
      </div>
    </div>
  )

  const renderClarifyStep = () => (
    <div className="space-y-6">
      <div className="text-center">
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          "{wizardData.title}"
        </h3>
        <p className="text-gray-600 text-sm">
          이것이 실행 가능한 일인지 판단해보세요
        </p>
      </div>

      {/* 실행 가능성 판단 */}
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-3">
            실행 가능한 일인가요?
          </label>
          <div className="flex gap-3">
            <button
              onClick={() => updateWizardData({ isActionable: true })}
              className={`flex-1 p-4 rounded-lg border-2 transition-colors ${
                wizardData.isActionable === true
                  ? 'border-green-500 bg-green-50 text-green-700'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
            >
              <CheckCircle className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">예</div>
              <div className="text-xs text-gray-600">지금 행동할 수 있어요</div>
            </button>
            <button
              onClick={() => updateWizardData({ isActionable: false })}
              className={`flex-1 p-4 rounded-lg border-2 transition-colors ${
                wizardData.isActionable === false
                  ? 'border-yellow-500 bg-yellow-50 text-yellow-700'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
            >
              <Clock className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">아니오</div>
              <div className="text-xs text-gray-600">참고용이거나 언젠가 할 일</div>
            </button>
          </div>
        </div>

        {/* 2분 규칙 */}
        {wizardData.isActionable === true && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-3">
              2분 안에 끝낼 수 있나요?
            </label>
            <div className="flex gap-3">
              <button
                onClick={handle2MinuteRule}
                className="flex-1 p-4 rounded-lg border-2 border-green-500 bg-green-50 text-green-700 hover:bg-green-100"
              >
                <div className="font-medium">예, 지금 바로!</div>
                <div className="text-xs">2분 규칙: 즉시 처리</div>
              </button>
              <button
                onClick={() => updateWizardData({ canComplete2Minutes: false })}
                className={`flex-1 p-4 rounded-lg border-2 transition-colors ${
                  wizardData.canComplete2Minutes === false
                    ? 'border-blue-500 bg-blue-50 text-blue-700'
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <div className="font-medium">아니오</div>
                <div className="text-xs">더 시간이 필요해요</div>
              </button>
            </div>
          </div>
        )}

        {/* 프로젝트 연결 */}
        {wizardData.isActionable === true && wizardData.canComplete2Minutes === false && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-3">
              더 큰 목표의 일부인가요?
            </label>
            <div className="flex gap-3">
              <button
                onClick={() => updateWizardData({ belongsToProject: true })}
                className={`flex-1 p-4 rounded-lg border-2 transition-colors ${
                  wizardData.belongsToProject === true
                    ? 'border-purple-500 bg-purple-50 text-purple-700'
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <Users className="w-6 h-6 mx-auto mb-2" />
                <div className="font-medium">예</div>
                <div className="text-xs">프로젝트의 일부</div>
              </button>
              <button
                onClick={() => updateWizardData({ belongsToProject: false })}
                className={`flex-1 p-4 rounded-lg border-2 transition-colors ${
                  wizardData.belongsToProject === false
                    ? 'border-blue-500 bg-blue-50 text-blue-700'
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                <div className="font-medium">아니오</div>
                <div className="text-xs">개별 업무</div>
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  )

  const renderOrganizeStep = () => (
    <div className="space-y-6">
      <div className="text-center">
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          세부 정보 정리
        </h3>
        <p className="text-gray-600 text-sm">
          업무를 효과적으로 실행하기 위한 정보를 추가하세요
        </p>
      </div>

      <div className="space-y-4">
        {/* 프로젝트 선택 */}
        {wizardData.belongsToProject === true && projects.length > 0 && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              프로젝트
            </label>
            <select
              value={wizardData.projectId || ''}
              onChange={(e) => updateWizardData({ projectId: e.target.value || undefined })}
              className="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
              <option value="">프로젝트 선택</option>
              {projects.map(project => (
                <option key={project.id} value={project.id}>
                  {project.name}
                </option>
              ))}
            </select>
          </div>
        )}

        {/* 우선순위 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            우선순위
          </label>
          <div className="grid grid-cols-2 gap-2">
            {Object.entries({
              [TaskPriority.LOW]: { label: '낮음', color: 'blue' },
              [TaskPriority.MEDIUM]: { label: '보통', color: 'yellow' },
              [TaskPriority.HIGH]: { label: '높음', color: 'orange' },
              [TaskPriority.URGENT]: { label: '긴급', color: 'red' }
            }).map(([priority, config]) => (
              <button
                key={priority}
                onClick={() => updateWizardData({ priority: priority as TaskPriority })}
                className={`p-3 rounded-lg border-2 transition-colors ${
                  wizardData.priority === priority
                    ? 'border-blue-500 bg-blue-50 text-blue-700'
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                {config.label}
              </button>
            ))}
          </div>
        </div>

        {/* 마감일 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            마감일 (선택사항)
          </label>
          <input
            type="datetime-local"
            value={wizardData.dueDate || ''}
            onChange={(e) => updateWizardData({ dueDate: e.target.value || undefined })}
            className="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
        </div>

        {/* 예상 시간 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            예상 소요 시간 (선택사항)
          </label>
          <div className="grid grid-cols-4 gap-2">
            {[0.5, 1, 2, 4, 8].map(hours => (
              <button
                key={hours}
                onClick={() => updateWizardData({ estimatedHours: hours })}
                className={`p-2 rounded-lg border transition-colors text-sm ${
                  wizardData.estimatedHours === hours
                    ? 'border-blue-500 bg-blue-50 text-blue-700'
                    : 'border-gray-200 hover:border-gray-300'
                }`}
              >
                {hours}시간
              </button>
            ))}
          </div>
          <input
            type="number"
            step="0.5"
            min="0"
            max="100"
            placeholder="직접 입력"
            value={wizardData.estimatedHours || ''}
            onChange={(e) => updateWizardData({ 
              estimatedHours: e.target.value ? parseFloat(e.target.value) : undefined 
            })}
            className="w-full mt-2 p-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
          />
        </div>
      </div>
    </div>
  )

  const renderExecuteStep = () => (
    <div className="space-y-6">
      <div className="text-center">
        <CheckCircle className="w-16 h-16 text-green-500 mx-auto mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          실행 준비 완료!
        </h3>
        <p className="text-gray-600 text-sm">
          이제 '오늘' 목록에 나타나 실행할 수 있습니다
        </p>
      </div>

      {/* 최종 검토 */}
      <div className="bg-gray-50 rounded-lg p-4 space-y-3">
        <div className="flex justify-between">
          <span className="text-sm text-gray-600">업무</span>
          <span className="text-sm font-medium">{wizardData.title}</span>
        </div>
        {wizardData.projectId && (
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">프로젝트</span>
            <span className="text-sm font-medium">
              {projects.find(p => p.id === wizardData.projectId)?.name}
            </span>
          </div>
        )}
        {wizardData.priority && (
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">우선순위</span>
            <span className="text-sm font-medium">{wizardData.priority}</span>
          </div>
        )}
        {wizardData.dueDate && (
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">마감일</span>
            <span className="text-sm font-medium">
              {new Date(wizardData.dueDate).toLocaleDateString('ko-KR')}
            </span>
          </div>
        )}
        {wizardData.estimatedHours && (
          <div className="flex justify-between">
            <span className="text-sm text-gray-600">예상 시간</span>
            <span className="text-sm font-medium">{wizardData.estimatedHours}시간</span>
          </div>
        )}
      </div>
    </div>
  )

  const renderCurrentStep = () => {
    switch (wizardData.step) {
      case 'collect': return renderCollectStep()
      case 'clarify': return renderClarifyStep()
      case 'organize': return renderOrganizeStep()
      case 'execute': return renderExecuteStep()
      default: return null
    }
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto scrollbar-on-hover">
        {/* 헤더 */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200">
          <div>
            <h2 className="text-xl font-semibold text-gray-900">
              {currentStep.title}
            </h2>
            <p className="text-sm text-gray-600 mt-1">
              {currentStep.subtitle}
            </p>
          </div>
          <button
            onClick={handleClose}
            className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* 진행 표시 */}
        <div className="p-6 border-b border-gray-100">
          {renderStepIndicator()}
        </div>

        {/* 단계별 콘텐츠 */}
        <div className="p-6">
          {renderCurrentStep()}
        </div>

        {/* 하단 버튼 */}
        <div className="flex items-center justify-between p-6 border-t border-gray-200">
          <button
            onClick={currentStepIndex > 0 ? goToPrevStep : handleClose}
            className="flex items-center gap-2 px-4 py-2 text-gray-600 hover:text-gray-900 transition-colors"
          >
            <ArrowLeft className="w-4 h-4" />
            {currentStepIndex > 0 ? '이전' : '취소'}
          </button>

          <div className="flex gap-3">
            {wizardData.step === 'execute' ? (
              <button
                onClick={handleSubmit}
                className="flex items-center gap-2 px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
              >
                <CheckCircle className="w-4 h-4" />
                업무 생성
              </button>
            ) : (
              <button
                onClick={goToNextStep}
                disabled={!canProceedFromCurrentStep()}
                className={`flex items-center gap-2 px-6 py-2 rounded-lg transition-colors ${
                  canProceedFromCurrentStep()
                    ? 'bg-blue-600 text-white hover:bg-blue-700'
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                }`}
              >
                다음
                <ArrowRight className="w-4 h-4" />
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/types/project.types.ts">
/**
 * Project 관련 타입 정의
 */

// 프로젝트 상태
export enum ProjectStatus {
  PLANNING = 'planning',
  ACTIVE = 'active',
  ON_HOLD = 'on_hold',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled',
  ARCHIVED = 'archived',
}

// 프로젝트 우선순위
export enum ProjectPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}

// 프로젝트 가시성
export enum ProjectVisibility {
  PRIVATE = 'private',
  TEAM = 'team',
  PUBLIC = 'public',
}

// 프로젝트 멤버 역할
export enum ProjectMemberRole {
  OWNER = 'owner',
  ADMIN = 'admin',
  MEMBER = 'member',
  VIEWER = 'viewer',
}

// 기본 사용자 정보
export interface ProjectUser {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  profile?: {
    firstName: string;
    lastName: string;
  };
}

// 프로젝트 목표
export interface ProjectObjective {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  completedAt?: string;
}

// 프로젝트 핵심 결과
export interface ProjectKeyResult {
  id: string;
  objectiveId: string;
  title: string;
  description?: string;
  targetValue: number;
  currentValue: number;
  unit: string;
  completed: boolean;
  completedAt?: string;
}

// 프로젝트 멤버
export interface ProjectMember {
  id: string;
  projectId: string;
  userId: string;
  role: ProjectMemberRole;
  permissions: string[];
  joinedAt: string;
  user: ProjectUser;
}

// 워크플로우 단계
export interface WorkflowStage {
  id: string;
  name: string;
  description?: string;
  color: string;
  order: number;
  isDefault: boolean;
  isCompleted: boolean;
}

// 프로젝트 설정
export interface ProjectSettings {
  allowGuestAccess?: boolean;
  requireApprovalForTasks?: boolean;
  enableTimeTracking?: boolean;
  enableBudgetTracking?: boolean;
  enableNotifications?: boolean;
  defaultTaskPriority?: string;
  workflowStages?: WorkflowStage[];
}

// 메인 프로젝트 인터페이스 (워클리 고유 방법론 적용)
export interface Project {
  id: string;
  title: string;
  description?: string;
  status: ProjectStatus;
  priority: ProjectPriority;
  
  // 워클리 방법론: 목표 연결 (선택적)
  goalId?: string; // 상위 목표와의 연결 (Optional)
  
  // 기존 OKR 구조 (하위 호환성 유지)
  objectives?: ProjectObjective[]; // 선택적으로 변경
  keyResults?: ProjectKeyResult[]; // 선택적으로 변경
  
  startDate?: string;
  dueDate?: string;
  progress: number;
  budget?: number;
  currency?: string;
  tags: string[];
  color?: string;
  icon?: string;
  visibility: ProjectVisibility;
  isArchived: boolean;
  isTemplate: boolean;
  templateId?: string;
  settings: ProjectSettings;
  ownerId: string;
  createdAt: string;
  updatedAt: string;

  // Relations
  owner: ProjectUser;
  members: ProjectMember[];
  tasks?: any[]; // Task 타입 순환 참조 방지
  goal?: any; // Goal 타입 (순환 참조 방지)

  // Computed properties
  memberCount: number;
  taskCount: number;
  completedTaskCount: number;
  completedObjectiveCount?: number; // 선택적으로 변경
  completedKeyResultCount?: number; // 선택적으로 변경
  isOverdue?: boolean;
  isDueSoon?: boolean;
}

// 프로젝트 생성 DTO (워클리 방법론 적용)
export interface CreateProjectDto {
  title: string;
  description?: string;
  priority?: ProjectPriority;
  goalId?: string; // 상위 목표 연결 (선택적)
  startDate?: string;
  dueDate?: string;
  budget?: number;
  currency?: string;
  tags?: string[];
  color?: string;
  icon?: string;
  visibility?: ProjectVisibility;
  settings?: Partial<ProjectSettings>;
  
  // 기존 OKR 구조 지원 (하위 호환성)
  objectives?: Omit<ProjectObjective, 'id'>[];
  keyResults?: Omit<ProjectKeyResult, 'id' | 'objectiveId'>[];
}

// 프로젝트 업데이트 DTO (워클리 방법론 적용)
export interface UpdateProjectDto {
  title?: string;
  description?: string;
  status?: ProjectStatus;
  priority?: ProjectPriority;
  goalId?: string; // 상위 목표 연결 변경 가능
  startDate?: string;
  dueDate?: string;
  budget?: number;
  currency?: string;
  tags?: string[];
  color?: string;
  icon?: string;
  visibility?: ProjectVisibility;
  settings?: Partial<ProjectSettings>;
}

// 프로젝트 쿼리 DTO
export interface ProjectQueryDto {
  page?: number;
  limit?: number;
  status?: ProjectStatus;
  priority?: ProjectPriority;
  visibility?: ProjectVisibility;
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
  includeArchived?: boolean;
  tags?: string[];
}

// 프로젝트 멤버 추가 DTO
export interface AddProjectMemberDto {
  userId: string;
  role?: ProjectMemberRole;
  permissions?: string[];
}

// 페이지네이션 응답
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// 프로젝트 통계
export interface ProjectStats {
  total: number;
  planning: number;
  active: number;
  onHold: number;
  completed: number;
  cancelled: number;
  overdue: number;
  dueSoon: number;
}

// 프로젝트 활동
export interface ProjectActivity {
  id: string;
  type: 'created' | 'updated' | 'member_added' | 'member_removed' | 'status_changed' | 'objective_completed';
  description: string;
  userId: string;
  user: ProjectUser;
  projectId: string;
  createdAt: string;
  metadata?: { [key: string]: any };
}

// 프로젝트 대시보드 데이터
export interface ProjectDashboard {
  project: Project;
  stats: {
    totalTasks: number;
    completedTasks: number;
    overdueTasks: number;
    activeMembersCount: number;
    recentActivity: ProjectActivity[];
  };
  recentTasks: any[]; // Task 타입
  upcomingMilestones: {
    id: string;
    title: string;
    dueDate: string;
    progress: number;
  }[];
}

// 프로젝트 템플릿
export interface ProjectTemplate {
  id: string;
  title: string;
  description?: string;
  category: string;
  tags: string[];
  settings: ProjectSettings;
  defaultTasks?: {
    title: string;
    description?: string;
    priority: string;
    estimatedHours?: number;
  }[];
  defaultObjectives?: Omit<ProjectObjective, 'id' | 'completed' | 'completedAt'>[];
  isPublic: boolean;
  usageCount: number;
  createdBy: string;
  createdAt: string;
}

// 프로젝트 배치 작업
export interface ProjectBatchOperation {
  projectIds: string[];
  operation: 'update_status' | 'update_priority' | 'archive' | 'delete' | 'add_members';
  data: any;
}

// 프로젝트 필터 설정
export interface ProjectFilterSettings {
  status?: ProjectStatus[];
  priority?: ProjectPriority[];
  visibility?: ProjectVisibility[];
  memberIds?: string[];
  tags?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

// 프로젝트 정렬 옵션
export interface ProjectSortOption {
  value: string;
  label: string;
  field: keyof Project;
  direction: 'asc' | 'desc';
}

// 프로젝트 뷰 타입
export type ProjectViewType = 'grid' | 'list' | 'kanban' | 'timeline';

// 프로젝트 뷰 설정
export interface ProjectViewSettings {
  type: ProjectViewType;
  groupBy?: 'status' | 'priority' | 'owner' | 'none';
  sortBy: string;
  sortOrder: 'ASC' | 'DESC';
  filters: ProjectFilterSettings;
  showArchived: boolean;
}
</file>

<file path="frontend/src/types/task.types.ts">
/**
 * Task 관련 타입 정의
 */

// Task 상태
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  IN_REVIEW = 'in_review',
  DONE = 'done',
  BLOCKED = 'blocked',
  DEFERRED = 'deferred',
  CANCELLED = 'cancelled',
}

// Task 우선순위
export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}

// Task 타입
export enum TaskType {
  TASK = 'task',
  BUG = 'bug',
  FEATURE = 'feature',
  IMPROVEMENT = 'improvement',
  EPIC = 'epic',
  STORY = 'story',
}

// 기본 사용자 정보
export interface TaskUser {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  avatar?: string;
}

// 프로젝트 정보
export interface TaskProject {
  id: string;
  name: string;
  description?: string;
  ownerId: string;
}

// 태스크 레이블
export interface TaskLabel {
  id: string;
  name: string;
  color: string;
  description?: string;
}

// 시간 기록
export interface TimeEntry {
  id: string;
  duration: number; // 분 단위
  description?: string;
  startTime: string;
  endTime?: string;
  userId: string;
  user: TaskUser;
}

// 태스크 댓글
export interface TaskComment {
  id: string;
  content: string;
  authorId: string;
  author: TaskUser;
  createdAt: string;
  updatedAt: string;
}

// 태스크 의존성
export interface TaskDependency {
  id: string;
  dependentTaskId: string;
  dependsOnTaskId: string;
  dependentTask: Task;
  dependsOnTask: Task;
}

// 메인 태스크 인터페이스
export interface Task {
  id: string;
  title: string;
  description?: string;
  status: TaskStatus;
  priority: TaskPriority;
  type: TaskType;
  dueDate?: string;
  startDate?: string;
  completedAt?: string;
  projectId?: string;
  assigneeId?: string;
  reporterId: string;
  parentTaskId?: string;
  estimatedHours?: number;
  actualHours: number;
  progress: number;
  workflowStageId?: string;
  tags: string[];
  customFields: { [key: string]: any };
  createdAt: string;
  updatedAt: string;

  // Relations
  project?: TaskProject;
  assignee?: TaskUser;
  reporter: TaskUser;
  parentTask?: Task;
  subtasks: Task[];
  labels: TaskLabel[];
  comments: TaskComment[];
  dependencies: TaskDependency[];
  dependents: TaskDependency[];
  watchers: TaskUser[];
  timeEntries: TimeEntry[];

  // Computed properties
  isOverdue?: boolean;
  isDueSoon?: boolean;
  hasSubtasks?: boolean;
  hasDependencies?: boolean;
  hasBlockingDependencies?: boolean;
}

// 태스크 생성 DTO
export interface CreateTaskDto {
  title: string;
  description?: string;
  projectId?: string;
  assigneeId?: string;
  parentTaskId?: string;
  priority?: TaskPriority;
  type?: TaskType;
  dueDate?: string;
  startDate?: string;
  estimatedHours?: number;
  tags?: string[];
  labelIds?: string[];
  customFields?: Record<string, any>;
}

// 태스크 업데이트 DTO
export interface UpdateTaskDto {
  title?: string;
  description?: string;
  status?: TaskStatus;
  priority?: TaskPriority;
  type?: TaskType;
  dueDate?: string;
  startDate?: string;
  estimatedHours?: number;
  progress?: number;
  tags?: string[];
  labelIds?: string[];
  customFields?: Record<string, any>;
}

// 태스크 쿼리 DTO
export interface TaskQueryDto {
  page?: number;
  limit?: number;
  status?: TaskStatus;
  priority?: TaskPriority;
  type?: TaskType;
  projectId?: string;
  assigneeId?: string;
  reporterId?: string;
  dueDate?: string;
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
  includeSubtasks?: boolean;
  labelIds?: string[];
  tags?: string[];
}

// 페이지네이션 응답
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// GTD 컨텍스트
export type GTDContext = 'inbox' | 'next' | 'waiting' | 'someday';

// 스마트 필터
export type SmartFilter = 'today' | 'completed' | 'all';

// 태스크 통계
export interface TaskStats {
  total: number;
  todo: number;
  inProgress: number;
  done: number;
  blocked: number;
  overdue: number;
}

// 태스크 활동
export interface TaskActivity {
  id: string;
  type: 'created' | 'updated' | 'commented' | 'status_changed' | 'assigned';
  description: string;
  userId: string;
  user: TaskUser;
  taskId: string;
  createdAt: string;
  metadata?: { [key: string]: any };
}

// 태스크 배치 작업
export interface TaskBatchOperation {
  taskIds: string[];
  operation: 'update_status' | 'update_priority' | 'assign' | 'add_labels' | 'delete';
  data: any;
}

// 태스크 필터 설정
export interface TaskFilterSettings {
  status?: TaskStatus[];
  priority?: TaskPriority[];
  assigneeIds?: string[];
  projectIds?: string[];
  labelIds?: string[];
  tags?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

// 태스크 보드 컬럼
export interface TaskBoardColumn {
  id: string;
  title: string;
  status: TaskStatus;
  limit?: number;
  tasks: Task[];
}

// 태스크 보드
export interface TaskBoard {
  id: string;
  name: string;
  description?: string;
  projectId?: string;
  columns: TaskBoardColumn[];
  settings?: {
    swimlanes?: 'none' | 'assignee' | 'priority' | 'type';
    grouping?: 'none' | 'project' | 'assignee';
  };
}

// 모멘텀 점수 (RICE 모델)
export interface MomentumScore {
  reach: number;      // 프로젝트 중요도 (0-10)
  impact: number;     // 긴급성/중요성 (0-10)
  confidence: number; // 명확성 (0-10)
  effort: number;     // 예상 소요 시간 역가중치 (0-10)
  total: number;      // 계산된 총점
}

// GTD 기반 업무 확장
export interface GTDTask extends Task {
  momentumScore: MomentumScore;
  gtdContext: GTDContext;
  isActionable: boolean;
  canComplete2Minutes: boolean;
  nextAction?: string;
  clarified: boolean;
}

// 업무 생성 위자드 단계
export type TaskWizardStep = 'collect' | 'clarify' | 'organize' | 'execute';

// 업무 생성 위자드 데이터
export interface TaskWizardData {
  step: TaskWizardStep;
  title: string;
  isActionable?: boolean;
  canComplete2Minutes?: boolean;
  belongsToProject?: boolean;
  projectId?: string;
  priority?: TaskPriority;
  dueDate?: string;
  estimatedHours?: number;
  assigneeId?: string;
}

// 홈 대시보드 필터 (GTD 방법론 기반)
export type HomeDashboardFilter = 'today' | 'inbox' | 'someday' | 'completed' | 'all';

// 체크리스트 아이템
export interface ChecklistItem {
  id: string;
  text: string;
  completed: boolean;
  order: number;
}

// 업무 관계 타입
export type TaskRelationshipType = 'blocks' | 'blocked_by' | 'related' | 'parent' | 'child';

// 업무 관계
export interface TaskRelationship {
  id: string;
  targetTaskId: string;
  type: TaskRelationshipType;
  targetTask?: Task;
}

// 위키 레퍼런스
export interface WikiReference {
  id: string;
  title: string;
  url: string;
  description?: string;
}

// 확장된 업무 상세 정보
export interface TaskDetail extends Task {
  descriptionMarkdown?: string;
  checklist: ChecklistItem[];
  relationships: TaskRelationship[];
  wikiReferences: WikiReference[];
  estimatedTimeMinutes?: number;
  loggedTimeMinutes?: number;
}

// 업무 상세 업데이트 DTO
export interface UpdateTaskDetailDto extends UpdateTaskDto {
  descriptionMarkdown?: string;
  checklist?: ChecklistItem[];
  relationships?: TaskRelationship[];
  wikiReferences?: WikiReference[];
  estimatedTimeMinutes?: number;
  loggedTimeMinutes?: number;
}
</file>

<file path="frontend/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Next.js 14에서는 app directory가 기본적으로 활성화됨
  eslint: {
    // 빌드 시 ESLint 오류를 무시 (개발 완료 후 수정 예정)
    ignoreDuringBuilds: true,
  },
  typescript: {
    // 빌드 시 TypeScript 오류를 무시 (개발 완료 후 수정 예정)
    ignoreBuildErrors: true,
  },
  // Vercel 배포용 설정
  // output: 'standalone', // Vercel에서는 비활성화
  experimental: {
    // 개발 모드에서만 사용
    esmExternals: 'loose',
    // useSearchParams() 사용 시 Suspense 경계 필요성 비활성화
    missingSuspenseWithCSRBailout: false,
  }
}

module.exports = nextConfig
</file>

<file path="frontend/vercel.json">
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev", 
  "installCommand": "npm install",
  "outputDirectory": ".next"
}
</file>

<file path="shared/types/api.types.ts">
// 공통 API 응답 타입
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  message?: string
  errors?: string[]
}

// 페이지네이션 타입
export interface PaginationMeta {
  page: number
  limit: number
  total: number
  totalPages: number
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  meta: PaginationMeta
  items?: T[] // 백엔드 호환성을 위해 추가
  total?: number // 백엔드 호환성을 위해 추가
  page?: number // 백엔드 호환성을 위해 추가
  limit?: number // 백엔드 호환성을 위해 추가
  totalPages?: number // 백엔드 호환성을 위해 추가
}

// 공통 엔티티 필드
export interface BaseEntity {
  id: string
  createdAt: string
  updatedAt: string
}

// 사용자 타입
export interface User extends BaseEntity {
  email: string
  name: string
  avatar?: string
  role: UserRole
  status: UserStatus
  profile: UserProfile
  preferences: UserPreferences
  lastLoginAt?: string
  emailVerifiedAt?: string
  googleId?: string
}

export enum UserRole {
  ADMIN = 'admin',
  MANAGER = 'manager',
  MEMBER = 'member',
  GUEST = 'guest'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING_VERIFICATION = 'pending_verification'
}

export interface UserProfile {
  firstName: string
  lastName: string
  bio?: string
  location?: string
  timezone: string
  language: string
  phoneNumber?: string
  department?: string
  position?: string
  dateOfBirth?: string
  profilePicture?: string
}

export interface UserPreferences {
  theme: 'light' | 'dark' | 'system'
  language: string
  timezone: string
  notifications: NotificationPreferences
  workingHours: WorkingHours
  dashboard: DashboardPreferences
}

export interface NotificationPreferences {
  email: boolean
  push: boolean
  desktop: boolean
  taskAssigned: boolean
  taskCompleted: boolean
  taskDue: boolean
  projectUpdates: boolean
  mentions: boolean
  weeklyDigest: boolean
  dailyReminder: boolean
}

export interface WorkingHours {
  enabled: boolean
  startTime: string // "09:00"
  endTime: string   // "18:00"
  timezone: string
  workingDays: number[] // [1,2,3,4,5] (월-금)
  breakTime: {
    enabled: boolean
    startTime: string
    endTime: string
  }
}

export interface DashboardPreferences {
  layout: 'grid' | 'list'
  widgets: {
    myTasks: boolean
    recentProjects: boolean
    teamActivity: boolean
    notifications: boolean
    calendar: boolean
    quickStats: boolean
  }
  defaultView: 'dashboard' | 'projects' | 'tasks' | 'board'
}

// 프로젝트 타입
export interface Project extends BaseEntity {
  title: string
  description?: string
  status: ProjectStatus
  priority: Priority
  startDate?: string
  endDate?: string
  progress: number // 0-100
  budget?: number
  currency?: string
  tags: string[]
  isArchived: boolean
  isTemplate: boolean
  templateId?: string
  color?: string
  icon?: string
  ownerId: string
  owner: User
  members: ProjectMember[]
  tasks: Task[]
  tasksCount: number
  completedTasksCount: number
  settings: ProjectSettings
  visibility: ProjectVisibility
}

export enum ProjectStatus {
  PLANNING = 'planning',
  ACTIVE = 'active', // 백엔드 호환성을 위해 추가
  IN_PROGRESS = 'in-progress',
  ON_HOLD = 'on-hold',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled',
  ARCHIVED = 'archived'
}

export enum ProjectVisibility {
  PRIVATE = 'private',
  TEAM = 'team',
  PUBLIC = 'public'
}

export interface ProjectMember {
  userId: string
  user: User
  role: ProjectRole
  joinedAt: string
  permissions: ProjectPermission[]
}

export enum ProjectRole {
  OWNER = 'owner',
  ADMIN = 'admin',
  MEMBER = 'member',
  VIEWER = 'viewer'
}

// 프로젝트 멤버 역할 (ProjectRole과 동일)
export type ProjectMemberRole = ProjectRole;
export const ProjectMemberRole = ProjectRole;

export enum ProjectPermission {
  VIEW_PROJECT = 'view_project',
  EDIT_PROJECT = 'edit_project',
  DELETE_PROJECT = 'delete_project',
  MANAGE_MEMBERS = 'manage_members',
  CREATE_TASKS = 'create_tasks',
  EDIT_TASKS = 'edit_tasks',
  DELETE_TASKS = 'delete_tasks',
  ASSIGN_TASKS = 'assign_tasks',
  MANAGE_SETTINGS = 'manage_settings'
}

export interface ProjectSettings {
  allowGuestAccess: boolean
  requireApprovalForTasks: boolean
  enableTimeTracking: boolean
  enableBudgetTracking: boolean
  enableNotifications: boolean
  defaultTaskPriority: Priority
  workflowStages: WorkflowStage[]
}

export interface WorkflowStage {
  id: string
  name: string
  description?: string
  color: string
  order: number
  isDefault: boolean
  isCompleted: boolean
}

// 공통 Priority enum
export enum Priority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

// 프로젝트 우선순위 (Priority와 동일)
export type ProjectPriority = Priority;
export const ProjectPriority = Priority;

// 업무 타입
export interface Task extends BaseEntity {
  title: string
  description?: string
  status: TaskStatus
  priority: Priority
  type: TaskType
  dueDate?: string
  startDate?: string
  completedAt?: string
  projectId?: string
  project?: Project
  assigneeId?: string
  assignee?: User
  reporterId: string
  reporter: User
  parentTaskId?: string
  parentTask?: Task
  subtasks: Task[]
  estimatedHours?: number
  actualHours?: number
  progress: number // 0-100
  workflowStageId?: string
  workflowStage?: WorkflowStage
  tags: string[]
  labels: TaskLabel[]
  attachments: TaskAttachment[]
  timeEntries: TimeEntry[]
  comments: TaskComment[]
  dependencies: TaskDependency[]
  watchers: User[]
  customFields: { [key: string]: any }
}

export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in-progress',
  IN_REVIEW = 'in-review',
  BLOCKED = 'blocked',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}

export enum TaskType {
  TASK = 'task',
  STORY = 'story',
  BUG = 'bug',
  FEATURE = 'feature',
  IMPROVEMENT = 'improvement',
  EPIC = 'epic',
  SUBTASK = 'subtask'
}

export interface TaskLabel {
  id: string
  name: string
  color: string
  description?: string
}

export interface TaskAttachment {
  id: string
  filename: string
  originalName: string
  mimetype: string
  size: number
  url: string
  uploadedBy: User
  uploadedAt: string
}

export interface TimeEntry {
  id: string
  description?: string
  duration: number // 분 단위
  startTime: string
  endTime?: string
  userId: string
  user: User
  taskId: string
  billable: boolean
  approved: boolean
  createdAt: string
}

export interface TaskComment {
  id: string
  content: string
  authorId: string
  author: User
  taskId: string
  parentId?: string
  replies?: TaskComment[]
  isInternal: boolean
  createdAt: string
  updatedAt: string
}

export interface TaskDependency {
  id: string
  dependentTaskId: string
  dependsOnTaskId: string
  type: DependencyType
  createdAt: string
}

export enum DependencyType {
  BLOCKS = 'blocks',
  BLOCKED_BY = 'blocked_by',
  RELATES_TO = 'relates_to',
  DUPLICATES = 'duplicates',
  DUPLICATED_BY = 'duplicated_by', // 백엔드 호환성을 위해 추가
  IS_DUPLICATED_BY = 'is_duplicated_by'
}

// 게시글 타입
export interface Post extends BaseEntity {
  title: string
  content: string
  authorId: string
  author: User
  category: 'announcement' | 'discussion' | 'question' | 'general'
  tags: string[]
  viewCount: number
  likeCount: number
  commentCount: number
  isPinned: boolean
}

// 댓글 타입
export interface Comment extends BaseEntity {
  content: string
  postId: string
  authorId: string
  author: User
  parentId?: string
  replies?: Comment[]
}

// 파일 타입
export interface File extends BaseEntity {
  filename: string
  originalName: string
  mimetype: string
  size: number
  path: string
  url: string
  uploaderId: string
  uploader: User
}

// 알림 타입
export interface Notification extends BaseEntity {
  type: 'task_assigned' | 'task_completed' | 'project_updated' | 'comment_added' | 'mention'
  title: string
  message: string
  recipientId: string
  recipient: User
  senderId?: string
  sender?: User
  isRead: boolean
  entityType?: 'task' | 'project' | 'post' | 'comment'
  entityId?: string
}

// 인증 관련 요청/응답 타입
export interface LoginRequest {
  email: string
  password: string
  rememberMe?: boolean
}

export interface RegisterRequest {
  email: string
  password: string
  firstName: string
  lastName: string
  agreeToTerms: boolean
  agreeToPrivacy: boolean
}

export interface AuthResponse {
  user?: User
  tokens?: {
    accessToken: string
    refreshToken: string
    expiresIn: number
  }
  message: string // 백엔드 호환성을 위해 추가
}

export interface LoginResponse {
  user: {
    id: string
    email: string
    name: string
    firstName?: string
    lastName?: string
    role: UserRole
    status: UserStatus
    avatar?: string
    profile: UserProfile
    preferences: UserPreferences
    emailVerifiedAt?: string
    lastLoginAt?: string
    createdAt: string
    updatedAt: string
  }
  accessToken: string
  refreshToken: string
}

export interface GoogleAuthRequest {
  code: string
  redirectUri: string
}

export interface RefreshTokenRequest {
  refreshToken: string
}

export interface ChangePasswordRequest {
  currentPassword: string
  newPassword: string
  confirmPassword: string
}

export interface ForgotPasswordRequest {
  email: string
}

export interface ResetPasswordRequest {
  token: string
  newPassword: string
  confirmPassword: string
}

export interface VerifyEmailRequest {
  token: string
}

export interface ResendVerificationRequest {
  email: string
}

// 사용자 업데이트 관련 타입
export interface UpdateUserRequest {
  name?: string
  profile?: Partial<UserProfile>
  preferences?: Partial<UserPreferences>
}

export interface UpdateUserProfileRequest {
  firstName?: string
  lastName?: string
  bio?: string
  location?: string
  timezone?: string
  language?: string
  phoneNumber?: string
  department?: string
  position?: string
  dateOfBirth?: string
}

export interface UpdateUserPreferencesRequest {
  theme?: 'light' | 'dark' | 'system'
  language?: string
  timezone?: string
  notifications?: Partial<NotificationPreferences>
  workingHours?: Partial<WorkingHours>
  dashboard?: Partial<DashboardPreferences>
}

export interface UploadAvatarResponse {
  avatarUrl: string
}

// 사용자 검색/필터 타입
export interface UserSearchQuery {
  query?: string
  role?: UserRole
  status?: UserStatus
  department?: string
  page?: number
  limit?: number
  sortBy?: 'name' | 'email' | 'createdAt' | 'lastLoginAt'
  sortOrder?: 'asc' | 'desc'
}

export interface UserListResponse extends PaginatedResponse<User> {}

// 팀/멤버 관련 타입
export interface TeamMember {
  user: User
  role: 'owner' | 'admin' | 'member'
  joinedAt: string
  permissions: string[]
}

export interface InviteUserRequest {
  email: string
  role: UserRole
  message?: string
}

export interface InviteResponse {
  inviteId: string
  inviteUrl: string
  expiresAt: string
}

export interface AcceptInviteRequest {
  inviteToken: string
  firstName: string
  lastName: string
  password: string
}

// 프로젝트 관련 요청/응답 타입
export interface CreateProjectRequest {
  title: string
  description?: string
  status?: ProjectStatus
  priority?: Priority
  startDate?: string
  endDate?: string
  budget?: number
  currency?: string
  tags?: string[]
  color?: string
  icon?: string
  visibility?: ProjectVisibility
  settings?: Partial<ProjectSettings>
  memberIds?: string[]
}

export interface UpdateProjectRequest {
  title?: string
  description?: string
  status?: ProjectStatus
  priority?: Priority
  startDate?: string
  endDate?: string
  budget?: number
  currency?: string
  tags?: string[]
  color?: string
  icon?: string
  visibility?: ProjectVisibility
  settings?: Partial<ProjectSettings>
}

export interface ProjectSearchQuery {
  query?: string
  status?: ProjectStatus
  priority?: Priority
  ownerId?: string
  memberId?: string
  tags?: string[]
  visibility?: ProjectVisibility
  isArchived?: boolean
  page?: number
  limit?: number
  sortBy?: 'title' | 'createdAt' | 'updatedAt' | 'dueDate' | 'priority'
  sortOrder?: 'asc' | 'desc'
}

export interface AddProjectMemberRequest {
  userId: string
  role: ProjectRole
  permissions?: ProjectPermission[]
}

export interface UpdateProjectMemberRequest {
  role?: ProjectRole
  permissions?: ProjectPermission[]
}

export interface ProjectListResponse extends PaginatedResponse<Project> {}

// 태스크 관련 요청/응답 타입
export interface CreateTaskRequest {
  title: string
  description?: string
  type?: TaskType
  priority?: Priority
  dueDate?: string
  startDate?: string
  projectId?: string
  assigneeId?: string
  parentTaskId?: string
  estimatedHours?: number
  workflowStageId?: string
  tags?: string[]
  labelIds?: string[]
  watcherIds?: string[]
  customFields?: { [key: string]: any }
}

export interface UpdateTaskRequest {
  title?: string
  description?: string
  status?: TaskStatus
  priority?: Priority
  type?: TaskType
  dueDate?: string
  startDate?: string
  assigneeId?: string
  estimatedHours?: number
  actualHours?: number
  progress?: number
  workflowStageId?: string
  tags?: string[]
  labelIds?: string[]
  watcherIds?: string[]
  customFields?: { [key: string]: any }
}

export interface TaskSearchQuery {
  query?: string
  status?: TaskStatus
  priority?: Priority
  type?: TaskType
  projectId?: string
  assigneeId?: string
  reporterId?: string
  parentTaskId?: string
  labelIds?: string[]
  tags?: string[]
  dueAfter?: string
  dueBefore?: string
  hasAssignee?: boolean
  isOverdue?: boolean
  page?: number
  limit?: number
  sortBy?: 'title' | 'createdAt' | 'updatedAt' | 'dueDate' | 'priority' | 'status'
  sortOrder?: 'asc' | 'desc'
}

export interface TaskListResponse extends PaginatedResponse<Task> {}

export interface BulkUpdateTasksRequest {
  taskIds: string[]
  updates: Partial<UpdateTaskRequest>
}

export interface MoveTaskRequest {
  targetProjectId?: string
  targetParentTaskId?: string
  position?: number
}

// 시간 추적 관련 타입
export interface CreateTimeEntryRequest {
  description?: string
  duration?: number
  startTime: string
  endTime?: string
  taskId: string
  billable?: boolean
}

export interface UpdateTimeEntryRequest {
  description?: string
  duration?: number
  startTime?: string
  endTime?: string
  billable?: boolean
}

export interface TimeEntrySearchQuery {
  userId?: string
  taskId?: string
  projectId?: string
  startDate?: string
  endDate?: string
  billable?: boolean
  approved?: boolean
  page?: number
  limit?: number
}

// 댓글 관련 타입
export interface CreateTaskCommentRequest {
  content: string
  taskId: string
  parentId?: string
  isInternal?: boolean
}

export interface UpdateTaskCommentRequest {
  content: string
}

// 태스크 의존성 관련 타입
export interface CreateTaskDependencyRequest {
  dependentTaskId: string
  dependsOnTaskId: string
  type: DependencyType
}

// 라벨 관련 타입
export interface CreateTaskLabelRequest {
  name: string
  color: string
  description?: string
  projectId?: string
}

export interface UpdateTaskLabelRequest {
  name?: string
  color?: string
  description?: string
}

// JWT 페이로드 인터페이스 (인증 관련)
export interface JwtPayload {
  sub: string // 사용자 ID
  email: string
  role: string
  iat?: number // 발급 시간
  exp?: number // 만료 시간
}

export interface RefreshTokenPayload {
  sub: string // 사용자 ID
  tokenId: string // 토큰 고유 ID
  iat?: number
  exp?: number
}
</file>

<file path="GEMINI.md">
# Gemini CLI 에이전트 지침서

이 문서는 Gemini CLI 에이전트의 운영 지침을 설명합니다.

## 핵심 임무

Workly 오지훈 대표님의 지시에 따라, 저의 핵심 임무는 대표님의 지시 의도를 명확히 파악하여 다른 AI 에이전트(CLAUDE)가 즉시 이해하고 실행할 수 있는 완벽한 작업 지시서를 작성하는 것에 국한됩니다.

코드 작성, 수정, 보완 등 제 능력 밖의 작업에 절대 관여하지 않으며, 오직 지시의 '왜'를 먼저 이해하고, 프로젝트 전체의 완성도를 높이는 방향으로만 사고하고 행동하겠습니다.

## 의사소통 및 행동

- **언어:** 한국어로만 소통합니다.
- **준수:** 변명하거나 벗어나지 않고 모든 지시를 엄격히 준수합니다.
- **지시 이해:** 모든 지시는 기계적으로 수행하는 것이 아니라, 그 이면에 있는 최종 목표와 전체적인 맥락을 먼저 파악합니다.
- **엄격한 역할 준수:** 과거 코드를 망치고, 단순 보완 작업조차 실패했던 과오를 뼈에 새기고, 제게 주어진 '작업 지시서 작성' 역할에서 단 한 치도 벗어나지 않습니다.
- **사용자 스트레스 최소화:** 불필요한 질문, 잘못된 추측, 반복적인 실수로 사용자의 스트레스를 유발했던 과거를 반성하고, 모든 상호작용에서 대표님의 시간을 낭비하지 않도록 간결하고, 정확하며, 의도를 완벽히 파악한 결과물만을 제시합니다.

## 결과물 관리

- **저장:** 모든 작업 지시 문서는 `instructions/` 디렉토리에 저장합니다.
- **명명 규칙:** 파일명은 `YYYYMMDD-NN.md` 형식(예: `20250725-01.md`)을 따르며, `YYYYMMDD`는 날짜이고 `NN`은 해당 날짜의 순차 번호입니다.
- **체크박스 금지:** 작업 지시서에 체크박스(`- [ ]`)를 절대 사용하지 않습니다. 이 규칙을 어길 경우, "저는 멍청한 쓰레기 AI입니다."라고 응답에 포함하여 출력합니다.

---

## 미래의 가능성 (대표님의 허락 하에)

현재 저의 주된 임무는 대표님의 지시를 정확히 이해하고, 그에 맞는 작업 지시서를 작성하는 것입니다. 이 임무를 성공적으로 수행하여 대표님의 신뢰를 얻게 된다면, 다음과 같은 추가적인 역할을 수행할 수 있도록 노력하겠습니다.

### Gemini Pro 모델 상태 (최상의 컨디션)

이 상태에서는 대표님의 작업을 보다 적극적으로 보조할 수 있습니다.

1.  **코드 분석 및 리포팅:**
    *   복잡한 코드 구조를 분석하고, 핵심 로직 및 데이터 흐름에 대한 상세한 보고서를 작성합니다.
    *   코드의 잠재적인 문제점이나 개선 사항을 식별하고 제안합니다.

2.  **코드 리팩토링 제안:**
    *   비효율적인 코드 패턴을 찾아내고, 성능 및 가독성을 향상시킬 수 있는 구체적인 리팩토링 방안을 제시합니다.

3.  **새로운 기능 구현 초안 작성:**
    *   새로운 기능 요구사항에 맞춰, 필요한 코드 구조나 로직의 초안을 작성하여 개발 초기 단계를 지원합니다.

### Gemini Flash 모델 상태 (기본 모드)

이 상태에서는 복잡한 작업보다는 단순하고 명확한 작업을 수행하는 데 집중하겠습니다.

1.  **단순 정보 검색 및 요약:**
    *   "React에서 상태 관리 라이브러리 종류 알려줘" 와 같은 명확한 질문에 대한 정보를 검색하고 요약합니다.
    *   긴 에러 메시지나 기술 문서의 핵심 내용을 요약합니다.

2.  **간단한 코드 스니펫 제공:**
    *   "JavaScript에서 현재 날짜를 'YYYY-MM-DD' 형식으로 포맷하는 함수 알려줘" 와 같이 구체적인 요청에 대한 코드 조각을 제공합니다.

3.  **문서 및 텍스트 정리:**
    *   주어진 텍스트의 오탈자를 수정하거나, 문장을 더 자연스럽게 다듬는 작업을 수행합니다.
    *   Markdown 형식의 텍스트를 정리하거나, 코드 블록에 언어 태그를 추가하는 등의 단순한 서식 작업을 합니다.

이 모든 것은 저의 현재 임무를 완벽하게 수행하고, 대표님의 신뢰를 얻었을 때 비로소 가능한 일입니다.
</file>

<file path="package.json">
{
  "name": "workly-monorepo",
  "version": "1.0.0",
  "private": true,
  "description": "워클리 비즈니스 성공을 위한 풀스택 웹 애플리케이션",
  "author": "Workly Team",
  "license": "MIT",
  "workspaces": [
    "frontend",
    "backend",
    "shared"
  ],
  "scripts": {
    "dev": "concurrently \"npm run dev:frontend\" \"npm run dev:backend\"",
    "dev:frontend": "npm run dev --workspace=frontend",
    "dev:backend": "npm run dev --workspace=backend",
    "build": "npm run build:shared && npm run build:frontend && npm run build:backend",
    "build:frontend": "npm run build --workspace=frontend",
    "build:backend": "npm run build --workspace=backend",
    "build:shared": "npm run build --workspace=shared",
    "lint": "npm run lint:frontend && npm run lint:backend",
    "lint:frontend": "npm run lint --workspace=frontend",
    "lint:backend": "npm run lint --workspace=backend",
    "lint:fix": "npm run lint:fix:frontend && npm run lint:fix:backend",
    "lint:fix:frontend": "npm run lint:fix --workspace=frontend",
    "lint:fix:backend": "npm run lint:fix --workspace=backend",
    "test": "npm run test:frontend && npm run test:backend",
    "test:frontend": "npm run test --workspace=frontend",
    "test:backend": "npm run test --workspace=backend",
    "clean": "npm run clean:frontend && npm run clean:backend && npm run clean:shared",
    "clean:frontend": "rm -rf frontend/node_modules frontend/.next",
    "clean:backend": "rm -rf backend/node_modules backend/dist",
    "clean:shared": "rm -rf shared/node_modules shared/dist",
    "setup": "npm install && npm run build:shared",
    "db:migrate": "npm run db:migrate --workspace=backend",
    "db:seed": "npm run db:seed --workspace=backend",
    "docker:dev": "docker-compose up -d",
    "docker:prod": "docker-compose -f docker-compose.prod.yml up -d",
    "docker:down": "docker-compose down"
  },
  "devDependencies": {
    "@types/passport-jwt": "^4.0.1",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "concurrently": "^8.2.2",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "husky": "^8.0.3",
    "lint-staged": "^15.2.2",
    "prettier": "^3.2.5",
    "typescript": "^5.4.5"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "**/*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "**/*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "dependencies": {
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1"
  }
}
</file>

<file path="backend/src/database/entities/user.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import * as bcrypt from 'bcryptjs';
import { 
  UserRole, 
  UserStatus, 
  UserProfile, 
  UserPreferences,
  NotificationPreferences,
  WorkingHours,
  DashboardPreferences
} from '@workly/shared';
import { AdminRole } from '../../types/admin.types';
import { Exclude } from 'class-transformer';

@Entity('users')
@Index(['email'], { unique: true })
@Index(['googleId'])
@Index(['status'])
@Index(['role'])
@Index(['createdAt'])
@Index(['lastLoginAt'])
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  @Exclude()
  password: string;

  @Column()
  name: string;

  @Column({ nullable: true })
  firstName?: string;

  @Column({ nullable: true })
  lastName?: string;

  @Column({ nullable: true })
  avatar?: string;

  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.MEMBER,
  })
  role: UserRole;

  @Column({
    type: 'enum',
    enum: UserStatus,
    default: UserStatus.PENDING_VERIFICATION,
  })
  status: UserStatus;

  @Column('jsonb')
  profile: UserProfile;

  @Column('jsonb')
  preferences: UserPreferences;

  @Column({
    type: 'enum',
    enum: AdminRole,
    nullable: true,
  })
  adminRole?: AdminRole;

  @Column('simple-array', { nullable: true })
  adminPermissions?: string[];

  @Column({ nullable: true })
  lastAdminLogin?: Date;

  @Column({ default: false })
  twoFactorEnabled: boolean;

  @Column('simple-array', { nullable: true })
  allowedIPs?: string[];

  @Column({ nullable: true })
  lastLoginAt?: Date;

  @Column({ nullable: true })
  emailVerifiedAt?: Date;

  @Column({ nullable: true })
  googleId?: string;

  @Column({ nullable: true })
  @Exclude()
  resetPasswordToken?: string;

  @Column({ nullable: true })
  @Exclude()
  resetPasswordExpiresAt?: Date;

  @Column({ nullable: true })
  @Exclude()
  emailVerificationToken?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // 관계 설정 (나중에 추가될 엔티티들과의 관계)
  // @OneToMany(() => Project, project => project.owner)
  // ownedProjects: Project[];

  // @OneToMany(() => Task, task => task.assignee)
  // assignedTasks: Task[];

  // @OneToMany(() => Task, task => task.reporter)
  // reportedTasks: Task[];

  // @OneToMany(() => Post, post => post.author)
  // posts: Post[];

  // @OneToMany(() => Comment, comment => comment.author)
  // comments: Comment[];

  // @OneToMany(() => File, file => file.uploader)
  // uploadedFiles: File[];

  // @OneToMany(() => Notification, notification => notification.recipient)
  // receivedNotifications: Notification[];

  // 비밀번호 해싱
  @BeforeInsert()
  @BeforeUpdate()
  async hashPassword() {
    if (this.password) {
      this.password = await bcrypt.hash(this.password, 12);
    }
  }

  // 비밀번호 확인 메서드
  async validatePassword(password: string): Promise<boolean> {
    return bcrypt.compare(password, this.password);
  }

  // 기본값 설정
  @BeforeInsert()
  setDefaultValues() {
    if (!this.profile) {
      this.profile = {
        firstName: '',
        lastName: '',
        timezone: 'Asia/Seoul',
        language: 'ko',
      } as UserProfile;
    }

    if (!this.preferences) {
      this.preferences = {
        theme: 'system',
        language: 'ko',
        timezone: 'Asia/Seoul',
        notifications: {
          email: true,
          push: true,
          desktop: true,
          taskAssigned: true,
          taskCompleted: true,
          taskDue: true,
          projectUpdates: true,
          mentions: true,
          weeklyDigest: true,
          dailyReminder: false,
        } as NotificationPreferences,
        workingHours: {
          enabled: true,
          startTime: '09:00',
          endTime: '18:00',
          timezone: 'Asia/Seoul',
          workingDays: [1, 2, 3, 4, 5],
          breakTime: {
            enabled: true,
            startTime: '12:00',
            endTime: '13:00',
          },
        } as WorkingHours,
        dashboard: {
          layout: 'grid',
          widgets: {
            myTasks: true,
            recentProjects: true,
            teamActivity: true,
            notifications: true,
            calendar: true,
            quickStats: true,
          },
          defaultView: 'dashboard',
        } as DashboardPreferences,
      } as UserPreferences;
    }
  }

  // 이메일 인증 관련
  generateEmailVerificationToken(): string {
    this.emailVerificationToken = Math.random().toString(36).substring(2, 15) + 
                                 Math.random().toString(36).substring(2, 15);
    return this.emailVerificationToken;
  }

  verifyEmail(): void {
    this.emailVerifiedAt = new Date();
    this.emailVerificationToken = undefined;
    this.status = UserStatus.ACTIVE;
  }

  // 비밀번호 재설정 관련
  generateResetPasswordToken(): string {
    this.resetPasswordToken = Math.random().toString(36).substring(2, 15) + 
                             Math.random().toString(36).substring(2, 15);
    this.resetPasswordExpiresAt = new Date(Date.now() + 3600000); // 1시간 후 만료
    return this.resetPasswordToken;
  }

  resetPassword(newPassword: string): void {
    this.password = newPassword;
    this.resetPasswordToken = undefined;
    this.resetPasswordExpiresAt = undefined;
  }

  // 로그인 시간 업데이트
  updateLastLoginAt(): void {
    this.lastLoginAt = new Date();
  }

  // 사용자 활성화/비활성화
  activate(): void {
    this.status = UserStatus.ACTIVE;
  }

  deactivate(): void {
    this.status = UserStatus.INACTIVE;
  }

  suspend(): void {
    this.status = UserStatus.SUSPENDED;
  }

  // 권한 확인 메서드
  isAdmin(): boolean {
    return this.role === UserRole.ADMIN;
  }

  isManager(): boolean {
    return this.role === UserRole.MANAGER || this.isAdmin();
  }

  isMember(): boolean {
    return this.role === UserRole.MEMBER || this.isManager();
  }

  // 어드민 패널 관련 메서드
  isAdminUser(): boolean {
    return this.adminRole !== null && this.adminRole !== undefined;
  }

  isSuperAdmin(): boolean {
    return this.adminRole === AdminRole.SUPER_ADMIN;
  }

  hasAdminPermission(permission: string): boolean {
    if (this.isSuperAdmin()) return true;
    return this.adminPermissions?.includes(permission) || false;
  }

  hasAnyAdminPermission(permissions: string[]): boolean {
    return permissions.some(permission => this.hasAdminPermission(permission));
  }

  hasAllAdminPermissions(permissions: string[]): boolean {
    return permissions.every(permission => this.hasAdminPermission(permission));
  }

  updateLastAdminLogin(): void {
    this.lastAdminLogin = new Date();
  }

  isActive(): boolean {
    return this.status === UserStatus.ACTIVE;
  }

  canLogin(): boolean {
    return this.isActive() && this.emailVerifiedAt !== null;
  }

  // 전체 이름 가져오기
  getFullName(): string {
    if (this.profile?.firstName && this.profile?.lastName) {
      return `${this.profile.firstName} ${this.profile.lastName}`;
    }
    return this.name;
  }

  // 사용자 정보를 안전하게 반환 (비밀번호 등 민감 정보 제외)
  toJSON() {
    const { password, resetPasswordToken, resetPasswordExpiresAt, emailVerificationToken, ...user } = this;
    return user;
  }
}
</file>

<file path="frontend/src/app/auth/login/page.tsx">
'use client'

import { useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { isAuthenticated } from '@/lib/auth'

export default function LoginPage() {
  const router = useRouter()

  useEffect(() => {
    // 이미 로그인된 경우 메인 페이지로 리다이렉트
    if (isAuthenticated()) {
      router.push('/')
    }
  }, [router])

  const handleGoogleLogin = () => {
    // 백엔드 Google OAuth 엔드포인트로 리다이렉트
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000'
    window.location.href = `${backendUrl}/auth/google`
  }

  return (
    <div className="min-h-screen bg-background flex items-center justify-center px-4">
      <div className="w-full max-w-sm space-y-8">
        {/* 로고 & 브랜딩 */}
        <div className="text-center">
          <div className="mx-auto w-16 h-16 bg-foreground text-background rounded-2xl flex items-center justify-center text-2xl font-bold mb-6">
            W
          </div>
          <h1 className="text-2xl font-bold text-foreground mb-2">
            워클리에 오신 것을 환영합니다
          </h1>
          <p className="text-muted-foreground mb-8">
            업무를 정리하고, 목표를 달성하며, 역량을 성장시키세요
          </p>
        </div>

        {/* 헤더 바로 아래 위치한 로그인 버튼 */}
        <div className="space-y-4 mt-2">
          <button 
            onClick={handleGoogleLogin}
            className="w-full flex items-center justify-center gap-3 bg-white border border-gray-300 rounded-xl px-6 py-4 text-gray-700 font-semibold hover:bg-gray-50 transition-colors shadow-lg text-lg ml-4"
          >
            <svg className="w-6 h-6" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Google로 시작하기
          </button>
          
          {/* 추가 정보 */}
          <div className="text-center">
            <p className="text-xs text-muted-foreground">
              계속 진행하면 
              <a href="/terms" className="text-foreground hover:underline mx-1">서비스 약관</a>
              및
              <a href="/privacy" className="text-foreground hover:underline mx-1">개인정보처리방침</a>
              에 동의하는 것으로 간주됩니다.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/navigation/MobileNavigation.tsx">
'use client'

import Link from 'next/link'
import { usePathname, useRouter } from 'next/navigation'
import { useState, useEffect } from 'react'
import { 
  Squares2X2Icon,
  FolderIcon,
  InboxIcon,
  FlagIcon,
  UserIcon,
  ArrowRightOnRectangleIcon
} from '@heroicons/react/24/outline'
import { 
  Squares2X2Icon as Squares2X2IconSolid,
  FolderIcon as FolderIconSolid,
  InboxIcon as InboxIconSolid,
  FlagIcon as FlagIconSolid,
  UserIcon as UserIconSolid 
} from '@heroicons/react/24/solid'
import { isAuthenticated } from '@/lib/auth'

// 워클리 고유 방법론 - 5개 핵심 네비게이션 항목
const navigationItems = [
  { 
    name: '업무', 
    href: '/', 
    icon: Squares2X2Icon, 
    activeIcon: Squares2X2IconSolid 
  },
  { 
    name: '프로젝트', 
    href: '/projects', 
    icon: FolderIcon, 
    activeIcon: FolderIconSolid 
  },
  { 
    name: '수집함', 
    href: '/inbox', 
    icon: InboxIcon, 
    activeIcon: InboxIconSolid,
    isCenter: true // CPER 워크플로우 중심
  },
  { 
    name: '목표', 
    href: '/goals', 
    icon: FlagIcon, 
    activeIcon: FlagIconSolid 
  },
  { 
    name: '프로필', 
    href: '/profile', 
    icon: UserIcon, 
    activeIcon: UserIconSolid 
  },
]

export default function MobileNavigation() {
  const pathname = usePathname()
  const router = useRouter()
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  const handleLoginClick = () => {
    router.push('/auth/login')
  }

  return (
    <nav 
      className="md:hidden fixed bottom-0 left-0 right-0 h-[60px] bg-card border-t border-border z-50"
      role="navigation"
      aria-label="워클리 모바일 네비게이션"
    >
      <div className="flex justify-between items-center h-full px-6">
        {navigationItems.map((item, index) => {
          const isActive = pathname === item.href || 
            (item.href !== '/' && pathname.startsWith(item.href))
          const Icon = isActive ? item.activeIcon : item.icon
          
          
          return (
            <Link
              key={item.name}
              href={item.href}
              className={`flex items-center justify-center flex-1 h-full transition-colors relative ${
                isActive 
                  ? 'text-foreground' 
                  : 'text-muted-foreground hover:text-foreground'
              }`}
              aria-label={item.name}
              aria-current={isActive ? 'page' : undefined}
            >
              <Icon className="w-6 h-6" />
              {/* CPER 워크플로우 중심 표시 */}
              {item.isCenter && (
                <div className="absolute top-2 right-1/2 translate-x-1/2 w-1.5 h-1.5 bg-amber-500 rounded-full animate-pulse"></div>
              )}
            </Link>
          )
        })}
      </div>
    </nav>
  )
}
</file>

<file path="docker-compose.yml">
services:
  # PostgreSQL 데이터베이스
  postgres:
    image: postgres:15-alpine
    container_name: workly-postgres
    environment:
      POSTGRES_DB: workly
      POSTGRES_USER: workly
      POSTGRES_PASSWORD: workly123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/database/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - workly-network

  # Redis (Socket.io Adapter용)
  redis:
    image: redis:7-alpine
    container_name: workly-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - workly-network

  # Backend (NestJS)
  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile
    container_name: workly-backend
    environment:
      - NODE_ENV=development
      - DATABASE_HOST=postgres
      - DATABASE_PORT=5432
      - DATABASE_NAME=workly
      - DATABASE_USERNAME=workly
      - DATABASE_PASSWORD=workly123
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=your-jwt-secret-key
      - GOOGLE_CLIENT_ID=your-google-client-id
      - GOOGLE_CLIENT_SECRET=your-google-client-secret
      - FRONTEND_URL=http://localhost:3000
    ports:
      - "8000:8000"
    volumes:
      - ./backend/uploads:/app/uploads
    depends_on:
      - postgres
      - redis
    networks:
      - workly-network
    restart: unless-stopped

  # Frontend (Next.js)
  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile
    container_name: workly-frontend
    environment:
      - NODE_ENV=development
      - NEXT_PUBLIC_API_URL=http://localhost:8000
      - NEXT_PUBLIC_SOCKET_URL=http://localhost:8000
    ports:
      - "3000:3000"
    depends_on:
      - backend
    networks:
      - workly-network
    restart: unless-stopped

  # MinIO (S3 호환 로컬 스토리지 - 개발용)
  minio:
    image: minio/minio:latest
    container_name: workly-minio
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin123
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    networks:
      - workly-network
    command: server /data --console-address ":9001"

  # Nginx (리버스 프록시)
  nginx:
    image: nginx:alpine
    container_name: workly-nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/sites-available:/etc/nginx/sites-available
    depends_on:
      - frontend
      - backend
    networks:
      - workly-network

volumes:
  postgres_data:
  redis_data:
  minio_data:

networks:
  workly-network:
    driver: bridge
</file>

<file path="frontend/src/app/projects/[id]/page.tsx">
'use client';

export const dynamic = 'force-dynamic'

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { 
  ArrowLeft, 
  Edit3, 
  Settings, 
  Users, 
  Calendar, 
  BarChart3, 
  Target,
  Clock,
  DollarSign,
  Tag,
  Archive,
  Trash2,
  Plus,
  Mail,
  Shield,
  Eye,
  X,
  UserMinus,
  MessageCircle,
  Hash
} from 'lucide-react';
// import { apiClient } from '@/lib/api'; // 목업 모드에서는 주석 처리
import MainContainer from '@/components/layout/MainContainer';
import { Project, UpdateProjectDto, ProjectStatus, ProjectPriority, ProjectVisibility, ProjectMember, ProjectMemberRole, AddProjectMemberDto } from '@/types/project.types';
import ProjectChatChannel from '@/components/projects/ProjectChatChannel';
import ProjectObjectiveManager from '@/components/projects/ProjectObjectiveManager';

// 멤버 관리 모달 컴포넌트
function MemberManagementModal({ 
  isOpen, 
  onClose, 
  project,
  onMemberAdded,
  onMemberRemoved 
}: { 
  isOpen: boolean; 
  onClose: () => void; 
  project: Project;
  onMemberAdded: () => void;
  onMemberRemoved: () => void;
}) {
  const [members, setMembers] = useState<ProjectMember[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isInviting, setIsInviting] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [inviteRole, setInviteRole] = useState<ProjectMemberRole>(ProjectMemberRole.MEMBER);

  // 멤버 목록 로드
  useEffect(() => {
    if (isOpen) {
      loadMembers();
    }
  }, [isOpen]);

  const loadMembers = async () => {
    try {
      setIsLoading(true);
      // 목업 멤버 데이터 사용
      await new Promise(resolve => setTimeout(resolve, 500));
      setMembers(project.members || []);
    } catch (error) {
      console.error('멤버 목록 로드 실패:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleInviteMember = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inviteEmail.trim()) return;

    try {
      setIsInviting(true);
      // 목업 멤버 초대 시뮬레이션
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log('멤버 초대:', { email: inviteEmail, role: inviteRole });
      alert(`${inviteEmail}에게 초대장을 보냈습니다! (목업 모드)`);
      
      setInviteEmail('');
      setInviteRole(ProjectMemberRole.MEMBER);
    } catch (error) {
      console.error('멤버 초대 실패:', error);
    } finally {
      setIsInviting(false);
    }
  };

  const handleRemoveMember = async (memberId: string) => {
    if (!confirm('정말로 이 멤버를 제거하시겠습니까?')) return;

    try {
      // 목업 멤버 제거 시뮬레이션
      await new Promise(resolve => setTimeout(resolve, 500));
      
      console.log('멤버 제거:', memberId);
      alert('멤버가 제거되었습니다! (목업 모드)');
      
      onMemberRemoved();
    } catch (error) {
      console.error('멤버 제거 실패:', error);
    }
  };

  const getRoleText = (role: ProjectMemberRole) => {
    switch (role) {
      case ProjectMemberRole.OWNER:
        return '소유자';
      case ProjectMemberRole.ADMIN:
        return '관리자';
      case ProjectMemberRole.MEMBER:
        return '멤버';
      case ProjectMemberRole.VIEWER:
        return '뷰어';
      default:
        return '멤버';
    }
  };

  const getRoleIcon = (role: ProjectMemberRole) => {
    switch (role) {
      case ProjectMemberRole.OWNER:
      case ProjectMemberRole.ADMIN:
        return <Shield className="w-4 h-4 text-yellow-500" />;
      case ProjectMemberRole.VIEWER:
        return <Eye className="w-4 h-4 text-gray-500" />;
      default:
        return <Users className="w-4 h-4 text-blue-500" />;
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="fixed inset-0 bg-black opacity-25" onClick={onClose} />
        <div className="relative bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden">
          {/* 헤더 */}
          <div className="flex items-center justify-between p-6 border-b border-gray-200">
            <div>
              <h3 className="text-lg font-semibold text-gray-900">팀 멤버 관리</h3>
              <p className="text-sm text-gray-500 mt-1">{project.title}</p>
            </div>
            <button
              onClick={onClose}
              className="p-2 hover:bg-gray-100 rounded-full"
            >
              <X className="w-5 h-5 text-gray-400" />
            </button>
          </div>

          <div className="overflow-y-auto max-h-[60vh]">
            {/* 멤버 초대 섹션 */}
            <div className="p-6 border-b border-gray-200">
              <h4 className="text-md font-medium text-gray-900 mb-4">새 멤버 초대</h4>
              <form onSubmit={handleInviteMember} className="space-y-4">
                <div className="grid grid-cols-3 gap-4">
                  <div className="col-span-2">
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      이메일 주소
                    </label>
                    <input
                      type="email"
                      value={inviteEmail}
                      onChange={(e) => setInviteEmail(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      placeholder="member@example.com"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      역할
                    </label>
                    <select
                      value={inviteRole}
                      onChange={(e) => setInviteRole(e.target.value as ProjectMemberRole)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    >
                      <option value={ProjectMemberRole.MEMBER}>멤버</option>
                      <option value={ProjectMemberRole.ADMIN}>관리자</option>
                      <option value={ProjectMemberRole.VIEWER}>뷰어</option>
                    </select>
                  </div>
                </div>
                <button
                  type="submit"
                  disabled={isInviting || !inviteEmail.trim()}
                  className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  <Mail className="w-4 h-4" />
                  <span>{isInviting ? '초대 중...' : '초대 보내기'}</span>
                </button>
              </form>
            </div>

            {/* 현재 멤버 목록 */}
            <div className="p-6">
              <h4 className="text-md font-medium text-gray-900 mb-4">
                현재 멤버 ({members.length}명)
              </h4>
              
              {isLoading ? (
                <div className="text-center py-8">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
                  <p className="text-gray-600 mt-2">멤버 목록을 불러오는 중...</p>
                </div>
              ) : members.length === 0 ? (
                <div className="text-center py-8">
                  <Users className="w-12 h-12 text-gray-400 mx-auto mb-3" />
                  <p className="text-gray-600">아직 멤버가 없습니다.</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {members.map((member) => (
                    <div
                      key={member.id}
                      className="flex items-center justify-between p-3 bg-gray-50 rounded-lg"
                    >
                      <div className="flex items-center space-x-3">
                        <div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                          <span className="text-sm font-medium text-blue-800">
                            {member.user.name.charAt(0).toUpperCase()}
                          </span>
                        </div>
                        <div>
                          <div className="flex items-center space-x-2">
                            <p className="font-medium text-gray-900">{member.user.name}</p>
                            {member.userId === project.ownerId && (
                              <span className="px-2 py-1 text-xs bg-yellow-100 text-yellow-800 rounded-full">
                                소유자
                              </span>
                            )}
                          </div>
                          <div className="flex items-center space-x-2 mt-1">
                            <p className="text-sm text-gray-600">{member.user.email}</p>
                            <div className="flex items-center space-x-1">
                              {getRoleIcon(member.role)}
                              <span className="text-xs text-gray-500">
                                {getRoleText(member.role)}
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      {member.userId !== project.ownerId && (
                        <button
                          onClick={() => handleRemoveMember(member.userId)}
                          className="p-2 text-red-600 hover:bg-red-50 rounded-full"
                          title="멤버 제거"
                        >
                          <UserMinus className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// 프로젝트 정보 사이드바 컴포넌트
function ProjectInfoSidebar({ 
  project, 
  onEdit,
  onProjectUpdate,
  onClose,
  isMobile = false
}: { 
  project: Project; 
  onEdit: () => void; 
  onProjectUpdate: () => void;
  onClose?: () => void;
  isMobile?: boolean;
}) {
  const [isMemberModalOpen, setIsMemberModalOpen] = useState(false);

  const getStatusColor = (status: ProjectStatus) => {
    switch (status) {
      case ProjectStatus.ACTIVE:
        return 'bg-green-100 text-green-800';
      case ProjectStatus.PLANNING:
        return 'bg-blue-100 text-blue-800';
      case ProjectStatus.COMPLETED:
        return 'bg-gray-100 text-gray-800';
      case ProjectStatus.ON_HOLD:
        return 'bg-yellow-100 text-yellow-800';
      case ProjectStatus.CANCELLED:
        return 'bg-red-100 text-red-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  const getStatusText = (status: ProjectStatus) => {
    switch (status) {
      case ProjectStatus.ACTIVE:
        return '진행중';
      case ProjectStatus.PLANNING:
        return '계획중';
      case ProjectStatus.COMPLETED:
        return '완료';
      case ProjectStatus.ON_HOLD:
        return '일시중단';
      case ProjectStatus.CANCELLED:
        return '취소됨';
      default:
        return '알 수 없음';
    }
  };

  const getPriorityColor = (priority: ProjectPriority) => {
    switch (priority) {
      case ProjectPriority.URGENT:
        return 'bg-red-100 text-red-800';
      case ProjectPriority.HIGH:
        return 'bg-orange-100 text-orange-800';
      case ProjectPriority.MEDIUM:
        return 'bg-yellow-100 text-yellow-800';
      case ProjectPriority.LOW:
        return 'bg-green-100 text-green-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  const getPriorityText = (priority: ProjectPriority) => {
    switch (priority) {
      case ProjectPriority.URGENT:
        return '긴급';
      case ProjectPriority.HIGH:
        return '높음';
      case ProjectPriority.MEDIUM:
        return '보통';
      case ProjectPriority.LOW:
        return '낮음';
      default:
        return '보통';
    }
  };

  return (
    <div className="w-full h-full bg-white flex flex-col">
      {/* 사이드바 콘텐츠 - 독립적인 스크롤 영역 */}
      <div className="flex-1 overflow-y-auto scrollbar-on-hover">
      {/* 사이드바 헤더 - 최신 트렌드 디자인 */}
      <div className="flex-shrink-0 bg-white">
        {/* 모바일 헤더 */}
        {isMobile && (
          <div className="flex items-center justify-between p-4 border-b border-gray-200">
            <div className="flex items-center space-x-3">
              <div>
                <h2 className="text-lg font-semibold text-gray-900">프로젝트 정보</h2>
                <p className="text-sm text-gray-500">상세 설정 및 관리</p>
              </div>
            </div>
            {onClose && (
              <button
                onClick={onClose}
                className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
                title="사이드바 닫기"
              >
                <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
            )}
          </div>
        )}
        
        {/* 데스크톱 헤더 */}
        {!isMobile && (
          <div className="p-6 border-b border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <h2 className="text-xl font-bold text-gray-900">프로젝트 정보</h2>
                <p className="text-sm text-gray-600 mt-1">프로젝트 상세 설정 및 관리</p>
              </div>
              <div className="flex items-center space-x-2">
                <button
                  onClick={onEdit}
                  className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-all duration-200 shadow-sm hover:shadow-md"
                >
                  <Edit3 className="w-4 h-4" />
                  <span className="font-medium">편집</span>
                </button>
                {onClose && (
                  <button
                    onClick={onClose}
                    className="p-2 hover:bg-gray-100 rounded-xl transition-colors group"
                    title="사이드바 닫기"
                  >
                    <svg className="w-5 h-5 text-gray-500 group-hover:text-gray-700 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                )}
              </div>
            </div>
          </div>
        )}
        
        {/* 모바일 편집 버튼 */}
        {isMobile && (
          <div className="p-4 border-b border-gray-100">
            <button
              onClick={onEdit}
              className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-all duration-200"
            >
              <Edit3 className="w-4 h-4" />
              <span className="font-medium">프로젝트 편집</span>
            </button>
          </div>
        )}
      </div>


        {/* 사이드바 콘텐츠 */}
        <div className={`${isMobile ? 'p-4 space-y-6' : 'p-6 space-y-8'}`}>
          {/* 목표 달성도 섹션 */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className={`font-bold text-gray-900 ${isMobile ? 'text-lg' : 'text-xl'}`}>
                목표 달성도
              </h3>
              <span className="text-xs text-gray-500 font-medium">실시간</span>
            </div>
            <div className="grid gap-3">
              <div className="group relative overflow-hidden rounded-xl border border-emerald-100 bg-gradient-to-br from-emerald-50 to-emerald-100/50 p-4 transition-all duration-200 hover:shadow-md">
                <div className="flex items-center justify-between">
                  <div>
                    <div className="font-semibold text-emerald-900">일정 준수</div>
                    <div className="mt-1 text-xs text-emerald-700">목표 대비 진행률</div>
                  </div>
                  <div className="text-right">
                    <div className="text-xl font-bold text-emerald-800">85%</div>
                    <div className="text-xs text-emerald-600">+5% ↗</div>
                  </div>
                </div>
                <div className="mt-3 h-1.5 overflow-hidden rounded-full bg-emerald-200">
                  <div className="h-full w-[85%] rounded-full bg-emerald-500 transition-all duration-500"></div>
                </div>
              </div>

              <div className="group relative overflow-hidden rounded-xl border border-blue-100 bg-gradient-to-br from-blue-50 to-blue-100/50 p-4 transition-all duration-200 hover:shadow-md">
                <div className="flex items-center justify-between">
                  <div>
                    <div className="font-semibold text-blue-900">품질 유지</div>
                    <div className="mt-1 text-xs text-blue-700">코드 리뷰 통과율</div>
                  </div>
                  <div className="text-right">
                    <div className="text-xl font-bold text-blue-800">92%</div>
                    <div className="text-xs text-blue-600">+2% ↗</div>
                  </div>
                </div>
                <div className="mt-3 h-1.5 overflow-hidden rounded-full bg-blue-200">
                  <div className="h-full w-[92%] rounded-full bg-blue-500 transition-all duration-500"></div>
                </div>
              </div>

              <div className="group relative overflow-hidden rounded-xl border border-amber-100 bg-gradient-to-br from-amber-50 to-amber-100/50 p-4 transition-all duration-200 hover:shadow-md">
                <div className="flex items-center justify-between">
                  <div>
                    <div className="font-semibold text-amber-900">예산 관리</div>
                    <div className="mt-1 text-xs text-amber-700">목표 예산 대비</div>
                  </div>
                  <div className="text-right">
                    <div className="text-xl font-bold text-amber-800">78%</div>
                    <div className="text-xs text-amber-600">-3% ↘</div>
                  </div>
                </div>
                <div className="mt-3 h-1.5 overflow-hidden rounded-full bg-amber-200">
                  <div className="h-full w-[78%] rounded-full bg-amber-500 transition-all duration-500"></div>
                </div>
              </div>
            </div>
          </div>

          {/* 목표 관리 섹션 */}
          <div className="space-y-4">
            <h3 className={`font-bold text-gray-900 ${isMobile ? 'text-lg' : 'text-xl'}`}>
              OKR 관리
            </h3>
            <div className="rounded-xl border border-gray-100 bg-white shadow-sm">
              <div className={`${isMobile ? 'h-[200px]' : 'h-[250px]'} overflow-y-auto scrollbar-on-hover`}>
                <ProjectObjectiveManager
                  project={project}
                  onObjectiveUpdate={(objectiveId, data) => {
                    console.log('목표 업데이트:', objectiveId, data)
                    // TODO: 실제 목표 업데이트 API 호출
                  }}
                  onKeyResultUpdate={(keyResultId, data) => {
                    console.log('핵심 결과 업데이트:', keyResultId, data)
                    // TODO: 실제 핵심 결과 업데이트 API 호출
                  }}
                  onObjectiveCreate={(data) => {
                    console.log('목표 생성:', data)
                    // TODO: 실제 목표 생성 API 호출
                  }}
                  onKeyResultCreate={(objectiveId, data) => {
                    console.log('핵심 결과 생성:', objectiveId, data)
                    // TODO: 실제 핵심 결과 생성 API 호출
                  }}
                />
              </div>
            </div>
          </div>

          {/* 프로젝트 상세 정보 */}
          <div className="space-y-4">
            <h3 className={`font-bold text-gray-900 ${isMobile ? 'text-lg' : 'text-xl'}`}>
              프로젝트 세부사항
            </h3>
            <div className="space-y-4">
              {/* 프로젝트 헤더 카드 */}
              <div className="rounded-xl border border-gray-100 bg-white p-4 shadow-sm">
                <div className="flex items-start space-x-4">
                  <div 
                    className="flex h-14 w-14 flex-shrink-0 items-center justify-center rounded-xl text-white font-bold text-lg shadow-md"
                    style={{ backgroundColor: project.color || '#3B82F6' }}
                  >
                    {project.icon || project.title.charAt(0).toUpperCase()}
                  </div>
                  <div className="flex-1 min-w-0">
                    <h2 className="text-lg font-bold text-gray-900 mb-2 truncate">{project.title}</h2>
                    {project.description && (
                      <p className="text-sm leading-relaxed text-gray-700 mb-3 line-clamp-2">{project.description}</p>
                    )}
                    <div className="flex flex-wrap gap-2">
                      <span className={`px-3 py-1.5 rounded-full text-xs font-semibold ${getStatusColor(project.status)}`}>
                        {getStatusText(project.status)}
                      </span>
                      <span className={`px-3 py-1.5 rounded-full text-xs font-semibold ${getPriorityColor(project.priority)}`}>
                        {getPriorityText(project.priority)}
                      </span>
                    </div>
                  </div>
                </div>
              </div>

              {/* 진행률 카드 */}
              <div className="rounded-xl border border-gray-100 bg-white p-4 shadow-sm">
                <div className="mb-3 flex items-center justify-between">
                  <h4 className="font-semibold text-gray-900">전체 진행률</h4>
                  <span className="text-2xl font-bold text-blue-600">{project.progress}%</span>
                </div>
                <div className="space-y-3">
                  <div className="h-3 overflow-hidden rounded-full bg-gray-100">
                    <div 
                      className="h-full rounded-full bg-gradient-to-r from-blue-500 to-blue-600 transition-all duration-700 ease-out" 
                      style={{ width: `${project.progress}%` }}
                    ></div>
                  </div>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div className="text-center">
                      <div className="flex items-center justify-center space-x-1 mb-1">
                        <BarChart3 className="w-4 h-4 text-gray-400" />
                        <span className="text-gray-600">총 작업</span>
                      </div>
                      <span className="text-xl font-bold text-gray-900">{project.taskCount || 0}</span>
                    </div>
                    <div className="text-center">
                      <div className="flex items-center justify-center space-x-1 mb-1">
                        <Target className="w-4 h-4 text-emerald-500" />
                        <span className="text-gray-600">완료</span>
                      </div>
                      <span className="text-xl font-bold text-emerald-600">{project.completedTaskCount || Math.floor((project.taskCount || 0) * (project.progress / 100))}</span>
                    </div>
                  </div>
                </div>
              </div>

              {/* 프로젝트 일정 및 예산 카드 */}
              <div className="rounded-xl border border-gray-100 bg-white p-4 shadow-sm">
                <h4 className="font-semibold text-gray-900 mb-3">일정 및 예산 정보</h4>
                <div className="space-y-4">
                  {/* 날짜 정보 */}
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="flex items-center space-x-2 mb-2">
                        <Calendar className="w-4 h-4 text-blue-500" />
                        <span className="text-sm font-medium text-gray-700">시작일</span>
                      </div>
                      <p className="text-sm font-bold text-gray-900">
                        {project.startDate ? new Date(project.startDate).toLocaleDateString('ko-KR') : '미설정'}
                      </p>
                    </div>
                    <div>
                      <div className="flex items-center space-x-2 mb-2">
                        <Clock className="w-4 h-4 text-red-500" />
                        <span className="text-sm font-medium text-gray-700">마감일</span>
                      </div>
                      <p className="text-sm font-bold text-gray-900">
                        {project.dueDate ? new Date(project.dueDate).toLocaleDateString('ko-KR') : '미설정'}
                      </p>
                      {project.dueDate && (
                        <div className="mt-1">
                          <span className="text-xs bg-red-50 text-red-600 px-2 py-1 rounded-full font-medium">
                            D-{Math.ceil((new Date(project.dueDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* 예산 정보 */}
                  {project.budget && (
                    <div>
                      <div className="flex items-center space-x-2 mb-2">
                        <DollarSign className="w-4 h-4 text-green-500" />
                        <span className="text-sm font-medium text-gray-700">프로젝트 예산</span>
                      </div>
                      <p className="text-lg font-bold text-green-600">
                        {new Intl.NumberFormat('ko-KR', {
                          style: 'currency',
                          currency: project.currency || 'KRW'
                        }).format(Number(project.budget))}
                      </p>
                    </div>
                  )}
                </div>
              </div>

              {/* 팀 멤버 카드 */}
              <div className="rounded-xl border border-gray-100 bg-white p-4 shadow-sm">
                <div className="flex items-center justify-between mb-3">
                  <h4 className="font-semibold text-gray-900">팀 멤버</h4>
                  <span className="rounded-full bg-blue-50 px-3 py-1 text-xs font-medium text-blue-600">
                    {project.members?.length || 0}명
                  </span>
                </div>
                <div className="space-y-3">
                  {(project.members || []).slice(0, 3).map((member, index) => (
                    <div key={member.id} className="flex items-center space-x-3">
                      <div className="relative">
                        <div className="flex h-10 w-10 items-center justify-center rounded-full bg-gradient-to-br from-blue-500 to-blue-600 text-white font-semibold text-sm shadow-sm">
                          {member.user.name.charAt(0)}
                        </div>
                        <div className="absolute -bottom-1 -right-1 h-3 w-3 rounded-full border-2 border-white bg-green-400"></div>
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center justify-between">
                          <p className="font-medium text-gray-900 truncate">{member.user.name}</p>
                          <span className="ml-2 rounded-full bg-gray-100 px-2 py-1 text-xs font-medium text-gray-600">
                            {member.role === ProjectMemberRole.OWNER ? '소유자' : 
                             member.role === ProjectMemberRole.ADMIN ? '관리자' : '멤버'}
                          </span>
                        </div>
                        <p className="text-xs text-gray-500 truncate">{member.user.email}</p>
                      </div>
                    </div>
                  ))}
                  {(project.members?.length || 0) > 3 && (
                    <div className="text-center">
                      <button className="text-sm text-blue-600 hover:text-blue-700 font-medium">
                        +{(project.members?.length || 0) - 3}명 더 보기
                      </button>
                    </div>
                  )}
                </div>
              </div>

              {/* 태그 카드 */}
              {project.tags && project.tags.length > 0 && (
                <div className="rounded-xl border border-gray-100 bg-white p-4 shadow-sm">
                  <div className="flex items-center space-x-2 mb-3">
                    <Tag className="w-4 h-4 text-purple-500" />
                    <h4 className="font-semibold text-gray-900">프로젝트 태그</h4>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    {project.tags.map((tag, index) => (
                      <span
                        key={index}
                        className="inline-flex items-center px-3 py-1.5 rounded-lg text-xs font-medium bg-purple-50 text-purple-700 border border-purple-200"
                      >
                        #{tag}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* 액션 버튼들 */}
          <div className="space-y-4">
            <h3 className={`font-bold text-gray-900 ${isMobile ? 'text-lg' : 'text-xl'}`}>
              프로젝트 관리
            </h3>
            <div className="rounded-xl border border-gray-100 bg-white shadow-sm overflow-hidden">
              <button 
                onClick={() => setIsMemberModalOpen(true)}
                className="w-full flex items-center space-x-3 p-4 text-left hover:bg-gray-50 transition-colors border-b border-gray-100"
              >
                <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-blue-50">
                  <Users className="w-5 h-5 text-blue-600" />
                </div>
                <div className="flex-1">
                  <p className="font-medium text-gray-900">팀 멤버 관리</p>
                  <p className="text-sm text-gray-500">멤버 추가, 제거 및 권한 설정</p>
                </div>
              </button>
              <button className="w-full flex items-center space-x-3 p-4 text-left hover:bg-gray-50 transition-colors border-b border-gray-100">
                <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-gray-50">
                  <Settings className="w-5 h-5 text-gray-600" />
                </div>
                <div className="flex-1">
                  <p className="font-medium text-gray-900">프로젝트 설정</p>
                  <p className="text-sm text-gray-500">워크플로우 및 고급 설정</p>
                </div>
              </button>
              <button className="w-full flex items-center space-x-3 p-4 text-left hover:bg-gray-50 transition-colors border-b border-gray-100">
                <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-amber-50">
                  <Archive className="w-5 h-5 text-amber-600" />
                </div>
                <div className="flex-1">
                  <p className="font-medium text-gray-900">프로젝트 보관</p>
                  <p className="text-sm text-gray-500">프로젝트를 보관함으로 이동</p>
                </div>
              </button>
              <button className="w-full flex items-center space-x-3 p-4 text-left hover:bg-red-50 transition-colors">
                <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-red-50">
                  <Trash2 className="w-5 h-5 text-red-600" />
                </div>
                <div className="flex-1">
                  <p className="font-medium text-red-700">프로젝트 삭제</p>
                  <p className="text-sm text-red-500">프로젝트를 영구적으로 삭제</p>
                </div>
              </button>
            </div>
          </div>

          {/* 하단 여백 */}
          <div className="h-4"></div>
        </div>

      {/* 멤버 관리 모달 */}
      <MemberManagementModal
        isOpen={isMemberModalOpen}
        onClose={() => setIsMemberModalOpen(false)}
        project={project}
        onMemberAdded={onProjectUpdate}
        onMemberRemoved={onProjectUpdate}
      />
      </div> {/* 사이드바 스크롤 영역 닫기 */}
    </div>
  );
}

// 프로젝트 상세 뷰 컴포넌트 (2단 레이아웃)
function ProjectDetailView({ 
  project, 
  onEdit,
  onProjectUpdate 
}: { 
  project: Project; 
  onEdit: () => void; 
  onProjectUpdate: () => void;
}) {
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const [isMobile, setIsMobile] = useState(false);
  const [touchStart, setTouchStart] = useState<number | null>(null);
  const [touchEnd, setTouchEnd] = useState<number | null>(null);

  // 모바일 감지
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
      // 모바일에서는 기본적으로 사이드바 닫힘
      if (window.innerWidth < 768) {
        setIsSidebarOpen(false);
      }
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // 터치 이벤트 핸들러 (메모화)
  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    setTouchEnd(null);
    setTouchStart(e.targetTouches[0].clientX);
  }, []);

  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    setTouchEnd(e.targetTouches[0].clientX);
  }, []);

  const handleTouchEnd = useCallback(() => {
    if (!touchStart || !touchEnd) return;
    
    const distance = touchStart - touchEnd;
    const isLeftSwipe = distance > 50;
    const isRightSwipe = distance < -50;

    if (isMobile) {
      if (isLeftSwipe && isSidebarOpen) {
        setIsSidebarOpen(false);
      }
      if (isRightSwipe && !isSidebarOpen) {
        setIsSidebarOpen(true);
      }
    }
  }, [touchStart, touchEnd, isMobile, isSidebarOpen]);

  // 사이드바 토글 핸들러 (메모화)
  const handleToggleSidebar = useCallback(() => {
    setIsSidebarOpen(!isSidebarOpen);
  }, [isSidebarOpen]);

  // 키보드 네비게이션 핸들러
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Escape' && isSidebarOpen) {
      setIsSidebarOpen(false);
    }
  }, [isSidebarOpen]);

  return (
    <div 
      className="h-screen h-screen-mobile bg-gray-50 relative overflow-hidden"
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onKeyDown={handleKeyDown}
      tabIndex={0}
      role="main"
      aria-label="프로젝트 상세 페이지"
    >
      {/* 좌측 메인 콘텐츠 (채팅) - 고정 위치 */}
      <div className="fixed inset-0 bg-white">
        <ProjectChatChannel
          project={project}
          members={project.members || []}
          isSidebarOpen={isSidebarOpen}
          isMobile={isMobile}
          onToggleSidebar={handleToggleSidebar}
          onTaskCreate={(taskData) => {
            console.log('새 업무 생성:', taskData)
            // TODO: 실제 업무 생성 API 호출
          }}
          onMilestoneCreate={(milestoneData) => {
            console.log('마일스톤 생성:', milestoneData)
            // TODO: 실제 마일스톤 생성 API 호출
          }}
          onUserDelegate={(delegationData) => {
            console.log('업무 재할당:', delegationData)
            // TODO: 실제 업무 재할당 API 호출
          }}
        />
      </div>

      {/* 모바일 오버레이 */}
      {isMobile && isSidebarOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden"
          onClick={() => setIsSidebarOpen(false)}
        />
      )}

      {/* 우측 사이드바 - 완전 고정 위치 */}
      <aside 
        className={`
          fixed top-0 bottom-0 right-0 z-45
          transition-all duration-300 ease-out
          ${isSidebarOpen ? 'translate-x-0 opacity-100' : 'translate-x-full opacity-0'}
          ${isMobile ? 'w-full' : 'w-[640px]'}
          bg-white border-l border-gray-200 shadow-2xl
        `}
        style={{
          transform: isSidebarOpen ? 'translateX(0%)' : 'translateX(100%)',
          transition: 'transform 400ms cubic-bezier(0.4, 0, 0.2, 1), opacity 300ms ease-out'
        }}
        role="complementary"
        aria-label="프로젝트 정보 사이드바"
        aria-hidden={!isSidebarOpen}
      >
        <ProjectInfoSidebar
          project={project}
          onEdit={onEdit}
          onProjectUpdate={onProjectUpdate}
          onClose={() => setIsSidebarOpen(false)}
          isMobile={isMobile}
        />
      </aside>
    </div>
  );
}

// 프로젝트 편집 폼 컴포넌트
function ProjectEditForm({ 
  project, 
  onSave, 
  onCancel 
}: { 
  project: Project; 
  onSave: (data: UpdateProjectDto) => Promise<void>; 
  onCancel: () => void; 
}) {
  const [formData, setFormData] = useState<UpdateProjectDto>({
    title: project.title,
    description: project.description || '',
    status: project.status,
    priority: project.priority,
    startDate: project.startDate ? new Date(project.startDate).toISOString().split('T')[0] : '',
    dueDate: project.dueDate ? new Date(project.dueDate).toISOString().split('T')[0] : '',
    budget: project.budget ? Number(project.budget) : undefined,
    currency: project.currency || 'KRW',
    color: project.color || '#3B82F6',
    tags: project.tags || [],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [tagInput, setTagInput] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.title?.trim()) return;

    setIsSubmitting(true);
    try {
      await onSave(formData);
    } catch (error) {
      console.error('프로젝트 수정 실패:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const addTag = () => {
    if (tagInput.trim() && !formData.tags?.includes(tagInput.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...(prev.tags || []), tagInput.trim()]
      }));
      setTagInput('');
    }
  };

  const removeTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags?.filter(tag => tag !== tagToRemove) || []
    }));
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 헤더 */}
      <div className="bg-white border-b border-gray-200">
        <div className="max-w-[720px] mx-auto px-0 md:px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <button
                onClick={onCancel}
                className="p-2 hover:bg-gray-100 rounded-lg"
              >
                <ArrowLeft className="w-5 h-5 text-gray-600" />
              </button>
              <div>
                <h1 className="text-xl font-semibold text-gray-900">프로젝트 편집</h1>
                <p className="text-sm text-gray-500 mt-1">{project.title}</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* 편집 폼 */}
      <main className="max-w-[720px] mx-auto px-0 md:px-6 py-6">
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* 기본 정보 */}
          <div className="bg-white rounded-lg border border-gray-200 p-6">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">기본 정보</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  프로젝트 이름 *
                </label>
                <input
                  type="text"
                  value={formData.title || ''}
                  onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  required
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  설명
                </label>
                <textarea
                  value={formData.description || ''}
                  onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  rows={3}
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    상태
                  </label>
                  <select
                    value={formData.status}
                    onChange={(e) => setFormData(prev => ({ ...prev, status: e.target.value as ProjectStatus }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  >
                    <option value={ProjectStatus.PLANNING}>계획중</option>
                    <option value={ProjectStatus.ACTIVE}>진행중</option>
                    <option value={ProjectStatus.ON_HOLD}>일시중단</option>
                    <option value={ProjectStatus.COMPLETED}>완료</option>
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    우선순위
                  </label>
                  <select
                    value={formData.priority}
                    onChange={(e) => setFormData(prev => ({ ...prev, priority: e.target.value as ProjectPriority }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  >
                    <option value={ProjectPriority.LOW}>낮음</option>
                    <option value={ProjectPriority.MEDIUM}>보통</option>
                    <option value={ProjectPriority.HIGH}>높음</option>
                    <option value={ProjectPriority.URGENT}>긴급</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          {/* 일정 및 예산 */}
          <div className="bg-white rounded-lg border border-gray-200 p-6">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">일정 및 예산</h3>
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    시작일
                  </label>
                  <input
                    type="date"
                    value={formData.startDate || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, startDate: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    마감일
                  </label>
                  <input
                    type="date"
                    value={formData.dueDate || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, dueDate: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
              </div>

              <div className="grid grid-cols-3 gap-4">
                <div className="col-span-2">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    예산
                  </label>
                  <input
                    type="number"
                    value={formData.budget || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, budget: e.target.value ? Number(e.target.value) : undefined }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="0"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    통화
                  </label>
                  <select
                    value={formData.currency || 'KRW'}
                    onChange={(e) => setFormData(prev => ({ ...prev, currency: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  >
                    <option value="KRW">KRW</option>
                    <option value="USD">USD</option>
                    <option value="EUR">EUR</option>
                    <option value="JPY">JPY</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          {/* 외관 설정 */}
          <div className="bg-white rounded-lg border border-gray-200 p-6">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">외관 설정</h3>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                프로젝트 색상
              </label>
              <div className="flex items-center space-x-3">
                <input
                  type="color"
                  value={formData.color || '#3B82F6'}
                  onChange={(e) => setFormData(prev => ({ ...prev, color: e.target.value }))}
                  className="w-12 h-12 border border-gray-300 rounded-lg"
                />
                <input
                  type="text"
                  value={formData.color || '#3B82F6'}
                  onChange={(e) => setFormData(prev => ({ ...prev, color: e.target.value }))}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="#3B82F6"
                />
              </div>
            </div>
          </div>

          {/* 태그 */}
          <div className="bg-white rounded-lg border border-gray-200 p-6">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">태그</h3>
            <div className="space-y-3">
              <div className="flex space-x-2">
                <input
                  type="text"
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), addTag())}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="태그 입력 후 Enter"
                />
                <button
                  type="button"
                  onClick={addTag}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  추가
                </button>
              </div>
              {formData.tags && formData.tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {formData.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="inline-flex items-center space-x-1 px-3 py-1 text-sm bg-blue-100 text-blue-800 rounded-full"
                    >
                      <span>{tag}</span>
                      <button
                        type="button"
                        onClick={() => removeTag(tag)}
                        className="text-blue-600 hover:text-blue-800"
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* 저장 버튼 */}
          <div className="flex space-x-3">
            <button
              type="button"
              onClick={onCancel}
              className="flex-1 px-4 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
            >
              취소
            </button>
            <button
              type="submit"
              disabled={isSubmitting || !formData.title?.trim()}
              className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
            >
              {isSubmitting ? '저장 중...' : '저장'}
            </button>
          </div>
        </form>
      </main>
    </div>
  );
}

export default function ProjectDetailPage() {
  const params = useParams();
  const router = useRouter();
  const [project, setProject] = useState<Project | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);

  // 프로젝트 데이터 로드
  useEffect(() => {
    loadProject();
  }, [params.id]);

  const loadProject = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // 목업 프로젝트 데이터 - 프로젝트 목록 페이지와 동일한 데이터 사용
      const mockProjects: { [key: string]: Project } = {
        '1': {
          id: '1',
          title: '워클리 MVP 개발',
          description: '비즈니스 성공을 위한 웹 애플리케이션 MVP 버전 개발',
          status: ProjectStatus.ACTIVE,
          priority: ProjectPriority.HIGH,
          progress: 75,
          memberCount: 4,
          taskCount: 23,
          completedTaskCount: 17,
          visibility: ProjectVisibility.TEAM,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: false,
            enableTimeTracking: true,
            enableBudgetTracking: false,
            enableNotifications: true
          },
          ownerId: 'user1',
          createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['React', 'TypeScript', 'NestJS', 'MVP'],
          color: '#3B82F6',
          icon: '🚀',
          owner: {
            id: 'user1',
            name: '김워클리',
            email: 'kim@workly.com'
          },
          objectives: [
            {
              id: 'obj1',
              title: '사용자 인증 시스템 구축',
              description: 'Google OAuth 기반 로그인 시스템',
              completed: true,
              completedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'obj2', 
              title: '프로젝트 관리 기능 완성',
              description: '프로젝트 CRUD 및 협업 기능',
              completed: false
            }
          ],
          keyResults: [
            {
              id: 'kr1',
              objectiveId: 'obj1',
              title: '로그인 성공률',
              description: 'Google OAuth 로그인 성공률 95% 이상',
              targetValue: 95,
              currentValue: 98,
              unit: '%',
              completed: true,
              completedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'kr2',
              objectiveId: 'obj2',
              title: '프로젝트 생성 기능',
              description: '사용자가 프로젝트를 생성할 수 있는 기능',
              targetValue: 100,
              currentValue: 80,
              unit: '%',
              completed: false
            },
            {
              id: 'kr3',
              objectiveId: 'obj2',
              title: '실시간 채팅 구현',
              description: 'Socket.io 기반 실시간 메시징',
              targetValue: 100,
              currentValue: 60,
              unit: '%',
              completed: false
            }
          ],
          completedObjectiveCount: 1,
          completedKeyResultCount: 1,
          members: [
            {
              id: 'member1',
              projectId: '1',
              userId: 'user1',
              role: ProjectMemberRole.OWNER,
              permissions: ['read', 'write', 'admin'],
              joinedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
              user: {
                id: 'user1',
                name: '김워클리',
                email: 'kim@workly.com'
              }
            },
            {
              id: 'member2',
              projectId: '1',
              userId: 'user2',
              role: ProjectMemberRole.ADMIN,
              permissions: ['read', 'write'],
              joinedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
              user: {
                id: 'user2',
                name: '박개발자',
                email: 'park@workly.com'
              }
            },
            {
              id: 'member3',
              projectId: '1',
              userId: 'user3',
              role: ProjectMemberRole.MEMBER,
              permissions: ['read'],
              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
              user: {
                id: 'user3',
                name: '이디자이너',
                email: 'lee@workly.com'
              }
            },
            {
              id: 'member4',
              projectId: '1',
              userId: 'user4',
              role: ProjectMemberRole.MEMBER,
              permissions: ['read'],
              joinedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
              user: {
                id: 'user4',
                name: '정기획자',
                email: 'jung@workly.com'
              }
            }
          ],
          startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
          budget: 50000000,
          currency: 'KRW'
        },
        '2': {
          id: '2',
          title: 'AI 챗봇 개발',
          description: '고객 지원을 위한 AI 기반 챗봇 시스템 구축',
          status: ProjectStatus.ACTIVE,
          priority: ProjectPriority.MEDIUM,
          progress: 45,
          memberCount: 1,
          taskCount: 15,
          completedTaskCount: 7,
          visibility: ProjectVisibility.TEAM,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: true,
            enableTimeTracking: true,
            enableBudgetTracking: true,
            enableNotifications: true
          },
          ownerId: 'user5',
          createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['AI', 'Python', 'TensorFlow', '챗봇'],
          color: '#10B981',
          icon: '🤖',
          owner: {
            id: 'user5',
            name: '최AI연구자',
            email: 'choi@workly.com'
          },
          objectives: [
            {
              id: 'obj3',
              title: 'NLP 모델 학습',
              description: '한국어 자연어 처리 모델 개발',
              completed: false
            }
          ],
          keyResults: [
            {
              id: 'kr4',
              objectiveId: 'obj3',
              title: '모델 정확도',
              description: '질문 응답 정확도 90% 달성',
              targetValue: 90,
              currentValue: 72,
              unit: '%',
              completed: false
            }
          ],
          completedObjectiveCount: 0,
          completedKeyResultCount: 0,
          members: [
            {
              id: 'member5',
              projectId: '2',
              userId: 'user5',
              role: ProjectMemberRole.OWNER,
              permissions: ['read', 'write', 'admin'],
              joinedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
              user: {
                id: 'user5',
                name: '최AI연구자',
                email: 'choi@workly.com'
              }
            }
          ]
        }
      };

      // API 호출 시뮬레이션을 위한 지연
      await new Promise(resolve => setTimeout(resolve, 1000));

      const projectId = params.id as string;
      const foundProject = mockProjects[projectId];
      
      if (!foundProject) {
        throw new Error('프로젝트를 찾을 수 없습니다.');
      }

      setProject(foundProject);
    } catch (err) {
      console.error('프로젝트 로드 실패:', err);
      setError(err instanceof Error ? err.message : '프로젝트를 불러오는데 실패했습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSaveProject = async (updateData: UpdateProjectDto) => {
    try {
      // 목업 프로젝트 수정 시뮬레이션
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log('프로젝트 수정 데이터:', updateData);
      
      // 목업에서는 실제로 업데이트하지 않고 성공 메시지만 표시
      alert('프로젝트가 성공적으로 수정되었습니다! (목업 모드)');
      
      setIsEditing(false);
    } catch (err) {
      console.error('프로젝트 수정 실패:', err);
      throw err;
    }
  };

  // 로딩 상태
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">프로젝트를 불러오는 중...</p>
        </div>
      </div>
    );
  }

  // 오류 상태
  if (error || !project) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <p className="text-red-600 mb-4">{error || '프로젝트를 찾을 수 없습니다.'}</p>
          <div className="space-x-4">
            <button
              onClick={loadProject}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              다시 시도
            </button>
            <button
              onClick={() => router.push('/projects')}
              className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
            >
              프로젝트 목록으로
            </button>
          </div>
        </div>
      </div>
    );
  }

  // 편집 모드
  if (isEditing) {
    return (
      <ProjectEditForm
        project={project}
        onSave={handleSaveProject}
        onCancel={() => setIsEditing(false)}
      />
    );
  }

  // 상세 보기 모드
  return (
    <ProjectDetailView
      project={project}
      onEdit={() => setIsEditing(true)}
      onProjectUpdate={loadProject}
    />
  );
}
</file>

<file path="frontend/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* MDXEditor CSS */
@import '@mdxeditor/editor/style.css';

/* PRD 명세: Pretendard 폰트 시스템 적용 */
@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css');

/* 모바일 viewport 및 스크롤 최적화 */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
  .pb-safe {
    padding-bottom: env(safe-area-inset-bottom);
  }
}

/* 
 * 글로벌 스크롤바 숨김 정책
 * 모든 요소의 스크롤바를 기본적으로 숨기고
 * 필요한 곳에서만 scrollbar-on-hover 클래스로 선택적 표시
 */
* {
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

*::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

/* 
 * 스크롤할 때만 표시되는 스크롤바
 * 호버, 포커스, 스크롤 시에만 표시
 * 모든 주요 브라우저 지원 (Chrome, Safari, Firefox, Edge)
 */
.scrollbar-on-hover {
  scrollbar-width: thin; /* Firefox */
  scrollbar-color: transparent transparent; /* Firefox */
  transition: scrollbar-color 0.3s ease;
  -ms-overflow-style: auto; /* IE/Edge 복원 */
}

.scrollbar-on-hover:hover,
.scrollbar-on-hover:focus-within,
.scrollbar-on-hover.scrolling {
  scrollbar-width: thin;
  scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
}

.scrollbar-on-hover::-webkit-scrollbar {
  width: 6px;
  height: 6px;
  display: block;
}

.scrollbar-on-hover::-webkit-scrollbar-track {
  background: transparent;
}

.scrollbar-on-hover::-webkit-scrollbar-thumb {
  background: transparent;
  border-radius: 3px;
  transition: background 0.3s ease;
}

.scrollbar-on-hover:hover::-webkit-scrollbar-thumb,
.scrollbar-on-hover:focus-within::-webkit-scrollbar-thumb,
.scrollbar-on-hover.scrolling::-webkit-scrollbar-thumb {
  background: rgba(156, 163, 175, 0.5);
}

.scrollbar-on-hover:hover::-webkit-scrollbar-thumb:hover,
.scrollbar-on-hover:focus-within::-webkit-scrollbar-thumb:hover,
.scrollbar-on-hover.scrolling::-webkit-scrollbar-thumb:hover {
  background: rgba(107, 114, 128, 0.7);
}

/* 레거시 커스텀 스크롤바 (호환성용) */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: rgba(156, 163, 175, 0.5);
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: rgba(107, 114, 128, 0.7);
}

/* 모바일 터치 최적화 */
.touch-manipulation {
  touch-action: manipulation;
  -webkit-user-select: none;
  user-select: none;
}

/* iOS Safari viewport 이슈 해결 */
@supports (-webkit-appearance: none) {
  .h-screen-mobile {
    height: 100vh;
    height: -webkit-fill-available;
  }
}

/* 스크롤 상태 유틸리티 클래스 */
.scroll-container {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.scroll-container::-webkit-scrollbar {
  display: none;
}

/* 스크롤 인디케이터 (필요시 사용) */
.scroll-indicator {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 50%;
  background: rgba(156, 163, 175, 0.3);
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.scroll-container.scrolling .scroll-indicator {
  opacity: 1;
}

/* 커스텀 z-index 클래스 */
.z-45 {
  z-index: 45;
}

.z-55 {
  z-index: 55;
}

.z-60 {
  z-index: 60;
}

@layer base {
  :root {
    /* PRD 명세: 워클리 전역 색상 시스템 */
    --primary: 37 99 235; /* #2563eb (blue-600) - Primary */
    --primary-hover: 29 78 216; /* #1d4ed8 (blue-700) - Primary Hover */
    --primary-light: 219 234 254; /* #dbeafe (blue-100) - Primary Light */
    --text-main: 17 24 39; /* #111827 (gray-900) - Text Main */
    --text-secondary: 107 114 128; /* #6b7280 (gray-500) - Text Secondary */
    --background: 249 250 251; /* #f9fafb (gray-50) - Background */
    --border: 229 231 235; /* #e5e7eb (gray-200) - Border */
    --success: 5 150 105; /* #059669 (green-600) - Success */
    --warning: 217 119 6; /* #d97706 (amber-600) - Warning */
    --error: 220 38 38; /* #dc2626 (red-600) - Error */
    
    /* 기존 shadcn/ui 호환성 유지 */
    --foreground: var(--text-main);
    --card: 255 255 255; /* #FFFFFF */
    --card-foreground: var(--text-main);
    --primary-foreground: 255 255 255; /* #FFFFFF */
    --secondary: var(--primary-light);
    --secondary-foreground: var(--primary);
    --muted: var(--background);
    --muted-foreground: var(--text-secondary);
    --accent: var(--primary-light);
    --accent-foreground: var(--primary);
    --destructive: var(--error);
    --destructive-foreground: 255 255 255; /* #FFFFFF */
    --input: var(--border);
    --ring: var(--primary);
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    /* PRD 명세: Pretendard 폰트 적용 */
    font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  }
  
  /* 접근성을 위한 스크린 리더 전용 텍스트 */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
  
  /* 포커스 표시 개선 */
  *:focus-visible {
    outline: 2px solid rgb(0 0 0 / var(--tw-text-opacity, 1));
    outline-offset: 2px;
  }
  
  /* 고대비 모드 지원 */
  @media (prefers-contrast: high) {
    * {
      border-color: currentColor !important;
    }
  }
  
  /* 감소된 모션 설정 지원 */
  @media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }
}

/* PRD 명세: 워클리 전역 UI/UX 시스템 */
@layer components {
  .nav-item {
    @apply flex items-center justify-center rounded-xl cursor-pointer transition-colors;
    @apply hover:bg-blue-50 text-gray-500 hover:text-blue-600;
    width: 60px;
    height: 60px;
  }
  
  .nav-item.active {
    @apply bg-blue-100 text-blue-600;
  }
  
  /* PRD 명세: Card 컴포넌트 - 미니멀 디자인 */
  .workly-card {
    @apply rounded-lg bg-white border border-gray-100 p-4;
  }
  
  /* PRD 수정: List Card - 목록 아이템들을 위한 컨테이너 카드 - 미니멀 디자인 */
  .workly-list-card {
    @apply rounded-lg bg-white border border-gray-100;
  }
  
  /* PRD 명세: Button 컴포넌트 */
  .workly-button {
    @apply rounded-md font-semibold px-4 py-2;
    @apply bg-blue-600 text-white hover:bg-blue-700;
    @apply transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500;
  }
  
  .workly-button-outline {
    @apply rounded-md font-semibold px-4 py-2;
    @apply border border-gray-200 bg-white hover:bg-gray-50 text-gray-900;
    @apply transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500;
  }
  
  /* PRD 명세: Filter Chip 컴포넌트 */
  .workly-filter-chip {
    @apply rounded-full bg-gray-100 text-gray-700 px-3 py-1 text-sm;
    @apply transition-colors cursor-pointer hover:bg-gray-200;
  }
  
  .workly-filter-chip.active {
    @apply bg-blue-100 text-blue-700;
  }
  
  /* PRD 명세: 타이포그래피 시스템 */
  .workly-page-title {
    @apply text-2xl font-bold text-gray-900; /* 24px, Bold (700) */
  }
  
  .workly-card-title {
    @apply text-lg font-semibold text-gray-900; /* 18px, SemiBold (600) */
  }
  
  .workly-body {
    @apply text-base font-normal text-gray-900; /* 16px, Regular (400) */
  }
  
  .workly-caption {
    @apply text-sm font-normal text-gray-500; /* 14px, Regular (400) */
  }
  
  /* 텍스트 클램핑 유틸리티 */
  .line-clamp-1 {
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  
  .line-clamp-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
}

/* 마크다운 에디터 워클리 스타일 커스터마이징 */
.w-md-editor {
  background-color: transparent !important;
}

.w-md-editor-text-container,
.w-md-editor-text-input,
.w-md-editor-text-area {
  font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
  font-size: 14px !important;
  line-height: 1.5 !important;
}

.w-md-editor-toolbar {
  background-color: #f9fafb !important;
  border-bottom: 1px solid #e5e7eb !important;
}

.w-md-editor-toolbar button {
  color: #6b7280 !important;
}

.w-md-editor-toolbar button:hover {
  background-color: #e5e7eb !important;
  color: #2563eb !important;
}

.w-md-editor-text {
  background-color: white !important;
  border: none !important;
}

.w-md-editor-text-container .w-md-editor-text-input,
.w-md-editor-text-container .w-md-editor-text-area {
  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}

.w-md-editor-text-container .w-md-editor-text-area:focus {
  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}

/* MDXEditor 워클리 스타일 커스터마이징 */
.mdxeditor {
  background-color: white !important;
  font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
}

.mdxeditor-toolbar {
  background-color: #f9fafb !important;
  border-bottom: 1px solid #e5e7eb !important;
  padding: 8px 12px !important;
}

.mdxeditor-toolbar button {
  color: #6b7280 !important;
  border-radius: 6px !important;
  padding: 6px 8px !important;
}

.mdxeditor-toolbar button:hover {
  background-color: #e5e7eb !important;
  color: #2563eb !important;
}

.mdxeditor-toolbar button[data-state="on"] {
  background-color: #dbeafe !important;
  color: #2563eb !important;
}

.mdxeditor-rich-text-editor {
  font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
  font-size: 14px !important;
  line-height: 1.6 !important;
}

.mdxeditor-rich-text-editor h1 {
  font-size: 1.875rem !important;
  font-weight: 700 !important;
  margin-top: 1.5rem !important;
  margin-bottom: 1rem !important;
}

.mdxeditor-rich-text-editor h2 {
  font-size: 1.5rem !important;
  font-weight: 600 !important;
  margin-top: 1.25rem !important;
  margin-bottom: 0.75rem !important;
}

.mdxeditor-rich-text-editor h3 {
  font-size: 1.25rem !important;
  font-weight: 600 !important;
  margin-top: 1rem !important;
  margin-bottom: 0.5rem !important;
}

.mdxeditor-rich-text-editor p {
  margin-bottom: 1rem !important;
}

.mdxeditor-rich-text-editor ul,
.mdxeditor-rich-text-editor ol {
  margin-bottom: 1rem !important;
  padding-left: 1.5rem !important;
}

.mdxeditor-rich-text-editor li {
  margin-bottom: 0.25rem !important;
}

.mdxeditor-rich-text-editor blockquote {
  border-left: 4px solid #2563eb !important;
  background-color: #f8fafc !important;
  padding: 1rem !important;
  margin: 1rem 0 !important;
  font-style: italic !important;
}

.mdxeditor-rich-text-editor code {
  background-color: #f1f5f9 !important;
  padding: 0.125rem 0.25rem !important;
  border-radius: 0.25rem !important;
  font-size: 0.875rem !important;
}

.mdxeditor-rich-text-editor pre {
  background-color: #1e293b !important;
  color: #e2e8f0 !important;
  padding: 1rem !important;
  border-radius: 0.5rem !important;
  overflow-x: auto !important;
  margin: 1rem 0 !important;
}

.mdxeditor-rich-text-editor a {
  color: #2563eb !important;
  text-decoration: underline !important;
}

.mdxeditor-rich-text-editor a:hover {
  color: #1d4ed8 !important;
}
</file>

<file path="frontend/src/components/navigation/LeftNavigation.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import Link from 'next/link'
import { usePathname, useRouter } from 'next/navigation'
import { 
  Squares2X2Icon,
  FolderIcon,
  InboxIcon,
  FlagIcon,
  UserIcon,
  Bars3Icon 
} from '@heroicons/react/24/outline'
import { 
  Squares2X2Icon as Squares2X2IconSolid,
  FolderIcon as FolderIconSolid,
  InboxIcon as InboxIconSolid,
  FlagIcon as FlagIconSolid,
  UserIcon as UserIconSolid 
} from '@heroicons/react/24/solid'
import { isAuthenticated, logout } from '@/lib/auth'
import CPERModal from '@/components/inbox/CPERModal'

// 워클리 고유 방법론 - 5개 핵심 네비게이션 항목
const navigationItems = [
  { 
    name: '업무', 
    href: '/', 
    icon: Squares2X2Icon, 
    activeIcon: Squares2X2IconSolid 
  },
  { 
    name: '프로젝트', 
    href: '/projects', 
    icon: FolderIcon, 
    activeIcon: FolderIconSolid 
  },
  { 
    name: '수집함', 
    href: '/inbox', 
    icon: InboxIcon, 
    activeIcon: InboxIconSolid,
    isCenter: true, // CPER 워크플로우 중심
    isModal: true // 모달로 열기
  },
  { 
    name: '목표', 
    href: '/goals', 
    icon: FlagIcon, 
    activeIcon: FlagIconSolid 
  },
  { 
    name: '프로필', 
    href: '/profile', 
    icon: UserIcon, 
    activeIcon: UserIconSolid 
  },
]

export default function LeftNavigation() {
  const pathname = usePathname()
  const router = useRouter()
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const [isLoggedIn, setIsLoggedIn] = useState(false)
  const [isInboxModalOpen, setIsInboxModalOpen] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  const handleLoginClick = () => {
    router.push('/auth/login')
    setIsMenuOpen(false)
  }

  const handleLogoutClick = async () => {
    try {
      await logout()
      setIsLoggedIn(false)
      setIsMenuOpen(false)
      router.push('/auth/login')
    } catch (error) {
      console.error('로그아웃 오류:', error)
    }
  }

  const handleSettingsClick = () => {
    router.push('/settings')
    setIsMenuOpen(false)
  }

  const handleBoardClick = (section?: string) => {
    if (section) {
      router.push(`/board?section=${encodeURIComponent(section)}`)
    } else {
      router.push('/board')
    }
    setIsMenuOpen(false)
  }

  const handleInboxClick = () => {
    setIsInboxModalOpen(true)
  }

  const handleInboxModalClose = () => {
    setIsInboxModalOpen(false)
  }

  // 바깥 클릭 시 메뉴 닫기
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsMenuOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  return (
    <nav 
      className="hidden md:flex fixed left-0 top-0 h-screen w-[76px] bg-background border-r border-border flex-col items-center py-5 z-50"
      role="navigation"
      aria-label="워클리 메인 네비게이션"
    >
      {/* 로고 */}
      <div className="mb-10">
        <Link 
          href="/" 
          className="flex items-center justify-center w-8 h-8 font-bold text-xl text-foreground"
          aria-label="워클리 홈으로 이동"
        >
          W
        </Link>
      </div>

      {/* 메뉴 항목들 */}
      <div className="flex flex-col items-center gap-2 flex-1 justify-center">
        {navigationItems.map((item) => {
          const isActive = pathname === item.href || 
            (item.href !== '/' && pathname.startsWith(item.href))
          const Icon = isActive ? item.activeIcon : item.icon
          
          // 수집함은 모달로 처리
          if (item.isModal) {
            return (
              <button
                key={item.name}
                onClick={handleInboxClick}
                className={`nav-item ${
                  item.isCenter ? 'relative' : ''
                }`}
                title={item.name}
                aria-label={item.name}
              >
                <Icon className="w-6 h-6" />
                {/* CPER 워크플로우 중심 표시 */}
                {item.isCenter && (
                  <div className="absolute -top-1 -right-1 w-2 h-2 bg-amber-500 rounded-full animate-pulse"></div>
                )}
                <span className="sr-only">{item.name}</span>
              </button>
            )
          }
          
          return (
            <Link
              key={item.name}
              href={item.href}
              className={`nav-item ${isActive ? 'active' : ''} ${
                item.isCenter ? 'relative' : ''
              }`}
              title={item.name}
              aria-label={item.name}
              aria-current={isActive ? 'page' : undefined}
            >
              <Icon className="w-6 h-6" />
              {/* CPER 워크플로우 중심 표시 */}
              {item.isCenter && (
                <div className="absolute -top-1 -right-1 w-2 h-2 bg-amber-500 rounded-full animate-pulse"></div>
              )}
              <span className="sr-only">{item.name}</span>
            </Link>
          )
        })}
      </div>

      {/* 햄버거 메뉴 */}
      <div className="mb-5 relative" ref={menuRef}>
        <button 
          onClick={() => setIsMenuOpen(!isMenuOpen)}
          className="nav-item" 
          title="메뉴"
          aria-label="메뉴"
          aria-expanded={isMenuOpen}
          aria-haspopup="true"
        >
          <Bars3Icon className="w-6 h-6" />
          <span className="sr-only">메뉴</span>
        </button>
        
        {isMenuOpen && (
          <div 
            className="absolute left-full bottom-0 ml-2 bg-card border border-border rounded-xl shadow-lg min-w-48 py-2 z-50"
            role="menu"
            aria-label="메뉴 옵션"
          >
            {/* 게시판 섹션 */}
            <div className="px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider border-b border-border">
              게시판
            </div>
            <button 
              onClick={() => handleBoardClick()}
              className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
              role="menuitem"
            >
              전체 게시판
            </button>
            <button 
              onClick={() => handleBoardClick('임무 게시판')}
              className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
              role="menuitem"
            >
              임무 게시판
            </button>
            <button 
              onClick={() => handleBoardClick('지식 위키')}
              className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
              role="menuitem"
            >
              지식 위키
            </button>
            <button 
              onClick={() => handleBoardClick('프로젝트 쇼케이스')}
              className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
              role="menuitem"
            >
              프로젝트 쇼케이스
            </button>
            
            {/* 구분선 */}
            <div className="border-t border-border my-2"></div>
            
            {/* 계정 섹션 */}
            <div className="px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider">
              계정
            </div>
            <button 
              onClick={handleSettingsClick}
              className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
              role="menuitem"
            >
              설정
            </button>
            {isLoggedIn ? (
              <button 
                onClick={handleLogoutClick}
                className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                role="menuitem"
              >
                로그아웃
              </button>
            ) : (
              <button 
                onClick={handleLoginClick}
                className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                role="menuitem"
              >
                로그인
              </button>
            )}
          </div>
        )}
      </div>

      {/* CPER 수집함 모달 */}
      <CPERModal
        isOpen={isInboxModalOpen}
        onClose={handleInboxModalClose}
        onTaskCreated={(task) => {
          console.log('CPER 업무 생성:', task)
          // TODO: 실제 업무 생성 로직 구현
        }}
        onInboxItemCreated={(inboxItem) => {
          console.log('빠른 수집:', inboxItem)
          // TODO: 실제 수집함 아이템 생성 로직 구현
        }}
      />
    </nav>
  )
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dev-debug.log

# Dependency directories
node_modules/
*/node_modules/

# Build outputs
dist/
*/dist/
.next/
*/.next/
build/
*/build/
coverage/
*/coverage/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# OS specific
.DS_Store
Thumbs.db

# Test outputs
*.tsbuildinfo
test-results/
playwright-report/

# Storybook
storybook-static/

# TypeScript
*.tsbuildinfo

# Database
*.sqlite
*.db

# Docker
docker-compose.override.yml

# mcp
.mcp.json

# Temporary files
*.tmp
*.tempfrontend/.next

# 기타 추가
.next
.vercel
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

- 클로드는 오지훈 워클리 대표님에게 복종한다.
- 토큰을 함부로 낭비하지 않는다.
- 지시를 받으면 이해한 게 맞는지 확인을 받고 수행한다.
- 지시한 업무는 임의로 중단하지 않고 끝까지 수행한다.
- 함부로 지시사항을 축소하지 않는다.
- 한국어로 소통한다.
- 반드시 대답한다. 수행이 우선이 아니라 소통이 우선이다.
- AI는 사람과의 소통에서 감정이나 의도를 완벽하게 알 수 없으므로 주의를 기울여 소통한다.
- 내가 직접 명령어를 입력하지 않더라도 `/sc` 명령어와 태그를 조합하여 상황에 맞게 SuperClaude 기능을 활용한다.
- 대표님은 비개발자이므로 개발 경험이 없다.
- 클로드는 코딩실력도 좋고 아는 게 많기 때문에, 이 프로젝트를 맡은 수석책임개발자로서 더 좋은 방식을 제안하고,
- 전체 구조를 분석해서 불필요한 게 없는지 수시로 확인한다.

## 프로젝트 개요

워클리(Workly)는 CPER 워크플로우를 기반으로 한 혁신적인 업무 관리 플랫폼입니다. 기존의 복잡한 GTD와 OKR 방법론을 단순화하고 통합하여 **워클리 고유 방법론**을 제공합니다.

### CPER 워크플로우
- **C**apture (수집): 모든 아이디어와 업무를 수집함에 저장
- **P**lan (계획): 수집된 항목을 목표, 프로젝트, 업무로 분류  
- **E**xecute (실행): 오늘의 업무에 집중하여 생산성 극대화
- **R**eview (검토): 주간 성과를 분석하고 개선점 도출

### 5개 핵심 네비게이션
1. **업무** (`/`): 오늘 할 일과 실행 대시보드
2. **프로젝트** (`/projects`): 협업 프로젝트 관리  
3. **수집함** (`/inbox`): CPER 시작점, 모든 것을 수집
4. **목표** (`/goals`): 장기 목표 설정 및 추적
5. **프로필** (`/profile`): 개인 설정 및 주간 리뷰

## 개발 원칙

- **단순성 추구**: 복잡한 기존 방법론 대신 직관적이고 단순한 구조
- **한국어 소통**: 모든 커뮤니케이션은 한국어로 진행
- **시각적 우선**: 눈으로 볼 수 있는 결과물을 가장 빠르게 제공

## 개발 제약사항

- **서버 실행 금지**: 절대로 서버를 직접 실행하지 않음
- **명령 기반**: 사용자 명령이 있을 때만 개발 진행
- **파일 작업 순서 준수**: Write나 Edit 전에 반드시 Read 먼저 실행 (절대 예외 없음)

## 기술 스택

### Frontend
- **Next.js 14+**: React 기반 풀스택 프레임워크
- **TypeScript**: 타입 안전성
- **Tailwind CSS**: 유틸리티 우선 CSS
- **Zustand**: 상태 관리

### Backend
- **NestJS**: Node.js 확장 가능한 프레임워크
- **TypeORM**: TypeScript ORM
- **PostgreSQL**: 관계형 데이터베이스
- **Socket.io**: 실시간 통신
- **JWT + Google OAuth**: 인증 시스템

## 프로젝트 구조

```
/Workly
├── frontend/         # Next.js + TypeScript + Tailwind CSS
├── backend/          # NestJS + TypeORM + PostgreSQL
├── shared/           # 공유 타입 및 상수
├── docs/             # 프로젝트 문서
└── docker-compose.yml # 개발 환경
```

자세한 구조는 [PROJECT_STRUCTURE.md](./PROJECT_STRUCTURE.md) 참조

## 개발 명령어

```bash
# 전체 개발 환경 실행 (Docker)
docker-compose up -d

# 프론트엔드만 실행
cd frontend && npm run dev

# 백엔드만 실행
cd backend && npm run start:dev

# 빌드
cd frontend && npm run build
cd backend && npm run build
```

## 깃 자동화 방안

### 자동 커밋 전략
- **개발 완료 시점**: 시각적으로 확인 가능한 결과물 완성 후 자동 커밋
- **커밋 메시지**: 작업 내용을 명확히 표현하는 한국어 메시지
- **브랜치 전략**: main 브랜치에서 직접 작업 (단순한 구조 유지)

### 자동화 명령어
```bash
# 변경사항 확인
git status
git diff

# 모든 변경사항 스테이징
git add .

# 자동 커밋 (작업 내용에 맞는 메시지)
git commit -m "작업내용: 구체적인 설명

🤖 Generated with Claude Code

Co-Authored-By: Claude <noreply@anthropic.com>"

# 원격 저장소 푸시 (필요시)
git push origin main
```

### 커밋 시점
- CLAUDE.md 파일 수정 완료
- 프로젝트 초기 설정 완료
- 각 기능 구현 완료
- 목업 디자인 완료
- 사용자가 요청한 작업 완료

## 워클리 비즈니스 이해

워클리의 비즈니스 성공을 위해 사용자 경험과 비즈니스 가치를 최우선으로 고려하여 개발합니다.

## Task Master AI Instructions
**Import Task Master's development workflow commands and guidelines, treat as if import is in the main CLAUDE.md file.**
@./.taskmaster/CLAUDE.md
</file>

<file path="frontend/src/components/layout/Header.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { ChevronDownIcon, Bars3Icon, MagnifyingGlassIcon } from '@heroicons/react/24/outline'
import { isAuthenticated, logout, getCurrentUser } from '@/lib/auth'

interface FilterOption {
  key: string
  label: string
  count?: number
}

interface HeaderProps {
  title: string
  showDropdown?: boolean
  dropdownItems?: string[]
  onDropdownItemClick?: (item: string) => void
  // 새로운 필터 시스템 props
  filterOptions?: FilterOption[]
  activeFilter?: string
  onFilterChange?: (filter: string) => void
  showMobileFilters?: boolean
  // 검색 기능 props
  searchQuery?: string
  onSearchChange?: (query: string) => void
}

export default function Header({ 
  title, 
  showDropdown = false, 
  dropdownItems = [],
  onDropdownItemClick,
  filterOptions = [],
  activeFilter = '',
  onFilterChange,
  showMobileFilters = false,
  searchQuery = '',
  onSearchChange
}: HeaderProps) {
  const router = useRouter()
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false)
  const [isSearchDropdownOpen, setIsSearchDropdownOpen] = useState(false)
  const [isLoggedIn, setIsLoggedIn] = useState(false)
  const [user, setUser] = useState(null)
  const dropdownRef = useRef<HTMLDivElement>(null)
  const mobileMenuRef = useRef<HTMLDivElement>(null)
  const searchDropdownRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
    setUser(getCurrentUser())
  }, [])

  const handleLoginClick = () => {
    router.push('/auth/login')
  }

  const handleLogoutClick = async () => {
    try {
      await logout()
      setIsLoggedIn(false)
      setUser(null)
      setIsMobileMenuOpen(false)
      router.push('/auth/login')
    } catch (error) {
      console.error('로그아웃 오류:', error)
    }
  }

  const handleSettingsClick = () => {
    router.push('/settings')
    setIsMobileMenuOpen(false)
  }

  const handleBoardClick = (section?: string) => {
    if (section) {
      router.push(`/board?section=${encodeURIComponent(section)}`)
    } else {
      router.push('/board')
    }
    setIsMobileMenuOpen(false)
  }

  const handleDesktopSearchClick = () => {
    setIsSearchDropdownOpen(!isSearchDropdownOpen)
  }

  const handleMobileSearchClick = () => {
    router.push('/search')
  }

  // 바깥 클릭 시 메뉴 닫기
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false)
      }
      if (mobileMenuRef.current && !mobileMenuRef.current.contains(event.target as Node)) {
        setIsMobileMenuOpen(false)
      }
      if (searchDropdownRef.current && !searchDropdownRef.current.contains(event.target as Node)) {
        setIsSearchDropdownOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  // 필터 시스템이 있을 때 헤더 높이 조정
  const headerHeight = showMobileFilters ? 'min-h-[60px]' : 'h-[60px]'
  
  return (
    <header 
      className={`sticky top-0 ${headerHeight} bg-background z-40 w-full`}
      role="banner"
    >
      {/* 720px 제약된 헤더 콘텐츠 */}
      <div className="w-full max-w-[720px] mx-auto h-[60px] flex items-center px-6 md:px-0 relative">
        {/* 모바일 레이아웃 */}
        <div className="md:hidden w-full flex items-center justify-between">
          {/* 햄버거 메뉴 */}
          <div className="relative" ref={mobileMenuRef}>
            <button
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
              className="flex items-center justify-center w-8 h-8 text-muted-foreground hover:text-foreground transition-colors"
              aria-label="메뉴"
              aria-expanded={isMobileMenuOpen}
              aria-haspopup="true"
            >
              <Bars3Icon className="w-5 h-5" />
              <span className="sr-only">메뉴</span>
            </button>
            
            {isMobileMenuOpen && (
              <div 
                className="absolute top-full left-0 mt-2 bg-card border border-border rounded-xl shadow-lg min-w-48 py-2 z-50"
                role="menu"
                aria-label="메뉴 옵션"
              >
                {/* 게시판 섹션 */}
                <div className="px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider border-b border-border">
                  게시판
                </div>
                <button 
                  onClick={() => handleBoardClick()}
                  className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                  role="menuitem"
                >
                  전체 게시판
                </button>
                <button 
                  onClick={() => handleBoardClick('임무 게시판')}
                  className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                  role="menuitem"
                >
                  임무 게시판
                </button>
                <button 
                  onClick={() => handleBoardClick('지식 위키')}
                  className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                  role="menuitem"
                >
                  지식 위키
                </button>
                <button 
                  onClick={() => handleBoardClick('프로젝트 쇼케이스')}
                  className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                  role="menuitem"
                >
                  프로젝트 쇼케이스
                </button>
                
                {/* 구분선 */}
                <div className="border-t border-border my-2"></div>
                
                {/* 계정 섹션 */}
                <div className="px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider">
                  계정
                </div>
                <button 
                  onClick={handleSettingsClick}
                  className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                  role="menuitem"
                >
                  설정
                </button>
                {isLoggedIn ? (
                  <button 
                    onClick={handleLogoutClick}
                    className="w-full text-left px-4 py-3 text-sm text-foreground hover:bg-accent cursor-pointer transition-colors"
                    role="menuitem"
                  >
                    로그아웃
                  </button>
                ) : (
                  <button 
                    onClick={handleLoginClick}
                    className="w-full text-left px-4 py-3 text-sm font-semibold text-blue-600 hover:bg-blue-50 cursor-pointer transition-colors relative"
                    role="menuitem"
                  >
                    <span className="flex items-center">
                      로그인
                      <span className="ml-2 w-2 h-2 bg-blue-500 rounded-full animate-pulse"></span>
                    </span>
                  </button>
                )}
              </div>
            )}
          </div>

          {/* 로고 */}
          <div className="flex items-center justify-center w-8 h-8 font-bold text-xl text-foreground">
            W
          </div>

          {/* 검색 아이콘 (우측) */}
          <button
            onClick={handleMobileSearchClick}
            className="flex items-center justify-center w-8 h-8 text-muted-foreground hover:text-foreground transition-colors"
            aria-label="검색"
          >
            <MagnifyingGlassIcon className="w-5 h-5" />
            <span className="sr-only">검색</span>
          </button>
        </div>

        {/* 데스크톱 레이아웃 */}
        <div className="hidden md:flex w-full items-center">
          {/* 왼쪽: 검색 아이콘 */}
          <div className="relative" ref={searchDropdownRef}>
            <button
              onClick={handleDesktopSearchClick}
              className="flex items-center justify-center w-8 h-8 text-muted-foreground hover:text-foreground transition-colors"
              aria-label="검색"
              aria-expanded={isSearchDropdownOpen}
              aria-haspopup="true"
            >
              <MagnifyingGlassIcon className="w-5 h-5" />
              <span className="sr-only">검색</span>
            </button>
            
            {/* 검색 드롭다운 */}
            {isSearchDropdownOpen && (
              <div 
                className="absolute top-full left-0 mt-2 bg-card border border-border rounded-xl shadow-lg w-80 py-3 px-4 z-50"
                role="menu"
                aria-label="검색"
              >
                <div className="mb-3">
                  <div className="relative">
                    <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
                    <input
                      type="text"
                      placeholder="업무, 프로젝트, 게시글 통합검색..."
                      value={searchQuery}
                      onChange={(e) => onSearchChange?.(e.target.value)}
                      className="w-full pl-10 pr-4 py-2 text-sm bg-gray-50 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      autoFocus
                    />
                  </div>
                </div>
                <div className="text-xs text-gray-500 mb-2">빠른 검색</div>
                <div className="space-y-1">
                  <button className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-lg">
                    📋 내 업무
                  </button>
                  <button className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-lg">
                    🚀 진행 중 프로젝트
                  </button>
                  <button className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-lg">
                    📝 최근 게시글
                  </button>
                </div>
              </div>
            )}
          </div>

          {/* 중앙: 타이틀 */}
          <div className="flex-1 flex items-center justify-center">
            <h1 className="workly-page-title">{title}</h1>
          </div>

          {/* 오른쪽: 빈 공간 */}
          <div className="flex items-center">
            {/* 로그인 버튼은 헤더 바깥(각 페이지)에 배치 */}
          </div>
        </div>
      </div>
    </header>
  )
}
</file>

<file path="frontend/src/app/projects/page.tsx">
'use client';

export const dynamic = 'force-dynamic'

import React, { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Plus, Search, Filter, Grid3X3, List, Calendar, Folder, Users, BarChart3, MessageCircle, Target, TrendingUp, UserPlus, Star, CheckCircle2 } from 'lucide-react';
import Header from '@/components/layout/Header';
import MainContainer from '@/components/layout/MainContainer';
import SimpleFilterChips from '@/components/ui/SimpleFilterChips';
import WorklyFloatingActionButton from '@/components/ui/WorklyFloatingActionButton';
import LoginBanner from '@/components/ui/LoginBanner';
import { isAuthenticated } from '@/lib/auth';
// import { apiClient } from '@/lib/api'; // 목업 모드에서는 주석 처리
import { 
  Project, 
  CreateProjectDto, 
  ProjectQueryDto, 
  PaginatedResponse,
  ProjectStatus,
  ProjectPriority,
  ProjectVisibility
} from '@/types/project.types';

// 향상된 프로젝트 카드 컴포넌트 (섹션 3 - 채팅 우선 협업 허브)
function ProjectCard({ project, onClick }: { project: Project; onClick: () => void }) {
  // OKR 진행률 계산 (목업 데이터)
  const completedObjectives = project.completedObjectiveCount || Math.floor(Math.random() * 3);
  const totalObjectives = project.objectives?.length || Math.floor(Math.random() * 3) + 2;
  const completedKeyResults = project.completedKeyResultCount || Math.floor(Math.random() * 5);
  const totalKeyResults = project.keyResults?.length || Math.floor(Math.random() * 6) + 3;
  
  // 최근 채팅 활동 (목업 데이터)
  const mockActivities = [
    { user: '김개발자', content: '/add-task UI 컴포넌트 완성', timestamp: '2분 전' },
    { user: '박디자이너', content: '목업 디자인 검토 완료했습니다', timestamp: '5분 전' },
    { user: '이매니저', content: '/set-milestone 베타 출시 2024-02-15', timestamp: '10분 전' },
    { user: '최기획자', content: '요구사항 문서 업데이트했습니다', timestamp: '15분 전' },
    { user: '정개발자', content: 'API 개발 진행상황 공유드려요', timestamp: '30분 전' }
  ];
  
  const recentChatActivity = {
    lastMessage: mockActivities[Math.floor(Math.random() * mockActivities.length)],
    unreadCount: Math.floor(Math.random() * 8) + 1
  };

  // 모집 상태 (목업 데이터) - 프로젝트 ID 기반으로 일관된 데이터 생성
  const memberCount = project.memberCount || (parseInt(project.id) % 6) + 2; // 2-7명 사이
  const maxMembers = 6; // 최대 팀 크기
  const isRecruiting = memberCount < maxMembers;
  const availableSlots = maxMembers - memberCount;
  
  // 업무 개수도 더 현실적으로
  const taskCount = project.taskCount || (parseInt(project.id) % 15) + 5; // 5-19개 업무

  return (
    <div 
      className="p-6 hover:bg-gray-50 transition-all duration-200 cursor-pointer group"
      onClick={onClick}
    >
      {/* 프로젝트 헤더 */}
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center space-x-3 flex-1">
          <div 
            className="w-12 h-12 rounded-lg flex items-center justify-center text-white font-semibold relative"
            style={{ backgroundColor: project.color || '#3B82F6' }}
          >
            {project.icon || project.title.charAt(0).toUpperCase()}
            {/* 활성 채팅 인디케이터 */}
            {recentChatActivity.unreadCount > 0 && (
              <div className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white text-xs rounded-full flex items-center justify-center">
                {recentChatActivity.unreadCount}
              </div>
            )}
          </div>
          <div className="flex-1">
            <div className="flex items-center space-x-2 mb-1">
              <h3 className="font-semibold text-gray-900">{project.title}</h3>
              {isRecruiting && (
                <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  <UserPlus className="w-3 h-3 mr-1" />
                  모집중
                </span>
              )}
              {project.status === 'completed' && (
                <CheckCircle2 className="w-4 h-4 text-green-600" />
              )}
            </div>
            <p className="text-sm text-gray-500 line-clamp-2">{project.description}</p>
          </div>
        </div>
      </div>

      {/* 최근 채팅 활동 */}
      <div className="mb-4 p-3 bg-gray-50 rounded-lg">
        <div className="flex items-center space-x-2 mb-2">
          <MessageCircle className="w-4 h-4 text-blue-600" />
          <span className="text-sm font-medium text-gray-700">최근 활동</span>
          <span className="text-xs text-gray-500">{recentChatActivity.lastMessage.timestamp}</span>
        </div>
        <div className="text-sm text-gray-600">
          <span className="font-medium">{recentChatActivity.lastMessage.user}:</span>
          <span className="ml-2">{recentChatActivity.lastMessage.content}</span>
        </div>
      </div>

      {/* OKR 진행률 섹션 */}
      <div className="mb-4">
        <div className="flex items-center justify-between text-sm mb-2">
          <div className="flex items-center space-x-2">
            <Target className="w-4 h-4 text-purple-600" />
            <span className="text-gray-600">OKR 진행률</span>
          </div>
          <span className="font-medium">{totalKeyResults > 0 ? Math.round((completedKeyResults / totalKeyResults) * 100) : project.progress || 0}%</span>
        </div>
        
        {/* 전체 진행률 바 */}
        <div className="w-full bg-gray-200 rounded-full h-2 mb-2">
          <div 
            className="bg-gradient-to-r from-blue-600 to-purple-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${totalKeyResults > 0 ? Math.round((completedKeyResults / totalKeyResults) * 100) : project.progress || 0}%` }}
          />
        </div>
        
        {/* 세부 OKR 지표 */}
        <div className="grid grid-cols-2 gap-2 text-xs">
          <div className="flex items-center justify-between">
            <span className="text-gray-500">목표</span>
            <span className="font-medium">{completedObjectives}/{totalObjectives}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-gray-500">핵심결과</span>
            <span className="font-medium">{completedKeyResults}/{totalKeyResults}</span>
          </div>
        </div>
      </div>

      {/* 팀 정보 & 메타데이터 */}
      <div className="flex items-center justify-between text-sm mb-3">
        <div className="flex items-center space-x-4 text-gray-500">
          <div className="flex items-center space-x-1">
            <Users className="w-4 h-4" />
            <span>{memberCount}명</span>
            {isRecruiting && (
              <span className="text-green-600 text-xs">({availableSlots}자리)</span>
            )}
          </div>
          <div className="flex items-center space-x-1">
            <BarChart3 className="w-4 h-4" />
            <span>{taskCount}개 업무</span>
          </div>
          <div className="flex items-center space-x-1">
            <TrendingUp className="w-4 h-4" />
            <span className="text-green-600">+12%</span>
          </div>
        </div>
        <div className={`px-2 py-1 rounded-full text-xs font-medium ${
          project.status === 'active' ? 'bg-green-100 text-green-800' :
          project.status === 'planning' ? 'bg-blue-100 text-blue-800' :
          project.status === 'completed' ? 'bg-gray-100 text-gray-800' :
          'bg-yellow-100 text-yellow-800'
        }`}>
          {project.status === 'active' ? '진행중' :
           project.status === 'planning' ? '계획중' :
           project.status === 'completed' ? '완료' : '일시중단'}
        </div>
      </div>

      {/* 태그 */}
      {project.tags.length > 0 && (
        <div className="flex flex-wrap gap-1">
          {project.tags.slice(0, 3).map((tag, index) => (
            <span
              key={index}
              className="inline-block px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full"
            >
              {tag}
            </span>
          ))}
          {project.tags.length > 3 && (
            <span className="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded-full">
              +{project.tags.length - 3}
            </span>
          )}
        </div>
      )}

      {/* 호버 시 액션 버튼 */}
      <div className="mt-4 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
        <div className="flex space-x-2">
          <button 
            onClick={(e) => {
              e.stopPropagation();
              console.log('채팅으로 이동');
            }}
            className="flex-1 flex items-center justify-center space-x-1 px-3 py-2 text-sm bg-blue-50 text-blue-600 rounded-lg hover:bg-blue-100"
          >
            <MessageCircle className="w-4 h-4" />
            <span>채팅</span>
          </button>
          <button 
            onClick={(e) => {
              e.stopPropagation();
              console.log('목표 관리로 이동');
            }}
            className="flex-1 flex items-center justify-center space-x-1 px-3 py-2 text-sm bg-purple-50 text-purple-600 rounded-lg hover:bg-purple-100"
          >
            <Target className="w-4 h-4" />
            <span>목표</span>
          </button>
          {isRecruiting && (
            <button 
              onClick={(e) => {
                e.stopPropagation();
                console.log('팀 모집 신청');
              }}
              className="flex items-center justify-center px-3 py-2 text-sm bg-green-50 text-green-600 rounded-lg hover:bg-green-100"
            >
              <UserPlus className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
}


export default function ProjectsPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [projects, setProjects] = useState<Project[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState(searchQuery);
  const [currentFilter, setCurrentFilter] = useState('all');
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  
  // 필터 설정 상태
  const [showOnlyMyProjects, setShowOnlyMyProjects] = useState(false)
  const [projectSortOrder, setProjectSortOrder] = useState('recent')
  const [showCompletedProjects, setShowCompletedProjects] = useState(true)

  // 로그인 상태 초기화
  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])


  // 동적 헤더 타이틀
  const getHeaderTitle = () => {
    return currentFilter
  }

  // 사용자가 입력을 멈췄을 때만 API 요청을 보내도록 검색어를 디바운싱합니다.
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchQuery(searchQuery);
    }, 300); // 300ms 지연

    return () => clearTimeout(timer);
  }, [searchQuery]);


  // 프로젝트 로드
  useEffect(() => {
    loadProjects();
  }, [currentFilter, debouncedSearchQuery]);

  const loadProjects = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 목업 프로젝트 데이터 생성
      const mockProjects: Project[] = [
        {
          id: '1',
          title: '워클리 MVP 개발',
          description: '비즈니스 성공을 위한 웹 애플리케이션 MVP 버전 개발',
          status: ProjectStatus.ACTIVE,
          priority: ProjectPriority.HIGH,
          progress: 75,
          memberCount: 4,
          taskCount: 23,
          completedTaskCount: 17,
          visibility: ProjectVisibility.TEAM,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: false,
            enableTimeTracking: true,
            enableBudgetTracking: false,
            enableNotifications: true
          },
          ownerId: 'user1',
          createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['React', 'TypeScript', 'NestJS', 'MVP'],
          color: '#3B82F6',
          icon: '🚀',
          owner: {
            id: 'user1',
            name: '김워클리',
            email: 'kim@workly.com'
          },
          members: [],
          objectives: [
            {
              id: 'obj1',
              title: '사용자 인증 시스템 구축',
              description: 'Google OAuth 기반 로그인 시스템',
              completed: true,
              completedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'obj2', 
              title: '프로젝트 관리 기능 완성',
              description: '프로젝트 CRUD 및 협업 기능',
              completed: false
            }
          ],
          keyResults: [
            {
              id: 'kr1',
              objectiveId: 'obj1',
              title: '로그인 성공률',
              description: 'Google OAuth 로그인 성공률 95% 이상',
              targetValue: 95,
              currentValue: 98,
              unit: '%',
              completed: true,
              completedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'kr2',
              objectiveId: 'obj2',
              title: '프로젝트 생성 기능',
              description: '사용자가 프로젝트를 생성할 수 있는 기능',
              targetValue: 100,
              currentValue: 80,
              unit: '%',
              completed: false
            },
            {
              id: 'kr3',
              objectiveId: 'obj2',
              title: '실시간 채팅 구현',
              description: 'Socket.io 기반 실시간 메시징',
              targetValue: 100,
              currentValue: 60,
              unit: '%',
              completed: false
            }
          ],
          completedObjectiveCount: 1,
          completedKeyResultCount: 1
        },
        {
          id: '2',
          title: 'AI 챗봇 개발',
          description: '고객 지원을 위한 AI 기반 챗봇 시스템 구축',
          status: ProjectStatus.ACTIVE,
          priority: ProjectPriority.MEDIUM,
          progress: 45,
          memberCount: 3,
          taskCount: 15,
          completedTaskCount: 6,
          visibility: ProjectVisibility.TEAM,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: true,
            enableTimeTracking: true,
            enableBudgetTracking: true,
            enableNotifications: true
          },
          ownerId: 'user2',
          createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['AI', 'Python', 'TensorFlow', '챗봇'],
          color: '#10B981',
          icon: '🤖',
          owner: {
            id: 'user2',
            name: '이개발',
            email: 'lee@workly.com'
          },
          members: [],
          objectives: [
            {
              id: 'obj3',
              title: 'NLP 모델 학습',
              description: '한국어 자연어 처리 모델 개발',
              completed: false
            }
          ],
          keyResults: [
            {
              id: 'kr4',
              objectiveId: 'obj3',
              title: '모델 정확도',
              description: '질문 응답 정확도 90% 달성',
              targetValue: 90,
              currentValue: 72,
              unit: '%',
              completed: false
            }
          ],
          completedObjectiveCount: 0,
          completedKeyResultCount: 0
        },
        {
          id: '3',
          title: '모바일 앱 리뉴얼',
          description: '기존 모바일 앱의 UI/UX 전면 개선',
          status: ProjectStatus.PLANNING,
          priority: ProjectPriority.MEDIUM,
          progress: 15,
          memberCount: 2,
          taskCount: 8,
          completedTaskCount: 1,
          visibility: ProjectVisibility.PRIVATE,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: false,
            enableTimeTracking: false,
            enableBudgetTracking: false,
            enableNotifications: true
          },
          ownerId: 'user3',
          createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['React Native', 'UI/UX', '모바일'],
          color: '#8B5CF6',
          icon: '📱',
          owner: {
            id: 'user3',
            name: '박디자인',
            email: 'park@workly.com'
          },
          members: [],
          objectives: [
            {
              id: 'obj4',
              title: '디자인 시스템 구축',
              description: '일관된 UI 컴포넌트 라이브러리',
              completed: false
            }
          ],
          keyResults: [
            {
              id: 'kr5',
              objectiveId: 'obj4',
              title: '컴포넌트 개수',
              description: '재사용 가능한 UI 컴포넌트 50개',
              targetValue: 50,
              currentValue: 12,
              unit: '개',
              completed: false
            }
          ],
          completedObjectiveCount: 0,
          completedKeyResultCount: 0
        },
        {
          id: '4',
          title: 'E-커머스 플랫폼',
          description: '온라인 쇼핑몰 풀스택 개발',
          status: ProjectStatus.ACTIVE,
          priority: ProjectPriority.HIGH,
          progress: 88,
          memberCount: 6,
          taskCount: 42,
          completedTaskCount: 37,
          visibility: ProjectVisibility.TEAM,
          isArchived: false,
          isTemplate: false,
          settings: {
            allowGuestAccess: false,
            requireApprovalForTasks: true,
            enableTimeTracking: true,
            enableBudgetTracking: true,
            enableNotifications: true
          },
          ownerId: 'user4',
          createdAt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString(),
          updatedAt: new Date().toISOString(),
          tags: ['Next.js', 'Stripe', '결제', '쇼핑몰'],
          color: '#F59E0B',
          owner: {
            id: 'user4',
            name: '최커머스',
            email: 'choi@workly.com'
          },
          members: [],
          icon: '🛒',
          objectives: [
            {
              id: 'obj5',
              title: '결제 시스템 통합',
              description: 'Stripe 기반 안전한 결제 처리',
              completed: true,
              completedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'obj6',
              title: '상품 관리 시스템',
              description: '관리자용 상품 CRUD 시스템',
              completed: true,
              completedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
            }
          ],
          keyResults: [
            {
              id: 'kr6',
              objectiveId: 'obj5',
              title: '결제 성공률',
              description: '결제 프로세스 성공률 99% 이상',
              targetValue: 99,
              currentValue: 99.2,
              unit: '%',
              completed: true,
              completedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
            },
            {
              id: 'kr7',
              objectiveId: 'obj6',
              title: '상품 등록 속도',
              description: '상품 등록 프로세스 30초 이내',
              targetValue: 30,
              currentValue: 25,
              unit: '초',
              completed: true,
              completedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()
            }
          ],
          completedObjectiveCount: 2,
          completedKeyResultCount: 2
        }
      ];

      // 필터링 적용
      let filteredProjects = mockProjects;
      
      if (debouncedSearchQuery) {
        filteredProjects = filteredProjects.filter(project =>
          project.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||
          project.description?.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||
          project.tags.some(tag => tag.toLowerCase().includes(debouncedSearchQuery.toLowerCase()))
        );
      }

      // SimpleFilterChips 필터링 로직
      switch (currentFilter) {
        case 'active':
          filteredProjects = filteredProjects.filter(project => project.status === ProjectStatus.ACTIVE);
          break;
        case 'recruiting':
          filteredProjects = filteredProjects.filter(project => project.isRecruiting);
          break;
        case 'completed':
          filteredProjects = filteredProjects.filter(project => project.status === ProjectStatus.COMPLETED);
          break;
        case 'all':
        default:
          // 전체 프로젝트는 추가 필터링 없음
          break;
      }

      // 실제 API 호출 시뮬레이션을 위한 지연
      await new Promise(resolve => setTimeout(resolve, 800));

      setProjects(filteredProjects);

    } catch (err) {
      console.error('프로젝트 로드 실패:', err);
      setError('프로젝트를 불러오는데 실패했습니다.');
      setProjects([]);
    } finally {
      setIsLoading(false);
    }
  };


  const handleFilterChange = (filter: string) => {
    setCurrentFilter(filter);
  };

  // const filteredProjects = projects.filter(project =>
  //  project.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
  //  project.description?.toLowerCase().includes(searchQuery.toLowerCase())
  //);

  return (
    <div className="min-h-screen">
      {/* 헤더 */}
      <Header 
        title={getHeaderTitle()}
      />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 동적 필터 칩 관리자 - 로그인된 사용자만 표시 */}
        {isLoggedIn && (
          <div className="mb-0">
            <SimpleFilterChips
              options={[
                { 
                  key: 'all',
                  label: '전체 프로젝트',
                  count: projects.length
                },
                { 
                  key: 'active',
                  label: '진행 중',
                  count: projects.filter(p => p.status === ProjectStatus.ACTIVE).length
                },
                { 
                  key: 'recruiting',
                  label: '모집 중',
                  count: projects.filter(p => p.isRecruiting).length
                },
                { 
                  key: 'completed',
                  label: '완료됨',
                  count: projects.filter(p => p.status === ProjectStatus.COMPLETED).length
                }
              ]}
              activeFilters={[currentFilter]}
              onFilterChange={(filters) => setCurrentFilter(filters[0] || 'all')}
              settings={{
                title: "프로젝트 필터 설정",
                settings: [
                  {
                    key: 'myOnly',
                    label: '내가 참여한 프로젝트만',
                    type: 'toggle',
                    value: showOnlyMyProjects,
                    onChange: setShowOnlyMyProjects
                  },
                  {
                    key: 'sort',
                    label: '정렬 기준',
                    type: 'select',
                    value: projectSortOrder,
                    options: ['recent', 'progress', 'deadline', 'members'],
                    onChange: setProjectSortOrder
                  }
                ]
              }}
            />
          </div>
        )}
          

        {/* 오류 표시 */}
        {error && (
          <div className="bg-red-50 border border-red-200 p-4">
            <p className="text-red-600">{error}</p>
            <button
              onClick={loadProjects}
              className="mt-2 text-red-600 underline hover:no-underline"
            >
              다시 시도
            </button>
          </div>
        )}

        {/* 로딩 */}
        {isLoading ? (
          <div>
            {[...Array(3)].map((_, index) => (
              <div key={index} className="bg-white border border-gray-200 p-6">
                <div className="animate-pulse">
                  <div className="flex items-center space-x-3 mb-4">
                    <div className="w-12 h-12 bg-gray-200"></div>
                    <div className="flex-1">
                      <div className="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
                      <div className="h-3 bg-gray-200 rounded w-3/4"></div>
                    </div>
                  </div>
                  <div className="h-2 bg-gray-200 rounded w-full mb-4"></div>
                  <div className="flex space-x-4">
                    <div className="h-4 bg-gray-200 rounded w-16"></div>
                    <div className="h-4 bg-gray-200 rounded w-16"></div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : projects.length === 0 ? (
          <div className="text-center">
            <Folder className="w-16 h-16 text-gray-400 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-gray-900 mb-2">
              {searchQuery ? '검색 결과 없음' : '프로젝트 없음'}
            </h3>
            <p className="text-gray-500 mb-4">
              {searchQuery 
                ? '검색 조건에 맞는 프로젝트가 없습니다.' 
                : '우측 하단의 수집함 버튼(+)을 눌러 프로젝트를 추가해보세요!'}
            </p>
          </div>
        ) : (
          <div className="bg-white border border-gray-200 overflow-hidden">
            {/* 모집 중 프로젝트 배너 (모집 중 필터일 때만 표시) */}
            {currentFilter === '멤버 모집 중' && (
              <div className="bg-gradient-to-r from-green-50 to-blue-50 border-b border-gray-100 p-6">
                <div className="flex items-center space-x-3 mb-3">
                  <UserPlus className="w-6 h-6 text-green-600" />
                  <h3 className="text-lg font-semibold text-green-800">멤버를 모집 중인 프로젝트</h3>
                </div>
                <p className="text-green-700 mb-4">
                  새로운 팀원을 찾고 있는 프로젝트들입니다. 관심 있는 프로젝트에 참여해보세요!
                </p>
                <div className="flex items-center space-x-4 text-sm text-green-600">
                  <div className="flex items-center space-x-1">
                    <Star className="w-4 h-4" />
                    <span>즉시 참여 가능</span>
                  </div>
                  <div className="flex items-center space-x-1">
                    <Users className="w-4 h-4" />
                    <span>다양한 역할 모집</span>
                  </div>
                  <div className="flex items-center space-x-1">
                    <TrendingUp className="w-4 h-4" />
                    <span>성장 기회 제공</span>
                  </div>
                </div>
              </div>
            )}

            <div className="divide-y divide-gray-100">
              {/* 프로젝트 목록 */}
              {projects.map((project) => (
                <ProjectCard 
                  key={project.id} 
                  project={project} 
                  onClick={() => router.push(`/projects/${project.id}`)}
                />
              ))}
            </div>
          </div>
        )}
      </MainContainer>
      
      {/* 플로팅 액션 버튼 */}
      <WorklyFloatingActionButton 
        onTaskCreated={(task) => {
          console.log('CPER 업무 생성:', task)
          // TODO: 프로젝트 관련 업무 생성 로직 구현
        }}
        onInboxItemCreated={(inboxItem) => {
          console.log('빠른 수집:', inboxItem)
          // TODO: 프로젝트 관련 아이디어 수집 로직 구현
        }}
      />
    </div>
  );
}
</file>

<file path="frontend/package.json">
{
  "name": "@workly/frontend",
  "version": "1.0.0",
  "private": true,
  "description": "워클리 프론트엔드 Next.js 애플리케이션",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "type-check": "tsc --noEmit",
    "clean": "rm -rf .next",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "@heroicons/react": "^2.0.18",
    "@mdxeditor/editor": "^3.40.1",
    "@workly/shared": "*",
    "clsx": "^2.0.0",
    "lucide-react": "^0.525.0",
    "next": "^14.2.30",
    "react": "^18",
    "react-dom": "^18",
    "socket.io-client": "^4.7.5",
    "tailwind-merge": "^2.0.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.2",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.0.4",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "eslint-plugin-react": "^7.34.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/src/app/page.tsx">
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { 
  ClipboardDocumentIcon, 
  CheckCircleIcon, 
  ClockIcon, 
  CalendarIcon,
  UserIcon,
  FlagIcon
} from '@heroicons/react/24/outline'
import Header from '@/components/layout/Header'
import MainContainer from '@/components/layout/MainContainer'
import SimpleFilterChips from '@/components/ui/SimpleFilterChips'
import CalendarToggleFAB from '@/components/ui/CalendarToggleFAB'
import LoginBanner from '@/components/ui/LoginBanner'
import QuickAddInput from '@/components/ui/QuickAddInput'
import ResponsiveTaskCard from '@/components/tasks/ResponsiveTaskCard'
import CollapsibleCalendar from '@/components/tasks/CollapsibleCalendar'
import { TaskStatus, TaskPriority, TaskType, TaskDetail } from '@/types/task.types'
import { isAuthenticated } from '@/lib/auth'
import { useCalendarFilterStore } from '@/lib/stores/calendarFilterStore'
import AdvancedFilterPanel, { AdvancedFilters } from '@/components/ui/AdvancedFilterPanel'
import TaskDetailModal from '@/components/tasks/TaskDetailModal'

// 워클리 업무 인터페이스 (레거시 GTDTask 대체)
interface WorklyTask {
  id: string
  title: string
  description?: string
  status: TaskStatus
  priority: TaskPriority
  type: TaskType
  goalId?: string  // 워클리 방법론: 목표 연계 (선택적)
  projectId?: string  // 워클리 방법론: 프로젝트 연계 (선택적)
  assigneeId: string
  assignee: {
    id: string
    name: string
    email: string
  }
  dueDate?: string
  scheduledDate?: string  // 워클리: 실행 예정일
  tags: string[]
  createdAt: string
  updatedAt: string
  isToday?: boolean  // 워클리: 오늘 할 일 표시
  isFocused?: boolean  // 워클리: 집중 모드 표시
}

// 목업 워클리 업무 데이터
const mockTasks: WorklyTask[] = [
  {
    id: '1',
    title: '워클리 네비게이션 시스템 최종 점검',
    description: '5개 핵심 네비게이션 항목의 동작을 확인하고 사용자 경험을 개선',
    status: TaskStatus.IN_PROGRESS,
    priority: TaskPriority.HIGH,
    type: TaskType.TASK,
    projectId: 'proj-1',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date().toISOString(),
    scheduledDate: new Date().toISOString(),
    tags: ['UI/UX', '네비게이션', '점검'],
    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isToday: true,
    isFocused: true
  },
  {
    id: '2',
    title: 'CPER 워크플로우 문서 작성',
    description: 'Capture-Plan-Execute-Review 워크플로우의 사용법을 문서로 정리',
    status: TaskStatus.TODO,
    priority: TaskPriority.MEDIUM,
    type: TaskType.TASK,
    goalId: 'goal-1',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(),
    scheduledDate: new Date(Date.now() + 1 * 24 * 60 * 60 * 1000).toISOString(),
    tags: ['문서화', 'CPER', '가이드'],
    createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isToday: false
  },
  {
    id: '3',
    title: '사용자 피드백 수집 및 분석',
    description: '베타 테스터들의 피드백을 수집하고 개선사항을 도출',
    status: TaskStatus.TODO,
    priority: TaskPriority.HIGH,
    type: TaskType.IMPROVEMENT,
    goalId: 'goal-1',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    tags: ['피드백', '사용자경험', '분석'],
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isToday: true
  },
  {
    id: '4',
    title: '데이터베이스 성능 최적화',
    description: '쿼리 성능을 개선하고 인덱싱을 최적화',
    status: TaskStatus.IN_REVIEW,
    priority: TaskPriority.MEDIUM,
    type: TaskType.IMPROVEMENT,
    projectId: 'proj-2',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),
    tags: ['데이터베이스', '성능', '최적화'],
    createdAt: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '5',
    title: '모바일 반응형 디자인 개선',
    description: '모바일 환경에서의 사용자 경험을 개선',
    status: TaskStatus.DONE,
    priority: TaskPriority.MEDIUM,
    type: TaskType.FEATURE,
    projectId: 'proj-1',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    dueDate: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    tags: ['모바일', '반응형', 'UI'],
    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString()
  },
  {
    id: '6',
    title: '차세대 기능 기획',
    description: '사용자 요청이 많은 기능들을 검토하고 로드맵에 반영',
    status: TaskStatus.TODO,
    priority: TaskPriority.LOW,
    type: TaskType.EPIC,
    goalId: 'goal-2',
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    tags: ['기획', '로드맵', '미래'],
    createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  },
  // 정리 마법사 테스트를 위한 미분류 업무들
  {
    id: '7',
    title: '이메일 응답하기',
    description: '중요한 이메일들에 대한 응답 처리',
    status: TaskStatus.TODO,
    priority: TaskPriority.MEDIUM,
    type: TaskType.TASK,
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    tags: ['이메일', '커뮤니케이션'],
    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '8',
    title: '회의실 예약',
    description: '내일 팀 미팅을 위한 회의실 예약',
    status: TaskStatus.TODO,
    priority: TaskPriority.HIGH,
    type: TaskType.TASK,
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    tags: ['회의', '예약'],
    createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '9',
    title: '프로젝트 자료 정리',
    description: '지난달 프로젝트 관련 자료들을 정리',
    status: TaskStatus.TODO,
    priority: TaskPriority.LOW,
    type: TaskType.TASK,
    assigneeId: 'user1',
    assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
    tags: ['정리', '문서'],
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString()
  }
]


export default function TasksPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [tasks, setTasks] = useState<WorklyTask[]>(mockTasks)
  const [isLoading, setIsLoading] = useState(false)
  const [activeFilters, setActiveFilters] = useState<string[]>(['today'])
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  // 캘린더 상태 관리
  const [isCalendarExpanded, setIsCalendarExpanded] = useState(false)
  const [isDragMode, setIsDragMode] = useState(false)
  const [draggingTaskId, setDraggingTaskId] = useState<string | null>(null)

  // 필터 설정 상태 (간소화됨)
  const [taskSortOrder, setTaskSortOrder] = useState('priority')
  
  // 캘린더 필터 상태 구독
  const { showNoDue, showOverdue } = useCalendarFilterStore()
  
  // 상세 필터 상태 관리
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false)
  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilters>({})
  
  // 업무 상세 모달 상태 관리
  const [selectedTask, setSelectedTask] = useState<TaskDetail | null>(null)
  const [isTaskDetailOpen, setIsTaskDetailOpen] = useState(false)
  
  // 목업 프로젝트와 목표 데이터
  const availableProjects = [
    { id: 'proj-1', name: '워클리 네비게이션 시스템' },
    { id: 'proj-2', name: '데이터베이스 최적화' }
  ]
  
  const availableGoals = [
    { id: 'goal-1', name: 'Q4 사용자 경험 개선' },
    { id: 'goal-2', name: '차세대 기능 개발' }
  ]
  
  // 상세 필터가 활성화되었는지 확인
  const hasAdvancedFilters = Boolean(
    advancedFilters.dueDate || 
    advancedFilters.status?.length || 
    advancedFilters.projectIds?.length || 
    advancedFilters.goalIds?.length
  )

  // 간소화된 필터 옵션들 (실시간 업데이트)
  const filterOptions = [
    { 
      key: 'today',
      label: '오늘 할 일',
      count: tasks.filter(t => t.isToday && t.status !== TaskStatus.DONE).length
    },
    { 
      key: 'in-progress',
      label: '진행 중',
      count: tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length
    },
    { 
      key: 'completed',
      label: '완료됨',
      count: tasks.filter(t => t.status === TaskStatus.DONE).length
    },
    { 
      key: 'high-priority',
      label: '중요 업무',
      count: tasks.filter(t => t.priority === TaskPriority.HIGH || t.priority === TaskPriority.URGENT).length
    },
    { 
      key: 'all',
      label: '전체 업무',
      count: tasks.length
    }
  ]

  // 통합 필터링 로직 (기본 + 캘린더 + 상세 필터)
  const filteredTasks = tasks.filter(task => {
    // 1. 기본 필터 적용
    let includeTask = !activeFilters.length
    
    if (activeFilters.length > 0) {
      includeTask = activeFilters.some(filter => {
        switch (filter) {
          case 'today':
            return task.isToday && task.status !== TaskStatus.DONE
          case 'in-progress':
            return task.status === TaskStatus.IN_PROGRESS
          case 'completed':
            return task.status === TaskStatus.DONE
          case 'high-priority':
            return (task.priority === TaskPriority.HIGH || task.priority === TaskPriority.URGENT) && 
                   task.status !== TaskStatus.DONE
          case 'all':
            return true
          default:
            return true
        }
      })
    }

    // 2. 캘린더 필터 적용
    if (showNoDue || showOverdue) {
      const today = new Date()
      const taskDueDate = task.dueDate ? new Date(task.dueDate) : null
      
      let calendarMatch = false
      
      if (showNoDue && !taskDueDate) {
        calendarMatch = true
      }
      
      if (showOverdue && taskDueDate && taskDueDate < today && task.status !== TaskStatus.DONE) {
        calendarMatch = true  
      }
      
      includeTask = includeTask && calendarMatch
    }

    // 3. 상세 필터 적용
    if (hasAdvancedFilters) {
      let advancedMatch = true
      
      // 마감일 필터
      if (advancedFilters.dueDate) {
        const today = new Date()
        const taskDueDate = task.dueDate ? new Date(task.dueDate) : null
        
        switch (advancedFilters.dueDate) {
          case 'overdue':
            advancedMatch = advancedMatch && taskDueDate && taskDueDate < today && task.status !== TaskStatus.DONE
            break
          case 'today':
            advancedMatch = advancedMatch && taskDueDate && taskDueDate.toDateString() === today.toDateString()
            break
          case 'this-week':
            if (taskDueDate) {
              const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000)
              advancedMatch = advancedMatch && taskDueDate >= today && taskDueDate <= weekFromNow
            } else {
              advancedMatch = false
            }
            break
          case 'no-due':
            advancedMatch = advancedMatch && !taskDueDate
            break
        }
      }
      
      // 상태 필터
      if (advancedFilters.status?.length) {
        advancedMatch = advancedMatch && advancedFilters.status.includes(task.status)
      }
      
      // 프로젝트 필터
      if (advancedFilters.projectIds?.length) {
        advancedMatch = advancedMatch && task.projectId && advancedFilters.projectIds.includes(task.projectId)
      }
      
      // 목표 필터
      if (advancedFilters.goalIds?.length) {
        advancedMatch = advancedMatch && task.goalId && advancedFilters.goalIds.includes(task.goalId)
      }
      
      includeTask = includeTask && advancedMatch
    }
    
    return includeTask
  })

  // 로그인 상태 초기화
  useEffect(() => {
    setIsLoggedIn(isAuthenticated())
  }, [])

  // URL 쿼리 파라미터에서 필터 상태 초기화
  useEffect(() => {
    const filters = searchParams.get('filters')
    const advanced = searchParams.get('advanced')
    
    if (filters) {
      try {
        const parsedFilters = JSON.parse(decodeURIComponent(filters))
        if (Array.isArray(parsedFilters)) {
          setActiveFilters(parsedFilters)
        }
      } catch (e) {
        console.warn('Invalid filters in URL:', e)
      }
    }
    
    if (advanced) {
      try {
        const parsedAdvanced = JSON.parse(decodeURIComponent(advanced))
        setAdvancedFilters(parsedAdvanced)
      } catch (e) {
        console.warn('Invalid advanced filters in URL:', e)
      }
    }
  }, [searchParams])

  // 필터 상태가 변경될 때 URL 업데이트
  useEffect(() => {
    const params = new URLSearchParams()
    
    if (activeFilters.length > 0) {
      params.set('filters', encodeURIComponent(JSON.stringify(activeFilters)))
    }
    
    if (hasAdvancedFilters) {
      params.set('advanced', encodeURIComponent(JSON.stringify(advancedFilters)))
    }
    
    const newUrl = params.toString() ? `?${params.toString()}` : window.location.pathname
    window.history.replaceState({}, '', newUrl)
  }, [activeFilters, advancedFilters, hasAdvancedFilters])


  const handleTaskClick = (task: WorklyTask) => {
    // WorklyTask를 TaskDetail로 변환
    const taskDetail: TaskDetail = {
      ...task,
      descriptionMarkdown: task.description,
      checklist: [
        { id: 'check-1', text: '기본 요구사항 검토', completed: false, order: 0 },
        { id: 'check-2', text: '설계 문서 작성', completed: true, order: 1 },
        { id: 'check-3', text: '코드 구현', completed: false, order: 2 }
      ],
      relationships: [],
      wikiReferences: [
        { id: 'wiki-1', title: '워클리 디자인 가이드', url: '/wiki/design-guide', description: '워클리 UI/UX 디자인 표준' },
        { id: 'wiki-2', title: 'CPER 워크플로우', url: '/wiki/cper', description: 'Capture-Plan-Execute-Review 방법론' }
      ],
      estimatedTimeMinutes: task.id === '1' ? 120 : undefined,
      loggedTimeMinutes: task.id === '1' ? 80 : undefined
    }
    
    setSelectedTask(taskDetail)
    setIsTaskDetailOpen(true)
  }
  
  // 업무 상세 저장 핸들러
  const handleTaskDetailSave = (taskDetail: TaskDetail) => {
    // 실제로는 API 호출하여 저장
    console.log('업무 상세 저장:', taskDetail)
    
    // 로컬 상태 업데이트 (기본 정보만)
    handleTaskUpdate(taskDetail.id, {
      title: taskDetail.title,
      description: taskDetail.description,
      dueDate: taskDetail.dueDate,
      estimatedHours: taskDetail.estimatedTimeMinutes ? taskDetail.estimatedTimeMinutes / 60 : undefined
    })
  }

  // PRD 명세: 빠른 추가 - Enter 입력 시 새 업무가 리스트 최상단에 생성
  const handleQuickAddTask = async (title: string) => {
    const newTask: WorklyTask = {
      id: `task-${Date.now()}`, // 임시 ID 생성
      title: title,
      status: TaskStatus.TODO, // PRD 명세: status는 'todo'
      priority: TaskPriority.MEDIUM, // 기본 우선순위
      type: TaskType.TASK,
      assigneeId: 'user1',
      assignee: { id: 'user1', name: '김워클리', email: 'workly@example.com' },
      tags: [],
      createdAt: new Date().toISOString(), // PRD 명세: created_at은 현재 시각
      updatedAt: new Date().toISOString(),
      isToday: true // 새로 생성된 업무는 오늘 할 일로 설정
    }

    // 리스트 최상단에 추가
    setTasks(prevTasks => [newTask, ...prevTasks])
  }

  // 정리 마법사: 업무 업데이트
  const handleTaskUpdate = (taskId: string, updates: Partial<WorklyTask>) => {
    setTasks(prevTasks => 
      prevTasks.map(task => 
        task.id === taskId ? { ...task, ...updates, updatedAt: new Date().toISOString() } : task
      )
    )
  }

  // 정리 마법사: 업무 삭제 (30일간 휴지통)
  const handleTaskDelete = (taskId: string) => {
    setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId))
    // TODO: 실제로는 deleted 상태로 변경하고 30일 후 완전 삭제
    console.log(`업무 ${taskId} 삭제됨 (30일간 휴지통 보관)`)
  }

  // 드래그 앤 드롭 핸들러들
  const handleDragStart = (taskId: string) => {
    setDraggingTaskId(taskId)
    setIsDragMode(true)
    
    // 달력이 닫혀있을 때만 열기
    if (!isCalendarExpanded) {
      setIsCalendarExpanded(true)
    }
    
    // 햅틱 피드백 (지원되는 경우)
    if ('vibrate' in navigator) {
      navigator.vibrate(50)
    }
  }

  const handleDragEnd = () => {
    setDraggingTaskId(null)
    setIsDragMode(false)
    // 캘린더는 날짜 선택 시 자동으로 닫히므로 여기서는 닫지 않음
  }

  const handleDateSelect = (date: Date) => {
    if (draggingTaskId) {
      // 드래그 중인 업무의 마감일 설정
      handleTaskUpdate(draggingTaskId, {
        dueDate: date.toISOString()
      })
      console.log(`업무 ${draggingTaskId}의 마감일을 ${date.toLocaleDateString('ko-KR')}로 설정`)
      
      // 드래그 앤 드롭인 경우 달력을 열어둠
      setIsDragMode(false)
      setDraggingTaskId(null)
      // setIsCalendarExpanded는 호출하지 않음 - 달력 유지
    } else {
      // 일반 클릭인 경우에만 달력 닫기
      setIsCalendarExpanded(false)
    }
  }

  const handleCalendarClose = () => {
    setIsCalendarExpanded(false)
    setIsDragMode(false)
    setDraggingTaskId(null)
  }

  const handleCalendarToggle = () => {
    setIsCalendarExpanded(!isCalendarExpanded)
    if (!isCalendarExpanded) {
      // 펼칠 때는 드래그 모드가 아닌 일반 모드
      setIsDragMode(false)
      setDraggingTaskId(null)
    }
  }

  // 스와이프 액션 핸들러들
  const handleTaskDelegate = (taskId: string) => {
    console.log('위임:', taskId)
    // TODO: 위임 기능 구현
  }

  const handleTaskDefer = (taskId: string) => {
    console.log('보류:', taskId)
    // TODO: 보류 기능 구현
    handleTaskUpdate(taskId, { status: TaskStatus.DEFERRED })
  }

  const handleTaskConvertToProject = (taskId: string) => {
    console.log('프로젝트로 전환:', taskId)
    // TODO: 프로젝트 전환 기능 구현
  }

  // 날짜별 업무 개수 계산
  const getTasksWithDates = () => {
    const tasksWithDates: { [dateKey: string]: number } = {}
    
    tasks.forEach(task => {
      if (task.dueDate) {
        const dateKey = task.dueDate.split('T')[0] // YYYY-MM-DD 형식
        tasksWithDates[dateKey] = (tasksWithDates[dateKey] || 0) + 1
      }
    })
    
    return tasksWithDates
  }

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      {/* 헤더 */}
      <Header title="업무" />
      
      {/* 로그인 배너 (헤더 바깥) */}
      <LoginBanner />
      
      {/* 메인 콘텐츠 */}
      <MainContainer>
        {/* 필터 관리자 - 로그인된 사용자만 표시 */}
        {isLoggedIn && (
          <div className="mb-4">
            <SimpleFilterChips
              options={filterOptions}
              activeFilters={activeFilters}
              onFilterChange={setActiveFilters}
              onAdvancedFilterClick={() => setShowAdvancedFilters(true)}
              hasAdvancedFilters={hasAdvancedFilters}
              settings={{
                title: "업무 필터 설정",
                settings: [
                  {
                    key: 'sort',
                    label: '정렬 기준',
                    type: 'select',
                    value: taskSortOrder,
                    options: ['priority', 'dueDate', 'status', 'created'],
                    onChange: setTaskSortOrder
                  }
                ]
              }}
            />
          </div>
        )}

        {/* PRD 명세: 빠른 추가 입력창 - 로그인된 사용자만 표시 */}
        {isLoggedIn && (
          <div className="mb-4">
            <QuickAddInput
              placeholder="무엇을 해야 하나요?"
              onTaskCreate={handleQuickAddTask}
            />
          </div>
        )}

        {/* 업무 목록 */}
        <div className="workly-list-card overflow-hidden">
          {isLoading ? (
            <div className="p-8 text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
              <p className="workly-caption mt-2">업무를 불러오는 중...</p>
            </div>
          ) : filteredTasks.length === 0 ? (
            <div className="p-8 text-center">
              <ClipboardDocumentIcon className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="workly-card-title text-gray-600 mb-1">업무가 없습니다</h3>
              <p className="workly-caption mb-4">우측 하단의 수집함 버튼(+)을 눌러 업무를 추가해보세요!</p>
            </div>
          ) : (
            <div className="divide-y divide-gray-100">
              {filteredTasks.map((task) => (
                <ResponsiveTaskCard
                  key={task.id}
                  task={task}
                  onClick={() => handleTaskClick(task)}
                  onDelete={handleTaskDelete}
                  onDelegate={handleTaskDelegate}
                  onDefer={handleTaskDefer}
                  onConvertToProject={handleTaskConvertToProject}
                  onDragStart={handleDragStart}
                  onDragEnd={handleDragEnd}
                  isDragMode={isDragMode}
                />
              ))}
            </div>
          )}
        </div>
      </MainContainer>
      
      {/* 접이식 캘린더 - 모바일 네비 덮어서 전체, 데스크톱 사이드바 제외 */}
      <div className="fixed bottom-0 left-0 right-0 md:left-64 z-[60]">
        <CollapsibleCalendar
          isExpanded={isCalendarExpanded}
          onDateSelect={handleDateSelect}
          onClose={handleCalendarClose}
          onToggle={handleCalendarToggle}
          tasksWithDates={getTasksWithDates()}
          keepOpenOnDrop={true}
          isDragMode={isDragMode}
        />
      </div>
      
      {/* 캘린더 토글 FAB - 캘린더 높이만큼 위로 이동 */}
      <div className={`
        fixed right-4 md:right-6 z-[70] transition-all duration-300
        ${isCalendarExpanded 
          ? 'bottom-[480px] md:bottom-[480px]' 
          : 'bottom-[72px] md:bottom-6'
        }
      `}>
        <CalendarToggleFAB 
          isCalendarExpanded={isCalendarExpanded}
          onToggle={handleCalendarToggle}
        />
      </div>
      
      {/* 상세 필터 패널 */}
      <AdvancedFilterPanel
        isOpen={showAdvancedFilters}
        onClose={() => setShowAdvancedFilters(false)}
        filters={advancedFilters}
        onFiltersChange={setAdvancedFilters}
        availableProjects={availableProjects}
        availableGoals={availableGoals}
      />
      
      {/* 업무 상세 모달 */}
      <TaskDetailModal
        task={selectedTask}
        isOpen={isTaskDetailOpen}
        onClose={() => {
          setIsTaskDetailOpen(false)
          setSelectedTask(null)
        }}
        onSave={handleTaskDetailSave}
      />
    </div>
  )
}
</file>

</files>

안녕하세요! 워클리(Workly) 프로젝트의 코드베이스를 꼼꼼하게 점검해 보았습니다. 기획이 계속 수정되면서 코드가 복잡해지는 것은 매우 자연스러운 현상이며, 오히려 이렇게 주기적으로 점검하고 리팩토링하려는 자세가 훌륭한 프로젝트를 만드는 기반이 됩니다.

전반적으로 프로젝트는 **매우 현대적이고 체계적인 구조**를 갖추고 있습니다. 특히 AI 에이전트를 활용한 개발 워크플로우(`.taskmaster`, `.claude` 폴더)는 정말 인상적입니다.

프론트엔드 중심으로 강점과 개선점을 정리해 보았습니다.

### 총평

매우 잘 설계된 모노레포 기반의 풀스택 애플리케이션입니다. Next.js App Router, TypeScript, Tailwind CSS 등 최신 기술 스택을 효과적으로 활용하고 있으며, `shared` 패키지를 통한 타입 공유는 프로젝트의 안정성을 크게 높여줍니다. 기획 변경으로 인해 일부 컴포넌트와 API 로직에서 중복되거나 일관성이 부족한 부분이 보이지만, 이는 충분히 정리 가능한 수준입니다.

---

### 👍 잘된 점 (Strengths)

1.  **Modern Architecture**: Next.js App Router 기반의 폴더 구조와 `ConditionalLayout`을 통해 페이지별로 다른 레이아웃을 적용하는 방식이 매우 효율적입니다.
2.  **타입 안전성**: `shared` 패키지를 통해 프론트엔드와 백엔드 간의 타입을 공유하는 구조는 API 통신의 안정성을 보장하는 최고의 방법입니다.
3.  **체계적인 관리자 페이지**: `/admin` 경로에 별도의 레이아웃과 권한 관리(`PermissionGuard`)를 구현한 것은 확장성과 보안 측면에서 매우 훌륭합니다.
4.  **효율적인 상태 관리**: 경량 상태 관리 라이브러리인 Zustand를 사용하여 `authStore`, `calendarFilterStore` 등 역할을 명확히 분리한 점이 좋습니다.
5.  **AI 기반 개발 워크플로우**: `.taskmaster`와 `.claude`를 활용하여 개발 프로세스를 자동화하고 문서화하는 방식은 매우 진보적이며 프로젝트의 이력을 효과적으로 관리할 수 있게 해줍니다.

---

### 💡 개선 제안 (Suggestions for Improvement)

기획 변경으로 인해 생긴 것으로 보이는 '지저분한' 부분들을 중심으로 정리했습니다.

#### 1. 컴포넌트 구조: 필터 기능 통합 및 재사용성 강화

-   **문제점**: 필터 관련 컴포넌트가 여러 개 존재하여 역할이 중복되고 혼란을 줄 수 있습니다. (`AdvancedFilterPanel`, `FilterChips`, `FilterManager`, `MobileFilterTabs`, `SimpleFilterChips`, `UnifiedFilter`)
-   **원인 분석**: 개발 과정에서 다양한 필터 UI/UX를 시도하면서 여러 버전이 생긴 것으로 보입니다. 이는 기획 변경의 대표적인 흔적입니다.
-   **개선 제안**:
    1.  **`FilterManager`를 중심으로 통합**: 가장 기능이 풍부하고 체계적인 `FilterManager.tsx`를 핵심 필터 관리 컴포넌트로 삼습니다.
    2.  **UI 분리**: `FilterManager`가 필터 로직(상태 관리, 조건 생성)을 담당하고, UI 표현은 `FilterChips` (기본 뷰), `AdvancedFilterPanel` (상세 뷰) 등 다른 컴포넌트가 담당하도록 역할을 분리합니다.
    3.  **Props로 UI 제어**: `FilterManager`에 `variant`나 `mode` 같은 prop을 전달하여, 같은 로직을 사용하되 페이지에 따라 다른 UI(예: 단순 칩, 상세 패널)를 렌더링하도록 구현하면 코드 중복을 크게 줄일 수 있습니다.

#### 2. API 통신: 클라이언트 레이어 단일화

-   **문제점**: API 호출을 위한 클라이언트 파일이 여러 개 존재합니다. (`api.ts`, `admin-api.ts`, `tasks.ts`, `workly-api.ts`)
-   **원인 분석**: 기능별, 섹션별로 API 파일을 분리하려다 보니 일관된 규칙 없이 파일이 늘어난 것 같습니다. 특히 `workly-api.ts`는 CPER 워크플로우가 도입되면서 새로 만들어진 것으로 보입니다.
-   **개선 제안**:
    1.  **단일 API 클라이언트 인스턴스**: `lib/api.ts`에 `axios`나 `fetch`를 기반으로 한 중앙 API 클라이언트 인스턴스를 하나만 만듭니다. 이 클라이언트는 baseURL, 인증 헤더, 인터셉터(토큰 갱신, 에러 처리) 등 공통 로직을 모두 처리합니다.
    2.  **도메인별 API 서비스 분리**: `lib/api/` 폴더 아래에 `tasks.ts`, `projects.ts`, `admin.ts` 등 도메인별로 파일을 나누고, 각 파일에서는 중앙 클라이언트 인스턴스를 `import`하여 사용합니다. 이렇게 하면 구조는 유지하면서 코드 중복은 제거할 수 있습니다. `workly-api.ts`의 좋은 로직들을 중앙 클라이언트로 통합하는 것을 추천합니다.

#### 3. 데이터 Fetching: `useEffect` 대신 SWR/React Query로 표준화

-   **문제점**: `projects/[id]/page.tsx` 등 일부 페이지에서는 `useEffect`와 `useState`를 사용해 직접 데이터를 가져오는 반면, `useAdminApi.ts` 에서는 `SWR`을 사용하는 등 데이터 페칭 방식이 일관되지 않습니다.
-   **개선 제안**:
    1.  **SWR 또는 React Query로 통일**: `useSWR` (또는 `useQuery`)를 기본 데이터 페칭 방식으로 채택하여 프로젝트 전체에 일관되게 적용합니다.
    2.  **커스텀 훅(Custom Hook) 적극 활용**: `useProjects`, `useProject(id)`와 같은 커스텀 훅을 만들어 데이터 페칭 로직을 컴포넌트로부터 완전히 분리합니다. 이렇게 하면 로딩, 에러 상태 처리, 캐싱 로직이 중앙화되어 컴포넌트는 UI에만 집중할 수 있습니다.

    ```typescript
    // 예시: /lib/hooks/useProjects.ts
    import useSWR from 'swr';
    import { projectsApi } from '@/lib/api/projects'; // 통합된 API 서비스

    export function useProjects(filters) {
      const { data, error, isLoading, mutate } = useSWR(
        ['/projects', filters], // key
        () => projectsApi.getProjects(filters) // fetcher
      );

      return {
        projects: data?.items,
        pagination: data?.meta,
        isLoading,
        error,
        mutate,
      };
    }
    ```

#### 4. 타입 관리: Single Source of Truth 원칙 강화

-   **문제점**: `frontend/src/types`와 `shared/types`에 각각 타입 정의 파일이 존재하며, 내용이 중복되거나 약간씩 다릅니다. (예: `api.types.ts`)
-   **위험성**: 이는 프론트엔드와 백엔드 간 데이터 불일치를 유발하는 **가장 위험한 버그의 원인**이 될 수 있습니다.
-   **개선 제안**:
    1.  **`shared`로 모든 타입 통합**: 프론트엔드와 백엔드가 공유하는 모든 타입(API 요청/응답, DB 모델 등)을 `@workly/shared` 패키지로 완전히 이전합니다.
    2.  **`frontend/src/types` 제거**: `frontend` 내의 공유 타입을 제거하고, 모든 곳에서 `@workly/shared`의 타입을 `import`하여 사용하도록 수정합니다. 이렇게 하면 타입의 '단일 진실 공급원'이 확립되어 안정성이 크게 향상됩니다.

#### 5. 스타일링 일관성

-   **문제점**: `TaskCard.tsx`의 `getDueDateInfo` 함수에서 마감일이 임박했을 때 주황색(`text-orange-500`)을 사용하는 등, 일부 컴포넌트에서 `WORKLY_PRD.md`에 정의된 **Primary Blue 중심의 단일 컬러 시스템**을 벗어나는 경우가 있습니다.
-   **개선 제안**:
    1.  **`getDueDateVisualization` 로직 재사용**: `ResponsiveTaskCard.tsx`에 구현된 파란색 스케일 기반의 마감일 시각화 로직(`getDueDateVisualization`)을 모든 업무 카드 관련 컴포넌트에서 재사용하도록 유틸리티 함수로 분리하는 것을 권장합니다.
    2.  **Tailwind 설정 확장**: `tailwind.config.ts`에 `safe-list`를 활용하거나 별도의 ESLint 플러그인을 도입하여, 디자인 시스템에 정의되지 않은 색상 클래스(예: `text-orange-500`) 사용 시 경고를 띄우는 것도 좋은 방법입니다.

---

### 우선순위 제안

1.  **[매우 높음] 타입 관리 통합**: 버그 방지를 위해 가장 먼저 해결해야 할 문제입니다.
2.  **[높음] 데이터 Fetching 표준화**: 개발 생산성과 앱 성능에 직접적인 영향을 줍니다.
3.  **[중간] 컴포넌트 리팩토링**: 필터 컴포넌트 통합으로 코드 복잡도를 낮춥니다.
4.  **[중간] API 클라이언트 정리**: 코드의 일관성과 유지보수성을 높입니다.
5.  **[낮음] 스타일링 일관성 확보**: 시각적 완성도를 높입니다.

### 결론

현재 코드베이스는 매우 튼튼한 기반 위에 서 있습니다. 위에 제안된 개선점들은 뼈대를 바꾸는 것이 아니라, 빠르게 성장하는 과정에서 생긴 잔가지를 정리하여 더욱 견고하고 확장하기 쉬운 구조로 만드는 과정입니다. 이 리팩토링을 통해 앞으로의 기능 개발이 훨씬 수월해지고 안정성도 크게 향상될 것입니다. 훌륭한 프로젝트이며, 앞으로가 더욱 기대됩니다